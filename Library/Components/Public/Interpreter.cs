/*
 * Interpreter.cs --
 *
 * Copyright (c) 2007-2012 by Joe Mistachkin.  All rights reserved.
 *
 * See the file "license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: $
 */

using System;
using System.Collections;
using System.Collections.Generic;

#if CAS_POLICY
using System.Configuration.Assemblies;
#endif

#if DATA
using System.Data;
#endif

#if SHELL && TEST
using System.Diagnostics;
#endif

using System.Globalization;
using System.IO;

#if NETWORK
using System.Net.Sockets;
#endif

using System.Reflection;
using System.Resources;
using System.Security;
using System.Security.Cryptography;

#if !NET_STANDARD_20
using System.Security.Cryptography.X509Certificates;
#endif

#if CAS_POLICY
using System.Security.Permissions;
using System.Security.Policy;
#endif

using System.Text;
using System.Threading;

#if WINFORMS
using System.Windows.Forms;
#endif

using Eagle._Attributes;
using Eagle._Components.Private;
using Eagle._Components.Private.Delegates;

#if NATIVE && TCL
using Eagle._Components.Private.Tcl;
#endif

using Eagle._Components.Public.Delegates;
using Eagle._Constants;
using Eagle._Containers.Private;

#if NATIVE && TCL
using Eagle._Containers.Private.Tcl;
#endif

using Eagle._Containers.Public;
using Eagle._Encodings;
using Eagle._Interfaces.Private;

#if NATIVE && TCL
using Eagle._Interfaces.Private.Tcl;
#endif

using Eagle._Interfaces.Public;

#if !CONSOLE
using ConsoleColor = Eagle._Components.Public.ConsoleColor;
#endif

#if DEBUGGER || (NATIVE && TCL)
using _Private = Eagle._Components.Private;
#endif

using _Public = Eagle._Components.Public;
using _Shared = Eagle._Components.Shared;
using _ClientData = Eagle._Components.Public.ClientData;

#if SHELL
using _ShellCallbackData = Eagle._Components.Public.ShellCallbackData;
#endif

using SharedStringOps = Eagle._Components.Shared.StringOps;
using StringLongPair = Eagle._Interfaces.Public.IAnyPair<string, long>;

#if APPDOMAINS || ISOLATED_INTERPRETERS || ISOLATED_PLUGINS
using PluginResourceDictionary = System.Collections.Generic.Dictionary<string, byte[]>;
#endif

#if NATIVE && TCL
using _TclApi = Eagle._Components.Private.Tcl.TclApi;
#endif

using CleanupPathPair = System.Collections.Generic.KeyValuePair<
    string, Eagle._Components.Private.CleanupPathClientData>;

using PathClientDataPair = System.Collections.Generic.KeyValuePair<
    string, Eagle._Components.Private.PathClientData>;

#if NET_STANDARD_21
using Index = Eagle._Constants.Index;
#endif

namespace Eagle._Components.Public
{
    [ObjectId("b98042f9-d66a-46db-81e9-a2f44c1f03fd")]
    public sealed class Interpreter :
#if ISOLATED_INTERPRETERS || ISOLATED_PLUGINS
        ScriptMarshalByRefObject,
#endif
        IArgumentManager,
#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || EXECUTE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
        ICacheManager,
#endif
#if CALLBACK_QUEUE
        ICallbackQueueManager,
#endif
        IDisposable, IDebugManager, IEngineManager,
        IEntityManager, IErrorManager,
        IHaveCultureInfo, IHaveOwner,
#if HISTORY
        IHistoryManager,
#endif
        IIdentifier,
#if DEBUGGER
        IInteractiveLoopManager,
#endif
        IInteractiveManager, IInterpreter, IInterpreterManager,
#if WINFORMS
        IKeyEventManager,
#endif
#if NOTIFY || NOTIFY_OBJECT
        INotifyManager,
#endif
        IPackageManager,
        IPluginManager, IPropertyManager, IResolveManager,
        IResourceManager, IRuntimeOptionManager, IScriptManager,
        ISecurityManager,
#if SHELL
        IShellManager,
#endif
#if WINFORMS
        IStatusManager,
#endif
        ISynchronize,
#if NATIVE && TCL
        ITclEntityManager, ITclManager,
#endif
        ITraceManager,
        IVariableManager
    {
        #region Global Read-Only Data (shared by all Interpreters)
        #region Static Data Lock -- Private
        private static readonly object staticSyncRoot = new object();
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Encodings -- Public
        //
        // WARNING: FOR EXTERNAL USE ONLY.  If any of these encodings are
        //          changed various things may not work correctly.
        //
        public static readonly Encoding SystemEncoding = StringOps.GetEncoding(
            EncodingType.System); /* Unicode (UTF-16) */

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static readonly Encoding DefaultEncoding = StringOps.GetEncoding(
            EncodingType.Default); /* UTF-8 */
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Global Data (shared by all Interpreters) -- Private
        private static int globalDisableCreationCount = 0;
        private static int globalStubAssemblyCount = 0;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static int globalInitializeCount = 0;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static int globalBreakCount = 0;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static int globalCreateCount = 0; /* TEST USE ONLY */
        private static int globalDisposeCount = 0; /* TEST USE ONLY */
        private static int globalFinalizeCount = 0; /* TEST USE ONLY */

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // HACK: These are purposely not read-only.
        //
        private static bool useBuiltInCommands = true; /* TODO: *PERF* Good default? */
        private static bool useBuiltInFunctions = true; /* TODO: *PERF* Good default? */
        private static bool useBuiltInOperators = true; /* TODO: *PERF* Good default? */

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Global Shell Integration Data -- Private
#if SHELL
        private static int globalShellMainCount = 0;
        private static int globalShellMainCoreCount = 0;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Global Host Integration Data -- Private
        private static bool defaultQuiet = false;
        private static bool defaultTraceStack = false;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static EventCallback newInterpreterCallback;
        private static EventCallback useInterpreterCallback;
        private static EventCallback freeInterpreterCallback;
        private static NewHostCallback newHostCallback;
        private static ComplainCallback complainCallback;

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL
        //
        // NOTE: This is used for testing the interactive loop input mechanism.
        //       This array normally has exactly two string elements.
        //
        //       The first element contains the string value to pass as input
        //       into the IInteractiveHost.ReadLine method of the host.  It is
        //       not modified by the interactive loop code itself.
        //
        //       The second element contains the string value that was most
        //       recently returned from the IInteractiveHost.ReadLine method
        //       of the host.  It will be modified by the interactive loop
        //       code every time a line of input is read from the host.
        //
        private static string[] readValue = {
            null, /* IInteractiveHost.ReadLine: in */
            null  /* IInteractiveHost.ReadLine: out */
        };
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if CONSOLE
        //
        // NOTE: [0] How should console control (Control-C) events be
        //           handled by the static interpreter event handler?
        //           Currently, the supported values are:
        //
        //           0: The event handler is completely disabled, the
        //              process should be allowed to die.
        //
        //           1: The event handler should prevent the process
        //              from dying; however, it should not cancel any
        //              scripts.
        //
        //           2: The event handler should prevent the process
        //              from dying and cancel all scripts running in
        //              the application domain.  This is the default
        //              value (COMPAT: Eagle beta).
        //
        //       [1] How many times has the console control static
        //           interpreter event handler been triggered?
        //
        private static readonly int[] cancelViaConsole = {
            2, 0
        };

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // HACK: This is purposely not read-only.
        //
        private static int cancelThreadViaConsole = 0;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Global Tcl/Tk Integration Data -- Private
        #region Zombie Tcl/Tk Object Tracking -- Private
#if NATIVE && TCL
        private static long deadTclThreadId;
        private static ITclApi deadTclApi;
        private static IntPtrDictionary deadTclInterps;
        private static TclBridgeDictionary deadTclBridges;

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TCL_THREADS
        private static TclThreadDictionary deadTclThreads;
#endif
#endif
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private Constants
        #region Entropy Defaults
        //
        // HACK: This is not read-only.
        //
        private static int DefaultEntropySize = 25;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Timeout Defaults
        //
        // HACK: This is no longer read-only.
        //
        private static int DefaultTimeout = _Timeout.Infinite; // NOTE: Never timeout.

        //
        // HACK: This is no longer read-only.
        //
        private static int DefaultFinallyTimeout = DefaultTimeout; // NOTE: Never timeout.

        //
        // HACK: This is no longer read-only.
        //
        private static int DefaultReadyTimeout = DefaultTimeout; // NOTE: Never timeout.

        //
        // HACK: These are not read-only.
        //
        private static int DefaultVariableEventTimeout = 0; /* TODO: Good default? */
        private static int DefaultSetupEventTimeout = 0; /* TODO: Good default? */
        private static int DefaultEventManagerTimeout = 0; /* TODO: Good default? */

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // HACK: These are purposely not read-only.
        //
#if WINFORMS
        private static DialogResult DefaultTimeoutDialogResult = DialogResult.Yes;
#else
        private static bool? DefaultTimeoutDialogResult = true;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Threading Defaults
#if SHELL && INTERACTIVE_COMMANDS
        //
        // NOTE: *TUNING* This is purposely not marked as read-only.
        //
        internal static int testGcSleepTime = 1000; /* milliseconds */
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Limits
#if CALLBACK_QUEUE
        //
        // HACK: These are not read-only.
        //
        private static int DefaultUnsafeCallbackLimit = 0; // NOTE: No limit.
        private static int DefaultSafeCallbackLimit = 50; // TODO: Good default?
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // HACK: These are not read-only.
        //
        private static int DefaultUnsafeEventLimit = 0; // NOTE: No limit.
        private static int DefaultSafeEventLimit = 50; // TODO: Good default?

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // HACK: These are not read-only.
        //
        private static int DefaultUnsafeProcedureLimit = 0; // NOTE: No limit.
        private static int DefaultSafeProcedureLimit = 100; // TODO: Good default?

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // HACK: These are not read-only.
        //
        private static int DefaultUnsafeVariableLimit = 0; // NOTE: No limit.
        private static int DefaultSafeVariableLimit = 100; // TODO: Good default?

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // HACK: These are not read-only.
        //
        private static int DefaultUnsafeArrayElementLimit = 0; // NOTE: No limit.
        private static int DefaultSafeArrayElementLimit = 100; // TODO: Good default?
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Result Limits
#if RESULT_LIMITS
        //
        // HACK: These are not read-only.
        //
        private static int DefaultUnsafeExecuteResultLimit = 0; // NOTE: No limit.
        private static int DefaultSafeExecuteResultLimit = 1048576; // NOTE: 1MB.

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // HACK: These are not read-only.
        //
        private static int DefaultUnsafeNestedResultLimit = 0; // NOTE: No limit.
        private static int DefaultSafeNestedResultLimit = 1048576; // NOTE: 1MB.
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region History & Caching
#if HISTORY
        //
        // HACK: *PERF* This is no longer read-only.
        //
        // TODO: *PERF* Good default?
        //
        private static int DefaultHistoryLimit = 100; /* items */
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Error Messages
        #region Resource Error Messages (FIXED-STRING)
        //
        // NOTE: These six strings must be compile time constants because
        //       they are used before the cultureInfo and resourceManager
        //       objects are available to resolve runtime string resources.
        //
        private const string CultureInfoError =
            "could not interpret \"{0}\" as a culture name or identifier";

        private const string InvalidCultureInfoError =
            "invalid culture";

        private const string InvalidBaseResourceName =
            "invalid base resource name";

        private const string ResourceManagerError =
            "could not create resource manager \"{0}\"";

        private const string InvalidCallStackError =
            "call stack is invalid";
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Script Cancellation Error Messages
        private const string demandCancelResultFormat = "user canceled";

        private const string timeoutCancelPromptFormat =
            "possible runaway script ({0} milliseconds), cancel?";

        internal const string timeoutCancelResultFormat =
            "runaway script unwound after {0} milliseconds";

        private const string finallyTimeoutCancelResultFormat =
            "runaway finally script unwound after {0} milliseconds";
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Procedure Declaration Error Messages
        //
        // NOTE: These two strings are used by the procedure declaration engine.
        //       For localization, we need to make them into properties and load
        //       them from a resource file.
        //
        internal const string ArgumentNotScalarError =
            "formal parameter \"{0}\" is an array element";

        internal const string ArgumentNotSimpleError =
            "formal parameter \"{0}\" is not a simple name";
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Opaque Handles
#if NATIVE && TCL
        #region Tcl Interpreters
        internal const string tclParentInterpPrefix = "parentInterp";
        private const string tclSafeInterpPrefix = "safeInterp";
        private const string tclInterpPrefix = "interp";
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Tcl Threads (Isolated Worker Threads)
#if TCL_THREADS
        private const string tclThreadPrefix = "thread";
#endif
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Nesting Level Defaults
        private static readonly int DefaultReadyLimit = 0;
        private static readonly int DefaultRecursionLimit = 1000;
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private Read-Only Data
        //
        // NOTE: The AppDomain-wide unique Id for this interpreter.
        //
        private readonly long id = GlobalState.NextInterpreterId();

        //
        // NOTE: The optional token used to locate this interpreter when the
        //       caller uses the IfNecessary creation flag.
        //
        private readonly ulong? token = null;

        //
        // NOTE: The creation DateTime for this interpreter (read-only).
        //
        private readonly DateTime created = TimeOps.GetUtcNow();

        //
        // NOTE: The number of times this interpreter has been returned from
        //       the Create static method.
        //
        private long createCount = 0;

        //
        // FIXME: Review and revise usage of locking in the interpreter object,
        //        paying careful attention to any routines whose primary purpose
        //        is to modify collections of data (e.g. commands, plugins, etc).
        //
        private readonly object syncRoot = new object();
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private Context Data
#if THREADING
        private int globalLevels;
        private int globalScriptLevels;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IContextManager contextManager;
        private int preDisposeContextCount;
        private int postDisposeContextCount;
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private Engine Context Data
        //
        // HACK: These cannot be (solely) per-thread because we allow script
        //       cancellation to occur from any thread; however, they do have
        //       per-thread peer fields in the engine context.
        //
        private bool cancel;
        private bool unwind;
        private bool halt;

        private Result cancelResult;
        private Result haltResult;
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private Context Data (!THREADING, per-interpreter, per-thread)
        #region Private Engine Context Data (!THREADING, per-interpreter, per-thread)
#if !THREADING
        private IClientData contextClientData;

        private int levels;
        private int maximumLevels;

        private int scriptLevels;
        private int maximumScriptLevels;

        private int parserLevels;
        private int maximumParserLevels;

        private int expressionLevels;
        private int entryExpressionLevels;
        private int maximumExpressionLevels;

        private int previousLevels;   // previous evaluation nesting level (for [test*], etc.)
        private int catchLevels;      // [catch] nesting level
        private int unknownLevels;    // [unknown] nesting level
        private int traceLevels;      // variable trace nesting level
        private int subCommandLevels; // sub-command nesting level
        private int settingLevels;    // EvaluateFileForSettings nesting level
        private int packageLevels;    // EvaluatePackageScript nesting level

#if ARGUMENT_CACHE
        private Argument cacheArgument;
#endif

#if DEBUGGER
        private int watchpointLevels; // variable watch nesting level
#endif

#if NOTIFY || NOTIFY_OBJECT
        private int notifyLevels;     // notification nesting level
#endif

        private int securityLevels;   // security plugin loader nesting level
        private int policyLevels;     // policy checking nesting level
        private int testLevels;       // the nesting level of the test(s).

#if DEBUGGER
        private bool isDebuggerExiting; // skip ready flag, always reset at level 0.
#endif

        private bool stackOverflow;   // stack overflow flag, always reset at level 0.

#if PREVIOUS_RESULT
        private Result previousResult;
#endif

        private IParseState parseState; // NOTE: For internal engine use only.
        private ReturnCode returnCode; // NOTE: For internal engine use only.

        private int errorLine;       // NOTE: For internal engine use only.
        private string errorCode;    // NOTE: For internal engine use only.
        private string errorInfo;    // NOTE: For internal engine use only.
        private int errorFrames;     // NOTE: For internal engine use only.
        private Exception exception; // NOTE: For internal engine use only.

        private IScriptLocation scriptLocation;     // used only when set by [info script ?fileName?]
        private ScriptLocationList scriptLocations; // used by [info] command directly.

#if SCRIPT_ARGUMENTS
        private ArgumentListStack scriptArguments;
#endif

        private long previousProcessId;   // id of the previous Process to be [exec]'d

        private ArraySearchDictionary arraySearches;

#if HISTORY
        private IHistoryFilter historyEngineFilter;
        private ClientDataList _history;
#endif

        //
        // NOTE: This is written to by "DebugOps.Complain" for inclusion in
        //       the interactive debugger output.
        //
        private string complaint;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private Interactive Context Data (!THREADING, per-interpreter, per-thread)
#if SHELL
        //
        // NOTE: This dictionary keeps track of which interactive loops for this
        //       interpreter are "paused" (i.e. the threads that are waiting inside
        //       of InteractiveOps.DispatchCommand to be "unpaused").  The key for
        //       these entries is a combination of the integer AppDomain identifier
        //       and the integer thread identifier.  The value for these entries is
        //       the number of times "pause" has been executed (i.e. for a thread)
        //       without a corresponding "unpause".  The lack of an entry indicates
        //       the interactive loop for that thread is not "paused".
        //
        private LongLongDictionary pausedInteractiveLoops;
        private int globalInteractiveLoops;
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if !THREADING
        private bool interactive;
        private string interactiveInput;
        private string previousInteractiveInput;
        private string interactiveMode;
        private int activeInteractiveLoops;
        private int totalInteractiveLoops;
        private int totalInteractiveInputs;

#if SHELL
        private IShellCallbackData shellCallbackData;
        private IInteractiveLoopData interactiveLoopData;
        private IUpdateData updateData;
#endif

        private StringTransformCallback interactiveCommandCallback;

#if HISTORY
        private IHistoryData historyLoadData;
        private IHistoryData historySaveData;

        private IHistoryFilter historyInfoFilter;
        private IHistoryFilter historyLoadFilter;
        private IHistoryFilter historySaveFilter;

        private string historyFileName;
#endif
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private Test Context Data (!THREADING, per-interpreter, per-thread)
#if !THREADING
        //
        // NOTE: TclTest related state.
        //
        private Interpreter testTargetInterpreter; // parent
        private long[] testStatistics; // total tests, passed, failed, etc.
        private StringList testConstraints;
        private IntDictionary testKnownBugs;
        private StringListDictionary testSkipped;
        private StringList testFailures;
        private IntDictionary testCounts; // all tests that have been run.
        private StringList testMatch;
        private StringList testSkip;
        private ReturnCodeDictionary testReturnCodeMessages; // used by the test suite.

#if DEBUGGER
        private StringDictionary testBreakpoints;
#endif

        private IComparer<string> testComparer;
        private string testPath;
        private TestOutputType testVerbose;
        private int testRepeatCount;
        private string testCurrent;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private Variable Context Data (!THREADING, per-interpreter, per-thread)
        //
        // NOTE: This always points to the global call frame; however, it cannot
        //       be used outside of this class.  Use the "CurrentGlobalFrame"
        //       property instead.
        //
        private ICallFrame globalFrame;

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if !THREADING
        private CallStack callStack;         // the script call stack.
        private ICallFrame globalScopeFrame; // current global scope frame, if any.
        private ICallFrame currentFrame;     // always the current call frame.
        private ICallFrame procedureFrame;   // current procedure call frame, if any.
        private ICallFrame uplevelFrame;     // current uplevel call frame, if any.
        private ITraceInfo traceInfo;        // current trace info, if any.
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private Data (per-interpreter)
        #region Identifier Data
        //
        // NOTE: Always has the value of the Guid for this class
        //       type (read-only).  This field is accessed via
        //       the IIdentifierBase.Id property.
        //
        private Guid uniqueId;

        //
        // NOTE: User-defined.  An arbitrary string used to help
        //       identify this instance.  This field is accessed
        //       via the IIdentifier.Group property.  Initially,
        //       it is always set to null.
        //
        private string group;

        //
        // NOTE: User-defined.  An arbitrary string used to help
        //       identify this instance.  This field is accessed
        //       via the IIdentifier.Description property.
        //       Initially, it is always set to null.
        //
        private string description;

        //
        // NOTE: User-defined.  An arbitrary object used to help
        //       identify this instance.  This field is accessed
        //       via the IHaveClientData.ClientData property.
        //       Initially, it is always set to null.  Any data
        //       that may be contained within it is not owned by
        //       this instance and will not be disposed.
        //
        private IClientData clientData;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Variable Handling Data
        //
        // NOTE: These are the extra variable flags to add, if any,
        //       to the variable flags specified by the caller for
        //       the associated named variable operations.  Use of
        //       these fields should be limited to testing.
        //
        // HACK: These are purposely not read-only.
        //
        private VariableFlags existVariableFlags;
        private VariableFlags getVariableFlags;
        private VariableFlags setVariableFlags;
        private VariableFlags resetVariableFlags;
        private VariableFlags unsetVariableFlags;
        private VariableFlags addVariableFlags;
        private VariableFlags systemArrayVariableFlags;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: When the CreateMissing variable flag is present,
        //       this value will be used as the value of all missing
        //       variables.  If this is of type ElementDictionary, it
        //       will be used for the ArrayValue property of the new
        //       variable; otherwise, it will be used for the Value
        //       property.  If this value is null, no value property
        //       will be set (i.e. the variable will have its default
        //       creation value).
        //
        // HACK: This is purposely not read-only.
        //
        private object missingVariableValue = null;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: When this is non-zero, all new variables created for
        //       the CreateMissing variable flag will be set as dirty
        //       (i.e. to satisfy a [vwait]).
        //
        // HACK: This is purposely not read-only.
        //
        private bool missingVariableDirty;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Plugin Token Data
        private long corePluginToken;

#if NOTIFY || NOTIFY_OBJECT
        private long objectPluginToken;

#if TEST
        private long scriptNotifyPluginToken;
#endif
#endif

#if NOTIFY && NOTIFY_ARGUMENTS
        private long monitorPluginToken;
#endif

#if TEST_PLUGIN || DEBUG
        private long testPluginToken;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Script Cancellation Data
        //
        // NOTE: This is the delegate to be called when the interpreter is
        //       interrupted for some reason, including script cancellations.
        //       Currently, this property is not exposed via the IInterpreter
        //       interface.  In order to take advantage of this feature, use
        //       of the [debug callback] sub-command is required.
        //
        private InterruptCallback interruptCallback;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Threading Data
        private int activeCount;
        private int disposalDisableCount;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private Thread healthThread;
        private EventWaitHandle healthEvent;
        private long goodHealthCount;
        private long badHealthCount;
        private DateTime? lastHealthCheck;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private Thread timeoutThread;

#if SHELL && INTERACTIVE_COMMANDS
        private Thread testGcThread;
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private long threadId; // NOTE: The "primary" (i.e. creation) thread for this interpreter.
        private long managedThreadId; // NOTE: The "primary" managed thread for this interpreter.
        private long nativeThreadId; // NOTE: The "primary" native thread for this interpreter.
        private Thread thread;
        private EventWaitHandle variableEvent;
        private EventWaitHandle setupEvent;

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL
        private Thread interactiveThread; // NOTE: Current interactive thread, if any.
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Extensibility Data
        private object applicationObject;
        private object policyObject;
        private object resolverObject;
        private object userObject;
        private ClientDataDictionary runtimeOptions;
        private bool throwOnFeatureNotSupported;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Status Data
#if WINFORMS
        private Thread statusThread;
        private string statusStartEventName;
        private string statusDoneEventName;
        private object statusObject;
        private StatusCallback statusCallback;
        private int statusLevels;
        private int statusDisposed;
        private long statusIterations;
        private bool statusSynchronous;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private KeyOps.KeyEventMap keyEventMap;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Xml Data
#if XML
        private XmlErrorTypes retryXml;
        private bool validateXml;
        private bool relaxedXml;
        private bool allXml;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Host Integration Data
#if ISOLATED_PLUGINS
        private IHost isolatedHost;
#endif

        private IHost host;
        private IInteractiveHost interactiveHost;
        private bool quiet;

#if POLICY_TRACE
        private bool policyTrace;
#endif

        private TraceFilterCallback traceFilterCallback;
        private NewCommandCallback newCommandCallback;
        private NewProcedureCallback newProcedureCallback;
        private MatchCallback matchCallback;
        private ReadyCallback readyCallback;
        private GetTimeoutCallback getTimeoutCallback;

#if NETWORK
        //
        // NOTE: This is used when creating new WebClient object instances from
        //       within the Engine and the SocketOps classes.
        //
        private PreWebClientCallback preWebClientCallback;
        private NewWebClientCallback newWebClientCallback;
#endif

        //
        // NOTE: This is written to by "DebugOps.TraceWrite" for persisting the information seen
        //       by the tracing subsystem (i.e. "TraceOps") to a stream (e.g. a file on disk).
        //
        private TextWriter traceTextWriter;

        //
        // NOTE: This is written to by "DebugOps.Complain" for persisting the error information
        //       to a stream (e.g. a file on disk).
        //
        private TextWriter debugTextWriter;

        //
        // NOTE: The system default foreground and background colors for this interpreter.  Right
        //       now, these are only used in certain circumstances (i.e. when GetColors is called
        //       and cannot determine from the interpreter host what color settings to use).
        //
        private ConsoleColor defaultForegroundColor;
        private ConsoleColor defaultBackgroundColor;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Entity Initialization Data
        private IRuleSet ruleSet;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Script Library Initialization Data
        private bool preInitialized;           // has the pre-init script been evaluated?
        private string preInitializeText;      // the saved copy of the pre-init script.

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private string libraryPath;            // the location of the "init" script.
        private StringList autoPathList;       // the list of additional dirs to check for packages.

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Lifecycle Flags & Data
        private bool preSetup;                 // has the PreSetup() method completed?
        private bool setup;                    // has the Setup() method completed?

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool initialized;              // is the core script library initialized?
        private string initializedPath;        // path actually used for the "init" script.

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL
        private bool initializedShell;         // is the shell script library initialized?
        private string initializedShellPath;   // path actually used for the "shell" script.
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Trusted Paths, URIs, and Types (When "Safe" Only)
        private StringList trustedPaths; // paths trusted when "safe".
        private UriDictionary<object> trustedUris; // URIs trusted when "safe".

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This is the list of managed types considered to be trusted [by
        //       this interpreter only] if it has been marked as "safe".  This
        //       list is only used when invoking static methods.  Managed types
        //       for non-static methods are checked for trust on a per-instance
        //       basis, via the ObjectFlags associated with the IObject wrapper.
        //
        private ObjectDictionary trustedTypes; // managed types trusted when "safe".
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region CLR Integration Data
        private AppDomain appDomain;
        private IBinder binder;
        private BindingFlags createInstanceBindingFlags;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Entity Manager Data
        #region Tcl/Tk Integration Data
#if NATIVE && TCL
        private readonly object tclSyncRoot = new object();
        private bool tclReadOnly;
        private ITclApi tclApi;

        private IntPtrDictionary tclInterps; // TODO: per-thread?

#if TCL_THREADS
        private TclThreadDictionary tclThreads;
#endif

        private TclBridgeDictionary tclBridges; // TODO: per-thread?
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region CLR Integration Entity Data
        private StringDictionary objectTypes;
        private StringLongPairStringDictionary objectNamespaces;
        private TypePairDictionary<string, long> objectInterfaces;
        private StringDictionary objectAliasNamespaces;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Core Entity Data
#if DATA
        private DbConnectionDictionary connections;
        private DbTransactionDictionary transactions;
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private PolicyWrapperDictionary policies;
        private TraceWrapperDictionary traces;

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if APPDOMAINS
        private AppDomainDictionary appDomains;
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private List<IResolve> resolvers;

        private INamespace globalNamespace;
        private Dictionary<string, INamespace> pendingNamespaces;
        private StringDictionary namespaceMappings;

        private CallFrameDictionary scopes;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private StringDictionary pluginArguments;
        private PluginWrapperDictionary plugins;

#if NOTIFY || NOTIFY_OBJECT
        [ThreadStatic()]
        private PluginWrapperDictionary notifyPlugins; /* CACHE */
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private FunctionWrapperDictionary functions;
        private OperatorWrapperDictionary operators;
        private IOperator[] operatorCache; /* CACHE */

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ObjectWrapperDictionary objects;
        private AliasWrapperDictionary aliases;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private CallbackDictionary callbacks;

#if CALLBACK_QUEUE
        private CallbackQueue callbackQueue;
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private CommandWrapperDictionary commands;
        private CommandWrapperDictionary hiddenCommands;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ProcedureWrapperDictionary procedures;
        private ProcedureWrapperDictionary hiddenProcedures;

        #region Dead Code
#if DEAD_CODE
        private LambdaWrapperDictionary lambdas;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ExecuteWrapperDictionary executes;
        private ExecuteWrapperDictionary hiddenExecutes;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private PackageIndexDictionary packageIndexes;
        private PackageWrapperDictionary packages;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private EncodingDictionary encodings;
        private ChannelDictionary channels;

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if EMIT && NATIVE && LIBRARY
        private ModuleWrapperDictionary modules;
        private DelegateWrapperDictionary delegates;
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private PathDictionary<CleanupPathClientData> cleanupPaths;
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Core Trace Lists
        private TraceList autoPathTraceList;
        private TraceList environmentTraceList;
        private TraceList enumerableVariableTraceList;
        private TraceList linkedVariableTraceList;
        private TraceList systemArrayTraceList;
        private TraceList objectTraceList;
        private TraceList precisionTraceList;
        private TraceList testsTraceList;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Cache Data
#if ARGUMENT_CACHE
        private ArgumentCacheDictionary argumentCache;
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if LIST_CACHE
        private StringListDictionary stringListCache;
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if PARSE_CACHE
        private ParseStateDictionary parseStateCache;
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if EXECUTE_CACHE
        private ExecuteCache executeCache;
        private ExecuteCache hiddenExecuteCache;
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TYPE_CACHE
        private TypeDictionary typeCache;
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if COM_TYPE_CACHE
        private IntPtrTypeListDictionary comTypeListCache;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Child Interpreter Data
        private Interpreter parentInterpreter;
        private string childName;

#if APPDOMAINS && ISOLATED_INTERPRETERS
        private string childAppDomainName;
#endif

        private InterpreterDictionary childInterpreters;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Owner Object Data
        //
        // NOTE: What object is logically the "owner" of this
        //       interpreter?
        //
        private object owner;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Object Group Data
        //
        // NOTE: What (interpreter) object is this interpreter associated
        //       with, if any?  Zero is used to mean it has no association.
        //       This is only set via the PutInGroup method, which is used
        //       by the ScriptOps.CreateInterpreterForSettings method to
        //       group the (cached, non-isolated) interpreters for use when
        //       loading settings (i.e. LoadSettingsViaFile) in order to
        //       clean them up when the "group leader" interpreter is being
        //       disposed.  Isolated interpreters cannot be handled in this
        //       way because their lifetimes are already tied to the "group
        //       leader" interpreter via the parent / child interpreter
        //       mechanism.
        //
        private long groupId;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Resource Data
        private CultureInfo cultureInfo;
        private ResourceManager resourceManager;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Shell Data
#if SHELL && !THREADING
        private PreviewArgumentCallback previewArgumentCallback;
        private UnknownArgumentCallback unknownArgumentCallback;
        private EvaluateScriptCallback evaluateScriptCallback;
        private EvaluateFileCallback evaluateFileCallback;
        private EvaluateEncodedFileCallback evaluateEncodedFileCallback;
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL
#if !THREADING
        private Semaphore savedInteractiveLoopSemaphore;
#endif

        private Semaphore interactiveLoopSemaphore;
        private EventWaitHandle interactiveLoopDoneEvent;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Debugger Data
#if DEBUGGER && !THREADING
        private IDebugger debugger;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This is used by the Debugger class when it needs to break into
        //       the interactive loop.
        //
        private InteractiveLoopCallback interactiveLoopCallback;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Data Type Conversion Data
        private string dateTimeFormat;
        private DateTimeKind dateTimeKind;
        private DateTimeStyles dateTimeStyles;
        private IEnumerable<string> timeServers;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Expression Engine Data
        private Random random;
        private RandomNumberGenerator randomNumberGenerator;

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int precision; // COMPAT: Tcl.
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Entropy Data
        private byte[] entropy;
        private byte[] safeEntropy;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Event Data
        private IEventManager eventManager;
        private SleepWaitCallback sleepWaitCallback;
        private int eventCount;

#if NATIVE && TCL
        private int tclEventCount;
        private int tclSleepCount;
#endif

        private int waitCount;
        private int waitSpinCount;

#if NETWORK
        private int serverSockets;
#endif

        private int sleepTime;
        private int timeout;
        private int finallyTimeout;
        private int networkTimeout;
        private int threadStackSize;
        private int extraStackSpace;

#if CALLBACK_QUEUE
        private int callbackLimit;
#endif

        private int eventLimit;
        private int procedureLimit;
        private int variableLimit;
        private int arrayElementLimit;

#if RESULT_LIMITS
        private int executeResultLimit;
        private int nestedResultLimit;
#endif

        private string backgroundError; // NOTE: Background error handler.
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Plugin Data
        private string pluginBaseDirectory;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Finalization Data
        private event DisposeCallback preDisposeCallbacks;
        private event DisposeCallback postDisposeCallbacks;
        private int disposeCount;
        private bool disposed;
        private bool deleted;
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Script Engine Data
        private long nextId;
        private bool readOnly;
        private bool immutable;

        private PolicyDecision commandDecision;
        private PolicyDecision scriptDecision;
        private PolicyDecision fileDecision;
        private PolicyDecision streamDecision;

        private IProfilerState profiler;

        private long unknownCount;
        private long operationCount;
        private long commandCount; // COMPAT: Tcl.
        private int readyCount;
        private int readyLimit;
        private int recursionLimit; // COMPAT: Tcl.

        private bool exit;
        private ExitCode exitCode;

#if HISTORY
        private bool history;
        private int historyLimit;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Flags Data
        private CreateFlags createFlags;
        private CreateFlags defaultCreateFlags;

        private HostCreateFlags hostCreateFlags;
        private HostCreateFlags defaultHostCreateFlags;

        private InitializeFlags initializeFlags;
        private InitializeFlags defaultInitializeFlags;

        private ScriptFlags scriptFlags;
        private ScriptFlags defaultScriptFlags;

        private InterpreterFlags interpreterFlags;
        private InterpreterFlags defaultInterpreterFlags;

        private InterpreterStateFlags interpreterStateFlags;

#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || EXECUTE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
        private CacheFlags cacheFlags;
#endif

        private PathComparisonType pathComparisonType;
        private PackageIndexFlags packageIndexFlags;
        private VariableFlags eventVariableFlags;
        private EventWaitFlags eventWaitFlags;
        private ReadyFlags readyFlags;
        private EngineFlags engineFlags;
        private SubstitutionFlags substitutionFlags;
        private ExpressionFlags expressionFlags;

        private EventFlags afterEventFlags;
        private EventFlags engineEventFlags;
        private EventFlags queueEventFlags;
        private EventFlags serviceEventFlags;
        private EventFlags updateEventFlags;
        private EventFlags waitEventFlags;

        private UpdateFlags updateFlags;

#if DEBUGGER || SHELL
        private HeaderFlags headerFlags;
        private DetailFlags detailFlags;
#endif

#if SHELL && INTERACTIVE_COMMANDS
        private bool interactiveCommandsEnabled;

        private EngineFlags interactiveEngineFlags;
        private SubstitutionFlags interactiveSubstitutionFlags;
        private EventFlags interactiveEventFlags;
        private ExpressionFlags interactiveExpressionFlags;
#endif

        private VariableFlags newGlobalVariableFlags;
        private VariableFlags newLocalVariableFlags;
        private PackageFlags packageFlags;
        private ProcedureFlags procedureFlags;

        private PluginFlags pluginFlags;
        private PluginFlags defaultPluginFlags;

#if NOTIFY || NOTIFY_OBJECT
        private NotifyType notifyTypes;
        private NotifyFlags notifyFlags;
        private int notify;
#endif

#if NATIVE && TCL
        private FindFlags tclFindFlags;
        private LoadFlags tclLoadFlags;
        private UnloadFlags tclCommandUnloadFlags;
        private UnloadFlags tclExitUnloadFlags;
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Unknown Handler Data
        private UnknownCallback unknownCallback;
        private string unknown;          // NOTE: Unknown command handler.
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Package Handling Data
        private PackageCallback packageFallback;
        private string packageUnknown;   // NOTE: Unknown package handler.
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IIdentifierName Members
        public string Name
        {
            get { CheckDisposed(); return String.Empty; }
            set { CheckDisposed(); throw new NotImplementedException(); }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IIdentifierBase Members
        public IdentifierKind Kind
        {
            get { CheckDisposed(); return IdentifierKind.Interpreter; }
            set { CheckDisposed(); throw new NotImplementedException(); }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        Guid IIdentifierBase.Id
        {
            get { CheckDisposed(); lock (syncRoot) { return uniqueId; } }
            set { CheckDisposed(); throw new NotImplementedException(); }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IIdentifier Members
        public string Group
        {
            get { CheckDisposed(); lock (syncRoot) { return group; } }
            set { CheckDisposed(); lock (syncRoot) { group = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string Description
        {
            get { CheckDisposed(); lock (syncRoot) { return description; } }
            set { CheckDisposed(); lock (syncRoot) { description = value; } }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IGetClientData / ISetClientData Members
        public IClientData ClientData
        {
            get { CheckDisposed(); lock (syncRoot) { return clientData; } }
            set { CheckDisposed(); lock (syncRoot) { clientData = value; } }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IArgumentManager Members
        public ReturnCode CheckOptions(
            OptionDictionary options,
            ArgumentList arguments,
            int listCount /* for MustBeIndex, the count of the list tied to the option(s) */,
            int startIndex,
            int stopIndex,
            ref int nextIndex /* upon success, location of the first non-option argument. */,
            ref Result error
            )
        {
            CheckDisposed();

            int endIndex = Index.Invalid;

            return GetOptions(
                options, arguments, listCount, startIndex, stopIndex,
                OptionBehaviorFlags.CheckOptions, true, false, false,
                ref nextIndex, ref endIndex, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetOptions(
            OptionDictionary options,
            ArgumentList arguments,
            int listCount /* for MustBeIndex, the count of the list tied to the option(s) */,
            int startIndex,
            int stopIndex,
            bool strict, /* raise an error if any unknown option is encountered (instead of stopping). */
            ref int nextIndex /* upon success, location of the first non-option argument. */,
            ref Result error
            )
        {
            CheckDisposed();

            int endIndex = Index.Invalid;

            return GetOptions(
                options, arguments, listCount, startIndex, stopIndex,
                strict ? OptionBehaviorFlags.Strict : OptionBehaviorFlags.Default,
                true, false, false, ref nextIndex, ref endIndex, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetOptions(
            IIdentifier identifier,
            OptionDictionary options,
            ArgumentList arguments,
            ref int argumentIndex,
            ref Result error
            )
        {
            CheckDisposed();

            int startIndex = 0;
            IEnsemble ensemble = identifier as IEnsemble;

            if (ensemble != null)
            {
                EnsembleDictionary subCommands = ensemble.SubCommands;

                if ((subCommands != null) && (subCommands.Count > 0))
                    startIndex = 2; /* NOTE: Yes, has sub-commands. */
                else
                    startIndex = 1; /* NOTE: No, treat as command. */
            }
            else if (identifier is ICommand)
            {
                startIndex = 1; /* NOTE: Treat as command, one name. */
            }

            return GetOptions(
                options, arguments, 0, startIndex, Index.Invalid,
                false, ref argumentIndex, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetArguments(
            ref StringList arguments,
            ref Result error
            )
        {
            CheckDisposed();

            return GetArguments(ref arguments, true, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetArguments(
            ref StringList arguments,
            bool strict,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code;
            Result localError; /* REUSED */
            Result value = null;

            localError = null;

            code = GetVariableValue(
                VariableFlags.None, TclVars.Core.ShellArguments,
                ref value, ref localError);

            if (code == ReturnCode.Ok)
            {
                StringList list = null;

                localError = null;

                code = ParserOps<string>.SplitList(
                    this, value, 0, Length.Invalid, false, ref list,
                    ref localError);

                if (code == ReturnCode.Ok)
                    arguments = list;
                else
                    error = localError;
            }
            else if (!strict)
            {
                arguments = null;
                code = ReturnCode.Ok;
            }
            else
            {
                error = localError;
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SetArguments(
            StringList arguments,
            ref Result error
            )
        {
            CheckDisposed();

            return SetArguments(arguments, true, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SetArguments(
            StringList arguments,
            bool strict,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code;

            if (arguments != null)
            {
                code = SetLibraryVariableValue(
                    VariableFlags.None, TclVars.Core.ShellArgumentCount,
                    arguments.Count.ToString(), ref error);

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue(
                        VariableFlags.None, TclVars.Core.ShellArguments,
                        arguments.ToString(), ref error);
            }
            else if (!strict)
            {
                code = SetLibraryVariableValue(
                    VariableFlags.None, TclVars.Core.ShellArgumentCount,
                    Value.ZeroString, ref error);

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue(
                        VariableFlags.None, TclVars.Core.ShellArguments,
                        null, ref error);
            }
            else
            {
                error = "invalid arguments";
                code = ReturnCode.Error;
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode MergeArguments(
            OptionDictionary options,
            ArgumentList arguments1,
            ArgumentList arguments2,
            int startIndex1,
            int startIndex2,
            bool skipFirst1,
            bool skipFirst2,
            bool useRemaining1,
            ref ArgumentList arguments,
            ref Result error
            )
        {
            CheckDisposed();

            return PrivateMergeArguments(
                options, arguments1, arguments2, OptionBehaviorFlags.Default,
                startIndex1, startIndex2, skipFirst1, skipFirst2, useRemaining1,
                ref arguments, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal bool HasZeroString()
        {
            return HasZeroString(interpreterFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool HasZeroString(
            InterpreterFlags interpreterFlags
            )
        {
#if !MONO && NATIVE && WINDOWS
            /* EXEMPT */
            return FlagOps.HasFlags(interpreterFlags,
                InterpreterFlags.ZeroString, true);
#else
            return false;
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetOptions(
            OptionDictionary options,
            ArgumentList arguments,
            int listCount,
            int startIndex,
            int stopIndex,
            OptionBehaviorFlags behaviorFlags,
            bool strict,
            ref int nextIndex,
            ref Result error
            )
        {
            int endIndex = Index.Invalid;

            return GetOptions(
                options, arguments, listCount, startIndex, stopIndex, behaviorFlags |
                (strict ? OptionBehaviorFlags.Strict : OptionBehaviorFlags.Default),
                true, false, false, ref nextIndex, ref endIndex, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ScanOptions(
            OptionDictionary options,
            ArgumentList arguments,
            int listCount,
            int startIndex,
            int stopIndex,
            bool strict,
            ref int nextIndex,
            ref Result error
            )
        {
            int endIndex = Index.Invalid;

            return ScanOptions(
                options, arguments, listCount, startIndex,
                stopIndex, strict ?
                    OptionBehaviorFlags.Strict :
                    OptionBehaviorFlags.Default,
                ref nextIndex, ref endIndex, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode ScanOptions(
            OptionDictionary options,
            ArgumentList arguments,
            int listCount,
            int startIndex,
            int stopIndex,
            OptionBehaviorFlags behaviorFlags,
            ref int nextIndex,
            ref int endIndex,
            ref Result error
            )
        {
            return GetOptions(
                options, arguments, listCount, startIndex,
                stopIndex, behaviorFlags, true, true, true,
                ref nextIndex, ref endIndex, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This is the "Universal Option Parser".
        //
        internal ReturnCode GetOptions(
            OptionDictionary options,
            ArgumentList arguments,
            int listCount /* for MustBeIndex, the count of the list tied to the option(s) */,
            int startIndex,
            int stopIndex,
            OptionBehaviorFlags behaviorFlags, /* do we want to stop, error, or ignore unknown options? */
            bool noCase, /* case-insensitive option names? */
            bool noValue, /* do not try to interpret strings as values of any kind. */
            bool noSet, /* scan mode, do not set any values (no changes to options dictionary). */
            ref int nextIndex, /* upon success, location of the first non-option argument. */
            ref int endIndex, /* upon success, location of EndOfOptions if found, otherwise unchanged. */
            ref Result error
            )
        {
            ReturnCode code;

            if (options != null)
            {
                if (arguments != null)
                {
                    int argumentCount = arguments.Count;

                    if (ListOps.CheckStartAndStopIndex(
                            0, argumentCount - 1, ref startIndex, ref stopIndex, ref error))
                    {
                        AppDomain appDomain = AppDomainOps.GetCurrent();
                        CultureInfo cultureInfo = Value.GetDefaultCulture();
                        string dateTimeFormat = ObjectOps.GetDefaultDateTimeFormat();
                        DateTimeKind dateTimeKind = ObjectOps.GetDefaultDateTimeKind();
                        LookupFlags lookupFlags = LookupFlags.OptionDefault;
                        bool safe = InternalIsSafe();

                        bool locked = false;

                        try
                        {
                            InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                            if (locked)
                            {
                                appDomain = this.appDomain;
                                cultureInfo = this.cultureInfo;
                                dateTimeFormat = this.dateTimeFormat;
                                dateTimeKind = this.dateTimeKind;
                            }
                            else
                            {
                                TraceOps.DebugTrace(
                                    "GetOptions: unable to acquire lock",
                                    typeof(Interpreter).Name,
                                    TracePriority.LockWarning);
                            }
                        }
                        finally
                        {
                            InternalExitLock(ref locked); /* TRANSACTIONAL */
                        }

                        if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.ValidateLookups, true))
                            lookupFlags |= LookupFlags.Validate;
                        else
                            lookupFlags &= ~LookupFlags.Validate;

                        if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.StrictLookups, true))
                            lookupFlags |= LookupFlags.Strict;
                        else
                            lookupFlags &= ~LookupFlags.Strict;

                        code = ReturnCode.Ok;

                        for (int argumentIndex = startIndex; argumentIndex <= stopIndex; argumentIndex++)
                        {
                            Argument currentArgument = arguments[argumentIndex];
                            string current = currentArgument;

                            Argument nextArgument = ((argumentIndex + 1) <= stopIndex) ?
                                arguments[argumentIndex + 1] : null;

                            string next = nextArgument;

                            //
                            // NOTE: If this is the last argument, make sure it can be
                            //       treated as a "possible option".  If not, stop now.
                            //
                            if ((argumentIndex == stopIndex) &&
                                FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.LastIsNonOption, true))
                            {
                                nextIndex = argumentIndex;
                                break;
                            }

                            IOption option = null;

                            if (Option.IsEndOfOptions(current))
                            {
                                if (options.Has(Option.EndOfOptions, ref option))
                                {
                                    if (option == null)
                                    {
                                        error = String.Format(
                                            "{0} option is invalid",
                                            FormatOps.WrapOrNull(current));

                                        code = ReturnCode.Error;
                                        break;
                                    }
                                    else if (option.IsIgnored(options))
                                    {
                                        if (option.MustHaveValue(options))
                                        {
                                            if (next != null)
                                            {
                                                argumentIndex++; // skip option value...
                                            }
                                            else
                                            {
                                                error = String.Format(
                                                    "{0} option must be followed by {1}",
                                                    FormatOps.WrapOrNull(current),
                                                    option.FlagsToString());

                                                code = ReturnCode.Error;
                                                break;
                                            }
                                        }
                                    }
                                    else if (option.CanBePresent(options, ref error))
                                    {
                                        //
                                        // BUGFIX: Unless forbidden, actually mark as present.
                                        //         Why not?
                                        //
                                        if (!noSet)
                                            option.SetPresent(options, true, argumentIndex, null);

                                        if ((argumentIndex + 1) < argumentCount)
                                            nextIndex = argumentIndex + 1;
                                        else
                                            nextIndex = Index.Invalid;

                                        endIndex = argumentIndex;
                                    }
                                    else
                                    {
                                        code = ReturnCode.Error;
                                    }
                                    break;
                                }
                                else if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.ErrorOnEndOfOptions, true))
                                {
                                    //
                                    // NOTE: This is rarely used because if they do not
                                    //       explicitly allow the end-of-options marker
                                    //       they normally also want it to be considered
                                    //       the first "non-option" argument.
                                    //
                                    error = "unexpected end-of-options marker";
                                    code = ReturnCode.Error;
                                    break;
                                }
                                else if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.StopOnEndOfOptions, true))
                                {
                                    //
                                    // NOTE: This end-of-options marker is not a valid
                                    //       option and we want to stop now because we
                                    //       want to assume it is the first non-option
                                    //       argument.  This is the default behavior.
                                    //
                                    nextIndex = argumentIndex;
                                    break;
                                }
                                else if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.IgnoreOnEndOfOptions, true))
                                {
                                    //
                                    // NOTE: This end-of-options marker is not a valid
                                    //       option and we want to simply ignore it.
                                    //       We may also want to skip the next argument.
                                    //       This behavior should almost never be used
                                    //       unless the caller is 100% sure what it does.
                                    //
                                    if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.SkipOnEndOfOptions, true))
                                        argumentIndex++;
                                }
                            }
                            else if (Option.IsListOfOptions(current))
                            {
                                if (options.Has(Option.ListOfOptions, ref option))
                                {
                                    if (option == null)
                                    {
                                        error = String.Format(
                                            "{0} option is invalid",
                                            FormatOps.WrapOrNull(current));

                                        code = ReturnCode.Error;
                                        break;
                                    }
                                    else if (option.IsIgnored(options))
                                    {
                                        if (option.MustHaveValue(options))
                                        {
                                            if (next != null)
                                            {
                                                argumentIndex++; // skip option value...
                                            }
                                            else
                                            {
                                                error = String.Format(
                                                    "{0} option must be followed by {1}",
                                                    FormatOps.WrapOrNull(current),
                                                    option.FlagsToString());

                                                code = ReturnCode.Error;
                                                break;
                                            }
                                        }
                                    }
                                    else if (option.CanBePresent(options, ref error))
                                    {
                                        //
                                        // BUGFIX: Unless forbidden, actually mark as present.
                                        //         Why not?
                                        //
                                        if (!noSet)
                                            option.SetPresent(options, true, argumentIndex, null);

                                        //
                                        // NOTE: The error message is the list of all
                                        //       available options.
                                        //
                                        error = OptionDictionary.ListOptions(options, !safe);
                                        code = ReturnCode.Return; /* SPECIAL */
                                    }
                                    else
                                    {
                                        code = ReturnCode.Error;
                                    }
                                    break;
                                }
                                else if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.ErrorOnListOfOptions, true))
                                {
                                    //
                                    // NOTE: This is rarely used because if they do not
                                    //       explicitly allow the list-of-options marker
                                    //       they normally also want it to be considered
                                    //       the first "non-option" argument.
                                    //
                                    error = "unexpected list-of-options marker";
                                    code = ReturnCode.Error;
                                    break;
                                }
                                else if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.StopOnListOfOptions, true))
                                {
                                    //
                                    // NOTE: This list-of-options marker is not a valid
                                    //       option and we want to stop now because we
                                    //       want to assume it is the first non-option
                                    //       argument.  This is the default behavior.
                                    //
                                    nextIndex = argumentIndex;
                                    break;
                                }
                                else if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.IgnoreOnListOfOptions, true))
                                {
                                    //
                                    // NOTE: This list-of-options marker is not a valid
                                    //       option and we want to simply ignore it.
                                    //       We may also want to skip the next argument.
                                    //       This behavior should almost never be used
                                    //       unless the caller is 100% sure what it does.
                                    //
                                    if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.SkipOnListOfOptions, true))
                                        argumentIndex++;
                                }
                            }
                            else if (Option.LooksLikeOption(current))
                            {
                                bool ambiguous = false;
                                Result localError = null;

                                if (options.TryResolve(
                                        current, true, noCase, !safe, ref ambiguous,
                                        ref option, ref localError) == ReturnCode.Ok)
                                {
                                    if (option != null)
                                    {
                                        string name = option.Name;
                                        OptionFlags flags = option.Flags;

                                        if (option.IsIgnored(options))
                                        {
                                            if (option.MustHaveValue(options))
                                            {
                                                if (next != null)
                                                {
                                                    argumentIndex++; // skip option value...
                                                }
                                                else
                                                {
                                                    error = String.Format(
                                                        "{0} option must be followed by {1}",
                                                        FormatOps.WrapOrNull(current),
                                                        option.FlagsToString());

                                                    code = ReturnCode.Error;
                                                    break;
                                                }
                                            }
                                        }
                                        else if (!option.CanBePresent(options, ref error))
                                        {
                                            code = ReturnCode.Error;
                                            break;
                                        }
                                        else if (FlagOps.HasFlags(flags, OptionFlags.EndOfOptions, true))
                                        {
                                            //
                                            // BUGFIX: Unless forbidden, actually mark as present.
                                            //         Why not?
                                            //
                                            if (!noSet)
                                                option.SetPresent(options, true, argumentIndex, null);

                                            if ((argumentIndex + 1) < argumentCount)
                                                nextIndex = argumentIndex + 1;
                                            else
                                                nextIndex = Index.Invalid;

                                            endIndex = argumentIndex;
                                            break;
                                        }
                                        else if (FlagOps.HasFlags(flags, OptionFlags.ListOfOptions, true))
                                        {
                                            //
                                            // BUGFIX: Unless forbidden, actually mark as present.
                                            //         Why not?
                                            //
                                            if (!noSet)
                                                option.SetPresent(options, true, argumentIndex, null);

                                            error = OptionDictionary.ListOptions(options, !safe);
                                            code = ReturnCode.Return; /* SPECIAL */
                                            break;
                                        }
                                        else if (option.IsUnsafe(options) && safe)
                                        {
                                            error = String.Format(
                                                "permission denied: safe interpreter cannot use option {0}",
                                                FormatOps.WrapOrNull(name));

                                            code = ReturnCode.Error;
                                        }
                                        else if (option.MustHaveValue(options))
                                        {
#if !MONO && NATIVE && WINDOWS
                                            bool canZero = HasZeroString();
#endif

                                            bool zero = false;

                                            try
                                            {
                                                if (next != null)
                                                {
                                                    //
                                                    // NOTE: Initially, this value of this option is null.  The block
                                                    //       below has the implicit guarantee that either the option
                                                    //       value will be set to something non-null OR the return
                                                    //       code will be set to something non-Ok.
                                                    //
                                                    Variant variant = null;

                                                    //
                                                    // NOTE: Are we allowed to interpret the string as the type of
                                                    //       value required for this option?  Otherwise, we will not
                                                    //       attempt any conversion and if we are in non-scan mode
                                                    //       the final option value will be set as a string.  We
                                                    //       assume that the caller knows this.
                                                    //
                                                    if (!noValue)
                                                    {
                                                        //
                                                        // NOTE: Does this option require strict value recognition
                                                        //       semantics?
                                                        //
                                                        bool strictOption = option.IsStrict(options);

                                                        //
                                                        // NOTE: Does this option not care about case?
                                                        //
                                                        bool noCaseOption = option.IsNoCase(options);

                                                        //
                                                        // NOTE: Does this option allow integer values?  This
                                                        //       only applies if the type is Enum.
                                                        //
                                                        bool allowIntegerOption = option.IsAllowInteger(options);

                                                        //
                                                        // NOTE: Ok, now figure out what kind of value this option
                                                        //       requires and try to parse it from the option value
                                                        //       string.
                                                        //
                                                        if (FlagOps.HasFlags(flags, OptionFlags.MustBeTypeList, true))
                                                        {
                                                            TypeList typeList = null;
                                                            ResultList errors = null;

                                                            code = Value.GetTypeList(
                                                                this, next, appDomain, Value.GetTypeValueFlags(
                                                                    strictOption, false, noCase || noCaseOption),
                                                                cultureInfo, ref typeList, ref errors);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(typeList);
                                                            else
                                                                error = errors;
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeEnumList, true))
                                                        {
                                                            Type valueType = option.Type;

                                                            if (valueType != null)
                                                            {
                                                                if (valueType.IsEnum)
                                                                {
                                                                    object oldValue = null;

                                                                    if (EnumOps.IsFlags(valueType))
                                                                        oldValue = option.Value;

                                                                    EnumList enumList = null;
                                                                    ResultList errors = null;

                                                                    code = Value.GetEnumList(
                                                                        this, next, valueType, (oldValue != null) ?
                                                                            oldValue.ToString() : null,
                                                                        Value.GetTypeValueFlags(
                                                                            allowIntegerOption, strictOption, false,
                                                                            noCase || noCaseOption), cultureInfo,
                                                                        ref enumList, ref errors);

                                                                    if (code == ReturnCode.Ok)
                                                                        variant = new Variant(enumList);
                                                                    else
                                                                        error = errors;
                                                                }
                                                                else
                                                                {
                                                                    error = String.Format(
                                                                        "option {0} value type is not an enum",
                                                                        FormatOps.WrapOrNull(name));

                                                                    code = ReturnCode.Error;
                                                                }
                                                            }
                                                            else
                                                            {
                                                                error = String.Format(
                                                                    "option {0} has an invalid value type",
                                                                    FormatOps.WrapOrNull(name));

                                                                code = ReturnCode.Error;
                                                            }
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeReturnCodeList, true))
                                                        {
                                                            ReturnCodeList returnCodeList = null;

                                                            code = Value.GetReturnCodeList(next, cultureInfo,
                                                                ref returnCodeList, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(returnCodeList);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeAbsoluteUri, true))
                                                        {
                                                            Uri uri = null;

                                                            code = Value.GetUri(
                                                                next, UriKind.Absolute, cultureInfo,
                                                                ref uri, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(uri);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeVersion, true))
                                                        {
                                                            Version version = null;

                                                            code = Value.GetVersion(next, cultureInfo,
                                                                ref version, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(version);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeIdentifier, true))
                                                        {
                                                            StringList list = null;

                                                            //
                                                            // TODO: *PERF* We cannot have this call to SplitList perform any
                                                            //       caching because we do not know exactly what the resulting
                                                            //       list will be used for.
                                                            //
                                                            code = ListOps.GetOrCopyOrSplitList(
                                                                this, nextArgument, false, ref list, ref error);

                                                            if (code == ReturnCode.Ok)
                                                            {
                                                                if (list.Count == 2)
                                                                {
                                                                    object enumValue = EnumOps.TryParse(
                                                                        typeof(IdentifierKind), list[0], allowIntegerOption,
                                                                        noCase || noCaseOption, ref error);

                                                                    if (enumValue is IdentifierKind)
                                                                    {
                                                                        IIdentifier identifier = null;

                                                                        code = GetIdentifier(
                                                                            (IdentifierKind)enumValue, list[1], arguments,
                                                                            lookupFlags, ref identifier, ref error);

                                                                        if (code == ReturnCode.Ok)
                                                                            variant = new Variant(identifier);
                                                                    }
                                                                }
                                                                else
                                                                {
                                                                    error = "identifier must be list with two elements: <kind> <name>";
                                                                    code = ReturnCode.Error;
                                                                }
                                                            }
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeAlias, true))
                                                        {
                                                            IAlias alias = null;

                                                            code = GetAlias(next, lookupFlags, ref alias, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(alias);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeOption, true))
                                                        {
                                                            IOption optionValue = Option.FromString(
                                                                this, next, appDomain, allowIntegerOption,
                                                                strictOption, false, noCase || noCaseOption,
                                                                cultureInfo, ref error);

                                                            if (optionValue != null)
                                                                variant = new Variant(optionValue);
                                                            else
                                                                code = ReturnCode.Error;
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeAbsoluteNamespace, true))
                                                        {
                                                            if (AreNamespacesEnabled())
                                                            {
                                                                INamespace @namespace = NamespaceOps.Lookup(
                                                                    this, next, true, false, ref error);

                                                                if (@namespace != null)
                                                                    variant = new Variant(@namespace);
                                                                else
                                                                    code = ReturnCode.Error;
                                                            }
                                                            else
                                                            {
                                                                error = "namespaces not available";
                                                                code = ReturnCode.Error;
                                                            }
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeRelativeNamespace, true))
                                                        {
                                                            if (AreNamespacesEnabled())
                                                            {
                                                                INamespace @namespace = NamespaceOps.Lookup(
                                                                    this, next, false, false, ref error);

                                                                if (@namespace != null)
                                                                    variant = new Variant(@namespace);
                                                                else
                                                                    code = ReturnCode.Error;
                                                            }
                                                            else
                                                            {
                                                                error = "namespaces not available";
                                                                code = ReturnCode.Error;
                                                            }
                                                        }
#if NATIVE && TCL
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeTclInterpreter, true))
                                                        {
                                                            IntPtr interp = IntPtr.Zero;

#if TCL_THREADS
                                                            code = GetTclInterpreterOrThread(
                                                                next, lookupFlags, ref interp, ref error);
#else
                                                            code = GetTclInterpreter(
                                                                next, lookupFlags, ref interp, ref error);
#endif

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(next); /* interpName */
                                                        }
#endif
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeType, true))
                                                        {
                                                            Type type = null;
                                                            ResultList errors = null;

                                                            code = Value.GetAnyType(
                                                                this, next, null, appDomain, Value.GetTypeValueFlags(
                                                                    strictOption, false, noCase || noCaseOption),
                                                                cultureInfo, ref type, ref errors);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(type);
                                                            else
                                                                error = errors;
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeInterpreter, true))
                                                        {
                                                            Interpreter interpreter = null;

                                                            code = Value.GetInterpreter(
                                                                this, next, InterpreterType.Default, ref interpreter,
                                                                ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(interpreter);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeObject, true))
                                                        {
                                                            IObject @object = null;

                                                            code = GetObject(next, lookupFlags, ref @object, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(@object);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeValue, true))
                                                        {
                                                            object value = null;

                                                            code = Value.GetValue(
                                                                next, dateTimeFormat, ValueFlags.AnyStrict,
                                                                dateTimeKind, dateTimeStyles, cultureInfo,
                                                                ref value, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(value);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeList, true))
                                                        {
                                                            StringList list = null;

                                                            //
                                                            // TODO: *PERF* We cannot have this call to SplitList perform any
                                                            //       caching because we do not know exactly what the resulting
                                                            //       list will be used for.
                                                            //
                                                            code = ListOps.GetOrCopyOrSplitList(
                                                                this, nextArgument, false, ref list, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(list);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeDictionary, true))
                                                        {
                                                            StringList list = null;

                                                            //
                                                            // TODO: *PERF* We cannot have this call to SplitList perform any
                                                            //       caching because we do not know exactly what the resulting
                                                            //       list will be used for.
                                                            //
                                                            code = ListOps.GetOrCopyOrSplitList(
                                                                this, nextArgument, false, ref list, ref error);

                                                            if (code == ReturnCode.Ok)
                                                            {
                                                                if ((list.Count % 2) == 0)
                                                                {
                                                                    try
                                                                    {
                                                                        variant = new Variant(
                                                                            new StringDictionary(list, true, true));
                                                                    }
                                                                    catch (Exception e)
                                                                    {
                                                                        error = e;
                                                                        code = ReturnCode.Error;
                                                                    }
                                                                }
                                                                else
                                                                {
                                                                    error = "dictionary list must have an even number of elements";
                                                                    code = ReturnCode.Error;
                                                                }
                                                            }
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeDateTime, true))
                                                        {
                                                            DateTime dateTime = DateTime.MinValue;

                                                            code = Value.GetDateTime2(next, dateTimeFormat, strictOption ?
                                                                ValueFlags.AnyStrictDateTime : ValueFlags.AnyDateTime,
                                                                dateTimeKind, dateTimeStyles, cultureInfo, ref dateTime,
                                                                ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(dateTime);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeTimeSpan, true))
                                                        {
                                                            TimeSpan timeSpan = TimeSpan.Zero;

                                                            code = Value.GetTimeSpan2(next, strictOption ?
                                                                ValueFlags.AnyStrictTimeSpan : ValueFlags.AnyTimeSpan,
                                                                cultureInfo, ref timeSpan, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(timeSpan);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeGuid, true))
                                                        {
                                                            Guid guid = Guid.Empty;

                                                            code = Value.GetGuid(next, cultureInfo, ref guid, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(guid);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeEnum, true))
                                                        {
                                                            Type valueType = option.Type;

                                                            if (valueType != null)
                                                            {
                                                                if (valueType.IsEnum)
                                                                {
                                                                    object enumValue;

                                                                    //
                                                                    // NOTE: Reset the local error result here because
                                                                    //       we check it below (i.e. it will not be
                                                                    //       set by TryParseEnum).
                                                                    //
                                                                    localError = null;

                                                                    if (EnumOps.IsFlags(valueType))
                                                                    {
                                                                        object oldValue = option.Value;

                                                                        enumValue = EnumOps.TryParseFlags(
                                                                            this, valueType, (oldValue != null) ?
                                                                            oldValue.ToString() : null, next,
                                                                            cultureInfo, allowIntegerOption,
                                                                            strictOption, noCase || noCaseOption,
                                                                            ref localError);
                                                                    }
                                                                    else
                                                                    {
                                                                        enumValue = EnumOps.TryParse(
                                                                            valueType, next, allowIntegerOption,
                                                                            noCase || noCaseOption);
                                                                    }

                                                                    //
                                                                    // NOTE: Did we end up with a valid enum value for this type?
                                                                    //
                                                                    if (enumValue != null)
                                                                    {
                                                                        //
                                                                        // NOTE: It is now guaranteed to be the correct Enum type because
                                                                        //       TryParseEnum uses our System.Type object directly and
                                                                        //       cannot return non-null unless Enum.Parse succeeds.
                                                                        //
                                                                        variant = new Variant((Enum)enumValue);
                                                                    }
                                                                    else
                                                                    {
                                                                        //
                                                                        // NOTE: Retain any locally generated error information (from
                                                                        //       TryParseFlagsEnum) because it provides more specific
                                                                        //       feedback than we can at this point.
                                                                        //
                                                                        if (!String.IsNullOrEmpty(localError))
                                                                            error = localError;
                                                                        else
                                                                            error = ScriptOps.BadValue(
                                                                                null, String.Format("{0} value",
                                                                                MarshalOps.GetErrorTypeName(valueType)),
                                                                                next, Enum.GetNames(valueType), null, null);

                                                                        code = ReturnCode.Error;
                                                                    }
                                                                }
                                                                else
                                                                {
                                                                    error = String.Format(
                                                                        "option {0} value type is not an enum",
                                                                        FormatOps.WrapOrNull(name));

                                                                    code = ReturnCode.Error;
                                                                }
                                                            }
                                                            else
                                                            {
                                                                error = String.Format(
                                                                    "option {0} has an invalid value type",
                                                                    FormatOps.WrapOrNull(name));

                                                                code = ReturnCode.Error;
                                                            }
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeReturnCode, true))
                                                        {
                                                            ReturnCode returnCode = ReturnCode.Ok;

                                                            code = Value.GetReturnCode2(next, ValueFlags.AnyReturnCode,
                                                                cultureInfo, ref returnCode, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(returnCode);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeMatchMode, true))
                                                        {
                                                            MatchMode matchMode = MatchMode.None;
                                                            object oldValue = option.Value;

                                                            code = Value.GetMatchMode2(this,
                                                                (oldValue != null) ? oldValue.ToString() : null,
                                                                next, strictOption ? ValueFlags.AnyStrictMatchMode :
                                                                ValueFlags.AnyMatchMode, cultureInfo, ref matchMode,
                                                                ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(matchMode);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeLevel, true))
                                                        {
                                                            ICallFrame otherFrame = null;

                                                            if (GetCallFrame(
                                                                    next, ref otherFrame,
                                                                    ref error) != FrameResult.Invalid)
                                                            {
                                                                variant = new Variant(otherFrame);
                                                            }
                                                            else
                                                            {
                                                                code = ReturnCode.Error;
                                                            }
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeIndex, true))
                                                        {
                                                            int index = Index.Invalid;

                                                            code = Value.GetIndex(
                                                                next, listCount, ValueFlags.AnyIndex,
                                                                cultureInfo, ref index, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(index);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeUnsignedWideInteger, true))
                                                        {
                                                            ulong ulongValue = 0;

                                                            code = Value.GetUnsignedWideInteger2(
                                                                next, ValueFlags.AnyWideInteger | ValueFlags.Unsigned,
                                                                cultureInfo, ref ulongValue, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(ulongValue);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeWideInteger, true))
                                                        {
                                                            long longValue = 0;

                                                            code = Value.GetWideInteger2(next, ValueFlags.AnyWideInteger,
                                                                cultureInfo, ref longValue, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(longValue);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeUnsignedInteger, true))
                                                        {
                                                            uint uintValue = 0;

                                                            code = Value.GetUnsignedInteger2(
                                                                next, ValueFlags.AnyInteger | ValueFlags.Unsigned,
                                                                cultureInfo, ref uintValue, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(uintValue);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeInteger, true))
                                                        {
                                                            int intValue = 0;

                                                            code = Value.GetInteger2(next, ValueFlags.AnyInteger,
                                                                cultureInfo, ref intValue, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(intValue);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeUnsignedNarrowInteger, true))
                                                        {
                                                            ushort ushortValue = 0;

                                                            code = Value.GetUnsignedNarrowInteger2(
                                                                next, ValueFlags.AnyNarrowInteger | ValueFlags.Unsigned,
                                                                cultureInfo, ref ushortValue, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(ushortValue);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeNarrowInteger, true))
                                                        {
                                                            short shortValue = 0;

                                                            code = Value.GetNarrowInteger2(next, ValueFlags.AnyNarrowInteger,
                                                                cultureInfo, ref shortValue, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(shortValue);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeByte, true))
                                                        {
                                                            byte byteValue = 0;

                                                            code = Value.GetByte2(next, ValueFlags.AnyByte, cultureInfo,
                                                                ref byteValue, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(byteValue);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeSignedByte, true))
                                                        {
                                                            sbyte sbyteValue = 0;

                                                            code = Value.GetSignedByte2(
                                                                next, ValueFlags.AnyByte | ValueFlags.Signed,
                                                                cultureInfo, ref sbyteValue, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(sbyteValue);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeBoolean, true))
                                                        {
                                                            bool boolValue = false;

                                                            code = Value.GetBoolean2(next, strictOption ?
                                                                ValueFlags.AnyStrictBoolean : ValueFlags.AnyBoolean,
                                                                cultureInfo, ref boolValue, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(boolValue);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeSecureString, true))
                                                        {
                                                            zero = true;

                                                            SecureString secureString = null;
                                                            IObject @object = null;

                                                            if (GetObject(
                                                                    next, lookupFlags, ref @object,
                                                                    ref error) == ReturnCode.Ok)
                                                            {
                                                                if (@object.Value is SecureString)
                                                                {
                                                                    secureString = (SecureString)@object.Value;
                                                                }
                                                                else
                                                                {
                                                                    error = "invalid secure string";
                                                                    code = ReturnCode.Error;
                                                                }
                                                            }
                                                            else
                                                            {
                                                                secureString = new SecureString();

                                                                foreach (char character in next)
                                                                    secureString.AppendChar(character);

                                                                secureString.MakeReadOnly();
                                                            }

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(secureString);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeEncoding, true))
                                                        {
                                                            Encoding encoding = null;

                                                            code = GetEncoding(
                                                                next, lookupFlags | LookupFlags.NoValidate, ref encoding,
                                                                ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(encoding);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeCultureInfo, true))
                                                        {
                                                            CultureInfo localCultureInfo = null;

                                                            try
                                                            {
                                                                localCultureInfo = CultureInfo.GetCultureInfo(
                                                                    next); /* throw */

                                                                if (localCultureInfo != null)
                                                                {
                                                                    variant = new Variant(localCultureInfo);
                                                                }
                                                                else
                                                                {
                                                                    error = "invalid culture";
                                                                    code = ReturnCode.Error;
                                                                }
                                                            }
                                                            catch (Exception e)
                                                            {
                                                                error = e;
                                                                code = ReturnCode.Error;
                                                            }
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBePlugin, true))
                                                        {
                                                            IPlugin plugin = null;

                                                            code = GetPlugin(
                                                                next, lookupFlags, ref plugin, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(plugin);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeExecute, true))
                                                        {
                                                            IExecute execute = null;

                                                            code = MatchAnyIExecute(null,
                                                                safe ? EngineFlags.None : EngineFlags.MatchHidden,
                                                                next, lookupFlags, ref execute, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(execute);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeCallback, true))
                                                        {
                                                            ICallback callback = null;

                                                            code = Value.GetCallback(this, null,
                                                                next, appDomain, options, Value.GetTypeValueFlags(
                                                                    strictOption, false, noCase || noCaseOption),
                                                                cultureInfo, null, ref callback, ref error);

                                                            if (code == ReturnCode.Ok)
                                                                variant = new Variant(callback);
                                                        }
                                                        else if (FlagOps.HasFlags(flags, OptionFlags.MustBeRuleSet, true))
                                                        {
                                                            IRuleSet ruleSet = RuleSet.Create(
                                                                next, cultureInfo, ref error);

                                                            if (ruleSet != null)
                                                                variant = new Variant(ruleSet);
                                                            else
                                                                code = ReturnCode.Error;
                                                        }
                                                        else
                                                        {
                                                            //
                                                            // NOTE: No strongly-typed value flags were set for this
                                                            //       option, just use the string verbatim.
                                                            //
                                                            variant = new Variant(next); // String
                                                        }
                                                    }
                                                    else
                                                    {
                                                        //
                                                        // NOTE: We are forbidden from interpreting the string as a
                                                        //       strongly-typed value, just use the string verbatim.
                                                        //
                                                        variant = new Variant(next); // String
                                                    }

                                                    //
                                                    // NOTE: If we succeeded, set the option value; otherwise, bail.
                                                    //
                                                    if (code == ReturnCode.Ok)
                                                    {
                                                        if (!noSet)
                                                            option.SetPresent(options, true, argumentIndex, variant);

                                                        argumentIndex++; // skip option value...
                                                    }
                                                    else
                                                    {
                                                        break;
                                                    }
                                                }
                                                else
                                                {
                                                    error = String.Format(
                                                        "{0} option must be followed by {1}",
                                                        FormatOps.WrapOrNull(current),
                                                        option.FlagsToString());

                                                    code = ReturnCode.Error;
                                                    break;
                                                }
                                            }
                                            finally
                                            {
                                                if (zero)
                                                {
                                                    //
                                                    // HACK: Attempt to forcibly "scrub"
                                                    //       the plain-text option value
                                                    //       from memory via whatever
                                                    //       means are available.
                                                    //
                                                    if (nextArgument != null)
                                                        nextArgument.ResetValue(this, true);

                                                    if (localError != null)
                                                        localError.ResetValue(this, true);

                                                    if (error != null)
                                                        error.ResetValue(this, true);

#if !MONO && NATIVE && WINDOWS
                                                    if (canZero)
                                                    {
                                                        ReturnCode scrubCode;
                                                        bool scrubNoComplain = false;
                                                        Result scrubError = null;

                                                        scrubCode = StringOps.ZeroString(
                                                            next, ref scrubNoComplain, ref scrubError);

                                                        if (!scrubNoComplain && (scrubCode != ReturnCode.Ok))
                                                            DebugOps.Complain(this, scrubCode, scrubError);
                                                    }
#endif

                                                    ObjectOps.CollectGarbage(); /* throw */
                                                }
                                            }
                                        }
                                        else if (!noSet)
                                        {
                                            option.SetPresent(options, true, argumentIndex, null);
                                        }
                                    }
                                    else
                                    {
                                        error = String.Format(
                                            "{0} option is invalid",
                                            FormatOps.WrapOrNull(current));

                                        code = ReturnCode.Error;
                                        break;
                                    }
                                }
                                else
                                {
                                    if (ambiguous)
                                    {
                                        if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.ErrorOnAmbiguousOption, true))
                                        {
                                            //
                                            // NOTE: This is not a valid option and we want to
                                            //       treat this as an error.
                                            //
                                            error = localError;
                                            code = ReturnCode.Error;
                                            break;
                                        }
                                        else if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.StopOnAmbiguousOption, true))
                                        {
                                            //
                                            // NOTE: This is not a valid option and we want to
                                            //       stop now because we want to assume it is
                                            //       the first non-option argument.  This is
                                            //       the default behavior.
                                            //
                                            nextIndex = argumentIndex;
                                            break;
                                        }
                                        else if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.IgnoreOnAmbiguousOption, true))
                                        {
                                            //
                                            // NOTE: This is not a valid option and we want to
                                            //       simply ignore it.  We may also want to skip
                                            //       the next argument.
                                            //
                                            if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.SkipOnAmbiguousOption, true))
                                                argumentIndex++;
                                        }
                                    }
                                    else
                                    {
                                        if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.ErrorOnUnknownOption, true))
                                        {
                                            //
                                            // NOTE: This is not a valid option and we want to
                                            //       treat this as an error.
                                            //
                                            error = localError;
                                            code = ReturnCode.Error;
                                            break;
                                        }
                                        else if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.StopOnUnknownOption, true))
                                        {
                                            //
                                            // NOTE: This is not a valid option and we want to
                                            //       stop now because we want to assume it is
                                            //       the first non-option argument.  This is
                                            //       the default behavior.
                                            //
                                            nextIndex = argumentIndex;
                                            break;
                                        }
                                        else if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.IgnoreOnUnknownOption, true))
                                        {
                                            //
                                            // NOTE: This is not a valid option and we want to
                                            //       simply ignore it.  We may also want to skip
                                            //       the next argument.
                                            //
                                            if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.SkipOnUnknownOption, true))
                                                argumentIndex++;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.ErrorOnNonOption, true))
                                {
                                    //
                                    // NOTE: This is a non-option and we want to treat
                                    //       this as an error.
                                    //
                                    error = String.Format(
                                        "unexpected non-option argument {0}",
                                        FormatOps.WrapOrNull(current));

                                    code = ReturnCode.Error;
                                    break;
                                }
                                else if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.StopOnNonOption, true))
                                {
                                    //
                                    // NOTE: This is a non-option and we want to stop
                                    //       now because we want to treat it as the
                                    //       first non-option argument.  This is the
                                    //       default behavior.
                                    //
                                    nextIndex = argumentIndex;
                                    break;
                                }
                                else if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.IgnoreOnNonOption, true))
                                {
                                    //
                                    // NOTE: This is a non-option and we want to simply
                                    //       ignore it.  We may also want to skip the
                                    //       next argument.
                                    //
                                    if (FlagOps.HasFlags(behaviorFlags, OptionBehaviorFlags.SkipOnNonOption, true))
                                        argumentIndex++;
                                }
                            }
                        }
                    }
                    else
                    {
                        code = ReturnCode.Error;
                    }
                }
                else
                {
                    error = "invalid arguments";
                    code = ReturnCode.Error;
                }
            }
            else
            {
                error = "invalid options";
                code = ReturnCode.Error;
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateMergeArguments(
            OptionDictionary options,
            ArgumentList arguments1,
            ArgumentList arguments2,
            OptionBehaviorFlags optionBehaviorFlags,
            int startIndex1,
            int startIndex2,
            bool skipFirst1,
            bool skipFirst2,
            bool useRemaining1,
            ref ArgumentList arguments,
            ref Result error
            )
        {
            ReturnCode code = ReturnCode.Ok;

            //
            // NOTE: The purpose of this method is to properly merge two
            //       arguments lists, including any options, so that the new
            //       combined argument list is constructed in a well-defined
            //       way and can be processed properly by the target command.
            //
            if ((arguments1 != null) || /* OPT: First set of raw arguments. */
                (arguments2 != null))   /* OPT: Second set of raw arguments. */
            {
                arguments = new ArgumentList();
            }
            else
            {
                arguments = null;
            }

            //
            // NOTE: *PHASE 1* Figure out where the options are in the first
            //       argument list (if there are any at all).
            //
            int argumentCount1 = Count.Invalid;
            int nextIndex1 = Index.Invalid;
            int endIndex1 = Index.Invalid;
            int remainingIndex1 = Index.Invalid;

            if (code == ReturnCode.Ok)
            {
                if (startIndex1 < 0)
                    startIndex1 = 0;

                if (arguments1 != null)
                {
                    argumentCount1 = arguments1.Count;

                    if (options != null)
                    {
                        if (argumentCount1 > startIndex1)
                        {
                            //
                            // NOTE: Execute the universal option parser in
                            //       "scan only" mode.  We do not want to
                            //       waste any time processing the option
                            //       values here just to throw them away, we
                            //       just need to know where they end so that
                            //       we can build the final argument list for
                            //       the target command.
                            //
                            code = ScanOptions(
                                options, arguments1, 0, startIndex1,
                                Index.Invalid, optionBehaviorFlags,
                                ref nextIndex1, ref endIndex1,
                                ref error);

                            if (code == ReturnCode.Ok)
                            {
                                if (endIndex1 != Index.Invalid)
                                {
                                    remainingIndex1 = endIndex1 + 1;
                                }
                                else if ((nextIndex1 != Index.Invalid) &&
                                    (nextIndex1 > 0))
                                {
                                    remainingIndex1 = nextIndex1;
                                }
                            }
                        }
                    }
                    else
                    {
                        //
                        // BUGFIX: We must set the next index even if there
                        //         are no options because the default value
                        //         means that there are "no non-option
                        //         arguments left".
                        //
                        nextIndex1 = startIndex1;

                        //
                        // TODO: Is this the right thing?  If "use remaining"
                        //       is set, should we treat this the same as
                        //       hitting a non-option at the start index?
                        //
                        if (nextIndex1 > 0)
                            remainingIndex1 = nextIndex1;
                    }
                }
            }

            //
            // NOTE: *PHASE 2* Figure out where the options are in the second
            //       argument list (if there are any at all).
            //
            int argumentCount2 = Count.Invalid;
            int nextIndex2 = Index.Invalid;
            int endIndex2 = Index.Invalid;

            if (code == ReturnCode.Ok)
            {
                if (startIndex2 < 0)
                    startIndex2 = 0;

                if (arguments2 != null)
                {
                    argumentCount2 = arguments2.Count;

                    if (options != null)
                    {
                        if (argumentCount2 > startIndex2)
                        {
                            //
                            // NOTE: Execute the universal option parser in
                            //       "scan only" mode.  We do not want to
                            //       waste any time processing the option
                            //       values here just to throw them away, we
                            //       just need to know where they end so that
                            //       we can build the final argument list for
                            //       the target command.
                            //
                            code = ScanOptions(
                                options, arguments2, 0, startIndex2,
                                Index.Invalid, optionBehaviorFlags,
                                ref nextIndex2, ref endIndex2,
                                ref error);
                        }
                    }
                    else
                    {
                        //
                        // BUGFIX: We must set the next index even if there
                        //         are no options because the default value
                        //         means that there are "no non-option
                        //         arguments left".
                        //
                        nextIndex2 = startIndex2;
                    }
                }
            }

            //
            // NOTE: *PHASE 3* With the information gathered above, perform
            //       the merge of the two argument lists into one, retaining
            //       the options chosen and any trailing end-of-options
            //       marker we find (one maximum).
            //
            if (code == ReturnCode.Ok)
            {
                //
                // NOTE: Process the arguments from the first list, if any.
                //
                int stopIndex1 = Index.Invalid;

                if (arguments1 != null)
                {
                    //
                    // NOTE: Figure out where we need to stop adding option
                    //       arguments from the first list.
                    //
                    if (endIndex1 != Index.Invalid) /* Exclude EndOfOptions? */
                        stopIndex1 = endIndex1 - ((arguments2 != null) ? 1 : 0);
                    else if ((nextIndex1 != Index.Invalid) && (nextIndex1 > 0))
                        stopIndex1 = nextIndex1 - 1; /* Before First Non-Option */
                    else
                        stopIndex1 = argumentCount1 - 1; /* All */

                    //
                    // NOTE: First, we want all the arguments from the first
                    //       list except the trailing end-of-options marker,
                    //       if any.
                    //
                    for (int argumentIndex1 = (skipFirst1 ? 1 : 0);
                            argumentIndex1 <= stopIndex1;
                            argumentIndex1++)
                    {
                        arguments.Add(arguments1[argumentIndex1]);
                    }
                }

                //
                // NOTE: Process the arguments from the second list, if any.
                //
                int stopIndex2 = Index.Invalid;

                if (arguments2 != null)
                {
                    //
                    // NOTE: Figure out where we need to stop adding option
                    //       arguments from the second list.
                    //
                    if (endIndex2 != Index.Invalid)
                        stopIndex2 = endIndex2; /* Include EndOfOptions */
                    else if ((nextIndex2 != Index.Invalid) && (nextIndex2 > 0))
                        stopIndex2 = nextIndex2 - 1; /* Before First Non-Option */
                    else
                        stopIndex2 = Index.Invalid; /* None */

                    //
                    // NOTE: Next, we want all the option arguments from the
                    //       second list, including the trailing end-of-options
                    //       marker, if any.  If there is no trailing
                    //       end-of-options marker in the second list and there
                    //       was in the first list, we "move" the one from the
                    //       first list to the end of the options arguments for
                    //       the second list.
                    //
                    if (stopIndex2 != Index.Invalid)
                    {
                        for (int argumentIndex2 = startIndex2;
                                argumentIndex2 <= stopIndex2; argumentIndex2++)
                        {
                            arguments.Add(arguments2[argumentIndex2]);
                        }
                    }

                    //
                    // NOTE: Next, if the first list had a trailing
                    //       end-of-options marker (which we skipped) and the
                    //       second list does not, add it to the resulting
                    //       argument list now.
                    //
                    if ((endIndex1 != Index.Invalid) && (endIndex2 == Index.Invalid))
                        arguments.Add(Option.EndOfOptions);

                    //
                    // NOTE: Optionally use the last argument from the first list
                    //       here.
                    //
                    if (arguments1 != null)
                    {
                        if (useRemaining1 && (remainingIndex1 != Index.Invalid))
                        {
                            for (int argumentIndex1 = remainingIndex1;
                                    argumentIndex1 < argumentCount1; argumentIndex1++)
                            {
                                arguments.Add(arguments1[argumentIndex1]);
                            }
                        }
                    }

                    //
                    // NOTE: Next, we want all the [non-option] arguments from
                    //       the second list starting at the beginning of the
                    //       list and ending before the first option argument.
                    //
                    for (int argumentIndex2 = (skipFirst2 ? 1 : 0);
                            (argumentIndex2 < argumentCount2) &&
                            (argumentIndex2 < startIndex2); argumentIndex2++)
                    {
                        arguments.Add(arguments2[argumentIndex2]);
                    }

                    //
                    // NOTE: Next, we want all the [non-option] arguments from
                    //       the second list starting after the last option
                    //       argument until the end of the list.
                    //
                    if (stopIndex2 != Index.Invalid)
                    {
                        for (int argumentIndex2 = stopIndex2 + 1;
                                argumentIndex2 < argumentCount2; argumentIndex2++)
                        {
                            arguments.Add(arguments2[argumentIndex2]);
                        }
                    }
                }
                else if (arguments1 != null)
                {
                    if (useRemaining1 && (remainingIndex1 != Index.Invalid))
                    {
                        for (int argumentIndex1 = remainingIndex1;
                                argumentIndex1 < argumentCount1; argumentIndex1++)
                        {
                            arguments.Add(arguments1[argumentIndex1]);
                        }
                    }
                }
            }

            return code;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ICacheManager Members
#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || EXECUTE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
        public bool AreCachesEnabled(
            CacheFlags flags
            )
        {
            CheckDisposed();

            return InternalAreCachesEnabled(flags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int ClearCaches(
            CacheFlags flags,
            bool enable
            )
        {
            CheckDisposed();

            return PrivateClearCaches(flags, enable);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public CacheFlags EnableCaches(
            CacheFlags flags,
            bool enable
            )
        {
            CheckDisposed();

            return InternalEnableCaches(flags, enable);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public CacheFlags ControlCaches(
            CacheFlags flags,
            bool enable
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                return PrivateControlCaches(flags, enable);
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
        private void InitializeCaches(
            bool refresh
            )
        {
            int level;

            if (HasHighPriority())
                level = CacheConfiguration.GetHighDefaultLevel(0);
            else
                level = CacheConfiguration.GetDefaultLevel();

            InitializeCaches(null, level, true, false);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void InitializeCaches(
            string text,
            int level,
            bool defaultLevel,
            bool refresh
            )
        {
            bool didInitialize;
            bool wasInitialized;

            didInitialize = CacheConfiguration.Initialize(
                this, text, level, refresh, out wasInitialized);

            int count = 0;

            if (didInitialize && wasInitialized)
                count = PrivateClearCaches(CacheFlags.Default, false);

            StringList state = CacheConfiguration.GetStateAndOrSettings(
                CacheInformationFlags.Initialize);

            TracePriority priority;

            if (didInitialize)
            {
                priority = wasInitialized ?
                    TracePriority.StartupDebug3 :
                    TracePriority.StartupDebug;
            }
            else
            {
                priority = TracePriority.StartupError2;
            }

            TraceOps.DebugTrace(String.Format(
                "InitializeCaches: {0}{1} at {2}level {3} and cleared {4} items: {5}",
                String.Format("{0}{1}{2}", didInitialize ? String.Empty : "failed to ",
                refresh ? (didInitialize ? "forcible " : "forcibly ") : String.Empty,
                wasInitialized ? "reinitialized" : "initialized"), (text != null) ?
                String.Format(" using text {0}", FormatOps.WrapOrNull(text)) :
                String.Empty, defaultLevel ? "default " : String.Empty, level, count,
                FormatOps.WrapOrNull(state)), typeof(Interpreter).Name, priority);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal CacheFlags InitializeAndPreSetupCaches(
            string text,
            int level,
            bool refresh
            )
        {
            lock (syncRoot)
            {
                /* NO RESULT */
                InitializeCaches(text, level, false, refresh);

                return PreSetupCaches();
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || EXECUTE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
        private CacheFlags CacheFlags
        {
            get { lock (syncRoot) { return cacheFlags; } }
            set { lock (syncRoot) { cacheFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalAreCachesEnabled(
            CacheFlags flags
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                return FlagOps.HasFlags(cacheFlags, flags, true);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal CacheFlags InternalEnableCaches(
            CacheFlags flags,
            bool enable
            )
        {
            CacheFlags result = CacheFlags.None;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                result |= PrivateControlCaches(flags, enable);

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Argument Cache
#if ARGUMENT_CACHE
                if (FlagOps.HasFlags(flags, CacheFlags.Argument, true))
                {
                    if (enable)
                        cacheFlags |= CacheFlags.Argument;
                    else
                        cacheFlags &= ~CacheFlags.Argument;

                    result |= CacheFlags.Argument;
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region StringList Cache
#if LIST_CACHE
                if (FlagOps.HasFlags(flags, CacheFlags.StringList, true))
                {
                    if (enable)
                        cacheFlags |= CacheFlags.StringList;
                    else
                        cacheFlags &= ~CacheFlags.StringList;

                    result |= CacheFlags.StringList;
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region ParseState Cache
#if PARSE_CACHE
                if (FlagOps.HasFlags(flags, CacheFlags.IParseState, true))
                {
                    if (enable)
                        cacheFlags |= CacheFlags.IParseState;
                    else
                        cacheFlags &= ~CacheFlags.IParseState;

                    result |= CacheFlags.IParseState;
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region IExecute Cache
#if EXECUTE_CACHE
                if (FlagOps.HasFlags(flags, CacheFlags.IExecute, true))
                {
                    if (enable)
                        cacheFlags |= CacheFlags.IExecute;
                    else
                        cacheFlags &= ~CacheFlags.IExecute;

                    result |= CacheFlags.IExecute;
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Type Cache
#if TYPE_CACHE
                if (FlagOps.HasFlags(flags, CacheFlags.Type, true))
                {
                    if (enable)
                        cacheFlags |= CacheFlags.Type;
                    else
                        cacheFlags &= ~CacheFlags.Type;

                    result |= CacheFlags.Type;
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region ComTypeList Cache
#if COM_TYPE_CACHE
                if (FlagOps.HasFlags(flags, CacheFlags.ComTypeList, true))
                {
                    if (enable)
                        cacheFlags |= CacheFlags.ComTypeList;
                    else
                        cacheFlags &= ~CacheFlags.ComTypeList;

                    result |= CacheFlags.ComTypeList;
                }
#endif
                #endregion
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private CacheFlags LockCaches(
            CacheFlags flags,
            bool @lock
            )
        {
            CacheFlags newFlags = CacheFlags.None;

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Argument Cache
#if ARGUMENT_CACHE
            if ((argumentCache != null) &&
                FlagOps.HasFlags(flags, CacheFlags.Argument, true))
            {
                if (@lock)
                    cacheFlags |= CacheFlags.LockArgument;
                else
                    cacheFlags &= ~CacheFlags.LockArgument;

                newFlags |= CacheFlags.Argument;
            }
#endif
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region StringList Cache
#if LIST_CACHE
            if ((stringListCache != null) &&
                FlagOps.HasFlags(flags, CacheFlags.StringList, true))
            {
                if (@lock)
                    cacheFlags |= CacheFlags.LockStringList;
                else
                    cacheFlags &= ~CacheFlags.LockStringList;

                newFlags |= CacheFlags.StringList;
            }
#endif
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region ParseState Cache
#if PARSE_CACHE
            if ((parseStateCache != null) &&
                FlagOps.HasFlags(flags, CacheFlags.IParseState, true))
            {
                if (@lock)
                    cacheFlags |= CacheFlags.LockIParseState;
                else
                    cacheFlags &= ~CacheFlags.LockIParseState;

                newFlags |= CacheFlags.IParseState;
            }
#endif
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region IExecute Cache
#if EXECUTE_CACHE
            if (FlagOps.HasFlags(flags, CacheFlags.IExecute, true))
            {
                if (@lock)
                    cacheFlags |= CacheFlags.LockIExecute;
                else
                    cacheFlags &= ~CacheFlags.LockIExecute;

                newFlags |= CacheFlags.IExecute;
            }
#endif
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Type Cache
#if TYPE_CACHE
            if ((typeCache != null) &&
                FlagOps.HasFlags(flags, CacheFlags.Type, true))
            {
                if (@lock)
                    cacheFlags |= CacheFlags.LockType;
                else
                    cacheFlags &= ~CacheFlags.LockType;

                newFlags |= CacheFlags.Type;
            }
#endif
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region ComTypeList Cache
#if COM_TYPE_CACHE
            if ((comTypeListCache != null) &&
                FlagOps.HasFlags(flags, CacheFlags.ComTypeList, true))
            {
                if (@lock)
                    cacheFlags |= CacheFlags.LockComTypeList;
                else
                    cacheFlags &= ~CacheFlags.LockComTypeList;

                newFlags |= CacheFlags.ComTypeList;
            }
#endif
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (FlagOps.HasFlags(newFlags, flags & CacheFlags.ObjectMask, true))
                return @lock ? CacheFlags.Lock : CacheFlags.Unlock;
            else
                return CacheFlags.None;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private CacheFlags PrivateControlCaches(
            CacheFlags flags,
            bool enable
            )
        {
            CacheFlags newFlags = CacheFlags.None;

            if (FlagOps.HasFlags(flags, CacheFlags.Unlock, true))
                newFlags |= LockCaches(flags, false);

            if (FlagOps.HasFlags(flags, CacheFlags.Lock, true))
                newFlags |= LockCaches(flags, true);

            if (FlagOps.HasFlags(flags, CacheFlags.Reset, true))
            {
                Dictionary<CacheFlags, long[]> savedCacheCounts = null;

                if (FlagOps.HasFlags(flags, CacheFlags.Clear, true))
                    newFlags |= ResetCaches(flags, ref savedCacheCounts);

                newFlags |= PreSetupCaches(flags, savedCacheCounts);

#if CACHE_DICTIONARY
                if (FlagOps.HasFlags(flags, CacheFlags.SetProperties, true))
                    newFlags |= SetPropertiesOnCaches(flags, enable);
#endif
            }

            return newFlags;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE
        internal bool CanUseArgumentCache(
            CacheFlags hasCacheFlags, /* in */
            ref Argument argument     /* out */
            )
        {
            bool locked = false;

            try
            {
                //
                // HACK: Since the cache is used primarily to speed
                //       things up, do not use a waiting lock here.
                //
                InternalSoftTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    bool result = FlagOps.HasFlags(
                        cacheFlags, CacheFlags.Argument | hasCacheFlags, true);

#if CACHE_DICTIONARY
                    if (!result &&
                        !FlagOps.HasFlags(cacheFlags, CacheFlags.LockArgument, true) &&
                        CacheConfiguration.MaybeEnableOrDisable<Argument, Argument>(
                            this, argumentCache, CacheFlags.Argument, cacheFlags))
                    {
                        if (argumentCache != null)
                            argumentCache.RestartChanges();

                        //
                        // TODO: Why aren't the "hasCacheFlags" considered here?
                        //       Of course, since the "cacheFlags" have not been
                        //       changed between the check above and here, that
                        //       would not make sense either.  Is this actually
                        //       correct?
                        //
                        result = FlagOps.HasFlags(
                            cacheFlags, CacheFlags.Argument, true);
                    }
#endif

                    if (result)
                    {
                        if (argumentCache != null)
                        {
                            Argument localArgument = CacheArgument; /* NOTE: Context only. */

                            if (localArgument != null)
                                argument = localArgument;
                            else
                                result = false;
                        }
                        else
                        {
                            result = false;
                        }
                    }

                    return result;
                }
                else
                {
                    //
                    // NOTE: If the interpreter lock cannot be obtained,
                    //       we cannot use its argument cache.
                    //
                    return false;
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For the core [source] command implementation and
        //       the core script library ("init.eagle") use only.
        //
        internal void BeginNoArgumentCache(
            ref CacheFlags savedCacheFlags
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                savedCacheFlags = cacheFlags;
                cacheFlags &= ~CacheFlags.Argument;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For the core [source] command implementation and
        //       the core script library ("init.eagle") use only.
        //
        internal void EndNoArgumentCache(
            ref CacheFlags savedCacheFlags
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                cacheFlags = savedCacheFlags;
                savedCacheFlags = CacheFlags.None;
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if EXECUTE_CACHE
        private void ClearExecuteCache()
        {
            if (hiddenExecuteCache != null)
            {
                hiddenExecuteCache.Clear();

#if CACHE_STATISTICS
                hiddenExecuteCache.IncrementCacheCount(CacheCountType.Clear);
#endif
            }

            if (executeCache != null)
            {
                executeCache.Clear();

#if CACHE_STATISTICS
                executeCache.IncrementCacheCount(CacheCountType.Clear);
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int PrivateClearCaches(
            CacheFlags flags
            )
        {
            return PrivateClearCaches(flags, false);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int PrivateClearCaches(
            CacheFlags flags,
            bool enable
            )
        {
            int result = 0;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                #region Argument Cache
#if ARGUMENT_CACHE
                if ((argumentCache != null) &&
                    FlagOps.HasFlags(flags, CacheFlags.Argument, true))
                {
                    result += argumentCache.Count;
                    argumentCache.Clear();

#if CACHE_STATISTICS
                    argumentCache.IncrementCacheCount(CacheCountType.Clear);
#endif
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region StringList Cache
#if LIST_CACHE
                if ((stringListCache != null) &&
                    FlagOps.HasFlags(flags, CacheFlags.StringList, true))
                {
                    result += stringListCache.Count;
                    stringListCache.Clear();

#if CACHE_STATISTICS
                    stringListCache.IncrementCacheCount(CacheCountType.Clear);
#endif
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region ParseState Cache
#if PARSE_CACHE
                if ((parseStateCache != null) &&
                    FlagOps.HasFlags(flags, CacheFlags.IParseState, true))
                {
                    result += parseStateCache.Count;
                    parseStateCache.Clear();

#if CACHE_STATISTICS
                    parseStateCache.IncrementCacheCount(CacheCountType.Clear);
#endif
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region IExecute Cache
#if EXECUTE_CACHE
                if ((executeCache != null) &&
                    FlagOps.HasFlags(flags, CacheFlags.IExecute, true))
                {
                    result += executeCache.Count;
                    executeCache.Clear();

#if CACHE_STATISTICS
                    executeCache.IncrementCacheCount(CacheCountType.Clear);
#endif
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                if ((hiddenExecuteCache != null) &&
                    FlagOps.HasFlags(flags, CacheFlags.IExecute, true))
                {
                    result += hiddenExecuteCache.Count;
                    hiddenExecuteCache.Clear();

#if CACHE_STATISTICS
                    hiddenExecuteCache.IncrementCacheCount(CacheCountType.Clear);
#endif
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Type Cache
#if TYPE_CACHE
                if ((typeCache != null) &&
                    FlagOps.HasFlags(flags, CacheFlags.Type, true))
                {
                    result += typeCache.Count;
                    typeCache.Clear();

#if CACHE_STATISTICS
                    typeCache.IncrementCacheCount(CacheCountType.Clear);
#endif
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region ComTypeList Cache
#if COM_TYPE_CACHE
                if ((comTypeListCache != null) &&
                    FlagOps.HasFlags(flags, CacheFlags.ComTypeList, true))
                {
                    result += comTypeListCache.Count;
                    comTypeListCache.Clear();

#if CACHE_STATISTICS
                    comTypeListCache.IncrementCacheCount(CacheCountType.Clear);
#endif
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

#if CACHE_DICTIONARY
                if (FlagOps.HasFlags(flags, CacheFlags.SetProperties, true))
                {
                    /* IGNORED */
                    SetPropertiesOnCaches(flags, enable);
                }
#endif
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Miscellaneous Caches
            if (FlagOps.HasFlags(flags, CacheFlags.Miscellaneous, true))
            {
                result += ProcessOps.Cleanup();

                ///////////////////////////////////////////////////////////////////////////////////////

                result += EnumOps.ClearCache();

                ///////////////////////////////////////////////////////////////////////////////////////

#if SHELL && INTERACTIVE_COMMANDS
                result += HelpOps.ClearCache();
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

                result += StringOps.ClearPreambleEncodings();

                ///////////////////////////////////////////////////////////////////////////////////////

                result += _Comparers.FileName.ClearCache();

                ///////////////////////////////////////////////////////////////////////////////////////

                result += HashOps.Cleanup();

                ///////////////////////////////////////////////////////////////////////////////////////

                result += FactoryOps.Cleanup();

                ///////////////////////////////////////////////////////////////////////////////////////

                result += ScriptOps.ClearInterpreterCache();

                ///////////////////////////////////////////////////////////////////////////////////////

                result += SyntaxOps.ClearCache();

                ///////////////////////////////////////////////////////////////////////////////////////

                result += ConfigurationOps.Cleanup(
                    FlagOps.HasFlags(flags, CacheFlags.FullClear, true));

                ///////////////////////////////////////////////////////////////////////////////////////

                result += TraceLimits.Cleanup();

                ///////////////////////////////////////////////////////////////////////////////////////

                result += MarshalOps.ToStringCache.Clear();

                ///////////////////////////////////////////////////////////////////////////////////////

                result += CertificateOps.ClearCache();

                ///////////////////////////////////////////////////////////////////////////////////////

                result += RuntimeOps.ClearCache();
            }
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            return result;
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IInteractiveLoopManager Members
#if DEBUGGER
        public InteractiveLoopCallback InteractiveLoopCallback
        {
            get
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.InteractiveLoopCallback;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return interactiveLoopCallback;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.InteractiveLoopCallback = value;
#else
                lock (syncRoot)
                {
                    interactiveLoopCallback = value;
                }
#endif
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IDebugManager Members
        public bool Debug
        {
            get
            {
                CheckDisposed();

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    return FlagOps.HasFlags(
                        createFlags, CreateFlags.Debug, true);
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    if (value)
                        createFlags |= CreateFlags.Debug;
                    else
                        createFlags &= ~CreateFlags.Debug;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if DEBUGGER
        public bool SingleStep
        {
            get
            {
                CheckDisposed();

#if !THREADING
                lock (syncRoot) /* TRANSACTIONAL */
#endif
                {
                    IDebugger debugger = Debugger;

                    return (debugger != null) ?
                        debugger.SingleStep : false;
                }
            }
            set
            {
                CheckDisposed();

#if !THREADING
                lock (syncRoot) /* TRANSACTIONAL */
#endif
                {
                    IDebugger debugger = Debugger;

                    if (debugger != null)
                        debugger.SingleStep = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsDebuggerAvailable()
        {
            CheckDisposed();

#if !THREADING
            lock (syncRoot)
#endif
            {
                return (Debugger != null);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsDebuggerActive()
        {
            CheckDisposed();

            return PrivateIsDebuggerActive();
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public TextWriter TraceTextWriter
        {
            get { CheckDisposed(); lock (syncRoot) { return traceTextWriter; } }
            set { CheckDisposed(); lock (syncRoot) { traceTextWriter = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool TraceTextWriterOwned
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return IsTraceTextWriterOwned();
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    if (value)
                        SetTraceTextWriterOwned();
                    else
                        UnsetTraceTextWriterOwned();
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public TextWriter DebugTextWriter
        {
            get { CheckDisposed(); lock (syncRoot) { return debugTextWriter; } }
            set { CheckDisposed(); lock (syncRoot) { debugTextWriter = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool DebugTextWriterOwned
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return IsDebugTextWriterOwned();
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    if (value)
                        SetDebugTextWriterOwned();
                    else
                        UnsetDebugTextWriterOwned();
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
#if DEBUGGER
        private bool PrivateHaveDebuggerLoops()
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                IDebugger debugger = Debugger;

                return ((debugger != null) && (debugger.Loops > 0));
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateIsDebuggerActive()
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                IDebugger debugger = Debugger;

                return ((debugger != null) && (debugger.Active > 0));
            }
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IEngineManager Members
        #region Script Cancellation
        public ReturnCode IsCanceled(
            CancelFlags cancelFlags,
            ref Result result
            )
        {
            CheckDisposed();

            return Engine.IsCanceled(
                this, cancelFlags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if THREADING
        public ReturnCode IsCanceled(
            object engineContext,
            CancelFlags cancelFlags,
            ref Result result
            )
        {
            CheckDisposed();

            InterruptType interruptType = InterruptType.None; /* NOT USED */

#if DEBUGGER
            BreakpointType breakpointType = BreakpointType.None; /* NOT USED */
#endif

            return InternalIsCanceled(
                engineContext as IEngineContext,
                cancelFlags, ref interruptType,
#if DEBUGGER
                ref breakpointType,
#endif
                ref result);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode CancelEvaluate(
            Result result,
            CancelFlags cancelFlags,
            ref Result error
            )
        {
            CheckDisposed();

            return PrivateCancelEvaluate(
#if THREADING
                null,
#endif
                result, cancelFlags, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode CancelAnyEvaluate(
            Result result,
            CancelFlags cancelFlags,
            ref Result error
            )
        {
            CheckDisposed();

            return InternalCancelAnyEvaluateNoContext(
                result, cancelFlags, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if THREADING
        public ReturnCode CancelAnyEvaluate(
            object engineContext,
            Result result,
            CancelFlags cancelFlags,
            ref Result error
            )
        {
            CheckDisposed();

            return InternalCancelAnyEvaluate(
                engineContext as IEngineContext, result,
                cancelFlags, ref error);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ResetCancel(
            CancelFlags cancelFlags,
            ref Result error
            )
        {
            CheckDisposed();

            return Engine.ResetCancel(
                this, cancelFlags, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if THREADING
        public ReturnCode ResetCancel(
            object engineContext,
            CancelFlags cancelFlags,
            ref Result error
            )
        {
            CheckDisposed();

            Result canceledResults = null;
            bool canceled = false;
            bool unwound = false;
            bool reset = false;

            return InternalResetCancel(
                engineContext as IEngineContext, cancelFlags,
                ref canceledResults, ref canceled, ref unwound,
                ref reset, ref error);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        //
        // NOTE: This method assumes the lock is held.
        //
        private Thread GetCancelThread(
            bool useInteractiveThread,
            ref string threadTypeName
            )
        {
#if SHELL
            if (useInteractiveThread)
            {
                threadTypeName = "interactive thread";

                /* NO-LOCK */
                return Interlocked.CompareExchange(
                    ref interactiveThread, null, null);
            }
            else
#endif
            {
                threadTypeName = "primary thread";

                /* NO-LOCK */
                return Interlocked.CompareExchange(
                    ref thread, null, null);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode CancelThread(
            int? timeout,
            bool useThreadAbort,
            bool useInteractiveThread,
            bool waitForThread,
            bool strict,
            ref Result error
            )
        {
            Thread thread = null;
            string threadTypeName = null;
            bool gotThread = false;
            bool locked = false;

            try
            {
                Result localError = null;

                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    thread = GetCancelThread(
                        useInteractiveThread, ref threadTypeName);

                    gotThread = true;
                }
                else
                {
                    localError = "could not lock interpreter";

                    if (strict)
                    {
                        error = localError;
                        return ReturnCode.Error;
                    }
                    else
                    {
                        TraceOps.DebugTrace(String.Format(
                            "CancelThread: {0}", localError),
                            typeof(Interpreter).Name,
                            TracePriority.LockWarning);
                    }
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }

            if (thread != null)
            {
                if (!Object.ReferenceEquals(thread, Thread.CurrentThread))
                {
                    try
                    {
                        ShutdownFlags flags = ShutdownFlags.Cancel;

                        if (useThreadAbort)
                            flags &= ~ShutdownFlags.NoAbort;

                        if (waitForThread)
                            flags |= ShutdownFlags.WaitAfter;

                        /* NO RESULT */
                        ThreadOps.MaybeShutdown(
                            this, timeout, flags, ref thread); /* throw */
                    }
                    catch (Exception e)
                    {
                        TraceOps.DebugTrace(
                            e, typeof(Interpreter).Name,
                            TracePriority.ThreadError);
                    }
                }
            }
            else if (gotThread)
            {
                TraceOps.DebugTrace(String.Format(
                    "CancelThread: no {0} to interrupt",
                    threadTypeName), typeof(Interpreter).Name,
                    TracePriority.ThreadError);
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode InternalCancelEvaluate(
#if THREADING
            IEngineContext engineContext,
#endif
            Result result,
            CancelFlags cancelFlags
            )
        {
            Result error = null;

            return PrivateCancelEvaluate(
#if THREADING
                engineContext,
#endif
                result, cancelFlags, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateCancelEvaluate(
#if THREADING
            IEngineContext engineContext,
#endif
            Result result,
            CancelFlags cancelFlags,
            ref Result error
            )
        {
            return Engine.InternalCancelEvaluate(this,
#if THREADING
                engineContext,
#endif
                result, cancelFlags, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode InternalCancelAnyEvaluateNoContext(
            Result result,
            CancelFlags cancelFlags,
            ref Result error
            )
        {
            return InternalCancelAnyEvaluate(
#if THREADING
                null,
#endif
                result, cancelFlags, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode InternalCancelAnyEvaluate(
#if THREADING
            IEngineContext engineContext,
#endif
            Result result,
            CancelFlags cancelFlags,
            ref Result error
            )
        {
            bool allInterpreters = FlagOps.HasFlags(
                cancelFlags, CancelFlags.AllInterpreters, true);

            if (allInterpreters)
            {
                if (AllCancelAnyEvaluate(FlagOps.HasFlags(
                        cancelFlags, CancelFlags.Global, true)) > 0)
                {
                    return ReturnCode.Ok;
                }
                else
                {
                    error = "nothing was canceled";
                    return ReturnCode.Error;
                }
            }

            ReturnCode code;
            Result localError; /* REUSED */

            bool useThreadInterrupt = FlagOps.HasFlags(
                cancelFlags, CancelFlags.UseThreadInterrupt, true);

            bool useThreadAbort = FlagOps.HasFlags(
                cancelFlags, CancelFlags.UseThreadAbort, true);

            bool waitForThread = FlagOps.HasFlags(
                cancelFlags, CancelFlags.WaitForThread, true);

#if SHELL
            bool unpauseInteractiveLoop = FlagOps.HasFlags(
                cancelFlags, CancelFlags.UnpauseInteractiveLoop, true);

            bool allInteractiveLoops = FlagOps.HasFlags(
                cancelFlags, CancelFlags.AllInteractiveLoops, true);
#endif

            bool useInteractiveThread = false;

#if SHELL
            useInteractiveThread = FlagOps.HasFlags(
                cancelFlags, CancelFlags.UseInteractiveThread, true);
#endif

#if NATIVE && TCL
            bool noNativeTcl = FlagOps.HasFlags(
                cancelFlags, CancelFlags.NoNativeTcl, true);
#endif

            bool strict = FlagOps.HasFlags(
                cancelFlags, CancelFlags.StopOnError, true);

            bool noComplain = FlagOps.HasFlags(
                cancelFlags, CancelFlags.NoComplain, true);

            //
            // NOTE: Cancel any outstanding script in the interpreter.
            //
            localError = null;

            code = Engine.InternalCancelEvaluate(
                this,
#if THREADING
                engineContext,
#endif
                result, cancelFlags, ref localError);

            if (code != ReturnCode.Ok)
            {
                if (strict)
                {
                    error = localError;
                    return code;
                }
                else
                {
                    if (!noComplain)
                        DebugOps.Complain(this, code, localError);

                    code = ReturnCode.Ok;
                }
            }

#if SHELL
            //
            // NOTE: Also forcibly "unpause" the primary interactive loop -OR-
            //       all interactive loops.
            //
            if (unpauseInteractiveLoop)
            {
                if (allInteractiveLoops)
                {
                    bool locked = false;

                    try
                    {
                        InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                        if (locked)
                        {
                            ClearAndMaybeResetPausedInteractiveLoops(
                                false);
                        }
                        else
                        {
                            error = "could not lock interpreter";
                            return ReturnCode.Error;
                        }
                    }
                    finally
                    {
                        InternalExitLock(ref locked); /* TRANSACTIONAL */
                    }
                }
                else
                {
                    localError = null;

                    code = UnpauseInteractiveLoop(
                        AppDomainOps.GetId(appDomain), threadId, false,
                        true, true, false, ref localError);

                    if (code != ReturnCode.Ok)
                    {
                        error = localError;
                        return code;
                    }
                }
            }
#endif

            //
            // NOTE: Now that evaluation has been canceled, maybe also try
            //       to interrupt (and/or wait for) the interpreter thread.
            //
            if (useThreadInterrupt)
            {
                localError = null;

                code = CancelThread(
                    null, useThreadAbort, useInteractiveThread,
                    waitForThread, strict, ref localError);

                if (code != ReturnCode.Ok)
                {
                    error = localError;
                    return code;
                }
            }

#if NATIVE && TCL
            //
            // NOTE: Attempt to cancel any outstanding Tcl scripts in the Tcl
            //       interpreters for this interpreter.
            //
            if (!noNativeTcl)
            {
                localError = null;

                code = PrivateCancelAnyTclEvaluate(
                    result, cancelFlags, ref localError);

                if (code != ReturnCode.Ok)
                {
                    error = localError;
                    return code;
                }
            }
#endif

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NATIVE && TCL
        private ReturnCode PrivateCancelAnyTclEvaluate(
            Result result,
            CancelFlags cancelFlags,
            ref Result error
            )
        {
            bool locked = false;
            ITclApi tclApi = null;
            IntPtrList interps = null;

            try
            {
                PrivateSoftTclTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    tclApi = this.tclApi;

                    if (InternalHasTclInterpreters())
                    {
                        interps = new IntPtrList(
                            tclInterps.Values);
                    }
                }
                else
                {
                    error = "unable to acquire lock";
                    return ReturnCode.Error;
                }
            }
            finally
            {
                PrivateTclExitLock(ref locked);
            }

            //
            // NOTE: If the interpreter has a Tcl API object and a
            //       list of interpreters, try to cancel them all
            //       now.  It must also support script cancellation
            //       (via TIP 285).
            //
            if ((tclApi != null) &&
                (tclApi.CancelEval != null) && (interps != null))
            {
                bool unwind = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.Unwind, true);

                bool strict = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.StopOnError, true);

                bool noComplain = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.NoComplain, true);

                Tcl_EvalFlags evalFlags =
                    TclWrapper.GetCancelEvaluateFlags(
                        unwind);

                foreach (IntPtr interp in interps)
                {
                    IClientData clientData = null;
                    Result localError = null;

                    if (TclWrapper.CancelEvaluate(
                            tclApi, interp, result,
                            evalFlags, ref clientData,
                            ref localError) != ReturnCode.Ok)
                    {
                        if (strict)
                        {
                            error = localError;
                            return ReturnCode.Error;
                        }
                        else if (!noComplain)
                        {
                            DebugOps.Complain(
                                this, ReturnCode.Error,
                                localError);
                        }
                    }
                }
            }

            return ReturnCode.Ok;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Cancel Flags & Results
        internal bool GlobalCancel
        {
            get
            {
                // CheckDisposed();

                //lock (syncRoot)
                //{
                    return cancel;
                //}
            }
            set
            {
                // CheckDisposed();

                //lock (syncRoot)
                //{
                    cancel = value;

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.Interpreter, NotifyFlags.Canceled,
                        cancel, this,
                        null, null, null);
#endif
                //}
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool GlobalUnwind
        {
            get
            {
                // CheckDisposed();

                //lock (syncRoot)
                //{
                    return unwind;
                //}
            }
            set
            {
                // CheckDisposed();

                //lock (syncRoot)
                //{
                    unwind = value;

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.Interpreter, NotifyFlags.Unwound,
                        unwind, this,
                        null, null, null);
#endif
                //}
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool GlobalHalt
        {
            get
            {
                // CheckDisposed();

                //lock (syncRoot)
                //{
                    return halt;
                //}
            }
            set
            {
                // CheckDisposed();

                //lock (syncRoot)
                //{
                    halt = value;

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.Interpreter, NotifyFlags.Halted,
                        halt, this,
                        null, null, null);
#endif
                //}
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal Result GlobalCancelResult
        {
            get
            {
                // CheckDisposed();

                //lock (syncRoot)
                //{
                    return cancelResult;
                //}
            }
            set
            {
                // CheckDisposed();

                //lock (syncRoot)
                //{
                    cancelResult = value;
                //}
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal Result GlobalHaltResult
        {
            get
            {
                // CheckDisposed();

                //lock (syncRoot)
                //{
                    return haltResult;
                //}
            }
            set
            {
                // CheckDisposed();

                //lock (syncRoot)
                //{
                    haltResult = value;
                //}
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool Cancel
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.Cancel;
                else
                    return false;
#else
                // lock (syncRoot)
                {
                    return cancel;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.Cancel = value;
#else
                // lock (syncRoot)
                {
                    cancel = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool Unwind
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.Unwind;
                else
                    return false;
#else
                // lock (syncRoot)
                {
                    return unwind;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.Unwind = value;
#else
                // lock (syncRoot)
                {
                    unwind = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool Halt
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.Halt;
                else
                    return false;
#else
                // lock (syncRoot)
                {
                    return halt;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.Halt = value;
#else
                // lock (syncRoot)
                {
                    halt = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal Result CancelResult
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.CancelResult;
                else
                    return null;
#else
                // lock (syncRoot)
                {
                    return cancelResult;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.CancelResult = value;
#else
                // lock (syncRoot)
                {
                    cancelResult = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal Result HaltResult
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.HaltResult;
                else
                    return null;
#else
                // lock (syncRoot)
                {
                    return haltResult;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.HaltResult = value;
#else
                // lock (syncRoot)
                {
                    haltResult = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if THREADING
        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private bool CancelEvaluate(
            Result result,
            bool unwind,
            bool needResult
            )
        {
            IEngineContext context = GetEngineContext();

            if (context == null)
                return false;

            return context.CancelEvaluate(
                result, unwind, needResult);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private void GetCancelFlags(
#if THREADING
            IEngineContext engineContext,
#endif
            CancelFlags cancelFlags,
#if THREADING
            out bool localCancel,
            out bool localUnwind,
#endif
            out bool globalCancel,
            out bool globalUnwind,
            out bool anyCancel,
            out bool anyUnwind
            )
        {
            bool local;
            bool global;

            GetCancelFlags(
#if THREADING
                engineContext,
#endif
                cancelFlags,
                out local,
                out global,
#if THREADING
                out localCancel,
                out localUnwind,
#endif
                out globalCancel,
                out globalUnwind,
                out anyCancel,
                out anyUnwind
            );
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private void GetCancelFlags(
#if THREADING
            IEngineContext engineContext,
#endif
            CancelFlags cancelFlags,
            out bool local,
            out bool global,
#if THREADING
            out bool localCancel,
            out bool localUnwind,
#endif
            out bool globalCancel,
            out bool globalUnwind,
            out bool anyCancel,
            out bool anyUnwind
            )
        {
            local = FlagOps.HasFlags(
                cancelFlags, CancelFlags.Local, true);

            global = FlagOps.HasFlags(
                cancelFlags, CancelFlags.Global, true);

#if THREADING
            localCancel = false;
            localUnwind = false;

            if (local &&
                HaveAnyEngineContext(engineContext, cancelFlags))
            {
                if (engineContext != null)
                {
                    localCancel = engineContext.Cancel; /* PROPERTY */
                    localUnwind = engineContext.Unwind; /* PROPERTY */
                }
                else
                {
                    localCancel = this.Cancel; /* PROPERTY */
                    localUnwind = this.Unwind; /* PROPERTY */
                }
            }
#endif

            globalCancel = false;
            globalUnwind = false;

            if (global)
            {
                globalCancel = this.cancel; /* FIELD */
                globalUnwind = this.unwind; /* FIELD */
            }

#if THREADING
            anyCancel = localCancel || globalCancel;
            anyUnwind = localUnwind || globalUnwind;
#else
            anyCancel = globalCancel;
            anyUnwind = globalUnwind;
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private void GetHaltFlags(
#if THREADING
            IEngineContext engineContext,
#endif
            CancelFlags cancelFlags,
#if THREADING
            out bool localHalt,
#endif
            out bool globalHalt,
            out bool anyHalt
            )
        {
            bool local;
            bool global;

            GetHaltFlags(
#if THREADING
                engineContext,
#endif
                cancelFlags,
                out local,
                out global,
#if THREADING
                out localHalt,
#endif
                out globalHalt,
                out anyHalt
            );
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private void GetHaltFlags(
#if THREADING
            IEngineContext engineContext,
#endif
            CancelFlags cancelFlags,
            out bool local,
            out bool global,
#if THREADING
            out bool localHalt,
#endif
            out bool globalHalt,
            out bool anyHalt
            )
        {
            local = FlagOps.HasFlags(
                cancelFlags, CancelFlags.Local, true);

            global = FlagOps.HasFlags(
                cancelFlags, CancelFlags.Global, true);

#if THREADING
            localHalt = false;

            if (local &&
                HaveAnyEngineContext(engineContext, cancelFlags))
            {
                if (engineContext != null)
                {
                    localHalt = engineContext.Halt; /* PROPERTY */
                }
                else
                {
                    localHalt = this.Halt; /* PROPERTY */
                }
            }
#endif

            globalHalt = false;

            if (global)
            {
                globalHalt = this.halt; /* FIELD */
            }

#if THREADING
            anyHalt = localHalt || globalHalt;
#else
            anyHalt = globalHalt;
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private bool MaybeCancelBusyOrNot(
            bool local,
            bool global,
            bool busy,
            bool ignorePending,
            bool failPending,
            out bool localBusy,
            out bool globalBusy,
            ref Result error
            )
        {
            bool result = true;
            ResultList errors = null;

            localBusy = false;
            globalBusy = false;

            if (!ignorePending)
            {
                if (local)
                {
                    localBusy = InternalIsBusy;

                    if ((localBusy == busy) && failPending)
                    {
                        if (errors == null)
                            errors = new ResultList();

                        if (busy)
                            errors.Add("cannot cancel local script evaluation");
                        else
                            errors.Add("cannot reset local script cancellation");

                        result = false;
                    }
                }

                if (global)
                {
                    globalBusy = InternalIsGlobalBusy;

                    if ((globalBusy == busy) && failPending)
                    {
                        if (errors == null)
                            errors = new ResultList();

                        if (busy)
                            errors.Add("cannot cancel global script evaluation");
                        else
                            errors.Add("cannot reset global script cancellation");

                        result = false;
                    }
                }
            }

            if (!result && (errors != null))
                error = errors;

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private bool MaybeHaltBusyOrNot(
            bool local,
            bool global,
            bool busy,
            bool ignorePending,
            bool failPending,
            out bool localBusy,
            out bool globalBusy,
            ref Result error
            )
        {
            bool result = true;
            ResultList errors = null;

            localBusy = false;
            globalBusy = false;

            if (!ignorePending)
            {
                if (local)
                {
                    localBusy = (ActiveInteractiveLoops > 1) || InternalIsBusy;

                    if ((localBusy == busy) && failPending)
                    {
                        if (errors == null)
                            errors = new ResultList();

                        if (busy)
                            errors.Add("cannot locally set halt");
                        else
                            errors.Add("cannot locally reset halt");

                        result = false;
                    }
                }

                if (global)
                {
                    globalBusy =
#if SHELL
                        (GlobalInteractiveLoops > 1) ||
#endif
                        InternalIsGlobalBusy;

                    if ((globalBusy == busy) && failPending)
                    {
                        if (errors == null)
                            errors = new ResultList();

                        if (busy)
                            errors.Add("cannot globally set halt");
                        else
                            errors.Add("cannot globally reset halt");

                        result = false;
                    }
                }
            }

            if (!result && (errors != null))
                error = errors;

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        internal ReturnCode InternalIsCanceled(
#if THREADING
            IEngineContext engineContext,
#endif
            CancelFlags cancelFlags,
            ref InterruptType interruptType,
#if DEBUGGER
            ref BreakpointType breakpointType,
#endif
            ref Result error
            ) /* ENTRY-POINT, THREAD-SAFE */
        {
#if THREADING
            bool localCancel;
            bool localUnwind;
#endif
            bool globalCancel;
            bool globalUnwind;
            bool anyCancel;
            bool anyUnwind;

            GetCancelFlags(
#if THREADING
                engineContext,
#endif
                cancelFlags,
#if THREADING
                out localCancel,
                out localUnwind,
#endif
                out globalCancel,
                out globalUnwind,
                out anyCancel,
                out anyUnwind
            );

            if (anyCancel || anyUnwind)
            {
                bool globalResult = false;
                bool didReset = false;

#if THREADING
                if (localCancel &&
                    HaveAnyEngineContext(engineContext, cancelFlags))
                {
                    if ((!didReset || FlagOps.HasFlags(
                            cancelFlags, CancelFlags.ResetAll, true)) &&
                        FlagOps.HasFlags(
                            cancelFlags, CancelFlags.ResetLocal, true))
                    {
                        if (engineContext != null)
                        {
                            engineContext.Cancel = false; /* PROPERTY */
                        }
                        else
                        {
                            this.Cancel = false; /* PROPERTY */
                        }

                        didReset = true;
                    }

                    interruptType |= InterruptType.Canceled;
                    interruptType |= InterruptType.Local;

#if DEBUGGER
                    breakpointType |= BreakpointType.Cancel;
#endif
                }
#endif

                if (globalCancel)
                {
                    if ((!didReset || FlagOps.HasFlags(
                            cancelFlags, CancelFlags.ResetAll, true)) &&
                        FlagOps.HasFlags(
                            cancelFlags, CancelFlags.ResetGlobal, true))
                    {
                        this.cancel = false; /* FIELD */
                        didReset = true;
                    }

                    interruptType |= InterruptType.Canceled;
                    interruptType |= InterruptType.Global;

#if DEBUGGER
                    breakpointType |= BreakpointType.Cancel;
#endif

#if THREADING
                    if (!localCancel)
#endif
                        globalResult = true;
                }

#if THREADING
                if (localUnwind)
                {
                    interruptType |= InterruptType.Unwound;
                    interruptType |= InterruptType.Local;

#if DEBUGGER
                    breakpointType |= BreakpointType.Unwind;
#endif
                }
#endif

                if (globalUnwind)
                {
                    interruptType |= InterruptType.Unwound;
                    interruptType |= InterruptType.Global;

#if DEBUGGER
                    breakpointType |= BreakpointType.Unwind;
#endif

#if THREADING
                    if (!localUnwind)
#endif
                        globalResult = true;
                }

                bool needResult = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.NeedResult, true);

                if (needResult)
                {
                    Result localError = null;

                    if (globalResult)
                    {
                        localError = this.cancelResult; /* FIELD */
                    }
#if THREADING
                    else
                    {
                        if (engineContext != null)
                        {
                            localError = engineContext.CancelResult; /* PROPERTY */
                        }
                        else
                        {
                            localError = this.CancelResult; /* PROPERTY */
                        }
                    }
#endif

                    if (localError == null)
                    {
#if THREADING
                        if (localUnwind || globalUnwind)
#else
                        if (globalUnwind)
#endif
                        {
                            localError = Result.Copy(
                                Engine.EvalUnwoundError, ResultFlags.CopyValue);
                        }
                        else
                        {
                            localError = Result.Copy(
                                Engine.EvalCanceledError, ResultFlags.CopyValue);
                        }
                    }

                    error = localError;
                }

                return ReturnCode.Error;
            }
            else
            {
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        internal ReturnCode InternalCancelEvaluate(
#if THREADING
            IEngineContext engineContext,
#endif
            Result result,
            CancelFlags cancelFlags,
            ref Result error
            )
        {
            bool local = FlagOps.HasFlags(
                cancelFlags, CancelFlags.Local, true);

            bool global = FlagOps.HasFlags(
                cancelFlags, CancelFlags.Global, true);

            if (local || global)
            {
                bool ignorePending = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.IgnorePending, true);

                bool failPending = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.FailPending, true);

                bool localBusy;
                bool globalBusy;

                if (!MaybeCancelBusyOrNot(
                        local, global, true, ignorePending, failPending,
                        out localBusy, out globalBusy, ref error))
                {
                    return ReturnCode.Error;
                }

                bool unwind = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.Unwind, true);

                bool needResult = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.NeedResult, true);

                Result localResult = null;

                if (needResult)
                {
                    localResult = (result != null) ? result : (unwind ?
                        Result.Copy(Engine.EvalUnwoundError, ResultFlags.CopyValue) :
                        Result.Copy(Engine.EvalCanceledError, ResultFlags.CopyValue));
                }

#if THREADING
                if (local && (ignorePending || localBusy) &&
                    HaveAnyEngineContext(engineContext, cancelFlags))
                {
                    if (engineContext != null)
                    {
                        engineContext.CancelEvaluate(
                            localResult, unwind, needResult);
                    }
                    else
                    {
                        CancelEvaluate(
                            localResult, unwind, needResult);
                    }
                }
#endif

                if (global && (ignorePending || globalBusy))
                {
                    this.cancel = true; /* FIELD */

                    if (unwind)
                        this.unwind = true; /* FIELD */

                    if (needResult)
                        this.cancelResult = localResult; /* FIELD */
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        internal ReturnCode InternalHaltEvaluate(
#if THREADING
            IEngineContext engineContext,
#endif
            Result result,
            CancelFlags cancelFlags,
            ref Result error
            )
        {
            bool local = FlagOps.HasFlags(
                cancelFlags, CancelFlags.Local, true);

            bool global = FlagOps.HasFlags(
                cancelFlags, CancelFlags.Global, true);

            if (local || global)
            {
                bool ignorePending = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.IgnorePending, true);

                bool failPending = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.FailPending, true);

                bool localBusy;
                bool globalBusy;

                if (!MaybeHaltBusyOrNot(
                        local, global, true, ignorePending, failPending,
                        out localBusy, out globalBusy, ref error))
                {
                    return ReturnCode.Error;
                }

                bool unwind = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.Unwind, true);

                bool needResult = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.NeedResult, true);

                Result localResult = null;

                if (needResult)
                {
                    localResult = (result != null) ? result :
                        Result.Copy(Engine.HaltedError, ResultFlags.CopyValue);
                }

#if THREADING
                if (local && (ignorePending || localBusy) &&
                    HaveAnyEngineContext(engineContext, cancelFlags))
                {
                    if (engineContext != null)
                    {
                        engineContext.Halt = true; /* PROPERTY */

                        if (needResult)
                            engineContext.HaltResult = localResult; /* PROPERTY */
                    }
                    else
                    {
                        this.Halt = true; /* PROPERTY */

                        if (needResult)
                            this.HaltResult = localResult; /* PROPERTY */
                    }
                }
#endif

                if (global && (ignorePending || globalBusy))
                {
                    this.halt = true; /* FIELD */

                    if (needResult)
                        this.haltResult = localResult; /* FIELD */
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by the Ready() method only.
        //
        private void ResetCancel(
            bool noGlobalCancel,
            bool notify
            ) /* NO-LOCK */
        {
#if NOTIFY
            bool anyCancel = false;
#endif

            /////////////////////////////////////////////////////////

#if THREADING
            if (HaveEngineContext() && this.Cancel) /* PROPERTY */
            {
                this.Cancel = false; /* PROPERTY */

#if NOTIFY
                anyCancel = true;
#endif
            }
#endif

            /////////////////////////////////////////////////////////

            if (!noGlobalCancel && this.cancel) /* FIELD */
            {
                this.cancel = false; /* FIELD */

#if NOTIFY
                anyCancel = true;
#endif
            }

            /////////////////////////////////////////////////////////

#if NOTIFY
            if (notify && anyCancel)
            {
                /* IGNORED */
                CheckNotification(
                    NotifyType.Interpreter,
                    NotifyFlags.Reset | NotifyFlags.Canceled,
                    anyCancel, this, null, null, null);
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        internal ReturnCode InternalResetCancel(
#if THREADING
            IEngineContext engineContext,
#endif
            CancelFlags cancelFlags,
            ref Result canceledResults,
            ref bool canceled,
            ref bool unwound,
            ref bool reset,
            ref Result error
            ) /* ENTRY-POINT, THREAD-SAFE */
        {
            bool local;
            bool global;
#if THREADING
            bool localCancel;
            bool localUnwind;
#endif
            bool globalCancel;
            bool globalUnwind;
            bool anyCancel;
            bool anyUnwind;

            GetCancelFlags(
#if THREADING
                engineContext,
#endif
                cancelFlags,
                out local,
                out global,
#if THREADING
                out localCancel,
                out localUnwind,
#endif
                out globalCancel,
                out globalUnwind,
                out anyCancel,
                out anyUnwind
            );

            if (anyCancel || anyUnwind)
            {
                bool ignorePending = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.IgnorePending, true);

                bool failPending = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.FailPending, true);

                bool localBusy;
                bool globalBusy;

                if (!MaybeCancelBusyOrNot(
                        local, global, false, ignorePending, failPending,
                        out localBusy, out globalBusy, ref error))
                {
                    return ReturnCode.Error;
                }

#if THREADING
                bool localResult = false;

                if ((ignorePending || !localBusy) &&
                    HaveAnyEngineContext(engineContext, cancelFlags))
                {
                    if (engineContext != null)
                    {
                        if (localCancel)
                        {
                            engineContext.Cancel = false; /* PROPERTY */
                            localResult = true;
                        }

                        if (localUnwind)
                        {
                            engineContext.Unwind = false; /* PROPERTY */
                            localResult = true;
                        }
                    }
                    else
                    {
                        if (localCancel)
                        {
                            this.Cancel = false; /* PROPERTY */
                            localResult = true;
                        }

                        if (localUnwind)
                        {
                            this.Unwind = false; /* PROPERTY */
                            localResult = true;
                        }
                    }
                }
#endif

                bool globalResult = false;

                if (ignorePending || !globalBusy)
                {
                    if (globalCancel)
                    {
                        this.cancel = false; /* FIELD */
                        globalResult = true;
                    }

                    if (globalUnwind)
                    {
                        this.unwind = false; /* FIELD */
                        globalResult = true;
                    }
                }

                bool needResult = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.NeedResult, true);

                if (needResult)
                {
                    Result result; /* REUSED */
                    ResultList results = null;

#if THREADING
                    if (localResult &&
                        HaveAnyEngineContext(engineContext, cancelFlags))
                    {
                        if (engineContext != null)
                        {
                            result = engineContext.CancelResult; /* PROPERTY */
                        }
                        else
                        {
                            result = this.CancelResult; /* PROPERTY */
                        }

                        if (result != null)
                        {
                            if (results == null)
                                results = new ResultList();

                            results.Add(result);
                            this.CancelResult = null; /* PROPERTY */
                        }
                    }
#endif

                    if (globalResult)
                    {
                        result = this.cancelResult; /* FIELD */

                        if (result != null)
                        {
                            if (results == null)
                                results = new ResultList();

                            results.Add(result);
                            this.cancelResult = null; /* FIELD */
                        }
                    }

                    canceledResults = results;
                }

                canceled = anyCancel;
                unwound = anyUnwind;

#if THREADING
                reset = localResult || globalResult;
#else
                reset = globalResult;
#endif
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        internal ReturnCode InternalIsHalted(
#if THREADING
            IEngineContext engineContext,
#endif
            CancelFlags cancelFlags,
            ref Result error
            ) /* ENTRY-POINT, THREAD-SAFE */
        {
#if THREADING
            bool localHalt;
#endif
            bool globalHalt;
            bool anyHalt;

            GetHaltFlags(
#if THREADING
                engineContext,
#endif
                cancelFlags,
#if THREADING
                out localHalt,
#endif
                out globalHalt,
                out anyHalt
            );

            if (anyHalt)
            {
                bool globalResult = false;

#if THREADING
                if (localHalt &&
                    HaveAnyEngineContext(engineContext, cancelFlags))
                {
                    if (FlagOps.HasFlags(
                            cancelFlags, CancelFlags.ResetLocal, true))
                    {
                        if (engineContext != null)
                        {
                            engineContext.Halt = false; /* PROPERTY */
                        }
                        else
                        {
                            this.Halt = false; /* PROPERTY */
                        }
                    }
                }
#endif

                if (globalHalt)
                {
                    if (FlagOps.HasFlags(
                            cancelFlags, CancelFlags.ResetGlobal, true))
                    {
                        this.halt = false; /* FIELD */
                    }

#if THREADING
                    if (!localHalt)
#endif
                        globalResult = true;
                }

                bool needResult = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.NeedResult, true);

                if (needResult)
                {
                    Result localError = null;

                    if (globalResult)
                    {
                        localError = this.haltResult; /* FIELD */
                    }
#if THREADING
                    else
                    {
                        if (engineContext != null)
                        {
                            localError = engineContext.HaltResult; /* PROPERTY */
                        }
                        else
                        {
                            localError = this.HaltResult; /* PROPERTY */
                        }
                    }
#endif

                    if (localError == null)
                    {
                        localError = Result.Copy(
                            Engine.HaltedError, ResultFlags.CopyValue);
                    }

                    error = localError;
                }

                return ReturnCode.Error;
            }
            else
            {
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        internal ReturnCode InternalResetHalt(
#if THREADING
            IEngineContext engineContext,
#endif
            CancelFlags cancelFlags,
            ref Result haltedResults,
            ref bool halted,
            ref bool reset,
            ref Result error
            ) /* ENTRY-POINT, THREAD-SAFE */
        {
            bool local;
            bool global;
#if THREADING
            bool localHalt;
#endif
            bool globalHalt;
            bool anyHalt;

            GetHaltFlags(
#if THREADING
                engineContext,
#endif
                cancelFlags,
                out local,
                out global,
#if THREADING
                out localHalt,
#endif
                out globalHalt,
                out anyHalt
            );

            if (anyHalt)
            {
                bool ignorePending = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.IgnorePending, true);

                bool failPending = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.FailPending, true);

                bool localBusy;
                bool globalBusy;

                if (!MaybeHaltBusyOrNot(
                        local, global, false, ignorePending, failPending,
                        out localBusy, out globalBusy, ref error))
                {
                    return ReturnCode.Error;
                }

#if THREADING
                bool localResult = false;

                if ((ignorePending || !localBusy) &&
                    HaveAnyEngineContext(engineContext, cancelFlags))
                {
                    if (engineContext != null)
                    {
                        if (localHalt)
                        {
                            engineContext.Halt = false; /* PROPERTY */
                            localResult = true;
                        }
                    }
                    else
                    {
                        if (localHalt)
                        {
                            this.Halt = false; /* PROPERTY */
                            localResult = true;
                        }
                    }
                }
#endif

                bool globalResult = false;

                if (ignorePending || !globalBusy)
                {
                    if (globalHalt)
                    {
                        this.halt = false; /* FIELD */
                        globalResult = true;
                    }
                }

                bool needResult = FlagOps.HasFlags(
                    cancelFlags, CancelFlags.NeedResult, true);

                if (needResult)
                {
                    Result result; /* REUSED */
                    ResultList results = null;

#if THREADING
                    if (localResult &&
                        HaveAnyEngineContext(engineContext, cancelFlags))
                    {
                        if (engineContext != null)
                        {
                            result = engineContext.HaltResult; /* PROPERTY */
                        }
                        else
                        {
                            result = this.HaltResult; /* PROPERTY */
                        }

                        if (result != null)
                        {
                            if (results == null)
                                results = new ResultList();

                            results.Add(result);
                            this.HaltResult = null; /* PROPERTY */
                        }
                    }
#endif

                    if (globalResult)
                    {
                        result = this.haltResult; /* FIELD */

                        if (result != null)
                        {
                            if (results == null)
                                results = new ResultList();

                            results.Add(result);
                            this.haltResult = null; /* FIELD */
                        }
                    }

                    haltedResults = results;
                }

                halted = anyHalt;

#if THREADING
                reset = localResult || globalResult;
#else
                reset = globalResult;
#endif
            }

            return ReturnCode.Ok;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interrupt Callback Handling
        //
        // WARNING: These property accessor methods assume the interpreter
        //          lock is already held.
        //
        internal InterruptCallback InterruptCallback
        {
            get
            {
                // CheckDisposed();

                //lock (syncRoot)
                //{
                    return interruptCallback;
                //}
            }
            set
            {
                // CheckDisposed();

                //lock (syncRoot)
                //{
                    interruptCallback = value;
                //}
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode FireInterruptCallback(
            InterruptType interruptType,
            IClientData clientData,
            bool waitForLock,
            ref Result error
            )
        {
            // CheckDisposed();

            ReturnCode code = ReturnCode.Ok;
            InterruptCallback localInterruptCallback = null;
            bool locked = false; /* REUSED */

            try
            {
                try
                {
                    //
                    // TODO: This was a "soft" lock; however, since this
                    //       is called to notify external components of
                    //       potentially important events, try harder.
                    //
                    if (waitForLock)
                        InternalHardTryLock(ref locked); /* TRANSACTIONAL */
                    else
                        InternalSoftTryLock(ref locked); /* TRANSACTIONAL */

                    if (locked)
                    {
                        localInterruptCallback = interruptCallback;
                        interruptCallback = null; /* NOTE: Prevent recursion? */
                    }
                    else
                    {
                        error = "unable to acquire lock";
                        code = ReturnCode.Error;
                    }
                }
                finally
                {
                    InternalExitLock(ref locked); /* TRANSACTIONAL */
                }

                if (code == ReturnCode.Ok)
                {
                    if (localInterruptCallback != null)
                    {
                        try
                        {
                            code = localInterruptCallback(
                                this, interruptType, clientData,
                                ref error);
                        }
                        catch (Exception e)
                        {
                            error = e;
                            code = ReturnCode.Error;
                        }
                    }
                }
            }
            finally
            {
                if (localInterruptCallback != null)
                {
                    try
                    {
                        if (waitForLock)
                            InternalHardTryLock(ref locked); /* TRANSACTIONAL */
                        else
                            InternalSoftTryLock(ref locked); /* TRANSACTIONAL */

                        if (locked)
                        {
                            //
                            // BUGFIX: Only restore the interrupt callback
                            //         if it was not changed while being
                            //         fired.
                            //
                            if (interruptCallback == null)
                            {
                                interruptCallback = localInterruptCallback;
                            }
                            else
                            {
                                DebugOps.Complain(this, ReturnCode.Error,
                                    "interrupt callback was not restored: " +
                                    "changed while being fired");
                            }
                        }
                        else
                        {
                            DebugOps.Complain(this, ReturnCode.Error,
                                "interrupt callback was not restored: " +
                                "unable to acquire lock");
                        }
                    }
                    finally
                    {
                        InternalExitLock(ref locked); /* TRANSACTIONAL */
                    }

                    localInterruptCallback = null;
                }
            }

            return code;
        }
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Script Evaluation
        public ReturnCode EvaluateScript(
            string text,
            ref Result result
            )
        {
            CheckDisposed();

            return Engine.EvaluateScript(
                this, text, engineFlags, substitutionFlags,
                engineEventFlags, expressionFlags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateScript(
            string text,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

            return Engine.EvaluateScript(
                this, text, engineFlags, substitutionFlags,
                engineEventFlags, expressionFlags, ref result,
                ref errorLine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateScript(
            IScript script,
            ref Result result
            )
        {
            CheckDisposed();

            int errorLine = 0;

            ReturnCode code = EvaluateScript(
                script, ref result, ref errorLine);

            if (errorLine != 0)
                SetErrorLine(this, errorLine);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateScript(
            IScript script,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

#if DEBUGGER && BREAKPOINTS
            bool pushed = false;

            PushScriptLocation(script, ref pushed);

            try
            {
#endif
                return Engine.EvaluateScript(
                    this, script, ref result, ref errorLine);
#if DEBUGGER && BREAKPOINTS
            }
            finally
            {
                PopScriptLocation(script, ref pushed);
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateGlobalScript(
            string text,
            ref Result result
            )
        {
            CheckDisposed();

            return Engine.EvaluateScript(
                this, text, engineFlags | EngineFlags.EvaluateGlobal,
                substitutionFlags, engineEventFlags, expressionFlags,
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateGlobalScript(
            string text,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

            return Engine.EvaluateScript(
                this, text, engineFlags | EngineFlags.EvaluateGlobal,
                substitutionFlags, engineEventFlags, expressionFlags,
                ref result, ref errorLine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateScriptWithScopeFrame(
            string text,          /* in */
            ref ICallFrame frame, /* in, out */
            ref Result result,    /* out */
            ref int errorLine     /* out */
            )
        {
            CheckDisposed();

            return Engine.EvaluateScriptWithScopeFrame(
                this, text, engineFlags, substitutionFlags,
                engineEventFlags, expressionFlags, ref frame,
                ref result, ref errorLine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateFile(
            string fileName,
            ref Result result
            )
        {
            CheckDisposed();

            int errorLine = 0;

            ReturnCode code = EvaluateFile(
                fileName, ref result, ref errorLine);

            if (errorLine != 0)
                SetErrorLine(this, errorLine);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateFile(
            string fileName,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

            return Engine.EvaluateFile(
                this, fileName, engineFlags, substitutionFlags,
                engineEventFlags, expressionFlags, ref result,
                ref errorLine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateFile(
            Encoding encoding,
            string fileName,
            ref Result result
            )
        {
            CheckDisposed();

            int errorLine = 0;

            ReturnCode code = EvaluateFile(
                encoding, fileName, ref result, ref errorLine);

            if (errorLine != 0)
                SetErrorLine(this, errorLine);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateFile(
            Encoding encoding,
            string fileName,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

            return Engine.EvaluateFile(
                this, encoding, fileName, engineFlags,
                substitutionFlags, engineEventFlags,
                expressionFlags, ref result, ref errorLine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateGlobalFile(
            string fileName,
            ref Result result
            )
        {
            CheckDisposed();

            int errorLine = 0;

            ReturnCode code = EvaluateGlobalFile(
                fileName, ref result, ref errorLine);

            if (errorLine != 0)
                SetErrorLine(this, errorLine);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateGlobalFile(
            string fileName,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

            return Engine.EvaluateFile(
                this, fileName, engineFlags | EngineFlags.EvaluateGlobal,
                substitutionFlags, engineEventFlags, expressionFlags,
                ref result, ref errorLine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateGlobalFile(
            Encoding encoding,
            string fileName,
            ref Result result
            )
        {
            CheckDisposed();

            int errorLine = 0;

            ReturnCode code = EvaluateGlobalFile(
                encoding, fileName, ref result, ref errorLine);

            if (errorLine != 0)
                SetErrorLine(this, errorLine);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateGlobalFile(
            Encoding encoding,
            string fileName,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

            return Engine.EvaluateFile(this, encoding, fileName,
                engineFlags | EngineFlags.EvaluateGlobal,
                substitutionFlags, engineEventFlags,
                expressionFlags, ref result, ref errorLine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateFileWithScopeFrame(
            Encoding encoding,    /* in */
            string fileName,      /* in */
            ref ICallFrame frame, /* in, out */
            ref Result result,    /* out */
            ref int errorLine     /* out */
            )
        {
            CheckDisposed();

            return Engine.EvaluateFileWithScopeFrame(
                this, encoding, fileName, engineFlags, substitutionFlags,
                engineEventFlags, expressionFlags, ref frame, ref result,
                ref errorLine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateStream(
            string name,
            TextReader textReader,
            int startIndex,
            int characters,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

            return Engine.EvaluateStream(
                this, name, textReader, startIndex, characters,
                engineFlags, substitutionFlags, engineEventFlags,
                expressionFlags, ref result, ref errorLine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateGlobalStream(
            string name,
            TextReader textReader,
            int startIndex,
            int characters,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

            return Engine.EvaluateStream(
                this, name, textReader, startIndex, characters,
                engineFlags | EngineFlags.EvaluateGlobal,
                substitutionFlags, engineEventFlags,
                expressionFlags, ref result, ref errorLine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateStreamWithScopeFrame(
            string name,           /* in */
            TextReader textReader, /* in */
            int startIndex,        /* in */
            int characters,        /* in */
            ref ICallFrame frame,  /* in, out */
            ref Result result,     /* out */
            ref int errorLine      /* out */
            )
        {
            CheckDisposed();

            return Engine.EvaluateStreamWithScopeFrame(
                this, name, textReader, startIndex, characters,
                engineFlags, substitutionFlags, engineEventFlags,
                expressionFlags, ref frame, ref result, ref errorLine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTrustedScript(
            string text,
            TrustFlags trustFlags,
            ref Result result
            )
        {
            CheckDisposed();

            return EvaluateTrustedScript(
                null, text, trustFlags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTrustedScript(
            string fileName,
            string text,
            TrustFlags trustFlags,
            ref Result result
            )
        {
            CheckDisposed();

            int errorLine = 0;

            ReturnCode code = EvaluateTrustedScript(
                fileName, text, trustFlags, ref result, ref errorLine);

            if (errorLine != 0)
                SetErrorLine(this, errorLine);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTrustedScript(
            string text,
            TrustFlags trustFlags,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

            return EvaluateTrustedScript(
                null, text, trustFlags, ref result, ref errorLine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTrustedScript(
            string fileName,
            string text,
            TrustFlags trustFlags,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

            bool exclusive;
            bool withEvents;
            bool markTrusted;
            bool allowUnsafe;
            bool ignoreHidden;
            bool useSecurityLevels;
            bool pushScriptLocation;

#if ISOLATED_PLUGINS
            bool noIsolatedPlugins;
#endif

            bool withScopeFrame;

            ScriptOps.ExtractTrustFlags(
                trustFlags, out exclusive, out withEvents, out markTrusted,
                out allowUnsafe, out ignoreHidden, out useSecurityLevels,
                out pushScriptLocation
#if ISOLATED_PLUGINS
                , out noIsolatedPlugins
#endif
                , out withScopeFrame
            );

            bool locked = false;

            try
            {
                if (exclusive)
                    InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (!exclusive || locked)
                {
                    int savedEnabled = 0;

                    if (!withEvents)
                    {
                        if (!EventOps.SaveEnabledAndForceDisabled(
                                this, true, ref savedEnabled))
                        {
                            result = "failed to forcibly disable events";
                            return ReturnCode.Error;
                        }
                    }

                    try
                    {
                        if (markTrusted)
                        {
                            //
                            // NOTE: Use of this flag is currently limited to
                            //       "safe" child interpreters only.  Just
                            //       ignore the flag if called for an "unsafe"
                            //       interpreter.
                            //
                            if (InternalIsSafe())
                                InternalMarkTrusted();
                            else
                                markTrusted = false;
                        }

                        //
                        // NOTE: Use of this method is currently limited to
                        //       "safe" child interpreters only.  Issue an
                        //       error message if called for an "unsafe"
                        //       interpreter.
                        //
                        if (!markTrusted && !allowUnsafe && !InternalIsSafe())
                        {
                            result = "interpreter is already trusted";
                            return ReturnCode.Error;
                        }

                        try
                        {
                            //
                            // HACK: If necessary, add the "IgnoreHidden" engine
                            //       flag to the per-thread engine flags for this
                            //       interpreter so that the script specified by
                            //       the caller can run with full trust.  The
                            //       per-thread engine flags must be used in this
                            //       case; otherwise, other scripts being evaluated
                            //       on other threads in this interpreter would
                            //       also gain full trust.
                            //
                            bool ignoredHidden = false;

                            if (ignoreHidden &&
                                !EngineFlagOps.HasIgnoreHidden(this.ContextEngineFlags))
                            {
                                ignoredHidden = true;
                                this.ContextEngineFlags |= EngineFlags.IgnoreHidden;
                            }

                            try
                            {
                                if (useSecurityLevels)
                                    EnterSecurityLevel();

                                try
                                {
#if ISOLATED_PLUGINS
                                    PluginFlags savedPluginFlags = PluginFlags.None;

                                    if (noIsolatedPlugins)
                                        BeginNoIsolatedPlugins(ref savedPluginFlags);

                                    try
                                    {
#endif
                                        bool pushed = false;

                                        if (pushScriptLocation)
                                            PushScriptLocation(fileName, true, ref pushed);

                                        try
                                        {
                                            if (withScopeFrame)
                                            {
                                                return Engine.EvaluateScriptWithScopeFrame(
                                                    this, text, engineFlags, substitutionFlags,
                                                    engineEventFlags, expressionFlags,
                                                    ref result, ref errorLine);
                                            }
                                            else
                                            {
                                                return Engine.EvaluateScript(
                                                    this, text, engineFlags, substitutionFlags,
                                                    engineEventFlags, expressionFlags,
                                                    ref result, ref errorLine);
                                            }
                                        }
                                        finally
                                        {
                                            if (pushScriptLocation)
                                                PopScriptLocation(true, ref pushed);
                                        }
#if ISOLATED_PLUGINS
                                    }
                                    finally
                                    {
                                        if (noIsolatedPlugins)
                                            EndNoIsolatedPlugins(ref savedPluginFlags);
                                    }
#endif
                                }
                                finally
                                {
                                    if (useSecurityLevels)
                                        ExitSecurityLevel();
                                }
                            }
                            finally
                            {
                                if (ignoredHidden)
                                {
                                    this.ContextEngineFlags &= ~EngineFlags.IgnoreHidden;
                                    ignoredHidden = false;
                                }
                            }
                        }
                        finally
                        {
                            if (markTrusted)
                            {
                                InternalMarkSafe();
                                markTrusted = false;
                            }
                        }
                    }
                    finally
                    {
                        if (!withEvents)
                        {
                            /* IGNORED */
                            EventOps.RestoreEnabled(this, savedEnabled);

                            savedEnabled = 0;
                        }
                    }
                }
                else
                {
                    result = "could not lock interpreter";
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTrustedFile(
            Encoding encoding,
            string fileName,
            TrustFlags trustFlags,
            ref Result result
            )
        {
            CheckDisposed();

            int errorLine = 0;

            ReturnCode code = EvaluateTrustedFile(
                encoding, fileName, trustFlags, ref result, ref errorLine);

            if (errorLine != 0)
                SetErrorLine(this, errorLine);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTrustedFile(
            Encoding encoding,
            string fileName,
            TrustFlags trustFlags,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

            bool exclusive;
            bool withEvents;
            bool markTrusted;
            bool allowUnsafe;
            bool ignoreHidden;
            bool useSecurityLevels;
            bool pushScriptLocation;

#if ISOLATED_PLUGINS
            bool noIsolatedPlugins;
#endif

            bool withScopeFrame;

            ScriptOps.ExtractTrustFlags(
                trustFlags, out exclusive, out withEvents, out markTrusted,
                out allowUnsafe, out ignoreHidden, out useSecurityLevels,
                out pushScriptLocation
#if ISOLATED_PLUGINS
                , out noIsolatedPlugins
#endif
                , out withScopeFrame
            );

            bool locked = false;

            try
            {
                if (exclusive)
                    InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (!exclusive || locked)
                {
                    int savedEnabled = 0;

                    if (!withEvents)
                    {
                        if (!EventOps.SaveEnabledAndForceDisabled(
                                this, true, ref savedEnabled))
                        {
                            result = "failed to forcibly disable events";
                            return ReturnCode.Error;
                        }
                    }

                    try
                    {
                        if (markTrusted)
                        {
                            //
                            // NOTE: Use of this flag is currently limited to
                            //       "safe" child interpreters only.  Just
                            //       ignore the flag if called for an "unsafe"
                            //       interpreter.
                            //
                            if (InternalIsSafe())
                                InternalMarkTrusted();
                            else
                                markTrusted = false;
                        }

                        //
                        // NOTE: Use of this method is currently limited to
                        //       "safe" child interpreters only.  Issue an
                        //       error message if called for an "unsafe"
                        //       interpreter.
                        //
                        if (!markTrusted && !allowUnsafe && !InternalIsSafe())
                        {
                            result = "interpreter is already trusted";
                            return ReturnCode.Error;
                        }

                        try
                        {
                            //
                            // HACK: If necessary, add the "IgnoreHidden" engine
                            //       flag to the per-thread engine flags for this
                            //       interpreter so that the script specified by
                            //       the caller can run with full trust.  The
                            //       per-thread engine flags must be used in this
                            //       case; otherwise, other scripts being evaluated
                            //       on other threads in this interpreter would
                            //       also gain full trust.
                            //
                            bool ignoredHidden = false;

                            if (ignoreHidden &&
                                !EngineFlagOps.HasIgnoreHidden(this.ContextEngineFlags))
                            {
                                ignoredHidden = true;
                                this.ContextEngineFlags |= EngineFlags.IgnoreHidden;
                            }

                            try
                            {
                                if (useSecurityLevels)
                                    EnterSecurityLevel();

                                try
                                {
#if ISOLATED_PLUGINS
                                    PluginFlags savedPluginFlags = PluginFlags.None;

                                    if (noIsolatedPlugins)
                                        BeginNoIsolatedPlugins(ref savedPluginFlags);

                                    try
                                    {
#endif
                                        if (withScopeFrame)
                                        {
                                            return Engine.EvaluateFileWithScopeFrame(
                                                this, encoding, fileName, engineFlags,
                                                substitutionFlags, engineEventFlags,
                                                expressionFlags, ref result, ref errorLine);
                                        }
                                        else
                                        {
                                            return Engine.EvaluateFile(
                                                this, encoding, fileName, engineFlags,
                                                substitutionFlags, engineEventFlags,
                                                expressionFlags, ref result, ref errorLine);
                                        }
#if ISOLATED_PLUGINS
                                    }
                                    finally
                                    {
                                        if (noIsolatedPlugins)
                                            EndNoIsolatedPlugins(ref savedPluginFlags);
                                    }
#endif
                                }
                                finally
                                {
                                    if (useSecurityLevels)
                                        ExitSecurityLevel();
                                }
                            }
                            finally
                            {
                                if (ignoredHidden)
                                {
                                    this.ContextEngineFlags &= ~EngineFlags.IgnoreHidden;
                                    ignoredHidden = false;
                                }
                            }
                        }
                        finally
                        {
                            if (markTrusted)
                            {
                                InternalMarkSafe();
                                markTrusted = false;
                            }
                        }
                    }
                    finally
                    {
                        if (!withEvents)
                        {
                            /* IGNORED */
                            EventOps.RestoreEnabled(this, savedEnabled);

                            savedEnabled = 0;
                        }
                    }
                }
                else
                {
                    result = "could not lock interpreter";
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTrustedStream(
            string name,
            TextReader textReader,
            int startIndex,
            int characters,
            TrustFlags trustFlags,
            ref Result result
            )
        {
            CheckDisposed();

            int errorLine = 0;

            ReturnCode code = EvaluateTrustedStream(
                name, textReader, startIndex, characters,
                trustFlags, ref result, ref errorLine);

            if (errorLine != 0)
                SetErrorLine(this, errorLine);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTrustedStream(
            string name,
            TextReader textReader,
            int startIndex,
            int characters,
            TrustFlags trustFlags,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

            bool exclusive;
            bool withEvents;
            bool markTrusted;
            bool allowUnsafe;
            bool ignoreHidden;
            bool useSecurityLevels;
            bool pushScriptLocation;

#if ISOLATED_PLUGINS
            bool noIsolatedPlugins;
#endif

            bool withScopeFrame;

            ScriptOps.ExtractTrustFlags(
                trustFlags, out exclusive, out withEvents, out markTrusted,
                out allowUnsafe, out ignoreHidden, out useSecurityLevels,
                out pushScriptLocation
#if ISOLATED_PLUGINS
                , out noIsolatedPlugins
#endif
                , out withScopeFrame
            );

            bool locked = false;

            try
            {
                if (exclusive)
                    InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (!exclusive || locked)
                {
                    int savedEnabled = 0;

                    if (!withEvents)
                    {
                        if (!EventOps.SaveEnabledAndForceDisabled(
                                this, true, ref savedEnabled))
                        {
                            result = "failed to forcibly disable events";
                            return ReturnCode.Error;
                        }
                    }

                    try
                    {
                        if (markTrusted)
                        {
                            //
                            // NOTE: Use of this flag is currently limited to
                            //       "safe" child interpreters only.  Just
                            //       ignore the flag if called for an "unsafe"
                            //       interpreter.
                            //
                            if (InternalIsSafe())
                                InternalMarkTrusted();
                            else
                                markTrusted = false;
                        }

                        //
                        // NOTE: Use of this method is currently limited to
                        //       "safe" child interpreters only.  Issue an
                        //       error message if called for an "unsafe"
                        //       interpreter.
                        //
                        if (!markTrusted && !allowUnsafe && !InternalIsSafe())
                        {
                            result = "interpreter is already trusted";
                            return ReturnCode.Error;
                        }

                        try
                        {
                            //
                            // HACK: If necessary, add the "IgnoreHidden" engine
                            //       flag to the per-thread engine flags for this
                            //       interpreter so that the script specified by
                            //       the caller can run with full trust.  The
                            //       per-thread engine flags must be used in this
                            //       case; otherwise, other scripts being evaluated
                            //       on other threads in this interpreter would
                            //       also gain full trust.
                            //
                            bool ignoredHidden = false;

                            if (ignoreHidden &&
                                !EngineFlagOps.HasIgnoreHidden(this.ContextEngineFlags))
                            {
                                ignoredHidden = true;
                                this.ContextEngineFlags |= EngineFlags.IgnoreHidden;
                            }

                            try
                            {
                                if (useSecurityLevels)
                                    EnterSecurityLevel();

                                try
                                {
#if ISOLATED_PLUGINS
                                    PluginFlags savedPluginFlags = PluginFlags.None;

                                    if (noIsolatedPlugins)
                                        BeginNoIsolatedPlugins(ref savedPluginFlags);

                                    try
                                    {
#endif
                                        if (withScopeFrame)
                                        {
                                            return Engine.EvaluateStreamWithScopeFrame(
                                                this, name, textReader, startIndex,
                                                characters, engineFlags, substitutionFlags,
                                                engineEventFlags, expressionFlags,
                                                ref result, ref errorLine);
                                        }
                                        else
                                        {
                                            return Engine.EvaluateStream(
                                                this, name, textReader, startIndex,
                                                characters, engineFlags, substitutionFlags,
                                                engineEventFlags, expressionFlags,
                                                ref result, ref errorLine);
                                        }
#if ISOLATED_PLUGINS
                                    }
                                    finally
                                    {
                                        if (noIsolatedPlugins)
                                            EndNoIsolatedPlugins(ref savedPluginFlags);
                                    }
#endif
                                }
                                finally
                                {
                                    if (useSecurityLevels)
                                        ExitSecurityLevel();
                                }
                            }
                            finally
                            {
                                if (ignoredHidden)
                                {
                                    this.ContextEngineFlags &= ~EngineFlags.IgnoreHidden;
                                    ignoredHidden = false;
                                }
                            }
                        }
                        finally
                        {
                            if (markTrusted)
                            {
                                InternalMarkSafe();
                                markTrusted = false;
                            }
                        }
                    }
                    finally
                    {
                        if (!withEvents)
                        {
                            /* IGNORED */
                            EventOps.RestoreEnabled(this, savedEnabled);

                            savedEnabled = 0;
                        }
                    }
                }
                else
                {
                    result = "could not lock interpreter";
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal ReturnCode EvaluateScript(
            string text,
            IScriptLocation location,
            ref Result result
            )
        {
            // CheckDisposed(); /* NON-PUBLIC, SANITY */

#if DEBUGGER && BREAKPOINTS
            bool pushed = false;

            PushScriptLocation(location, ref pushed);

            try
            {
#endif
                return EvaluateScript(text, ref result);
#if DEBUGGER && BREAKPOINTS
            }
            finally
            {
                PopScriptLocation(location, ref pushed);
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        internal ReturnCode EvaluateScript(
            string text,
            IScriptLocation location,
            ref Result result,
            ref int errorLine
            )
        {
            // CheckDisposed(); /* NON-PUBLIC, SANITY */

#if DEBUGGER && BREAKPOINTS
            bool pushed = false;

            PushScriptLocation(location, ref pushed);

            try
            {
#endif
                return EvaluateScript(text, ref result, ref errorLine);
#if DEBUGGER && BREAKPOINTS
            }
            finally
            {
                PopScriptLocation(location, ref pushed);
            }
#endif
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluateScript( /* CORE COMMAND USE ONLY */
            Argument argument,
            ref Result result
            )
        {
            // CheckDisposed(); /* NON-PUBLIC, SANITY */

#if DEBUGGER && BREAKPOINTS
            bool pushed = false;

            PushScriptLocation(argument, ref pushed);

            try
            {
#endif
                return EvaluateScript((string)argument, ref result);
#if DEBUGGER && BREAKPOINTS
            }
            finally
            {
                PopScriptLocation(argument, ref pushed);
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluateFinallyScript( /* FOR [try] USE ONLY */
            Argument argument,
            ref Result result
            )
        {
            // CheckDisposed(); /* NON-PUBLIC, SANITY */

#if THREADING
            EngineFlags savedEngineFlags = ContextEngineFlags;
            ContextEngineFlags |= EngineFlags.NoGlobalCancel;

            try
            {
#endif
#if DEBUGGER && BREAKPOINTS
                bool pushed = false;

                PushScriptLocation(argument, ref pushed);

                try
                {
#endif
                    return EvaluateScript((string)argument, ref result);
#if DEBUGGER && BREAKPOINTS
                }
                finally
                {
                    PopScriptLocation(argument, ref pushed);
                }
#endif
#if THREADING
            }
            finally
            {
                ContextEngineFlags = savedEngineFlags;
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluateScript( /* FOR [catch] USE ONLY */
            Argument argument,
            EngineFlags engineFlags,
            ref Result result,
            ref int errorLine
            )
        {
            // CheckDisposed(); /* NON-PUBLIC, SANITY */

#if DEBUGGER && BREAKPOINTS
            bool pushed = false;

            PushScriptLocation(argument, ref pushed);

            try
            {
#endif
                return Engine.EvaluateScript(
                    this, argument, engineFlags, substitutionFlags,
                    engineEventFlags, expressionFlags, ref result,
                    ref errorLine);
#if DEBUGGER && BREAKPOINTS
            }
            finally
            {
                PopScriptLocation(argument, ref pushed);
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluateScript(
            ArgumentList arguments,
            int startIndex,
            ref Result result
            )
        {
            // CheckDisposed(); /* NON-PUBLIC, SANITY */

            int errorLine = 0;

            ReturnCode code = EvaluateScript(
                arguments, startIndex, ref result, ref errorLine);

            if (errorLine != 0)
                SetErrorLine(this, errorLine);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluateScript(
            ArgumentList arguments,
            int startIndex,
            ref Result result,
            ref int errorLine
            )
        {
            // CheckDisposed(); /* NON-PUBLIC, SANITY */

#if DEBUGGER && BREAKPOINTS
            IScriptLocation location = null;

            if (ScriptOps.GetLocation(
                    this, arguments, startIndex, ref location,
                    ref result) != ReturnCode.Ok)
            {
                return ReturnCode.Error;
            }

            bool pushed = false;

            PushScriptLocation(location, ref pushed);

            try
            {
#endif
                return EvaluateScript(
                    ListOps.Concat(arguments, startIndex), ref result,
                    ref errorLine);
#if DEBUGGER && BREAKPOINTS
            }
            finally
            {
                PopScriptLocation(location, ref pushed);
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluateScriptOrBackgroundError(
            ref string text /* in, out */
            )
        {
            // CheckDisposed();

            ReturnCode code;
            Result result = null;
            int errorLine = 0; /* NOT USED */

            code = Engine.EvaluateScript(
                this, text, engineFlags, substitutionFlags,
                engineEventFlags, expressionFlags, ref result,
                ref errorLine);

            if (code == ReturnCode.Ok)
            {
                text = result;
            }
            else if (!FlagOps.HasFlags(
                    engineEventFlags, EventFlags.NoBgError, true))
            {
                if (EventOps.HandleBackgroundError(
                        this, code, result) != ReturnCode.Ok)
                {
                    DebugOps.Complain(this, code, result);
                }
            }
            else
            {
                TraceOps.DebugTrace(String.Format(
                    "EvaluateScriptOrBackgroundError: interpreter = {0}, " +
                    "code = {1}, result = {2}, errorLine = {3}",
                    FormatOps.InterpreterNoThrow(this), code,
                    FormatOps.WrapOrNull(true, true, result),
                    errorLine), typeof(Interpreter).Name,
                    TracePriority.ScriptError2);
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluatePackageScript(
            string text,
            ref Result result
            )
        {
            EnterPackageLevel();

            try
            {
                return Engine.EvaluateScript(
                    this, text, engineFlags | EngineFlags.EvaluateGlobal,
                    substitutionFlags, engineEventFlags, expressionFlags,
                    ref result);
            }
            finally
            {
                ExitPackageLevel();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluatePromptScript(
            string text,
            ref Result result,
            ref int errorLine
            )
        {
#if ARGUMENT_CACHE
            CacheFlags savedCacheFlags = CacheFlags.None;
            BeginNoArgumentCache(ref savedCacheFlags);

            try
            {
#endif
                return Engine.EvaluateScript(
                    this, text, engineFlags | EngineFlags.ForPromptMask,
                    substitutionFlags, engineEventFlags, expressionFlags,
                    ref result, ref errorLine);
#if ARGUMENT_CACHE
            }
            finally
            {
                EndNoArgumentCache(ref savedCacheFlags);
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluateSafeScript(
            string text,
            ref Result result
            )
        {
            int errorLine = 0;

            ReturnCode code = EvaluateSafeScript(
                text, ref result, ref errorLine);

            if (errorLine != 0)
                SetErrorLine(this, errorLine);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode EvaluateSafeScript(
            string text,
            ref Result result,
            ref int errorLine
            )
        {
            // CheckDisposed();

            bool locked = false;

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    if (InternalIsSafe())
                    {
                        result = "interpreter is already safe";
                        return ReturnCode.Error;
                    }

                    if (InternalMakeSafe(
                            MakeFlags.SafeEvaluate, true,
                            ref result) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }

                    try
                    {
                        return Engine.EvaluateScript(
                            this, text, engineFlags, substitutionFlags,
                            engineEventFlags, expressionFlags, ref result,
                            ref errorLine);
                    }
                    finally
                    {
                        ReturnCode safeCode;
                        Result safeError = null;

                        safeCode = InternalMakeSafe(
                            MakeFlags.SafeEvaluate, false,
                            ref safeError);

                        if (safeCode != ReturnCode.Ok)
                            DebugOps.Complain(this, safeCode, safeError);
                    }
                }
                else
                {
                    result = "could not lock interpreter";
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluateSafeFile(
            Encoding encoding,
            string fileName,
            ref Result result
            )
        {
            int errorLine = 0;

            ReturnCode code = EvaluateSafeFile(
                encoding, fileName, ref result, ref errorLine);

            if (errorLine != 0)
                SetErrorLine(this, errorLine);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluateSafeFile(
            Encoding encoding,
            string fileName,
            ref Result result,
            ref int errorLine
            )
        {
            // CheckDisposed();

            bool locked = false;

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    EngineFlags localEngineFlags;
                    SubstitutionFlags localSubstitutionFlags;
                    EventFlags localEventFlags;
                    ExpressionFlags localExpressionFlags;

                    localEngineFlags = engineFlags;
                    localSubstitutionFlags = substitutionFlags;
                    localEventFlags = engineEventFlags;
                    localExpressionFlags = expressionFlags;

                    string text = null;

                    if (Engine.ReadOrGetScriptFile(
                            this, encoding, ref fileName,
                            ref localEngineFlags, ref localSubstitutionFlags,
                            ref localEventFlags, ref localExpressionFlags,
                            ref text, ref result) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }

                    bool pushed = false;

                    PushScriptLocation(fileName, true, ref pushed);

                    try
                    {
                        if (InternalIsSafe())
                        {
                            result = "interpreter is already safe";
                            return ReturnCode.Error;
                        }

                        if (InternalMakeSafe(
                                MakeFlags.SafeEvaluate, true,
                                ref result) != ReturnCode.Ok)
                        {
                            return ReturnCode.Error;
                        }

                        try
                        {
                            return Engine.EvaluateScript(
                                this, text, localEngineFlags,
                                localSubstitutionFlags, localEventFlags,
                                localExpressionFlags, ref result,
                                ref errorLine);
                        }
                        finally
                        {
                            ReturnCode safeCode;
                            Result safeError = null;

                            safeCode = InternalMakeSafe(
                                MakeFlags.SafeEvaluate, false,
                                ref safeError);

                            if (safeCode != ReturnCode.Ok)
                                DebugOps.Complain(this, safeCode, safeError);
                        }
                    }
                    finally
                    {
                        PopScriptLocation(true, ref pushed);
                    }
                }
                else
                {
                    result = "could not lock interpreter";
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }

            return ReturnCode.Error;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Expression Evaluation
        public ReturnCode EvaluateExpression(
            string text,
            ref Result result
            )
        {
            CheckDisposed();

            return Engine.EvaluateExpression(
                this, text, engineFlags,
                substitutionFlags, engineEventFlags,
                expressionFlags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private static bool HasTraceResult(
            InterpreterFlags interpreterFlags
            )
        {
            /* EXEMPT */
            return FlagOps.HasFlags(interpreterFlags,
                InterpreterFlags.TraceResult, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluateExpression(
            Argument argument,
            ref Result result
            )
        {
            // CheckDisposed(); /* NON-PUBLIC, SANITY */

#if DEBUGGER && BREAKPOINTS
            bool pushed = false;

            PushScriptLocation(argument, ref pushed);

            try
            {
#endif
                return EvaluateExpression((string)argument, ref result);
#if DEBUGGER && BREAKPOINTS
            }
            finally
            {
                PopScriptLocation(argument, ref pushed);
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluateExpression(
            ArgumentList arguments,
            int startIndex,
            ref Result result
            )
        {
            // CheckDisposed(); /* NON-PUBLIC, SANITY */

#if DEBUGGER && BREAKPOINTS
            IScriptLocation location = null;

            if (ScriptOps.GetLocation(
                    this, arguments, startIndex, ref location,
                    ref result) != ReturnCode.Ok)
            {
                return ReturnCode.Error;
            }

            bool pushed = false;

            PushScriptLocation(location, ref pushed);

            try
            {
#endif
                return EvaluateExpression(
                    ListOps.Concat(arguments, startIndex), ref result);
#if DEBUGGER && BREAKPOINTS
            }
            finally
            {
                PopScriptLocation(location, ref pushed);
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EvaluateExpressionWithErrorInfo(
            Argument argument,
            string errorInfo,
            ref Result result
            )
        {
            // CheckDisposed(); /* NON-PUBLIC, SANITY */

#if DEBUGGER && BREAKPOINTS
            bool pushed = false;

            PushScriptLocation(argument, ref pushed);

            try
            {
#endif
                return Engine.EvaluateExpressionWithErrorInfo(
                    this, argument, engineFlags, substitutionFlags,
                    engineEventFlags, expressionFlags,
#if RESULT_LIMITS
                    executeResultLimit, nestedResultLimit,
#endif
                    errorInfo, ref result);
#if DEBUGGER && BREAKPOINTS
            }
            finally
            {
                PopScriptLocation(argument, ref pushed);
            }
#endif
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Substitution Processing
        public ReturnCode SubstituteString(
            string text,
            ref Result result
            )
        {
            CheckDisposed();

            return SubstituteString(text, substitutionFlags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteString(
            string text,
            SubstitutionFlags substitutionFlags,
            ref Result result
            )
        {
            CheckDisposed();

            return Engine.SubstituteString(
                this, text, engineFlags, substitutionFlags,
                engineEventFlags, expressionFlags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteGlobalString(
            string text,
            ref Result result
            )
        {
            CheckDisposed();

            return SubstituteGlobalString(text, substitutionFlags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteGlobalString(
            string text,
            SubstitutionFlags substitutionFlags,
            ref Result result
            )
        {
            CheckDisposed();

            return Engine.SubstituteString(
                this, text, engineFlags | EngineFlags.EvaluateGlobal,
                substitutionFlags, engineEventFlags, expressionFlags,
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteFile(
            string fileName,
            ref Result result
            )
        {
            CheckDisposed();

            return SubstituteFile(
                fileName, substitutionFlags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteFile(
            string fileName,
            SubstitutionFlags substitutionFlags,
            ref Result result
            )
        {
            CheckDisposed();

            return Engine.SubstituteFile(
                this, fileName, engineFlags, substitutionFlags,
                engineEventFlags, expressionFlags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteGlobalFile(
            string fileName,
            ref Result result
            )
        {
            CheckDisposed();

            return SubstituteGlobalFile(
                fileName, substitutionFlags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteGlobalFile(
            string fileName,
            SubstitutionFlags substitutionFlags,
            ref Result result
            )
        {
            CheckDisposed();

            return Engine.SubstituteFile(
                this, fileName, engineFlags | EngineFlags.EvaluateGlobal,
                substitutionFlags, engineEventFlags, expressionFlags,
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteStream(
            string name,
            TextReader textReader,
            int startIndex,
            int characters,
            ref Result result
            )
        {
            CheckDisposed();

            return SubstituteStream(
                name, textReader, startIndex, characters,
                substitutionFlags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteStream(
            string name,
            TextReader textReader,
            int startIndex,
            int characters,
            SubstitutionFlags substitutionFlags,
            ref Result result
            )
        {
            CheckDisposed();

            return Engine.SubstituteStream(
                this, name, textReader, startIndex, characters,
                engineFlags, substitutionFlags, engineEventFlags,
                expressionFlags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteGlobalStream(
            string name,
            TextReader textReader,
            int startIndex,
            int characters,
            ref Result result
            )
        {
            CheckDisposed();

            return SubstituteGlobalStream(
                name, textReader, startIndex, characters,
                substitutionFlags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteGlobalStream(
            string name,
            TextReader textReader,
            int startIndex,
            int characters,
            SubstitutionFlags substitutionFlags,
            ref Result result
            )
        {
            CheckDisposed();

            return Engine.SubstituteStream(
                this, name, textReader, startIndex, characters,
                engineFlags | EngineFlags.EvaluateGlobal,
                substitutionFlags, engineEventFlags,
                expressionFlags, ref result);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Asynchronous Script Evaluation
        public ReturnCode EvaluateScript(
            string text,
            AsynchronousCallback callback, /* NOTE: May be null for "fire-and-forget" type scripts. */
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return Engine.EvaluateScript(
                this, text, engineFlags, substitutionFlags, engineEventFlags,
                expressionFlags, callback, clientData, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateFile(
            string fileName,
            AsynchronousCallback callback, /* NOTE: May be null for "fire-and-forget" type scripts. */
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return Engine.EvaluateFile(
                this, fileName, engineFlags, substitutionFlags,
                engineEventFlags, expressionFlags, callback,
                clientData, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateGlobalScript(
            string text,
            AsynchronousCallback callback, /* NOTE: May be null for "fire-and-forget" type scripts. */
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return Engine.EvaluateScript(
                this, text, engineFlags | EngineFlags.EvaluateGlobal,
                substitutionFlags, engineEventFlags, expressionFlags,
                callback, clientData, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateGlobalFile(
            string fileName,
            AsynchronousCallback callback, /* NOTE: May be null for "fire-and-forget" type scripts. */
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return Engine.EvaluateFile(
                this, fileName, engineFlags | EngineFlags.EvaluateGlobal,
                substitutionFlags, engineEventFlags, expressionFlags,
                callback, clientData, ref error);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Asynchronous Substitution Processing
        public ReturnCode SubstituteString(
            string text,
            AsynchronousCallback callback, /* NOTE: May be null for "fire-and-forget" type scripts. */
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return SubstituteString(
                text, substitutionFlags, callback, clientData,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteString(
            string text,
            SubstitutionFlags substitutionFlags,
            AsynchronousCallback callback, /* NOTE: May be null for "fire-and-forget" type scripts. */
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return Engine.SubstituteString(
                this, text, engineFlags, substitutionFlags,
                engineEventFlags, expressionFlags, callback,
                clientData, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteGlobalString(
            string text,
            AsynchronousCallback callback, /* NOTE: May be null for "fire-and-forget" type scripts. */
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return SubstituteGlobalString(
                text, substitutionFlags, callback, clientData,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteGlobalString(
            string text,
            SubstitutionFlags substitutionFlags,
            AsynchronousCallback callback, /* NOTE: May be null for "fire-and-forget" type scripts. */
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return Engine.SubstituteString(
                this, text, engineFlags | EngineFlags.EvaluateGlobal,
                substitutionFlags, engineEventFlags, expressionFlags,
                callback, clientData, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteFile(
            string fileName,
            AsynchronousCallback callback, /* NOTE: May be null for "fire-and-forget" type scripts. */
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return SubstituteFile(
                fileName, substitutionFlags,
                callback, clientData, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteFile(
            string fileName,
            SubstitutionFlags substitutionFlags,
            AsynchronousCallback callback, /* NOTE: May be null for "fire-and-forget" type scripts. */
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return Engine.SubstituteFile(
                this, fileName, engineFlags, substitutionFlags,
                engineEventFlags, expressionFlags, callback,
                clientData, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteGlobalFile(
            string fileName,
            AsynchronousCallback callback, /* NOTE: May be null for "fire-and-forget" type scripts. */
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return SubstituteGlobalFile(
                fileName, substitutionFlags,
                callback, clientData, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteGlobalFile(
            string fileName,
            SubstitutionFlags substitutionFlags,
            AsynchronousCallback callback, /* NOTE: May be null for "fire-and-forget" type scripts. */
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return Engine.SubstituteFile(
                this, fileName, engineFlags | EngineFlags.EvaluateGlobal,
                substitutionFlags, engineEventFlags, expressionFlags,
                callback, clientData, ref error);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Command Execution
        public ReturnCode Invoke(
            string name,
            IClientData clientData,
            ArgumentList arguments,
            ref Result result
            )
        {
            CheckDisposed();

            IExecute execute = null;

            if (GetIExecuteViaResolvers(GetResolveEngineFlagsNoLock(true),
                    name, arguments, LookupFlags.Default, ref execute,
                    ref result) != ReturnCode.Ok)
            {
                return ReturnCode.Error;
            }

            //
            // WARNING: This now (indirectly) uses ContextEngineFlags.
            //
            return Engine.Execute(
                name, execute, this, clientData, arguments,
                EngineFlags, substitutionFlags, engineEventFlags,
                expressionFlags,
#if RESULT_LIMITS
                executeResultLimit,
#endif
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal long OperationCount
        {
            get { lock (syncRoot) { return OperationCountNoLock; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal long OperationCountNoLock
        {
            get { return operationCount; }
            set { operationCount = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal long CommandCount
        {
            get { lock (syncRoot) { return CommandCountNoLock; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal long CommandCountNoLock
        {
            get { return commandCount; }
            set { commandCount = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void IncrementOperationAndCommandCount(
            bool isCommand
            )
        {
            Interlocked.Increment(ref operationCount);

            if (isCommand)
                Interlocked.Increment(ref commandCount);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode Execute(
            string name,
            IExecute execute,
            IClientData clientData,
            ArgumentList arguments,
            ref Result result
            )
        {
            // CheckDisposed(); /* NON-PUBLIC, SANITY */

            //
            // WARNING: This now (indirectly) uses ContextEngineFlags.
            //
            return Engine.Execute(
                name, execute, this, clientData, arguments, EngineFlags,
                substitutionFlags, engineEventFlags, expressionFlags,
#if RESULT_LIMITS
                executeResultLimit,
#endif
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Hidden IProcedure, IExecute, ICommand
        internal ReturnCode ExecuteHidden(
            string name,
            IExecute execute,
            IClientData clientData,
            ArgumentList arguments,
            ref Result result
            )
        {
            // CheckDisposed(); /* NON-PUBLIC, SANITY */

            return Engine.Execute(
                name, execute, this, clientData, arguments,
                engineFlags | EngineFlags.InvokeHidden,
                substitutionFlags, engineEventFlags,
                expressionFlags,
#if RESULT_LIMITS
                executeResultLimit,
#endif
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode MoveExposedAndHiddenCommands(
            PluginFlags flags, /* in */
            ref Result error   /* out */
            )
        {
            /* CheckDisposed(); */

            int count = 0;

            return MoveExposedAndHiddenCommands(flags, ref count, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode MoveExposedAndHiddenCommands(
            PluginFlags flags, /* in */
            ref int count,     /* in, out */
            ref Result error   /* out */
            )
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if ((procedures != null) && (hiddenProcedures != null))
                {
                    //
                    // NOTE: Are we merging procedures from this plugin?  If so, ignore any procedures
                    //       that already exist; otherwise, an existing hidden procedure of the same
                    //       name will raise an error.
                    //
                    bool ignoreExisting = FlagOps.HasFlags(flags, PluginFlags.MergeProcedures, true);
                    bool replaceExisting = FlagOps.HasFlags(flags, PluginFlags.OverwriteProcedures, true);

                    ///////////////////////////////////////////////////////////////////////////////////

                    ProcedureWrapperDictionary localProcedures;

                    ///////////////////////////////////////////////////////////////////////////////////

                    localProcedures = new ProcedureWrapperDictionary(procedures);

                    foreach (KeyValuePair<string, _Wrappers.Procedure> pair in localProcedures)
                    {
                        string key = pair.Key;
                        _Wrappers.Procedure procedure = pair.Value;

                        if ((procedure != null) && EntityOps.IsHidden(procedure))
                        {
                            bool exists = hiddenProcedures.ContainsKey(key);

                            if (exists && !replaceExisting)
                            {
                                if (ignoreExisting)
                                    continue;

                                error = String.Format(
                                    "can't move {0}: hidden procedure already exists",
                                    FormatOps.WrapOrNull(key));

                                return ReturnCode.Error;
                            }
                            else
                            {
                                if (exists)
                                    hiddenProcedures[key] = procedure;
                                else
                                    hiddenProcedures.Add(key, procedure);

                                procedures.Remove(key);

#if EXECUTE_CACHE
                                RemoveIExecuteFromCache(key, false, false);
                                RemoveIExecuteFromCache(key, true, false);
#endif

                                count++;
                            }
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////

                    localProcedures = new ProcedureWrapperDictionary(hiddenProcedures);

                    foreach (KeyValuePair<string, _Wrappers.Procedure> pair in localProcedures)
                    {
                        string key = pair.Key;
                        _Wrappers.Procedure procedure = pair.Value;

                        if ((procedure != null) && !EntityOps.IsHidden(procedure))
                        {
                            bool exists = procedures.ContainsKey(key);

                            if (exists && !replaceExisting)
                            {
                                if (ignoreExisting)
                                    continue;

                                error = String.Format(
                                    "can't move {0}: procedure already exists",
                                    FormatOps.WrapOrNull(key));

                                return ReturnCode.Error;
                            }
                            else
                            {
                                if (exists)
                                    procedures[key] = procedure;
                                else
                                    procedures.Add(key, procedure);

                                hiddenProcedures.Remove(key);

#if EXECUTE_CACHE
                                RemoveIExecuteFromCache(key, false, false);
                                RemoveIExecuteFromCache(key, true, false);
#endif

                                count++;
                            }
                        }
                    }
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                if ((commands != null) && (hiddenCommands != null))
                {
                    //
                    // NOTE: Are we merging commands from this plugin?  If so, ignore any commands
                    //       that already exist; otherwise, an existing hidden command of the same
                    //       name will raise an error.
                    //
                    bool ignoreExisting = FlagOps.HasFlags(flags, PluginFlags.MergeCommands, true);
                    bool replaceExisting = FlagOps.HasFlags(flags, PluginFlags.OverwriteCommands, true);

                    ///////////////////////////////////////////////////////////////////////////////////

                    CommandWrapperDictionary localCommands;

                    ///////////////////////////////////////////////////////////////////////////////////

                    localCommands = new CommandWrapperDictionary(commands);

                    foreach (KeyValuePair<string, _Wrappers.Command> pair in localCommands)
                    {
                        string key = pair.Key;
                        _Wrappers.Command newCommand = pair.Value;

                        if ((newCommand != null) && EntityOps.IsHidden(newCommand))
                        {
                            _Wrappers.Command oldCommand;
                            bool exists = hiddenCommands.TryGetValue(key, out oldCommand);

                            if (exists && !replaceExisting)
                            {
                                if (ignoreExisting)
                                    continue;

                                error = String.Format(
                                    "can't move {0}: hidden command already exists",
                                    FormatOps.WrapOrNull(key));

                                return ReturnCode.Error;
                            }
                            else
                            {
                                if (exists)
                                {
                                    string oldCommandName = null;

                                    GlobalState.PushActiveInterpreter(this);

                                    try
                                    {
                                        oldCommandName = EntityOps.GetNameNoThrow(
                                            oldCommand);

                                        Result localResult = null;

                                        if (TerminateCommand(oldCommand, null,
                                                ref localResult) != ReturnCode.Ok)
                                        {
                                            error = localResult;
                                            return ReturnCode.Error;
                                        }
                                    }
                                    catch (Exception e)
                                    {
                                        error = String.Format(
                                            "caught exception while deleting hidden command {0}: {1}",
                                             FormatOps.WrapOrNull(oldCommandName), e);

                                        return ReturnCode.Error;
                                    }
                                    finally
                                    {
                                        /* IGNORED */
                                        GlobalState.PopActiveInterpreter();
                                    }

                                    hiddenCommands[key] = newCommand;
                                }
                                else
                                {
                                    hiddenCommands.Add(key, newCommand);
                                }

                                commands.Remove(key);

#if EXECUTE_CACHE
                                RemoveIExecuteFromCache(key, false, false);
                                RemoveIExecuteFromCache(key, true, false);
#endif

                                count++;
                            }
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////

                    localCommands = new CommandWrapperDictionary(hiddenCommands);

                    foreach (KeyValuePair<string, _Wrappers.Command> pair in localCommands)
                    {
                        string key = pair.Key;
                        _Wrappers.Command newCommand = pair.Value;

                        if ((newCommand != null) && !EntityOps.IsHidden(newCommand))
                        {
                            _Wrappers.Command oldCommand;
                            bool exists = commands.TryGetValue(key, out oldCommand);

                            if (exists && !replaceExisting)
                            {
                                if (ignoreExisting)
                                    continue;

                                error = String.Format(
                                    "can't move {0}: command already exists",
                                    FormatOps.WrapOrNull(key));

                                return ReturnCode.Error;
                            }
                            else
                            {
                                if (exists)
                                {
                                    string oldCommandName = null;

                                    GlobalState.PushActiveInterpreter(this);

                                    try
                                    {
                                        oldCommandName = EntityOps.GetNameNoThrow(
                                            oldCommand);

                                        Result localResult = null;

                                        if (TerminateCommand(oldCommand, null,
                                                ref localResult) != ReturnCode.Ok)
                                        {
                                            error = localResult;
                                            return ReturnCode.Error;
                                        }
                                    }
                                    catch (Exception e)
                                    {
                                        error = String.Format(
                                            "caught exception while deleting command {0}: {1}",
                                             FormatOps.WrapOrNull(oldCommandName), e);

                                        return ReturnCode.Error;
                                    }
                                    finally
                                    {
                                        /* IGNORED */
                                        GlobalState.PopActiveInterpreter();
                                    }

                                    commands[key] = newCommand;
                                }
                                else
                                {
                                    commands.Add(key, newCommand);
                                }

                                hiddenCommands.Remove(key);

#if EXECUTE_CACHE
                                RemoveIExecuteFromCache(key, false, false);
                                RemoveIExecuteFromCache(key, true, false);
#endif

                                count++;
                            }
                        }
                    }
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ExposeCommand(
            string name,
            ref Result error
            )
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                IExecute execute = null;

                if (GetIExecuteViaResolvers(
                        GetResolveEngineFlagsNoLock(true) | EngineFlags.UseHidden, name,
                        null, LookupFlags.NoVerbose, ref execute) == ReturnCode.Ok)
                {
                    if (execute is _Wrappers._Execute)
                    {
                        if (HasIExecutes(ref error) && HasHiddenIExecutes(ref error))
                        {
                            _Wrappers._Execute executeWrapper = (_Wrappers._Execute)execute;

                            string newName = ScriptOps.MakeCommandName(name);

                            executes.Add(newName, executeWrapper);
                            hiddenExecutes.Remove(newName);

#if EXECUTE_CACHE
                            RemoveIExecuteFromCache(newName, false, false);
                            RemoveIExecuteFromCache(newName, true, false);
#endif

                            return ReturnCode.Ok;
                        }
                    }
                    else if (execute is _Wrappers.Procedure)
                    {
                        if (HasProcedures(ref error) && HasHiddenProcedures(ref error))
                        {
                            _Wrappers.Procedure procedureWrapper = (_Wrappers.Procedure)execute;

                            procedures.Add(procedureWrapper.Name, procedureWrapper);
                            hiddenProcedures.Remove(procedureWrapper.Name);

                            procedureWrapper.Flags &= ~ProcedureFlags.Hidden;

#if EXECUTE_CACHE
                            RemoveIExecuteFromCache(procedureWrapper.Name, false, false);
                            RemoveIExecuteFromCache(procedureWrapper.Name, true, false);
#endif

                            return ReturnCode.Ok;
                        }
                    }
                    else if (execute is _Wrappers.Command)
                    {
                        if (HasCommands(ref error) && HasHiddenCommands(ref error))
                        {
                            _Wrappers.Command commandWrapper = (_Wrappers.Command)execute;

                            commands.Add(commandWrapper.Name, commandWrapper);
                            hiddenCommands.Remove(commandWrapper.Name);

                            commandWrapper.Flags &= ~CommandFlags.Hidden;

#if EXECUTE_CACHE
                            RemoveIExecuteFromCache(commandWrapper.Name, false, false);
                            RemoveIExecuteFromCache(commandWrapper.Name, true, false);
#endif

                            return ReturnCode.Ok;
                        }
                    }
                    else
                    {
                        error = String.Format(
                            "unknown execution type for {0}",
                            FormatOps.WrapOrNull(name));
                    }
                }
                else
                {
                    error = String.Format(
                        "unknown hidden command {0}",
                        FormatOps.WrapOrNull(name));
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode HideCommand(
            string name,
            ref Result error
            )
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                IExecute execute = null;

                if (GetIExecuteViaResolvers(
                        GetResolveEngineFlagsNoLock(true), name, null,
                        LookupFlags.NoVerbose, ref execute) == ReturnCode.Ok)
                {
                    if (execute is _Wrappers._Execute)
                    {
                        if (HasIExecutes(ref error) && HasHiddenIExecutes(ref error))
                        {
                            _Wrappers._Execute executeWrapper = (_Wrappers._Execute)execute;

                            string newName = ScriptOps.MakeCommandName(name);

                            hiddenExecutes.Add(newName, executeWrapper);
                            executes.Remove(newName);

#if EXECUTE_CACHE
                            RemoveIExecuteFromCache(newName, false, false);
                            RemoveIExecuteFromCache(newName, true, false);
#endif

                            return ReturnCode.Ok;
                        }
                    }
                    else if (execute is _Wrappers.Procedure)
                    {
                        if (HasProcedures(ref error) && HasHiddenProcedures(ref error))
                        {
                            _Wrappers.Procedure procedureWrapper = (_Wrappers.Procedure)execute;

                            hiddenProcedures.Add(procedureWrapper.Name, procedureWrapper);
                            procedures.Remove(procedureWrapper.Name);

                            procedureWrapper.Flags |= ProcedureFlags.Hidden;

#if EXECUTE_CACHE
                            RemoveIExecuteFromCache(procedureWrapper.Name, false, false);
                            RemoveIExecuteFromCache(procedureWrapper.Name, true, false);
#endif

                            return ReturnCode.Ok;
                        }
                    }
                    else if (execute is _Wrappers.Command)
                    {
                        if (HasCommands(ref error) && HasHiddenCommands(ref error))
                        {
                            _Wrappers.Command commandWrapper = (_Wrappers.Command)execute;

                            hiddenCommands.Add(commandWrapper.Name, commandWrapper);
                            commands.Remove(commandWrapper.Name);

                            commandWrapper.Flags |= CommandFlags.Hidden;

#if EXECUTE_CACHE
                            RemoveIExecuteFromCache(commandWrapper.Name, false, false);
                            RemoveIExecuteFromCache(commandWrapper.Name, true, false);
#endif

                            return ReturnCode.Ok;
                        }
                    }
                    else
                    {
                        error = String.Format(
                            "unknown execution type for {0}",
                            FormatOps.WrapOrNull(name));
                    }
                }
                else
                {
                    error = String.Format(
                        "unknown command {0}",
                        FormatOps.WrapOrNull(name));
                }
            }

            return ReturnCode.Error;
        }
        #endregion
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ICallbackQueueManager Members
#if CALLBACK_QUEUE
        public bool HasCallbackQueue(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                return PrivateHasCallbackQueue(ref error);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ClearCallbackQueue(
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateHasCallbackQueue(ref error))
                {
                    callbackQueue.Clear();

                    code = ReturnCode.Ok;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EnqueueCallback(
            ICallback callback,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                int queueCount = 0;

                if (PrivateHasCallbackQueue(ref queueCount, ref error))
                {
                    if ((callbackLimit <= 0) || (queueCount < callbackLimit))
                    {
                        CommandCallback commandCallback =
                            callback as CommandCallback;

                        if (commandCallback != null)
                        {
                            callbackQueue.Enqueue(commandCallback);

                            code = ReturnCode.Ok;
                        }
                        else
                        {
                            error = "invalid command callback";
                        }
                    }
                    else
                    {
                        error = "callback queue limit would be exceeded";
                    }
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DequeueCallback(
            ref ICallback callback,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                int queueCount = 0;

                if (PrivateHasCallbackQueue(ref queueCount, ref error))
                {
                    if (queueCount > 0)
                    {
                        callback = callbackQueue.Dequeue();

                        code = ReturnCode.Ok;
                    }
                    else
                    {
                        error = "callback queue is empty";
                    }
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal ReturnCode CountCallbacks(
            ref int count,
            ref Result error
            )
        {
            // CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                int queueCount = 0;

                if (PrivateHasCallbackQueue(ref queueCount, ref error))
                {
                    count = queueCount;
                    code = ReturnCode.Ok;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ListCallbacks(
            string pattern,
            bool noCase,
            ref StringList list,
            ref Result error
            )
        {
            // CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateHasCallbackQueue(ref error))
                {
                    StringList inputList = new StringList(
                        callbackQueue.ToArray());

                    StringList outputList = new StringList();

                    code = GenericOps<string>.FilterList(
                        inputList, outputList, Index.Invalid, Index.Invalid,
                        ToStringFlags.None, pattern, noCase, ref error);

                    if (code == ReturnCode.Ok)
                        list = outputList;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DequeueCallback(
            ref CommandCallback callback
            )
        {
            ICallback localCallback = null;
            Result error = null;

            if (DequeueCallback(ref localCallback, ref error) == ReturnCode.Ok)
            {
                if (localCallback is CommandCallback)
                {
                    callback = (CommandCallback)localCallback;

                    return ReturnCode.Ok;
                }
                else
                {
                    error = "invalid command callback";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateHasCallbackQueue(
            ref Result error
            )
        {
            int queueCount = 0; /* NOT USED */

            return PrivateHasCallbackQueue(ref queueCount, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateHasCallbackQueue(
            ref int queueCount,
            ref Result error
            )
        {
            if (callbackQueue != null)
            {
                queueCount = callbackQueue.Count;
                return true;
            }
            else
            {
                error = "callback queue not available";
                return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DequeueAllCallbacks( /* For Engine use only. */
            ref CommandCallback[] callbacks, /* in, out */
            ref Result error                 /* out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                int queueCount = 0;

                if (!PrivateHasCallbackQueue(ref queueCount, ref error))
                    return ReturnCode.Error;

                if (callbacks != null)
                {
                    error = "cannot overwrite valid callback array";
                    return ReturnCode.Error;
                }

                if (queueCount > 0)
                {
                    callbacks = new CommandCallback[queueCount];
                    callbackQueue.CopyTo(callbacks, 0);
                    callbackQueue.Clear();
                }

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode EnqueueSomeCallbacks( /* For Engine use only. */
            int nextIndex,                   /* in */
            ref CommandCallback[] callbacks, /* in, out */
            ref Result error                 /* out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                int queueCount = 0;

                if (!PrivateHasCallbackQueue(ref queueCount, ref error))
                    return ReturnCode.Error;

                if (callbacks == null)
                {
                    error = "invalid callback array";
                    return ReturnCode.Error;
                }

                int length = callbacks.Length;

                if ((nextIndex < 0) || (nextIndex >= length))
                {
                    error = "next callback index is out-of-bounds";
                    return ReturnCode.Error;
                }

                if ((callbackLimit > 0) &&
                    ((queueCount + (length - nextIndex)) > callbackLimit))
                {
                    error = "callback limit would be exceeded";
                    return ReturnCode.Error;
                }

                for (int index = nextIndex; index < length; index++)
                {
                    callbackQueue.Enqueue(callbacks[index]);
                    callbacks[index] = null;
                }

                Array.Resize(ref callbacks, 0);
                callbacks = null;

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the [callback] command only.
        //
        internal ReturnCode ExecuteCallbackQueue(
            ref Result result
            )
        {
            //
            // WARNING: This now (indirectly) uses ContextEngineFlags.
            //
            return Engine.ExecuteCallbackQueue(
                this, EngineFlags, substitutionFlags, engineEventFlags,
                expressionFlags,
#if RESULT_LIMITS
                executeResultLimit,
#endif
                ref result);
        }
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IEntityManager Members
        #region Entity Checking
        public bool HasAliases(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (aliases != null);

                if (!result)
                    error = "aliases not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasCallbacks(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (callbacks != null);

                if (!result)
                    error = "callbacks not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasChannels(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                return PrivateHasChannels(ref error);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasCommands(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (commands != null);

                if (!result)
                    error = "commands not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasFunctions(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (functions != null);

                if (!result)
                    error = "functions not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasIExecutes(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (executes != null);

                if (!result)
                    error = "executes not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasObjects(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (objects != null);

                if (!result)
                    error = "objects not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasOperators(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (operators != null);

                if (!result)
                    error = "operators not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasPackageIndexes(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (packageIndexes != null);

                if (!result)
                    error = "package indexes not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasPackages(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (packages != null);

                if (!result)
                    error = "packages not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasPlugins(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                return PrivateHasPlugins(ref error);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasPolicies(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (policies != null);

                if (!result)
                    error = "policies not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasProcedures(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (procedures != null);

                if (!result)
                    error = "procedures not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasScopes(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (scopes != null);

                if (!result)
                    error = "scopes not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasTraces(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (traces != null);

                if (!result)
                    error = "traces not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if DATA
        public bool HasDbConnections(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (connections != null);

                if (!result)
                    error = "database connections not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasDbTransactions(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (transactions != null);

                if (!result)
                    error = "database transactions not available";

                return result;
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if EMIT && NATIVE && LIBRARY
        public bool HasDelegates(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (delegates != null);

                if (!result)
                    error = "delegates not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasModules(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (modules != null);

                if (!result)
                    error = "modules not available";

                return result;
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private bool HasCommands()
        {
            Result error = null;

            return HasCommands(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the lock is already held.
        //
        internal bool InternalHasChannels()
        {
            Result error = null;

            return PrivateHasChannels(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the lock is already held.
        //
        private bool PrivateHasChannels(
            ref Result error
            )
        {
            bool result = (channels != null);

            if (!result)
                error = "channels not available";

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateHasPlugins(
            ref Result error
            )
        {
            bool result = (plugins != null);

            if (!result)
                error = "plugins not available";

            return result;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Entity Detection
        public ReturnCode DoesAliasExist(string name)
        {
            CheckDisposed();

            IAlias alias = null;
            Result error = null;

            return GetAlias(name, LookupFlags.Exists, ref alias, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesCallbackExist(string name)
        {
            CheckDisposed();

            ICallback callback = null;
            Result error = null;

            return GetCallback(name, LookupFlags.Exists, ref callback, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesChannelExist(string name)
        {
            CheckDisposed();

            Result error = null;
            IChannel channel = GetChannel(name, ref error);

            if (channel != null)
                return ReturnCode.Ok;
            else
                return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesCommandExist(string name)
        {
            CheckDisposed();

            ICommand command = null;
            Result error = null;

            return GetCommand(name, LookupFlags.Exists, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesFunctionExist(string name)
        {
            CheckDisposed();

            IFunction function = null;
            Result error = null;

            return GetFunction(name, LookupFlags.Exists, ref function, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesIExecuteExist(string name)
        {
            CheckDisposed();

            IExecute execute = null;
            Result error = null;

            return GetIExecute(name, LookupFlags.Exists, ref execute, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesObjectExist(string name)
        {
            CheckDisposed();

            IObject @object = null;
            Result error = null;

            return GetObject(name, LookupFlags.Exists, ref @object, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesOperatorExist(string name)
        {
            CheckDisposed();

            IOperator @operator = null;
            Result error = null;

            return GetOperator(name, LookupFlags.Exists, ref @operator, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesPackageExist(string name)
        {
            CheckDisposed();

            IPackage package = null;
            Result error = null;

            return GetPackage(name, LookupFlags.Exists, ref package, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesPluginExist(string name)
        {
            CheckDisposed();

            IPlugin plugin = null;
            Result error = null;

            return GetPlugin(name, LookupFlags.Exists, ref plugin, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesPolicyExist(string name)
        {
            CheckDisposed();

            IPolicy policy = null;
            Result error = null;

            return GetPolicy(name, LookupFlags.Exists, ref policy, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesProcedureExist(string name)
        {
            CheckDisposed();

            IProcedure procedure = null;
            Result error = null;

            return GetProcedure(name, LookupFlags.Exists, ref procedure, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesScopeExist(string name)
        {
            CheckDisposed();

            ICallFrame frame = null;
            Result error = null;

            return GetScope(name, LookupFlags.Exists, ref frame, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesTraceExist(string name)
        {
            CheckDisposed();

            ITrace trace = null;
            Result error = null;

            return GetTrace(name, LookupFlags.Exists, ref trace, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if EMIT && NATIVE && LIBRARY
        public ReturnCode DoesDelegateExist(string name)
        {
            CheckDisposed();

            IDelegate @delegate = null;
            Result error = null;

            return GetDelegate(name, LookupFlags.Exists, ref @delegate, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesModuleExist(string name)
        {
            CheckDisposed();

            IModule module = null;
            Result error = null;

            return GetModule(name, LookupFlags.Exists, ref module, ref error);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private ReturnCode DoesCommandExist(long token)
        {
            string name = null;
            ICommand command = null;
            Result error = null;

            return GetCommand(token, LookupFlags.Exists, ref name, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesFunctionExist(long token)
        {
            string name = null;
            IFunction function = null;
            Result error = null;

            return GetFunction(token, LookupFlags.Exists, ref name, ref function, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private ReturnCode DoesIExecuteExist(long token)
        {
            string name = null;
            IExecute execute = null;
            Result error = null;

            return GetIExecute(token, LookupFlags.Exists, ref name, ref execute, ref error);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DoesIExecuteExistViaResolvers(
            string name
            )
        {
            // CheckDisposed();

            Result error = null;

            return DoesIExecuteExistViaResolvers(name, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DoesIExecuteExistViaResolvers(
            string name,
            ref Result error
            )
        {
            // CheckDisposed();

            IdentifierKind kind = IdentifierKind.None;

            return DoesIExecuteExistViaResolvers(
                name, ref kind, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesIExecuteExistViaResolvers(
            string name,
            ref IdentifierKind kind
            )
        {
            // CheckDisposed();

            Result error = null;

            return DoesIExecuteExistViaResolvers(
                name, ref kind, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesIExecuteExistViaResolvers(
            string name,
            ref IdentifierKind kind,
            ref Result error
            )
        {
            // CheckDisposed();

            IExecute execute = null;

            if (GetIExecuteViaResolvers(
                    GetResolveEngineFlagsNoLock(true), name,
                    null, LookupFlags.Exists, ref execute,
                    ref error) != ReturnCode.Ok)
            {
                return ReturnCode.Error;
            }

            IIdentifierBase identifierBase = execute as IIdentifierBase;

            if (identifierBase != null)
                kind = identifierBase.Kind;

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DoesObjectExist(
            string name,
            bool addReference,
            bool removeReference,
            ref object value
            )
        {
            IObject @object = null;
            Result error = null;

            if (GetObject(
                    name, LookupFlags.Default, ref @object,
                    ref error) == ReturnCode.Ok)
            {
                //
                // BUGFIX: Do not adjust reference counts for locked objects.
                //
                if (!FlagOps.HasFlags(
                        @object.ObjectFlags, ObjectFlags.Locked, true))
                {
                    if (addReference)
                        @object.AddReference();

                    if (removeReference)
                        @object.RemoveReference();
                }

                value = @object.Value;
                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DoesObjectExist(
            string name,
            ref Result error
            )
        {
            IObject @object = null;

            return GetObject(name, LookupFlags.Exists, ref @object, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesAnyObjectExist(
            params string[] names
            )
        {
            if (names != null)
            {
                foreach (string name in names)
                {
                    IObject @object = null;
                    Result error = null;

                    if (GetObject(name,
                            LookupFlags.Exists, ref @object,
                            ref error) == ReturnCode.Ok)
                    {
                        return ReturnCode.Ok;
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesPolicyExist(long token)
        {
            string name = null;
            IPolicy policy = null;
            Result error = null;

            return GetPolicy(token, LookupFlags.Exists, ref name, ref policy, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private ReturnCode DoesProcedureExist(long token)
        {
            string name = null;
            IProcedure procedure = null;
            Result error = null;

            return GetProcedure(token, LookupFlags.Exists, ref name, ref procedure, ref error);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesTraceExist(long token)
        {
            string name = null;
            ITrace trace = null;
            Result error = null;

            return GetTrace(token, LookupFlags.Exists, ref name, ref trace, ref error);
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Entity Management
        #region Any IExecute
        private ReturnCode IsValidAnyIExecuteName(
            string newName,
            bool noNamespaces,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                IExecute execute = null;

                if (GetIExecute(
                        newName, LookupFlags.Exists, ref execute) == ReturnCode.Ok)
                {
                    error = String.Format(
                        "can't rename to {0}: execute already exists",
                        FormatOps.WrapOrNull(newName));

                    return ReturnCode.Error;
                }

                IProcedure procedure = null;

                if (GetProcedure(
                        newName, LookupFlags.Exists, ref procedure) == ReturnCode.Ok)
                {
                    error = String.Format(
                        "can't rename to {0}: procedure already exists",
                        FormatOps.WrapOrNull(newName));

                    return ReturnCode.Error;
                }

                ICommand command = null;

                if (GetCommand(
                        newName, LookupFlags.Exists, ref command) == ReturnCode.Ok)
                {
                    error = String.Format(
                        "can't rename to {0}: command already exists",
                        FormatOps.WrapOrNull(newName));

                    return ReturnCode.Error;
                }

                bool useNamespaces = !noNamespaces && AreNamespacesEnabled();
                Result localError = null;

                if (useNamespaces && (NamespaceOps.LookupParent(
                        this, newName, false, true, false, ref localError) == null))
                {
                    error = String.Format(
                        "can't rename to {0}: {1}",
                        FormatOps.WrapOrNull(newName),
                        localError);

                    return ReturnCode.Error;
                }

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode IsValidAnyHiddenIExecuteName(
            string newName,
            bool noNamespaces,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                IExecute execute = null;

                if (GetHiddenIExecute(
                        newName, LookupFlags.Exists, ref execute) == ReturnCode.Ok)
                {
                    error = String.Format(
                        "can't rename to {0}: hidden execute already exists",
                        FormatOps.WrapOrNull(newName));

                    return ReturnCode.Error;
                }

                IProcedure procedure = null;

                if (GetHiddenProcedure(
                        newName, LookupFlags.Exists, ref procedure) == ReturnCode.Ok)
                {
                    error = String.Format(
                        "can't rename to {0}: hidden procedure already exists",
                        FormatOps.WrapOrNull(newName));

                    return ReturnCode.Error;
                }

                ICommand command = null;

                if (GetHiddenCommand(
                        newName, LookupFlags.Exists, ref command) == ReturnCode.Ok)
                {
                    error = String.Format(
                        "can't rename to {0}: hidden command already exists",
                        FormatOps.WrapOrNull(newName));

                    return ReturnCode.Error;
                }

                bool useNamespaces = !noNamespaces && AreNamespacesEnabled();
                Result localError = null;

                if (useNamespaces && (NamespaceOps.LookupParent(
                        this, newName, false, true, false, ref localError) == null))
                {
                    error = String.Format(
                        "can't rename to {0}: {1}",
                        FormatOps.WrapOrNull(newName),
                        localError);

                    return ReturnCode.Error;
                }

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RenameAnyIExecute(
            string oldName,
            string newName,
            string varName,
            IdentifierKind kind,
            bool noNamespaces,
            bool delete,
            bool hidden,
            bool hiddenOnly,
            ref Result result
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool useNamespaces = !noNamespaces && AreNamespacesEnabled();

                ///////////////////////////////////////////////////////////////////////////////////////

                if (!useNamespaces || (NamespaceOps.GetIExecuteName(
                        this, hidden, hiddenOnly, ref oldName,
                        ref result) == ReturnCode.Ok))
                {
                    oldName = ScriptOps.MakeCommandName(oldName);
                }
                else
                {
                    return ReturnCode.Error;
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                if (!useNamespaces || (NamespaceOps.NormalizeName(
                        this, ref newName, ref result) == ReturnCode.Ok))
                {
                    newName = ScriptOps.MakeCommandName(newName);
                }
                else
                {
                    return ReturnCode.Error;
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                return PrivateRenameAnyIExecute(
                    oldName, newName, varName, kind, noNamespaces, delete,
                    hidden, hiddenOnly, ref result);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRenameAnyIExecute(
            string oldName,
            string newName,
            string varName,
            IdentifierKind kind,
            bool noNamespaces,
            bool delete,
            bool hidden,
            bool hiddenOnly,
            ref Result result
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                switch (kind)
                {
                    case IdentifierKind.None:
                        {
                            if (hidden)
                            {
                                if (DoesHiddenIExecuteExist(oldName) == ReturnCode.Ok)
                                {
                                    if (PrivateRenameHiddenIExecute(
                                            oldName, newName, noNamespaces,
                                            delete, ref result) == ReturnCode.Ok)
                                    {
                                        break;
                                    }
                                    else
                                    {
                                        return ReturnCode.Error;
                                    }
                                }

                                if (DoesHiddenProcedureExist(oldName) == ReturnCode.Ok)
                                {
                                    if (PrivateRenameHiddenProcedure(
                                            oldName, newName, noNamespaces,
                                            delete, ref result) == ReturnCode.Ok)
                                    {
                                        break;
                                    }
                                    else
                                    {
                                        return ReturnCode.Error;
                                    }
                                }

                                if (DoesHiddenCommandExist(oldName) == ReturnCode.Ok)
                                {
                                    if (PrivateRenameHiddenCommand(
                                            oldName, newName, noNamespaces,
                                            delete, ref result) == ReturnCode.Ok)
                                    {
                                        break;
                                    }
                                    else
                                    {
                                        return ReturnCode.Error;
                                    }
                                }

                                if (hiddenOnly)
                                {
                                    result = String.Format(
                                        "can't rename {0}: it is not hidden",
                                        FormatOps.WrapOrNull(oldName));

                                    return ReturnCode.Error;
                                }
                            }

                            if (DoesIExecuteExist(oldName) == ReturnCode.Ok)
                            {
                                if (PrivateRenameIExecute(
                                        oldName, newName, noNamespaces,
                                        delete, ref result) == ReturnCode.Ok)
                                {
                                    break;
                                }
                                else
                                {
                                    return ReturnCode.Error;
                                }
                            }

                            if (DoesProcedureExist(oldName) == ReturnCode.Ok)
                            {
                                if (PrivateRenameProcedure(
                                        oldName, newName, noNamespaces,
                                        delete, ref result) == ReturnCode.Ok)
                                {
                                    break;
                                }
                                else
                                {
                                    return ReturnCode.Error;
                                }
                            }

                            if (DoesCommandExist(oldName) == ReturnCode.Ok)
                            {
                                if (PrivateRenameCommand(
                                        oldName, newName, noNamespaces,
                                        delete, ref result) == ReturnCode.Ok)
                                {
                                    break;
                                }
                                else
                                {
                                    return ReturnCode.Error;
                                }
                            }

                            result = String.Format(
                                "can't rename {0}: unknown identifier kind",
                                FormatOps.WrapOrNull(oldName));

                            return ReturnCode.Error;
                        }
                    case IdentifierKind.Command:
                        {
                            if (PrivateRenameCommand(
                                    oldName, newName, noNamespaces,
                                    delete, ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }
                            break;
                        }
                    case IdentifierKind.HiddenCommand:
                        {
                            if (PrivateRenameHiddenCommand(
                                    oldName, newName, noNamespaces,
                                    delete, ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }
                            break;
                        }
                    case IdentifierKind.Procedure:
                        {
                            if (PrivateRenameProcedure(
                                    oldName, newName, noNamespaces,
                                    delete, ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }
                            break;
                        }
                    case IdentifierKind.HiddenProcedure:
                        {
                            if (PrivateRenameHiddenProcedure(
                                    oldName, newName, noNamespaces,
                                    delete, ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }
                            break;
                        }
                    case IdentifierKind.IExecute:
                        {
                            if (PrivateRenameIExecute(
                                    oldName, newName, noNamespaces,
                                    delete, ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }
                            break;
                        }
                    case IdentifierKind.HiddenIExecute:
                        {
                            if (PrivateRenameHiddenIExecute(
                                    oldName, newName, noNamespaces,
                                    delete, ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }
                            break;
                        }
                    default:
                        {
                            result = "identifier kind not supported";
                            return ReturnCode.Error;
                        }
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                if (varName != null)
                {
                    if (SetVariableValue(
                            VariableFlags.None, varName, newName,
                            ref result) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                return ReturnCode.Ok;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IIdentifier
        public ReturnCode GetIdentifier(
            IdentifierKind kind,
            string name,
            ArgumentList arguments,
            LookupFlags lookupFlags,
            ref IIdentifier identifier,
            ref Result error
            )
        {
            CheckDisposed();

            switch (kind)
            {
                case IdentifierKind.Interpreter:
                    {
                        Interpreter interpreter = null;

                        if (GetChildInterpreter(
                                name, lookupFlags, ref interpreter,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = interpreter;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.Policy:
                    {
                        IPolicy policy = null;

                        if (GetPolicy(
                                name, lookupFlags, ref policy,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = policy;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.Trace:
                    {
                        ITrace trace = null;

                        if (GetTrace(
                                name, lookupFlags, ref trace,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = trace;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.AnyIExecute: /* NOTE: IExecute may or may not derive from IIdentifier. */
                    {
                        IExecute execute = null;

                        if (GetIExecuteViaResolvers(
                                GetResolveEngineFlagsNoLock(true), name,
                                arguments, lookupFlags, ref execute,
                                ref error) == ReturnCode.Ok)
                        {
                            if (execute is IIdentifier)
                            {
                                identifier = (IIdentifier)execute;
                                return ReturnCode.Ok;
                            }
                            else
                            {
                                error = "invalid identifier";
                            }
                        }
                        break;
                    }
                case IdentifierKind.Command:
                    {
                        ICommand command = null;

                        if (GetCommand(
                                name, lookupFlags, ref command,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = command;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.HiddenCommand:
                    {
                        ICommand command = null;

                        if (GetHiddenCommand(
                                name, lookupFlags, ref command,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = command;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.Ensemble: /* NOTE: ICommand may or may not derive from _Commands.Ensemble. */
                    {
                        ICommand command = null;

                        if (GetEnsemble(
                                name, lookupFlags, ref command,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = command;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.Procedure:
                    {
                        IProcedure procedure = null;

                        if (GetProcedure(
                                name, lookupFlags, ref procedure,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = procedure;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.HiddenProcedure:
                    {
                        IProcedure procedure = null;

                        if (GetHiddenProcedure(
                                name, lookupFlags, ref procedure,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = procedure;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.IExecute: /* NOTE: IExecute may or may not derive from IIdentifier. */
                    {
                        IExecute execute = null;

                        if (GetIExecute(
                                name, lookupFlags, ref execute,
                                ref error) == ReturnCode.Ok)
                        {
                            if (execute is IIdentifier)
                            {
                                identifier = (IIdentifier)execute;
                                return ReturnCode.Ok;
                            }
                            else
                            {
                                error = "invalid identifier";
                            }
                        }
                        break;
                    }
                case IdentifierKind.HiddenIExecute:
                    {
                        IExecute execute = null;

                        if (GetHiddenIExecute(
                                name, lookupFlags, ref execute,
                                ref error) == ReturnCode.Ok)
                        {
                            if (execute is IIdentifier)
                            {
                                identifier = (IIdentifier)execute;
                                return ReturnCode.Ok;
                            }
                            else
                            {
                                error = "invalid identifier";
                            }
                        }
                        break;
                    }
                case IdentifierKind.Lambda:
                    {
                        #region Dead Code
#if DEAD_CODE
                        ILambda lambda = null;

                        if (GetLambda(
                                name, lookupFlags, ref lambda,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = lambda;
                            return ReturnCode.Ok;
                        }
#else
                        error = "not implemented";
#endif
                        #endregion
                        break;
                    }
                case IdentifierKind.Operator:
                    {
                        IOperator @operator = null;

                        if (GetOperator(
                                name, lookupFlags, ref @operator,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = @operator;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.Function:
                    {
                        IFunction function = null;

                        if (GetFunction(
                                name, lookupFlags, ref function,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = function;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.Variable:
                    {
                        VariableFlags flags = VariableFlags.NoElement;

                        if (FlagOps.HasFlags(
                                lookupFlags, LookupFlags.CreateMissing,
                                true))
                        {
                            flags |= VariableFlags.CreateMissing;
                        }

                        IVariable variable = null;

                        if (GetVariableViaResolversWithSplit(
                                name, ref flags, ref variable,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = variable;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.CallFrame:
                    {
                        FrameResult frameResult;
                        ICallFrame frame = null;

                        frameResult = GetCallFrame(
                            name, ref frame, ref error);

                        if (frameResult != FrameResult.Invalid)
                        {
                            identifier = frame;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.Package:
                    {
                        IPackage package = null;

                        if (GetPackage(
                                name, lookupFlags, ref package,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = package;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.Plugin:
                    {
                        IPlugin plugin = null;

                        if (GetPlugin(
                                name, lookupFlags, ref plugin,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = plugin;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.Object:
                    {
                        IObject @object = null;

                        if (GetObject(
                                name, lookupFlags, ref @object,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = @object;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.NativeModule:
                    {
#if EMIT && NATIVE && LIBRARY
                        IModule module = null;

                        if (GetModule(
                                name, lookupFlags, ref module,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = module;
                            return ReturnCode.Ok;
                        }
#else
                        error = "not implemented";
#endif
                        break;
                    }
                case IdentifierKind.NativeDelegate:
                    {
#if EMIT && NATIVE && LIBRARY
                        IDelegate @delegate = null;

                        if (GetDelegate(
                                name, lookupFlags, ref @delegate,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = @delegate;
                            return ReturnCode.Ok;
                        }
#else
                        error = "not implemented";
#endif
                        break;
                    }
                case IdentifierKind.Host:
                    {
                        if (String.IsNullOrEmpty(name))
                        {
                            identifier = this.InternalHost;
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            error = "unsupported host type";
                        }
                        break;
                    }
                case IdentifierKind.Alias:
                    {
                        IAlias alias = null;

                        if (GetAlias(
                                name, lookupFlags, ref alias,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = alias;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.Callback:
                    {
                        ICallback callback = null;

                        if (GetCallback(
                                name, lookupFlags, ref callback,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = callback;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.Resolve:
                    {
                        object enumValue = EnumOps.TryParse(
                            typeof(Priority), name, true, true,
                            ref error);

                        if (enumValue is Priority)
                        {
                            IResolve resolve = null;

                            if (GetResolver(
                                    (Priority)enumValue, ref resolve,
                                    ref error) == ReturnCode.Ok)
                            {
                                identifier = resolve;
                                return ReturnCode.Ok;
                            }
                        }
                        break;
                    }
                case IdentifierKind.Namespace:
                    {
                        INamespace @namespace = NamespaceOps.Lookup(
                            this, name, false, false, ref error);

                        if (@namespace != null)
                        {
                            identifier = @namespace;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.SubCommand:
                    {
                        StringList list = null;

                        if (ParserOps<string>.SplitList(
                                this, name, 0, Length.Invalid, true,
                                ref list, ref error) == ReturnCode.Ok)
                        {
                            if (list.Count >= 2)
                            {
                                string commandName = list[0];
                                ICommand command = null;

                                if (GetEnsemble(
                                        commandName, lookupFlags, ref command,
                                        ref error) == ReturnCode.Ok)
                                {
                                    string subCommandName = list[1];
                                    ISubCommand subCommand = null;

                                    if (ScriptOps.SubCommandFromEnsemble(this,
                                            command, null, null, true, false,
                                            ref subCommandName, ref subCommand,
                                            ref error) == ReturnCode.Ok)
                                    {
                                        identifier = subCommand;
                                        return ReturnCode.Ok;
                                    }
                                }
                            }
                            else
                            {
                                error = "need name of command and sub-command";
                            }
                        }
                        break;
                    }
                case IdentifierKind.InteractiveLoopData:
                    {
#if SHELL
                        if (String.IsNullOrEmpty(name))
                        {
                            identifier = this.InteractiveLoopData;
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            error = "unsupported interactive loop data type";
                        }
#else
                        error = "not implemented";
#endif
                        break;
                    }
                case IdentifierKind.ShellCallbackData:
                    {
#if SHELL
                        if (String.IsNullOrEmpty(name))
                        {
                            identifier = this.ShellCallbackData;
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            error = "unsupported shell callback data type";
                        }
#else
                        error = "not implemented";
#endif
                        break;
                    }
                case IdentifierKind.UpdateData:
                    {
#if SHELL
                        if (String.IsNullOrEmpty(name))
                        {
                            identifier = this.UpdateData;
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            error = "unsupported update data type";
                        }
#else
                        error = "not implemented";
#endif
                        break;
                    }
                case IdentifierKind.Certificate:
                    {
                        IPlugin plugin = null;

                        if (GetPlugin(
                                name, lookupFlags, ref plugin,
                                ref error) == ReturnCode.Ok)
                        {
                            if (plugin != null)
                            {
                                IIdentifier localIdentifier =
                                    plugin.GetCertificate(
                                        this, null, ref error);

                                if (localIdentifier != null)
                                {
                                    identifier = localIdentifier;
                                    return ReturnCode.Ok;
                                }
                            }
                            else
                            {
                                error = "invalid plugin";
                            }
                        }
                        break;
                    }
                case IdentifierKind.KeyPair:
                    {
                        IPlugin plugin = null;

                        if (GetPlugin(
                                name, lookupFlags, ref plugin,
                                ref error) == ReturnCode.Ok)
                        {
                            if (plugin != null)
                            {
                                IIdentifier localIdentifier =
                                    plugin.GetKeyPair(
                                        this, null, ref error);

                                if (localIdentifier != null)
                                {
                                    identifier = localIdentifier;
                                    return ReturnCode.Ok;
                                }
                            }
                            else
                            {
                                error = "invalid plugin";
                            }
                        }
                        break;
                    }
                case IdentifierKind.KeyRing:
                    {
                        IPlugin plugin = null;

                        if (GetPlugin(
                                name, lookupFlags, ref plugin,
                                ref error) == ReturnCode.Ok)
                        {
                            if (plugin != null)
                            {
                                IIdentifier localIdentifier =
                                    plugin.GetKeyRing(
                                        this, null, ref error);

                                if (localIdentifier != null)
                                {
                                    identifier = localIdentifier;
                                    return ReturnCode.Ok;
                                }
                            }
                            else
                            {
                                error = "invalid plugin";
                            }
                        }
                        break;
                    }
                case IdentifierKind.Channel:
                    {
                        IChannel channel = GetChannel(
                            name, ref error);

                        if (channel != null)
                        {
                            identifier = channel;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                case IdentifierKind.None:
                case IdentifierKind.PolicyData:
                case IdentifierKind.TraceData:
                case IdentifierKind.CommandData:
                case IdentifierKind.SubCommandData:
                case IdentifierKind.ProcedureData:
                case IdentifierKind.LambdaData:
                case IdentifierKind.OperatorData:
                case IdentifierKind.FunctionData:
                case IdentifierKind.EnsembleData:
                case IdentifierKind.PackageData:
                case IdentifierKind.PluginData:
                case IdentifierKind.ObjectData:
                case IdentifierKind.ObjectTypeData:
                case IdentifierKind.ObjectType:
                case IdentifierKind.Option:
                case IdentifierKind.HostData:
                case IdentifierKind.AliasData:
                case IdentifierKind.DelegateData:
                case IdentifierKind.Delegate:
                case IdentifierKind.SubDelegate:
                case IdentifierKind.ResolveData:
                case IdentifierKind.ClockData:
                case IdentifierKind.Script:
                case IdentifierKind.ScriptBuilder:
                case IdentifierKind.NamespaceData:
                    {
                        error = "identifier kind not supported";
                        break;
                    }
                case IdentifierKind.Path:
                    {
                        PathClientData path = null;

                        if (GetPath(
                                name, lookupFlags, ref path,
                                ref error) == ReturnCode.Ok)
                        {
                            identifier = path;
                            return ReturnCode.Ok;
                        }
                        break;
                    }
                default:
                    {
                        error = "unknown identifier kind";
                        break;
                    }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        //
        // NOTE: This method is designed to lookup and return a named
        //       ICommand that derives from the "_Commands.Ensemble"
        //       base class.  If the command does not exist -OR- does
        //       not derive from the appropriate base class, an error
        //       is returned instead.
        //
        private ReturnCode GetEnsemble(
            string name,
            LookupFlags lookupFlags,
            ref ICommand command,
            ref Result error
            )
        {
            ICommand localCommand = null;
            Result localError = null;

            if (GetCommand(
                    name, lookupFlags, ref localCommand,
                    ref localError) == ReturnCode.Ok)
            {
                if ((localCommand is _Commands.Ensemble) ||
                    (localCommand is _Commands.Stub))
                {
                    command = localCommand;
                    return ReturnCode.Ok;
                }

                error = "invalid ensemble";
            }
            else
            {
                ResultList errors = new ResultList();

                errors.Add(localError);

                localCommand = null;
                localError = null;

                if (GetHiddenCommand(
                        name, lookupFlags, ref localCommand,
                        ref localError) == ReturnCode.Ok)
                {
                    if ((localCommand is _Commands.Ensemble) ||
                        (localCommand is _Commands.Stub))
                    {
                        command = localCommand;
                        return ReturnCode.Ok;
                    }

                    errors.Add("invalid ensemble");
                }
                else
                {
                    errors.Add(localError);
                }

                error = errors;
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetPath(
            string name,
            LookupFlags lookupFlags,
            ref PathClientData path,
            ref Result error
            )
        {
            // CheckDisposed();

            if (PrivateGetPath(
                    name, lookupFlags, ref path,
                    ref error) != ReturnCode.Ok)
            {
                error = FlagOps.HasFlags(
                    lookupFlags, LookupFlags.Verbose, true) ?
                    String.Format(
                        "invalid path name {0}",
                        FormatOps.DisplayName(name)) :
                    "invalid path name";

                return ReturnCode.Error;
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetPath(
            string name,
            LookupFlags lookupFlags,
            ref PathClientData path,
            ref Result error
            )
        {
            int sequence = 0;
            PathClientDataDictionary paths = null;

            GlobalState.PopulatePaths(
                this, false, false, FlagOps.HasFlags(
                lookupFlags, LookupFlags.AllPaths, true),
                ref sequence, ref paths);

            if (paths == null)
            {
                error = "paths unavailable";
                return ReturnCode.Error;
            }

            if (name == null)
            {
                error = "invalid path name";
                return ReturnCode.Error;
            }

            //
            // NOTE: Search by the value of the path
            //       itself.
            //
            if (paths.TryGetValue(name, out path))
                goto found;

            IEnumerable<PathClientDataPair> pairs =
                paths.GetPairsInOrder(false);

            if (pairs == null)
            {
                error = "paths unavailable in order";
                return ReturnCode.Error;
            }

            foreach (PathClientDataPair pair in pairs)
            {
                PathClientData clientData = pair.Value;

                if (clientData == null)
                    continue;

                //
                // NOTE: Search by name.
                //
                if (SharedStringOps.SystemEquals(
                        clientData.Name, name))
                {
                    path = clientData;
                    goto found;
                }

                //
                // NOTE: Search by description.
                //
                if (SharedStringOps.SystemEquals(
                        clientData.Description, name))
                {
                    path = clientData;
                    goto found;
                }
            }

            error = "invalid path name";
            return ReturnCode.Error;

        found:

            if ((path == null) &&
                FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
            {
                error = "invalid path";
                return ReturnCode.Error;
            }
            else
            {
                return ReturnCode.Ok;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region INamespace
        public ReturnCode LookupNamespace(
            string name,
            bool absolute,
            ref INamespace @namespace,
            ref Result error
            )
        {
            CheckDisposed();

            if (!AreNamespacesEnabled())
            {
                error = "namespaces not available";
                return ReturnCode.Error;
            }

            INamespace localNamespace = NamespaceOps.Lookup(
                this, name, absolute, false, ref error);

            if (localNamespace == null)
                return ReturnCode.Error;

            @namespace = localNamespace;
            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode CreateNamespace(
            INamespaceData namespaceData,
            ArgumentList arguments,
            bool newFrame,
            ref INamespace @namespace,
            ref Result error
            )
        {
            CheckDisposed();

            if (!AreNamespacesEnabled())
            {
                error = "namespaces not available";
                return ReturnCode.Error;
            }

            bool success = false;
            INamespace childNamespace = null;

            try
            {
                childNamespace = NamespaceOps.Create(
                    namespaceData, arguments, newFrame, ref error);

                if (childNamespace != null)
                {
                    INamespace parentNamespace = childNamespace.Parent;

                    if (parentNamespace != null)
                    {
                        if (parentNamespace.AddChild(
                                childNamespace, ref error) == ReturnCode.Ok)
                        {
                            @namespace = childNamespace;
                            success = true;

                            return ReturnCode.Ok;
                        }
                    }
                    else
                    {
                        error = "invalid parent namespace";
                    }
                }
            }
            finally
            {
                if (!success && (childNamespace != null))
                    NamespaceOps.Dispose(this, ref childNamespace);
            }

            return ReturnCode.Error;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ICallback
        public ReturnCode GetCallback(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref ICallback callback,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetCallback(
                        name, lookupFlags, ref token, ref callback,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid callback name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid callback name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddCallback(
            ICallback callback,
            IClientData clientData,
            ref long token, /* IGNORED */
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (callback == null)
                {
                    result = "invalid callback";
                    return ReturnCode.Error;
                }

                string name = callback.Name;

                if (name == null)
                {
                    result = "invalid callback name";
                    return ReturnCode.Error;
                }

                if (!HasCallbacks(ref result))
                    return ReturnCode.Error;

                if (DoesCallbackExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: callback already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                callbacks.Add(name, callback);

#if NOTIFY
                /* IGNORED */
                CheckNotification(
                    NotifyType.Callback, NotifyFlags.Added,
                    callback, this,
                    clientData, null, null, ref result);
#endif
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveCallback(
            string name,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasCallbacks(ref result))
                {
                    long token = 0;
                    ICallback callback = null;

                    if (GetCallback(name, LookupFlags.Remove, ref token,
                            ref callback, ref result) == ReturnCode.Ok)
                    {
                        if (!EntityOps.IsReadOnly(callback))
                        {
                            callbacks.Remove(name);

#if NOTIFY
                            /* IGNORED */
                            CheckNotification(
                                NotifyType.Callback, NotifyFlags.Removed,
                                new ObjectPair(callback, token), this,
                                clientData, null, null, ref result);
#endif

                            return ReturnCode.Ok;
                        }
                        else
                        {
                            result = "callback is read-only";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal string CallbacksToString(
            string pattern,
            bool noCase
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (callbacks != null)
                    return callbacks.ToString(pattern, noCase);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetCallback(
            string name,
            LookupFlags lookupFlags,
            ref long token, /* IGNORED */
            ref ICallback callback,
            ref Result error
            )
        {
            if (!HasCallbacks(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid callback name";
                return ReturnCode.Error;
            }

            if (!callbacks.TryGetValue(name, out callback))
            {
                error = "callback not found";
                return ReturnCode.Error;
            }

            if ((callback == null) &&
                FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
            {
                error = "invalid callback";
                return ReturnCode.Error;
            }
            else
            {
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // TODO: Make sure this method needs to be public.
        //       This is marked as internal for now.
        //
        internal ReturnCode GetCallback(
            string name,
            LookupFlags lookupFlags,
            ref ICallback callback
            )
        {
            // CheckDisposed();

            Result error = null;

            return GetCallback(name, lookupFlags, ref callback, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetCallback(
            string name,
            LookupFlags lookupFlags,
            ref ICallback callback,
            ref Result error
            )
        {
            long token = 0;

            return GetCallback(name, lookupFlags, ref token, ref callback, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetCallback(
            Delegate @delegate,
            LookupFlags lookupFlags,
            ref ICallback callback
            )
        {
            string name = null;
            Result error = null;

            return GetCallback(
                @delegate, lookupFlags, CallbackFlags.None,
                CallbackFlags.None, false, false, ref name,
                ref callback, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetCallback(
            Delegate @delegate,
            LookupFlags lookupFlags,
            CallbackFlags hasFlags,
            CallbackFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            ref string name,
            ref ICallback callback,
            ref Result error
            )
        {
            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasCallbacks(ref error))
                {
                    if (callbacks.Count > 0)
                    {
                        foreach (KeyValuePair<string, ICallback> pair in callbacks)
                        {
                            ICallback wrapper = pair.Value;

                            if (wrapper == null)
                                continue;

                            if (Object.ReferenceEquals(wrapper.Delegate, @delegate))
                            {
                                if (((hasFlags == CallbackFlags.None) ||
                                        FlagOps.HasFlags(wrapper.CallbackFlags, hasFlags, hasAll)) &&
                                    ((notHasFlags == CallbackFlags.None) ||
                                        !FlagOps.HasFlags(wrapper.CallbackFlags, notHasFlags, notHasAll)))
                                {
                                    name = pair.Key;
                                    callback = wrapper;

                                    code = ReturnCode.Ok;
                                    break;
                                }
                            }
                        }
                    }

                    if (code != ReturnCode.Ok)
                    {
                        //
                        // HACK: Prevent ToString method from throwing any
                        //       exceptions here (e.g. proxy).
                        //
                        try
                        {
                            if (!AppDomainOps.IsTransparentProxy(@delegate))
                            {
                                error = FlagOps.HasFlags(
                                    lookupFlags, LookupFlags.Verbose, true) ?
                                    String.Format(
                                        "invalid callback delegate {0}",
                                        FormatOps.WrapOrNull(@delegate)) :
                                    "invalid callback delegate";
                            }
                            else
                            {
                                error = "invalid callback delegate";
                            }
                        }
                        catch (Exception e)
                        {
                            error = FlagOps.HasFlags(
                                lookupFlags, LookupFlags.Verbose, true) ?
                                String.Format(
                                    "invalid callback delegate: {0}",
                                    e) :
                                "invalid callback delegate";
                        }
                    }
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddCallback(
            ICallback callback,
            IClientData clientData,
            ref Result result
            )
        {
            long token = 0;

            return AddCallback(callback, clientData, ref token, ref result);
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IExecute
        public ReturnCode GetIExecute(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IExecute execute,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetIExecute(
                        token, lookupFlags, ref name, ref execute,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid execute token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid execute token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetIExecute(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IExecute execute,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetIExecute(
                        name, lookupFlags, ref token, ref execute,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid execute name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid execute name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ListIExecutes(
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                Result localError = null;

                if (HasIExecutes(ref localError))
                {
                    if (AreNamespacesEnabled())
                    {
                        INamespace currentNamespace = null;

                        code = GetCurrentNamespaceViaResolvers(
                            null, LookupFlags.Default, ref currentNamespace,
                            ref error);

                        if (code == ReturnCode.Ok)
                        {
                            StringList[] localLists = { null, null };

                            code = executes.ToList(
                                null, false, ref localLists[0], ref error);

                            if (code == ReturnCode.Ok)
                            {
                                code = MatchItems(
                                    currentNamespace, pattern, noCase,
                                    ref localLists, ref error);

                                if (list == null)
                                    list = localLists[1];
                                else
                                    list.AddRange(localLists[1]);
                            }
                        }
                    }
                    else
                    {
                        pattern = ScriptOps.MakeCommandName(pattern);

                        code = executes.ToList(
                            pattern, noCase, ref list, ref error);
                    }
                }
                else if (strict)
                {
                    error = localError;
                }
                else
                {
                    if (list == null)
                        list = new StringList();

                    code = ReturnCode.Ok;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddIExecute(
            string name,
            IExecute execute,
            IClientData clientData, /* NOT USED */
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (execute == null)
                {
                    result = "invalid execute";
                    return ReturnCode.Error;
                }

                if (name == null)
                {
                    result = "invalid execute name";
                    return ReturnCode.Error;
                }

                if (!HasIExecutes(ref result))
                    return ReturnCode.Error;

                //
                // WARNING: Currently, if somebody adds an IExecute that shadows a
                //          command or procedure (by name), it will take priority.
                //          This behavior could be prevented here by changing this
                //          check to be DoesAnyIExecuteExist instead of DoesIExecuteExist;
                //          however, I am not convinced that task should be the
                //          responsibility of this method (i.e. why should a method
                //          that deals with IExecute objects need to know about command
                //          or procedure objects?).  The spirit of this check is basically
                //          "can we physically add the object in question?".
                //
                /* EXEMPT */
                if (FlagOps.HasFlags(interpreterFlags,
                        InterpreterFlags.DoesAnythingExist, true))
                {
                    if (DoesIExecuteExistViaResolvers(name) == ReturnCode.Ok)
                    {
                        result = String.Format(
                            "can't add {0}: something already exists",
                            FormatOps.WrapOrNull(name));

                        return ReturnCode.Error;
                    }
                }
                else
                {
                    if (DoesIExecuteExist(name) == ReturnCode.Ok)
                    {
                        result = String.Format(
                            "can't add {0}: execute already exists",
                            FormatOps.WrapOrNull(name));

                        return ReturnCode.Error;
                    }
                }

                Result localError = null;

                if (AreNamespacesEnabled() && (NamespaceOps.LookupParent(
                        this, name, false, true, true, ref localError) == null))
                {
                    result = String.Format(
                        "can't add execute {0}: {1}",
                        FormatOps.WrapOrNull(name),
                        localError);

                    return ReturnCode.Error;
                }

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    bool success = false;
                    _Wrappers._Execute wrapper = null;

                    try
                    {
                        long id = EntityOps.NextTokenIdNoThrow(execute as IWrapperData);
                        wrapper = new _Wrappers._Execute(id, execute);

                        executes.Add(name, wrapper);
                        success = true;

                        long newToken = EntityOps.GetToken(wrapper);

#if EXECUTE_CACHE
                        AddOrUpdateIExecuteToCache(name, wrapper, false, false);
#endif

#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.IExecute, NotifyFlags.Added,
                            new ObjectPair(execute, newToken), this,
                            clientData, null, null, ref result);
#endif

                        token = newToken;
                    }
                    finally
                    {
                        if (!success && (wrapper != null))
                        {
                            wrapper.Dispose();
                            wrapper = null;
                        }
                    }
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RenameIExecute(
            string oldName,
            string newName,
            bool delete,
            ref Result result
            )
        {
            CheckDisposed();

            return PrivateRenameIExecute(oldName, newName, false, delete, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RenameHiddenIExecute(
            string oldName,
            string newName,
            bool delete,
            ref Result result
            )
        {
            CheckDisposed();

            return PrivateRenameHiddenIExecute(oldName, newName, false, delete, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveIExecute(
            long token,
            IClientData clientData, /* NOT USED */
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasIExecutes(ref result))
                {
                    string name = null;
                    IExecute execute = null;

                    if (GetIExecute(token, LookupFlags.Remove, ref name,
                            ref execute, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemoveIExecute(
                            name, token, execute, clientData, false,
                            ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveIExecute(
            string name,
            IClientData clientData /* NOT USED */,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasIExecutes(ref result))
                {
                    long token = 0;
                    IExecute execute = null;

                    if (GetIExecute(name, LookupFlags.Remove, ref token,
                            ref execute, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemoveIExecute(
                            name, token, execute, clientData, false,
                            ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode MatchIExecute(
            EngineFlags engineFlags,
            string name,
            LookupFlags lookupFlags,
            ref bool ambiguous,
            ref long token,
            ref IExecute execute,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool useHidden = EngineFlagOps.HasUseHidden(engineFlags);

                ExecuteWrapperDictionary localExecutes =
                    useHidden ? hiddenExecutes : executes;

                if (localExecutes != null)
                {
                    //
                    // NOTE: *WARNING* Empty command/procedure names are allowed,
                    //       please do not change this to "!String.IsNullOrEmpty".
                    //
                    if (name != null)
                    {
                        if (localExecutes.Count > 0)
                        {
                            _Wrappers._Execute localExecute;
                            string exactName = null;
                            StringList list = new StringList();

                            if (localExecutes.TryGetValue(name, out localExecute))
                            {
                                //
                                // NOTE: Exact execute match.
                                //
                                exactName = name;

                                //
                                // NOTE: Store the exact execute match in the result
                                //       list.
                                //
                                list.Add(name);
                            }
                            else
                            {
                                foreach (KeyValuePair<string, _Wrappers._Execute> pair in localExecutes)
                                {
                                    if (SharedStringOps.SystemEquals(pair.Key, 0, name, 0, name.Length))
                                    {
                                        //
                                        // NOTE: Was the key valid (this should always succeed).
                                        //
                                        if (pair.Key != null)
                                        {
                                            //
                                            // NOTE: It was a match; however, was it an exact match?
                                            //
                                            if (pair.Key.Length == name.Length)
                                                //
                                                // NOTE: Preserve match, it may differ in case.
                                                //
                                                exactName = pair.Key;

                                            //
                                            // NOTE: Was it an exact match or did we match at least one
                                            //       character in a partial match?
                                            //
                                            if ((pair.Key.Length == name.Length) || (name.Length > 0))
                                                //
                                                // NOTE: Store the exact or partial match in the results
                                                //       dictionary.
                                                //
                                                list.Add(pair.Key);
                                        }
                                    }
                                }
                            }

                            //
                            // NOTE: If there was an exact match, just use it.
                            //
                            if (exactName != null)
                            {
                                //
                                // NOTE: No need to change the caller's variable,
                                //       it already contains the correct value.
                                //
                                if (PrivateGetIExecute(
                                        exactName, lookupFlags, ref token,
                                        ref execute, ref error) == ReturnCode.Ok)
                                {
#if NOTIFY
                                    /* IGNORED */
                                    CheckNotification(
                                        useHidden ? NotifyType.HiddenIExecute : NotifyType.IExecute,
                                        NotifyFlags.Matched | (useHidden ? NotifyFlags.Hidden : NotifyFlags.None),
                                        new ObjectList(engineFlags, name, exactName, execute, token), this, null, null,
                                        null, ref error);
#endif

                                    return ReturnCode.Ok;
                                }
                            }
                            else if (list.Count == 1)
                            {
                                //
                                // NOTE: Normal case, exactly one command matched.
                                //
                                if (PrivateGetIExecute(
                                        list[0], lookupFlags, ref token,
                                        ref execute, ref error) == ReturnCode.Ok)
                                {
#if NOTIFY
                                    /* IGNORED */
                                    CheckNotification(
                                        useHidden ? NotifyType.HiddenIExecute : NotifyType.IExecute,
                                        NotifyFlags.Matched | (useHidden ? NotifyFlags.Hidden : NotifyFlags.None),
                                        new ObjectList(engineFlags, name, list[0], execute, token), this, null, null,
                                        null, ref error);
#endif

                                    return ReturnCode.Ok;
                                }
                            }
                            else if (list.Count > 1)
                            {
                                error = FlagOps.HasFlags(
                                    lookupFlags, LookupFlags.Verbose, true) ?
                                    ScriptOps.BadValue(
                                        "ambiguous", "execute", name, list,
                                        null, null) :
                                    (Result)"ambiguous execute";

                                ambiguous = true;
                            }
                            else
                            {
                                error = FlagOps.HasFlags(
                                    lookupFlags, LookupFlags.Verbose, true) ?
                                    ScriptOps.BadValue(
                                        null, "execute", name, localExecutes.Keys,
                                        null, null) :
                                    (Result)"bad execute";
                            }
                        }
                        else
                        {
                            error = "no executes defined";
                        }
                    }
                    else
                    {
                        error = "invalid execute name";
                    }
                }
                else
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "{0}executes not available",
                            useHidden ? "hidden " : String.Empty) :
                        "executes not available";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private ReturnCode PrivateGetIExecute(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IExecute execute,
            ref Result error
            )
        {
            if (!HasIExecutes(ref error))
                return ReturnCode.Error;

            _Wrappers._Execute wrapper;

            if (!executes.TryGetValue(token, out wrapper))
            {
                error = "execute not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                execute = wrapper;
                name = EntityOps.GetName(execute as IIdentifierName);

                if ((execute == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid execute";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid execute wrapper";
                    return ReturnCode.Error;
                }

                execute = wrapper.execute;
                name = EntityOps.GetName(execute as IIdentifierName);

                if ((execute == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid execute";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetIExecute(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IExecute execute,
            ref Result error
            )
        {
            if (!HasIExecutes(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid execute name";
                return ReturnCode.Error;
            }

            _Wrappers._Execute wrapper;

            if (!executes.TryGetValue(name, out wrapper))
            {
                error = "execute not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                execute = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((execute == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid execute";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid execute wrapper";
                    return ReturnCode.Error;
                }

                execute = wrapper.execute;

                //
                // WARNING: Cannot grab the token from the IExecute here
                //          because that interface does not inherit from
                //          IWrapperData.
                //
                token = EntityOps.GetToken(wrapper);

                if ((execute == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid execute";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetIExecute(
            string name,
            LookupFlags lookupFlags,
            ref IExecute execute
            )
        {
            Result error = null;

            return GetIExecute(name, lookupFlags, ref execute, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetIExecute(
            string name,
            LookupFlags lookupFlags,
            ref IExecute execute,
            ref Result error
            )
        {
            long token = 0;

            return GetIExecute(name, lookupFlags, ref token, ref execute, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ListIExecutes(
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list
            )
        {
            Result error = null;

            return ListIExecutes(
                pattern, noCase, strict, ref list, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ListHiddenIExecutes(
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list
            )
        {
            Result error = null;

            return ListHiddenIExecutes(
                pattern, noCase, strict, ref list, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ListHiddenIExecutes(
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list,
            ref Result error
            )
        {
            // CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                Result localError = null;

                if (HasHiddenIExecutes(ref localError))
                {
                    if (AreNamespacesEnabled())
                    {
                        INamespace currentNamespace = null;

                        code = GetCurrentNamespaceViaResolvers(
                            null, LookupFlags.Default, ref currentNamespace,
                            ref error);

                        if (code == ReturnCode.Ok)
                        {
                            StringList[] localLists = { null, null };

                            code = hiddenExecutes.ToList(
                                null, false, ref localLists[0], ref error);

                            if (code == ReturnCode.Ok)
                            {
                                code = MatchItems(
                                    currentNamespace, pattern, noCase,
                                    ref localLists, ref error);

                                if (code == ReturnCode.Ok)
                                    list = localLists[1];
                            }
                        }
                    }
                    else
                    {
                        pattern = ScriptOps.MakeCommandName(pattern);

                        code = hiddenExecutes.ToList(
                            pattern, noCase, ref list, ref error);
                    }
                }
                else if (strict)
                {
                    error = localError;
                }
                else
                {
                    if (list == null)
                        list = new StringList();

                    code = ReturnCode.Ok;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRenameIExecute(
            string oldName,
            string newName,
            bool noNamespaces,
            bool delete,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasIExecutes(ref result))
                {
                    if (!delete || !String.IsNullOrEmpty(newName))
                    {
                        IExecute oldExecute = null;

                        if (GetIExecute(oldName, LookupFlags.Default, ref oldExecute, ref result) == ReturnCode.Ok)
                        {
                            _Wrappers._Execute oldWrapper = oldExecute as _Wrappers._Execute;

                            if (oldWrapper != null)
                            {
                                IAlias oldAlias = oldWrapper.execute as IAlias;

                                if (PreventAliasLoop(oldAlias, newName, ref result) == ReturnCode.Ok)
                                {
                                    if (IsValidAnyIExecuteName(newName, noNamespaces, ref result) == ReturnCode.Ok)
                                    {
                                        bool useNamespaces = !noNamespaces && AreNamespacesEnabled();

                                        if (!useNamespaces ||
                                            RenameImportInNamespaces(oldName, newName, ref result) == ReturnCode.Ok)
                                        {
                                            /* IGNORED */
                                            executes.Rename(oldName, newName);

#if EXECUTE_CACHE
                                            RenameIExecuteInCache(oldName, newName, oldWrapper, false, false);
#endif

#if NOTIFY
                                            /* IGNORED */
                                            CheckNotification(
                                                NotifyType.IExecute, NotifyFlags.Renamed,
                                                new ObjectTriplet(oldExecute, oldName, newName), this,
                                                null, null, null, ref result);
#endif

                                            result = String.Empty;
                                            return ReturnCode.Ok;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                result = String.Format(
                                    "can't rename {0}: invalid execute wrapper",
                                    FormatOps.WrapOrNull(oldName));
                            }
                        }
                        else
                        {
                            result = String.Format(
                                "can't rename {0}: execute doesn't exist",
                                FormatOps.WrapOrNull(oldName));
                        }
                    }
                    else
                    {
                        return RemoveIExecute(oldName, null, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRemoveIExecute(
            string name,
            long token,
            IExecute execute,
            IClientData clientData,
            bool hidden,
            ref Result result
            )
        {
            if (name == null)
            {
                result = "invalid execute name";
                return ReturnCode.Error;
            }

            GlobalState.PushActiveInterpreter(this);

            try
            {
                if (AreNamespacesEnabled() &&
                    RemoveImportFromNamespaces(name, ref result) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }

#if NATIVE && TCL
                if ((execute == null) ||
                    (DisposeTclBridges(IntPtr.Zero, execute, null, false, ref result) == ReturnCode.Ok))
#endif
                {
                    if (hidden)
                        /* IGNORED */
                        hiddenExecutes.Remove(name, token);
                    else
                        /* IGNORED */
                        executes.Remove(name, token);

#if EXECUTE_CACHE
                    RemoveIExecuteFromCache(name, hidden, false);
#endif

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(hidden ?
                        NotifyType.HiddenIExecute : NotifyType.IExecute,
                        NotifyFlags.Removed, new ObjectTriplet(execute,
                            name, token), this, clientData, null, null,
                        ref result);
#endif

                    return ReturnCode.Ok;
                }

#if NATIVE && TCL
                return ReturnCode.Error;
#endif
            }
            catch (Exception e)
            {
                result = String.Format(
                    "caught exception while removing {0}execute: {1}",
                    hidden ? "hidden " : String.Empty, e);

                return ReturnCode.Error;
            }
            finally
            {
                /* IGNORED */
                GlobalState.PopActiveInterpreter();
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IObject
        public ReturnCode GetObject(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IObject @object,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetObject(
                        token, lookupFlags, ref name, ref @object,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid object token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid object token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetObject(
            string name,
            LookupFlags lookupFlags,
            ref IObject @object
            )
        {
            CheckDisposed();

            Result error = null;

            return GetObject(name, lookupFlags, ref @object, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetObject(
            string name,
            LookupFlags lookupFlags,
            ref IObject @object,
            ref Result error
            )
        {
            CheckDisposed();

            long token = 0;

            return GetObject(name, lookupFlags, ref token, ref @object, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetObject(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IObject @object,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetObject(
                        name, lookupFlags, ref token, ref @object,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid object name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid object name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetObject(
            object value,
            LookupFlags lookupFlags,
            ref string name,
            ref long token,
            ref IObject @object,
            ref Result error
            )
        {
            CheckDisposed();

            return GetObject(
                value, lookupFlags, ObjectFlags.None, ObjectFlags.None,
                false, false, ref name, ref token, ref @object, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddObject(
            string name,
            Type type,
            ObjectFlags objectFlags,
            IClientData clientData,
            int referenceCount,
#if NATIVE && TCL
            string interpName,
#endif
#if DEBUGGER && DEBUGGER_ARGUMENTS
            ArgumentList executeArguments,
#endif
            object value,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            return AddObject(new _Objects.Default(new ObjectData(
                name, null, null, clientData, type, null, objectFlags,
                referenceCount, 0,
#if NATIVE && TCL
                interpName,
#endif
#if DEBUGGER && DEBUGGER_ARGUMENTS
                executeArguments,
#endif
                0), value, null), null, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddObject(
            IObject @object,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (@object == null)
                {
                    result = "invalid object";
                    return ReturnCode.Error;
                }

                string name = @object.Name;

                if (name == null)
                {
                    result = "invalid object name";
                    return ReturnCode.Error;
                }

                if (!HasObjects(ref result))
                    return ReturnCode.Error;

                if (DoesObjectExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: object already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    bool success = false;
                    _Wrappers._Object wrapper = null;

                    try
                    {
                        long id = EntityOps.NextTokenIdNoThrow(@object);
                        wrapper = new _Wrappers._Object(id, @object);

                        objects.Add(name, wrapper);
                        success = true;

                        long newToken = EntityOps.GetToken(wrapper);
                        EntityOps.SetToken(@object, newToken);

#if DEBUG && VERBOSE
                        TraceOps.DebugTrace(String.Format(
                            "AddObject: token = {0}, name = {1}, hashCode = {2}",
                            newToken, FormatOps.WrapOrNull(name),
                            FormatOps.WrapHashCode(@object)),
                            typeof(Interpreter).Name, TracePriority.AddDebug);
#endif

#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Object, NotifyFlags.Added,
                            new ObjectPair(@object, newToken), this,
                            clientData, null, null, ref result);
#endif

                        token = newToken;
                    }
                    finally
                    {
                        if (!success && (wrapper != null))
                        {
                            wrapper.Dispose();
                            wrapper = null;
                        }
                    }
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Object Renaming Support (WARNING: EXPERIMENTAL)
        public ReturnCode RenameObject(
            string oldName,
            string newName,
            bool ignoreAlias,
            bool noNamespaces,
            bool strict,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (oldName == null)
                {
                    result = "invalid old object name";
                    return ReturnCode.Error;
                }

                if (newName == null)
                {
                    result = "invalid new object name";
                    return ReturnCode.Error;
                }

                if (!HasObjects(ref result))
                    return ReturnCode.Error;

                if (DoesObjectExist(newName) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't rename {0}: object already exists",
                        FormatOps.WrapOrNull(newName));

                    return ReturnCode.Error;
                }

                _Wrappers._Object @object;

                if (!objects.TryGetValue(oldName, out @object))
                {
                    result = String.Format(
                        "can't rename {0}: object does not exist",
                        FormatOps.WrapOrNull(oldName));

                    return ReturnCode.Error;
                }

                IAlias alias = null;

                if (@object != null)
                {
                    if (FlagOps.HasFlags(
                            @object.ObjectFlags, ObjectFlags.Locked, true))
                    {
                        result = String.Format(
                            "can't rename {0}: object is locked",
                            FormatOps.WrapOrNull(oldName));

                        return ReturnCode.Error;
                    }

                    if (!ignoreAlias && FlagOps.HasFlags(
                            @object.ObjectFlags, ObjectFlags.Alias, true))
                    {
                        alias = @object.Alias;

                        string oldCommandName = oldName;
                        string newCommandName = newName;

                        GetCommandNamesForRename(alias,
                            noNamespaces, ref oldCommandName, ref newCommandName);

                        Result localResult = null; /* REUSED */

                        if ((alias != null) && RenameAlias(
                                alias, newName, ref localResult) != ReturnCode.Ok)
                        {
                            if (strict)
                            {
                                result = localResult;
                                return ReturnCode.Error;
                            }
                        }

                        localResult = null;

                        if (PrivateRenameAnyIExecute(
                                oldCommandName, newCommandName,
                                null, IdentifierKind.None,
                                noNamespaces, false, false, false,
                                ref localResult) != ReturnCode.Ok)
                        {
                            if (strict)
                            {
                                result = localResult;
                                return ReturnCode.Error;
                            }
                        }
                    }

                    //
                    // NOTE: New name, same token.
                    //
                    @object.Name = newName;
                }

                /* IGNORED */
                objects.Rename(oldName, newName);

                //
                // NOTE: At this point, make sure the alias arguments, if any,
                //       are updated to reflect the new object name.  This is
                //       only applicable if the associated compile-time option
                //       is enabled.
                //
#if CACHE_ARGUMENTLIST_TOSTRING
                if (alias != null)
                {
                    ArgumentList arguments = alias.Arguments;

                    if (arguments != null)
                        arguments.InvalidateCachedString(true);
                }
#endif

#if NOTIFY
                /* IGNORED */
                CheckNotification(
                    NotifyType.Object, NotifyFlags.Renamed,
                    new ObjectTriplet(@object, oldName, newName),
                    this, null, null, null, ref result);
#endif
            }

            return ReturnCode.Ok;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveObject(
            long token,
            IClientData clientData,
            ref bool dispose,
            ref Result result
            )
        {
            CheckDisposed();

            return RemoveObject(
                token, clientData, ObjectOps.GetDefaultSynchronous(), true,
                ref dispose, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveObject(
            long token,
            IClientData clientData,
            bool synchronous,
            ref bool dispose,
            ref Result result
            )
        {
            CheckDisposed();

            return RemoveObject(
                token, clientData, synchronous, true, ref dispose, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveObject(
            string name,
            IClientData clientData,
            ref bool dispose,
            ref Result result
            )
        {
            CheckDisposed();

            return RemoveObject(
                name, clientData, ObjectOps.GetDefaultSynchronous(), true,
                ref dispose, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveObject(
            string name,
            IClientData clientData,
            bool synchronous,
            ref bool dispose,
            ref Result result
            )
        {
            CheckDisposed();

            return RemoveObject(
                name, clientData, synchronous, true, ref dispose, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal string ObjectsToString(
            string pattern,
            bool noCase
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (objects != null)
                    return objects.ToString(pattern, noCase);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TEST
        internal void InitializeObjects()
        {
            if (objects != null) return;
            objects = new ObjectWrapperDictionary();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void SaveObjects(
            ref ObjectWrapperDictionary savedObjects
            )
        {
            savedObjects = objects;
            objects = null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void RestoreObjects(
            ref ObjectWrapperDictionary savedObjects
            )
        {
            objects = savedObjects;
            savedObjects = null;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetObject(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IObject @object,
            ref Result error
            )
        {
            if (!HasObjects(ref error))
                return ReturnCode.Error;

            _Wrappers._Object wrapper;

            if (!objects.TryGetValue(token, out wrapper))
            {
                error = "object not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                @object = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((@object == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid object";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid object wrapper";
                    return ReturnCode.Error;
                }

                @object = wrapper.@object;
                name = EntityOps.GetName(@object);

                if ((@object == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid object";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetObject(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IObject @object,
            ref Result error
            )
        {
            if (!HasObjects(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid object name";
                return ReturnCode.Error;
            }

            _Wrappers._Object wrapper;

            if (!objects.TryGetValue(name, out wrapper))
            {
                error = "object not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                @object = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((@object == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid object";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid object wrapper";
                    return ReturnCode.Error;
                }

                @object = wrapper.@object;
                token = EntityOps.GetToken(@object);

                if ((@object == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid object";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetObjectAsBytes(
            Encoding encoding,
            string name,
            LookupFlags lookupFlags,
            ref byte[] bytes,
            ref Result error
            )
        {
            IObject @object = null;

            if (GetObject(
                    name, lookupFlags, ref @object,
                    ref error) != ReturnCode.Ok)
            {
                return ReturnCode.Error;
            }

            object value = @object.Value;

            if (value is string)
            {
                if (StringOps.GetBytes(
                        encoding, (string)value, EncodingType.Binary,
                        true, ref bytes, ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }
            }
            else if (value is char)
            {
                bytes = new byte[] {
                    ConversionOps.ToLowByte((char)value),
                    ConversionOps.ToHighByte((char)value)
                };
            }
            else if (value is byte[])
            {
                bytes = (byte[])value;
            }
            else if (value is ByteList)
            {
                bytes = ArrayOps.GetArray<byte>(
                    (ByteList)value, true);
            }
            else
            {
                error = "unsupported object value for bytes";
                return ReturnCode.Error;
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AppendObjectAsVirtualOutput(
            string name,
            LookupFlags lookupFlags,
            IChannel channel,
            ref Result error
            )
        {
            if (channel == null)
            {
                error = "invalid channel";
                return ReturnCode.Error;
            }

            IObject @object = null;

            if (GetObject(
                    name, lookupFlags, ref @object,
                    ref error) != ReturnCode.Ok)
            {
                return ReturnCode.Error;
            }

            object value = @object.Value;

            if (value is string)
            {
                channel.AppendVirtualOutput((string)value);
            }
            else if (value is char)
            {
                channel.AppendVirtualOutput((char)value);
            }
            else if (value is byte[])
            {
                channel.AppendVirtualOutput((byte[])value);
            }
            else if (value is ByteList)
            {
                channel.AppendVirtualOutput(
                    ArrayOps.GetArray<byte>((ByteList)value, true));
            }
            else
            {
                error = "unsupported object value for bytes";
                return ReturnCode.Error;
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetObject(
            object value,
            LookupFlags lookupFlags,
            ObjectFlags hasFlags,
            ObjectFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            ref string name
            )
        {
            IObject @object = null;

            return GetObject(
                value, lookupFlags, hasFlags, notHasFlags, hasAll,
                notHasAll, ref name, ref @object);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetObject(
            object value,
            LookupFlags lookupFlags,
            ObjectFlags hasFlags,
            ObjectFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            ref string name,
            ref IObject @object
            )
        {
            Result error = null;

            return GetObject(
                value, lookupFlags, hasFlags, notHasFlags, hasAll,
                notHasAll, ref name, ref @object, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetObject(
            object value,
            LookupFlags lookupFlags,
            ObjectFlags hasFlags,
            ObjectFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            ref string name,
            ref IObject @object,
            ref Result error
            )
        {
            long token = 0;

            return GetObject(
                value, lookupFlags, hasFlags, notHasFlags, hasAll, notHasAll,
                ref name, ref token, ref @object, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetObject( /* FOR USE BY [sql] ONLY */
            object value,
            LookupFlags lookupFlags
            )
        {
            string name = null;

            return GetObject(value, lookupFlags, ref name);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetObject( /* FOR USE BY HandleOps.Wrap ONLY */
            object value,
            LookupFlags lookupFlags,
            ref string name
            )
        {
            long token = 0;
            IObject @object = null;
            Result error = null;

            return GetObject(
                value, lookupFlags, ObjectFlags.None, ObjectFlags.None,
                false, false, ref name, ref token, ref @object, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetObject(
            object value,
            LookupFlags lookupFlags,
            ObjectFlags hasFlags,
            ObjectFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            ref string name,
            ref long token,
            ref IObject @object,
            ref Result error
            )
        {
            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasObjects(ref error))
                {
                    if (objects.Count > 0)
                    {
                        foreach (KeyValuePair<string, _Wrappers._Object> pair in objects)
                        {
                            _Wrappers._Object wrapper = pair.Value;

                            if (wrapper == null)
                                continue;

                            if (Object.ReferenceEquals(wrapper.Value, value))
                            {
                                if (((hasFlags == ObjectFlags.None) ||
                                        FlagOps.HasFlags(wrapper.ObjectFlags, hasFlags, hasAll)) &&
                                    ((notHasFlags == ObjectFlags.None) ||
                                        !FlagOps.HasFlags(wrapper.ObjectFlags, notHasFlags, notHasAll)))
                                {
                                    name = pair.Key;

                                    if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
                                        @object = wrapper;
                                    else
                                        @object = wrapper.@object;

                                    token = EntityOps.GetToken(wrapper);

                                    if ((@object != null) ||
                                        !FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                                    {
                                        code = ReturnCode.Ok;
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    if (code != ReturnCode.Ok)
                    {
                        //
                        // HACK: Prevent ToString method from throwing any
                        //       exceptions here (e.g. proxy).
                        //
                        try
                        {
                            if (!AppDomainOps.IsTransparentProxy(value))
                            {
                                error = FlagOps.HasFlags(
                                    lookupFlags, LookupFlags.Verbose, true) ?
                                    String.Format(
                                        "invalid object value {0}",
                                        FormatOps.WrapOrNull(value)) :
                                    "invalid object value";
                            }
                            else
                            {
                                error = "invalid object value";
                            }
                        }
                        catch (Exception e)
                        {
                            error = FlagOps.HasFlags(
                                lookupFlags, LookupFlags.Verbose, true) ?
                                String.Format(
                                    "invalid object value: {0}",
                                    e) :
                                "invalid object value";
                        }
                    }
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by the ObjectTraceCallback method only.
        //
        private void GetObjectsForTrace(
            StringList names,                    /* in */
            ref IList<_Wrappers._Object> objects /* in, out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (names == null)
                    return;

                ObjectWrapperDictionary localObjects = this.objects;

                if ((localObjects == null) || (localObjects.Count == 0))
                    return;

                foreach (string name in names)
                {
                    if (name == null)
                        continue;

                    _Wrappers._Object wrapper;

                    if (localObjects.TryGetValue(name, out wrapper))
                    {
                        if (objects == null)
                            objects = new List<_Wrappers._Object>(names.Count);

                        objects.Add(wrapper); /* throw */
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddNullObject(
            ref Result error
            )
        {
            Result result = null;

            if (AddObject(
                    Vars.Core.Null, null,
                    ObjectFlags.ForNullObject,
                    _ClientData.Empty, 0,
#if NATIVE && TCL
                    null,
#endif
#if DEBUGGER && DEBUGGER_ARGUMENTS
                    null,
#endif
                    null, ref result) != ReturnCode.Ok)
            {
                error = result;
                return ReturnCode.Error;
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddSharedObject(
            IObjectData objectData,
            IClientData clientData,
            IClientData valueData,
            object value,
            ref long token,
            ref Result result
            )
        {
            // CheckDisposed();

            return AddObject(new _Objects.Default(
                objectData, value, valueData), clientData, ref token,
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddObject(
            string name,
            Type type,
            ObjectFlags objectFlags,
            IClientData clientData,
            int referenceCount,
#if NATIVE && TCL
            string interpName,
#endif
#if DEBUGGER && DEBUGGER_ARGUMENTS
            ArgumentList executeArguments,
#endif
            object value,
            ref Result result
            )
        {
            long token = 0;

            return AddObject(
                name, type, objectFlags,
                clientData, referenceCount,
#if NATIVE && TCL
                interpName,
#endif
#if DEBUGGER && DEBUGGER_ARGUMENTS
                executeArguments,
#endif
                value, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode MaybeRemoveObject(
            string name,
            IClientData clientData,
            bool synchronous,
            bool alias,
            ref bool dispose,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasObjects(ref result))
                {
                    long token = 0;
                    IObject @object = null;

                    if (GetObject(name, LookupFlags.Remove, ref token,
                            ref @object, ref result) == ReturnCode.Ok)
                    {
                        if ((@object == null) || !FlagOps.HasFlags(
                                @object.ObjectFlags, ObjectFlags.Locked,
                                true))
                        {
                            return PrivateRemoveObject(
                                name, token, @object, clientData,
                                synchronous, alias, ref dispose,
                                ref result);
                        }
                        else
                        {
                            result = "cannot dispose or remove a locked object";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode MaybeRemoveObject(
            long token,
            IClientData clientData,
            bool synchronous,
            bool alias,
            ref Result result
            )
        {
            bool dispose = ObjectOps.GetDefaultDispose();

            return MaybeRemoveObject(
                token, clientData, synchronous, alias,
                ref dispose, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode MaybeRemoveObject(
            long token,
            IClientData clientData,
            bool synchronous,
            bool alias,
            ref bool dispose,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasObjects(ref result))
                {
                    string name = null;
                    IObject @object = null;

                    if (GetObject(token, LookupFlags.Remove, ref name,
                            ref @object, ref result) == ReturnCode.Ok)
                    {
                        if ((@object == null) || !FlagOps.HasFlags(
                                @object.ObjectFlags, ObjectFlags.Locked,
                                true))
                        {
                            return PrivateRemoveObject(
                                name, token, @object, clientData,
                                synchronous, alias, ref dispose,
                                ref result);
                        }
                        else
                        {
                            result = "cannot dispose or remove a locked object";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRemoveObject(
            string name,
            long token,
            IObject @object,
            IClientData clientData,
            bool synchronous,
            bool alias,
            ref bool dispose,
            ref Result result
            )
        {
            if (name == null)
            {
                result = "invalid object name";
                return ReturnCode.Error;
            }

            //
            // HACK: Calculate the runtime hash code for this object
            //       now, before it is possibly disposed.
            //
            string hashCode = FormatOps.WrapHashCode(@object);

            //
            // HACK: The alias name must be figured out before the
            //       object is disposed (if applicable).
            //
            string aliasName = GetObjectAliasName(@object, name);

            if (dispose)
            {
                if (@object != null)
                {
#if NATIVE && TCL
                    //
                    // NOTE: Remove the Tcl command for this object, if it exists.
                    //
                    string objectName = @object.Name;

                    string bridgeName = FormatOps.TclBridgeName(
                        @object.InterpName, objectName);

                    if ((DoesTclBridgeExist(bridgeName) != ReturnCode.Ok) ||
                        (RemoveTclBridge(@object.InterpName, objectName,
                                null, ref result) == ReturnCode.Ok))
#endif
                    {
                        object objectValue = @object.Value;

                        if (objectValue != null)
                        {
                            ObjectFlags objectFlags = @object.ObjectFlags;

                            if (!Object.ReferenceEquals(objectValue, this) &&
                                !IsParentOrChildInterpreter(objectValue) &&
                                !FlagOps.HasFlags(objectFlags, ObjectFlags.NoDispose, true))
                            {
                                GlobalState.PushActiveInterpreter(this);

                                try
                                {
                                    object savedObjectValue = objectValue;

                                    if (ObjectOps.TryDispose<object>(ref objectValue,
                                            ref dispose, ref result) == ReturnCode.Ok)
                                    {
#if NOTIFY
                                        /* IGNORED */
                                        CheckNotification(
                                            NotifyType.Object, NotifyFlags.Disposed,
                                            new ObjectTriplet(savedObjectValue, name, token),
                                            this, clientData, null, null, ref result);
#endif

                                        @object.Value = null;
                                        @object = null;

                                        if (synchronous)
                                            ObjectOps.CollectGarbage(); /* throw */
                                    }
                                    else
                                    {
                                        return ReturnCode.Error;
                                    }
                                }
                                catch (Exception e)
                                {
                                    result = String.Format(
                                        "caught exception while disposing object: {0}",
                                        e);

                                    return ReturnCode.Error;
                                }
                                finally
                                {
                                    /* IGNORED */
                                    GlobalState.PopActiveInterpreter();
                                }
                            }
                            else
                            {
                                //
                                // NOTE: We did not dispose the object because
                                //       it was prohibited.
                                //
                                dispose = false;
                            }
                        }
                        else
                        {
                            //
                            // NOTE: We did not dispose the object because
                            //       it was invalid.
                            //
                            dispose = false;
                        }
                    }
#if NATIVE && TCL
                    else
                    {
                        //
                        // NOTE: Failed to remove the Tcl bridge.
                        //
                        return ReturnCode.Error;
                    }
#endif
                }
                else
                {
                    //
                    // NOTE: We did not dispose the object because the wrapper
                    //       was invalid.
                    //
                    dispose = false;
                }
            }

            //
            // NOTE: Remove the command alias for this object, if it exists.
            //       We cannot use the token here because it is the object
            //       token, not the command (alias) token.
            //
            if (alias && (DoesAliasExist(aliasName) == ReturnCode.Ok) &&
                (RemoveAliasAndCommand(aliasName, clientData, false, ref result) != ReturnCode.Ok))
            {
                return ReturnCode.Error;
            }

            objects.Remove(name, token);

#if DEBUG && VERBOSE
            TraceOps.DebugTrace(String.Format(
                "RemoveObject: token = {0}, name = {1}, hashCode = {2}",
                token, FormatOps.WrapOrNull(name), hashCode),
                typeof(Interpreter).Name, TracePriority.RemoveDebug);
#endif

#if NOTIFY
            /* IGNORED */
            CheckNotification(
                NotifyType.Object, NotifyFlags.Removed,
                new ObjectTriplet(@object, name, token), this,
                clientData, null, null, ref result);
#endif

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveObject(
            long token,
            IClientData clientData,
            bool synchronous,
            ref Result result
            )
        {
            bool dispose = ObjectOps.GetDefaultDispose();

            return RemoveObject(token, clientData, synchronous, ref dispose, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RemoveObject(
            long token,
            IClientData clientData,
            bool synchronous,
            bool alias,
            ref Result result
            )
        {
            bool dispose = ObjectOps.GetDefaultDispose();

            return RemoveObject(token, clientData, synchronous, alias, ref dispose, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RemoveObject(
            long token,
            IClientData clientData,
            bool synchronous,
            bool alias,
            ref bool dispose,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasObjects(ref result))
                {
                    string name = null;
                    IObject @object = null;

                    if (GetObject(token, LookupFlags.Remove, ref name,
                            ref @object, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemoveObject(
                            name, token, @object, clientData, synchronous,
                            alias, ref dispose, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RemoveObject(
            string name,
            IClientData clientData,
            bool synchronous,
            bool alias,
            ref bool dispose,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasObjects(ref result))
                {
                    long token = 0;
                    IObject @object = null;

                    if (GetObject(name, LookupFlags.Remove, ref token,
                            ref @object, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemoveObject(
                            name, token, @object, clientData, synchronous,
                            alias, ref dispose, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveObjects(
            IClientData clientData,
            int referenceCount,
            bool stopOnError,
            bool synchronous,
            ref bool dispose,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasObjects(ref result))
                {
                    StringList keys = new StringList();

                    //
                    // NOTE: Cleanup, PASS #1, collect the list of keys we need to remove
                    //       from the objects collection in the containing interpreter.
                    //
                    foreach (KeyValuePair<string, _Wrappers._Object> pair in objects)
                    {
                        IObject @object = pair.Value;

                        if (@object == null)
                            continue;

                        //
                        // HACK: Using a negative reference count here means that -ALL-
                        //       unlocked opaque object handles will be removed and/or
                        //       disposed.
                        //
                        if ((referenceCount >= 0) &&
                            (@object.ReferenceCount > referenceCount))
                        {
                            continue;
                        }

                        if (!FlagOps.HasFlags(
                                @object.ObjectFlags, ObjectFlags.Locked, true))
                        {
                            keys.Add(pair.Key);
                        }
                    }

                    int disposed = 0;

                    //
                    // NOTE: Cleanup, PASS #2, dispose and remove all the objects we found
                    //       from PASS #1 (above).
                    //
                    foreach (string key in keys)
                    {
                        bool localDispose = dispose;
                        Result localResult = null;

                        if ((RemoveObject(
                                key, clientData, synchronous, ref localDispose,
                                ref localResult) != ReturnCode.Ok) && stopOnError)
                        {
                            result = localResult;
                            return ReturnCode.Error;
                        }

                        //
                        // NOTE: At least one object has been disposed.
                        //
                        if (localDispose)
                            disposed++;
                    }

                    //
                    // NOTE: Inform the caller if any of the objects were disposed.
                    //
                    dispose = (disposed > 0);

                    //
                    // NOTE: Return the number of objects we disposed and removed.
                    //
                    result = StringList.MakeList(
                        "disposed", disposed, "removed", keys.Count);

                    return ReturnCode.Ok;
                }
            }

            return ReturnCode.Error;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IPackage
        public ReturnCode GetPackage(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IPackage package,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetPackage(
                        token, lookupFlags, ref name, ref package,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid package token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid package token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetPackage(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IPackage package,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetPackage(
                        name, lookupFlags, ref token, ref package,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid package name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid package name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddPackage(
            IPackage package,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (package == null)
                {
                    result = "invalid package";
                    return ReturnCode.Error;
                }

                string name = package.Name;

                if (name == null)
                {
                    result = "invalid package name";
                    return ReturnCode.Error;
                }

                if (!HasPackages(ref result))
                    return ReturnCode.Error;

                if (DoesPackageExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: package already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                ReturnCode code = ReturnCode.Ok;

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    try
                    {
                        try
                        {
                            code = package.Initialize(this,
                                (clientData != null) ? clientData : package.ClientData,
                                ref result);
                        }
                        catch (Exception e)
                        {
                            result = String.Format(
                                "caught exception while initializing package: {0}",
                                e);

                            code = ReturnCode.Error;
                        }
                    }
                    finally
                    {
                        ReturnCode terminateCode;
                        Result terminateResult = null;

                        terminateCode = TerminatePackage(
                            package, clientData, ref terminateResult);

                        if (terminateCode != ReturnCode.Ok)
                        {
                            DebugOps.Complain(
                                this, terminateCode, terminateResult);
                        }
                    }

                    if (code != ReturnCode.Ok)
                        return code;

                    bool success = false;
                    _Wrappers.Package wrapper = null;

                    try
                    {
                        long id = EntityOps.NextTokenIdNoThrow(package);
                        wrapper = new _Wrappers.Package(id, package);

                        packages.Add(name, wrapper);
                        success = true;

                        long newToken = EntityOps.GetToken(wrapper);
                        EntityOps.SetToken(package, newToken);

#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Package, NotifyFlags.Added,
                            new ObjectPair(package, newToken), this,
                            clientData, null, null, ref result);
#endif

                        token = newToken;
                    }
                    finally
                    {
                        if (!success && (wrapper != null))
                        {
                            wrapper.Dispose();
                            wrapper = null;
                        }
                    }
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }

                return code;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemovePackage(
            long token,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasPackages(ref result))
                {
                    string name = null;
                    IPackage package = null;

                    if (GetPackage(token, LookupFlags.Remove, ref name,
                            ref package, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemovePackage(
                            name, token, package, clientData, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemovePackage(
            string name,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasPackages(ref result))
                {
                    long token = 0;
                    IPackage package = null;

                    if (GetPackage(name, LookupFlags.Remove, ref token,
                            ref package, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemovePackage(
                            name, token, package, clientData, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private ReturnCode PrivateGetPackage(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IPackage package,
            ref Result error
            )
        {
            if (!HasPackages(ref error))
                return ReturnCode.Error;

            _Wrappers.Package wrapper;

            if (!packages.TryGetValue(token, out wrapper))
            {
                error = "package not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                package = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((package == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid package";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid package wrapper";
                    return ReturnCode.Error;
                }

                package = wrapper.package;
                name = EntityOps.GetName(package);

                if ((package == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid package";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetPackage(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IPackage package,
            ref Result error
            )
        {
            if (!HasPackages(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid package name";
                return ReturnCode.Error;
            }

            _Wrappers.Package wrapper;

            if (!packages.TryGetValue(name, out wrapper))
            {
                error = "package not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                package = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((package == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid package";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid package wrapper";
                    return ReturnCode.Error;
                }

                package = wrapper.package;
                token = EntityOps.GetToken(package);

                if ((package == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid package";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetPackage(
            string name,
            LookupFlags lookupFlags,
            ref IPackage package
            )
        {
            Result error = null;

            return GetPackage(name, lookupFlags, ref package, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetPackage(
            string name,
            LookupFlags lookupFlags,
            ref IPackage package,
            ref Result error
            )
        {
            long token = 0;

            return GetPackage(name, lookupFlags, ref token, ref package, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddPackage(
            IPackage package,
            IClientData clientData,
            ref Result result
            )
        {
            long token = 0;

            return AddPackage(package, clientData, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRemovePackage(
            string name,
            long token,
            IPackage package,
            IClientData clientData,
            ref Result result
            )
        {
            if (name == null)
            {
                result = "invalid package name";
                return ReturnCode.Error;
            }

            GlobalState.PushActiveInterpreter(this);

            try
            {
                if ((package == null) || (TerminatePackage(
                        package, clientData, ref result) == ReturnCode.Ok))
                {
                    packages.Remove(name, token);

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.Package, NotifyFlags.Removed,
                        new ObjectTriplet(package, name, token), this,
                        clientData, null, null, ref result);
#endif

                    return ReturnCode.Ok;
                }

                return ReturnCode.Error;
            }
            catch (Exception e)
            {
                result = String.Format(
                    "caught exception while removing package: {0}",
                    e);

                return ReturnCode.Error;
            }
            finally
            {
                /* IGNORED */
                GlobalState.PopActiveInterpreter();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode TerminatePackage(
            IPackage package,
            IClientData clientData,
            ref Result result
            )
        {
            if (package == null)
            {
                result = "invalid package";
                return ReturnCode.Error;
            }

            bool savedImmutable = BeginMutableExecution();

            ReturnCode code;

            try
            {
                code = package.Terminate(this,
                    (clientData != null) ? clientData : package.ClientData,
                    ref result);

#if NOTIFY
                /* IGNORED */
                CheckNotification(
                    NotifyType.Package, NotifyFlags.Terminated,
                    new ObjectTriplet(package, code), this,
                    clientData, null, null, ref result);
#endif
            }
            catch (Exception e)
            {
                result = String.Format(
                    "caught exception while terminating package: {0}",
                    e);

                code = ReturnCode.Error;
            }
            finally
            {
                EndMutableExecution(savedImmutable);
            }

            return code;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IPlugin
        public ReturnCode GetPlugin(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IPlugin plugin,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetPlugin(
                        token, lookupFlags, ref name, ref plugin,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid plugin token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid plugin token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetPlugin(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IPlugin plugin,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetPlugin(
                        name, lookupFlags, ref token, ref plugin,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid plugin name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid plugin name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetPlugin(
            AssemblyName assemblyName,
            LookupFlags lookupFlags,
            ref string name,
            ref long token,
            ref IPlugin plugin,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPlugins(ref error))
                    return ReturnCode.Error;

                if (plugins.Count == 0)
                {
                    error = "no plugins are loaded";
                    return ReturnCode.Error;
                }

                foreach (KeyValuePair<string, _Wrappers.Plugin> pair in plugins)
                {
                    _Wrappers.Plugin wrapper = pair.Value;

                    if (wrapper == null)
                        continue;

                    if (!AssemblyOps.IsSameAssemblyName(
                            wrapper.AssemblyName, assemblyName))
                    {
                        continue;
                    }

                    if (!RuntimeOps.CheckPluginVersusLookupFlags(
                            wrapper, lookupFlags))
                    {
                        continue;
                    }

                    string localName = pair.Key;
                    long localToken = EntityOps.GetToken(wrapper);
                    IPlugin localPlugin;

                    if (FlagOps.HasFlags(
                            lookupFlags, LookupFlags.Wrapper, true))
                    {
                        localPlugin = wrapper;
                    }
                    else
                    {
                        localPlugin = wrapper.plugin;
                    }

                    if ((localPlugin == null) && FlagOps.HasFlags(
                            lookupFlags, LookupFlags.Validate, true))
                    {
                        error = "invalid plugin";
                        return ReturnCode.Error;
                    }

                    name = localName;
                    token = localToken;
                    plugin = localPlugin;

                    return ReturnCode.Ok;
                }

                error = FlagOps.HasFlags(
                    lookupFlags, LookupFlags.Verbose, true) ?
                    String.Format(
                        "invalid plugin assembly name {0}",
                        FormatOps.AssemblyName(
                            assemblyName, 0, false, true)) :
                    "invalid plugin assembly name";

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetPlugin(
            Assembly assembly,
            LookupFlags lookupFlags,
            ref string name,
            ref long token,
            ref IPlugin plugin,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPlugins(ref error))
                    return ReturnCode.Error;

                if (plugins.Count == 0)
                {
                    error = "no plugins are loaded";
                    return ReturnCode.Error;
                }

                foreach (KeyValuePair<string, _Wrappers.Plugin> pair in plugins)
                {
                    _Wrappers.Plugin wrapper = pair.Value;

                    if (wrapper == null)
                        continue;

                    if (!Object.ReferenceEquals(
                            wrapper.Assembly, assembly))
                    {
                        continue;
                    }

                    if (!RuntimeOps.CheckPluginVersusLookupFlags(
                            wrapper, lookupFlags))
                    {
                        continue;
                    }

                    string localName = pair.Key;
                    long localToken = EntityOps.GetToken(wrapper);
                    IPlugin localPlugin;

                    if (FlagOps.HasFlags(
                            lookupFlags, LookupFlags.Wrapper, true))
                    {
                        localPlugin = wrapper;
                    }
                    else
                    {
                        localPlugin = wrapper.plugin;
                    }

                    if ((localPlugin == null) && FlagOps.HasFlags(
                            lookupFlags, LookupFlags.Validate, true))
                    {
                        error = "invalid plugin";
                        return ReturnCode.Error;
                    }

                    name = localName;
                    token = localToken;
                    plugin = localPlugin;

                    return ReturnCode.Ok;
                }

                error = FlagOps.HasFlags(
                    lookupFlags, LookupFlags.Verbose, true) ?
                    String.Format(
                        "invalid plugin assembly {0}",
                        FormatOps.AssemblyName(
                            assembly, 0, false, true)) :
                    "invalid plugin assembly";

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode MatchPlugin(
            string name,
            LookupFlags lookupFlags,
            ref IPlugin plugin,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPlugins(ref error))
                    return ReturnCode.Error;

                if (plugins.Count == 0)
                {
                    error = "no plugins are loaded";
                    return ReturnCode.Error;
                }

                foreach (KeyValuePair<string, _Wrappers.Plugin> pair in plugins)
                {
                    _Wrappers.Plugin wrapper = pair.Value;

                    if (wrapper == null)
                        continue;

                    if (!StringOps.Match(
                            this, MatchMode.Glob, pair.Key, name, false))
                    {
                        continue;
                    }

                    if (!RuntimeOps.CheckPluginVersusLookupFlags(
                            wrapper, lookupFlags))
                    {
                        continue;
                    }

                    IPlugin localPlugin;

                    if (FlagOps.HasFlags(
                            lookupFlags, LookupFlags.Wrapper, true))
                    {
                        localPlugin = wrapper;
                    }
                    else
                    {
                        localPlugin = wrapper.plugin;
                    }

                    if ((localPlugin == null) && FlagOps.HasFlags(
                            lookupFlags, LookupFlags.Validate, true))
                    {
                        error = "invalid plugin";
                        return ReturnCode.Error;
                    }

                    plugin = localPlugin;
                    return ReturnCode.Ok;
                }

                error = FlagOps.HasFlags(
                    lookupFlags, LookupFlags.Verbose, true) ?
                    String.Format(
                        "invalid plugin name {0}",
                        FormatOps.DisplayName(name)) :
                    "invalid plugin name";

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ListPlugins(
            PluginFlags hasFlags,
            PluginFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                Result localError = null;

                if (HasPlugins(ref localError))
                {
                    code = plugins.ToList(
                        hasFlags, notHasFlags, hasAll, notHasAll,
                        pattern, noCase, ref list, ref error);
                }
                else if (strict)
                {
                    error = localError;
                }
                else
                {
                    if (list == null)
                        list = new StringList();

                    code = ReturnCode.Ok;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddPlugin(
            IPlugin plugin,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (plugin == null)
                {
                    result = "invalid plugin";
                    return ReturnCode.Error;
                }

                string name = plugin.Name;

                if (name == null)
                {
                    result = "invalid plugin name";
                    return ReturnCode.Error;
                }

                if (!HasPlugins(ref result))
                    return ReturnCode.Error;

                if (DoesPluginExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: plugin already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                ReturnCode code;

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    code = InitializePlugin(plugin, clientData, ref result);

                    if (code != ReturnCode.Ok)
                        return code;

                    bool success = false;
                    _Wrappers.Plugin wrapper = null;

                    try
                    {
                        long id = EntityOps.NextTokenIdNoThrow(plugin);
                        wrapper = new _Wrappers.Plugin(id, plugin);

                        plugins.Add(name, wrapper);
                        success = true;

                        long newToken = EntityOps.GetToken(wrapper);
                        EntityOps.SetToken(plugin, newToken);

#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Plugin, NotifyFlags.Added,
                            new ObjectPair(plugin, newToken), this,
                            clientData, null, null, ref result);
#endif

                        /* NO RESULT */
                        plugin.PostInitialize(this, clientData); /* throw */

                        token = newToken;
                    }
                    finally
                    {
                        if (!success && (wrapper != null))
                        {
                            wrapper.Dispose();
                            wrapper = null;
                        }
                    }
                }
                catch (Exception e)
                {
                    result = e;
                    code = ReturnCode.Error;
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }

                return code;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemovePlugin(
            long token,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasPlugins(ref result))
                {
                    string name = null;
                    IPlugin plugin = null;

                    if (GetPlugin(token, LookupFlags.Remove, ref name,
                            ref plugin, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemovePlugin(
                            name, token, plugin, clientData, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemovePlugin(
            string name,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasPlugins(ref result))
                {
                    long token = 0;
                    IPlugin plugin = null;

                    if (GetPlugin(name, LookupFlags.Remove, ref token,
                            ref plugin, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemovePlugin(
                            name, token, plugin, clientData, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private void GetClientDataForAddPlugin(
            IPluginData pluginData,
            IClientData oldClientData,
            out IClientData newClientData
            )
        {
            if (pluginData != null)
            {
                StringList arguments = null;

                if (GetPluginArguments(pluginData.Name, false, ref arguments))
                {
                    //
                    // NOTE: There are plugin arguments to pass.  Now, check
                    //       if there is more client data available as well.
                    //
                    TraceOps.DebugTrace(String.Format(
                        "GetClientDataForAddPlugin: interpreter = {0}, " +
                        "plugin = {1}, oldClientData = {2}, arguments = {3}",
                        FormatOps.InterpreterNoThrow(this),
                        FormatOps.WrapOrNull(pluginData),
                        FormatOps.WrapOrNull(true, true, oldClientData),
                        FormatOps.WrapOrNull(true, true, arguments)),
                        typeof(Interpreter).Name,
                        TracePriority.StartupDebug);

                    newClientData = _ClientData.WrapOrReplace(
                        (oldClientData != null) ? oldClientData :
                        pluginData.ClientData, (arguments != null) ?
                        arguments.ToString() : null);
                }
                else if (oldClientData != null)
                {
                    //
                    // NOTE: There are no plugin arguments; however, there is
                    //       some client data provided by the caller.
                    //
                    newClientData = oldClientData;
                }
                else
                {
                    //
                    // NOTE: There are no plugin arguments.  There is also no
                    //       client data provided by the caller; therefore,
                    //       use the client data associated with this plugin
                    //       context (which may be null).
                    //
                    newClientData = pluginData.ClientData;
                }
            }
            else
            {
                //
                // NOTE: We have no plugin context, there is no other
                //       option.
                //
                newClientData = oldClientData;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool GetPluginArguments(
            string name,
            bool exact,
            ref StringList arguments
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (String.IsNullOrEmpty(name))
                    return false;

                if (pluginArguments != null)
                {
                    int count = 0;
                    string value;

                    if (pluginArguments.TryGetValue(name, out value))
                    {
                        if (arguments == null)
                            arguments = new StringList();

                        arguments.Add(value);
                        count++;
                    }

                    if (!exact)
                    {
                        foreach (KeyValuePair<string, string> pair in pluginArguments)
                        {
                            if (StringOps.Match(
                                    this, MatchMode.Glob, name, pair.Key, false))
                            {
                                if (arguments == null)
                                    arguments = new StringList();

                                arguments.Add(pair.Value);
                                count++;
                            }
                        }
                    }

                    return (count > 0);
                }

                return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal StringList CopyPluginKeys()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (plugins != null)
                    return new StringList(plugins.Keys);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal PluginWrapperDictionary CopyPlugins()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (plugins != null)
                    return new PluginWrapperDictionary(plugins);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY || NOTIFY_OBJECT
#if ISOLATED_PLUGINS
        private void RemoveIsolatedNotifyPlugins()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                int count = 0;

                if (notifyPlugins == null)
                    return;

                StringList keys = new StringList(notifyPlugins.Keys);

                foreach (string key in keys)
                {
                    if (key == null)
                        continue;

                    _Wrappers.Plugin pluginWrapper;

                    if (!notifyPlugins.TryGetValue(key, out pluginWrapper))
                        continue;

                    if (pluginWrapper == null)
                        continue;

                    if (!AppDomainOps.IsTransparentProxy(pluginWrapper))
                        continue;

                    if (notifyPlugins.Remove(key))
                        count++;
                }

                if ((plugins != null) && (count > 0))
                    notifyPlugins.TryCopyVersion(plugins);
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private PluginWrapperDictionary GetNotifyPlugins()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (plugins == null)
                {
                    if (notifyPlugins != null)
                    {
                        notifyPlugins.Clear();
                        notifyPlugins = null;
                    }

                    return null;
                }

                if ((notifyPlugins == null) ||
                    !notifyPlugins.TryMatchVersion(plugins))
                {
                    notifyPlugins = new PluginWrapperDictionary(plugins);

#if ISOLATED_PLUGINS
                    if (IsNoIsolatedNotify())
                        RemoveIsolatedNotifyPlugins();
#endif
                }

                return notifyPlugins;
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetPlugin(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IPlugin plugin,
            ref Result error
            )
        {
            if (!HasPlugins(ref error))
                return ReturnCode.Error;

            _Wrappers.Plugin wrapper;

            if (!plugins.TryGetValue(token, out wrapper))
            {
                error = "plugin not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                plugin = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((plugin == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid plugin";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid plugin wrapper";
                    return ReturnCode.Error;
                }

                plugin = wrapper.plugin;
                name = EntityOps.GetName(plugin);

                if ((plugin == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid plugin";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetPlugin(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IPlugin plugin,
            ref Result error
            )
        {
            if (!HasPlugins(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid plugin name";
                return ReturnCode.Error;
            }

            _Wrappers.Plugin wrapper;

            if (!plugins.TryGetValue(name, out wrapper))
            {
                error = "plugin not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                plugin = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((plugin == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid plugin";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid plugin wrapper";
                    return ReturnCode.Error;
                }

                plugin = wrapper.plugin;
                token = EntityOps.GetToken(plugin);

                if ((plugin == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid plugin";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the [unload] command only.
        //
        internal IPluginData GetPluginData(
            string name
            )
        {
            if (name != null)
            {
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    if (plugins != null)
                    {
                        _Wrappers.Plugin wrapper;

                        if (plugins.TryGetValue(name, out wrapper))
                            return wrapper;
                    }
                }
            }

            return null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetPlugin(
            long token,
            LookupFlags lookupFlags,
            ref IPlugin plugin,
            ref Result error
            )
        {
            string name = null;

            return GetPlugin(token, lookupFlags, ref name, ref plugin, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetPlugin(
            string name,
            LookupFlags lookupFlags,
            ref IPlugin plugin,
            ref Result error
            )
        {
            long token = 0;

            return GetPlugin(name, lookupFlags, ref token, ref plugin, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRemovePlugin(
            string name,
            long token,
            IPlugin plugin,
            IClientData clientData,
            ref Result result
            )
        {
            if (name == null)
            {
                result = "invalid plugin name";
                return ReturnCode.Error;
            }

            GlobalState.PushActiveInterpreter(this);

            try
            {
                if ((plugin == null) || (TerminatePlugin(
                        plugin, clientData, ref result) == ReturnCode.Ok))
                {
                    plugins.Remove(name, token);

#if NOTIFY || NOTIFY_OBJECT
                    if (notifyPlugins != null)
                        notifyPlugins.Remove(name, token);
#endif

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.Plugin, NotifyFlags.Removed,
                        new ObjectTriplet(plugin, name, token), this,
                        clientData, null, null, ref result);
#endif

                    return ReturnCode.Ok;
                }

                return ReturnCode.Error;
            }
            catch (Exception e)
            {
                result = String.Format(
                    "caught exception while removing plugin: {0}",
                    e);

                return ReturnCode.Error;
            }
            finally
            {
                /* IGNORED */
                GlobalState.PopActiveInterpreter();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode TerminatePlugin(
            IPlugin plugin,
            IClientData clientData,
            ref Result result
            )
        {
            if (plugin == null)
            {
                result = "invalid plugin";
                return ReturnCode.Error;
            }

            bool savedImmutable = BeginMutableExecution();

            ReturnCode code;

            try
            {
                code = plugin.Terminate(this,
                    (clientData != null) ? clientData : plugin.ClientData,
                    ref result);

#if NOTIFY
                /* IGNORED */
                CheckNotification(
                    NotifyType.Plugin, NotifyFlags.Terminated,
                    new ObjectTriplet(plugin, code), this,
                    clientData, null, null, ref result);
#endif
            }
            catch (Exception e)
            {
                result = String.Format(
                    "caught exception while terminating plugin: {0}",
                    e);

                code = ReturnCode.Error;
            }
            finally
            {
                EndMutableExecution(savedImmutable);
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode InitializePlugin(
            IPlugin plugin,
            IClientData clientData,
            ref Result result
            )
        {
            if (plugin == null)
            {
                result = "invalid plugin";
                return ReturnCode.Error;
            }

            ReturnCode code = ReturnCode.Ok;

            try
            {
                GlobalState.PushActiveInterpreter(this);

                try
                {
                    IClientData addClientData;

                    GetClientDataForAddPlugin(
                        plugin, clientData, out addClientData);

                    code = plugin.Initialize(
                        this, addClientData, ref result);

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.Plugin, NotifyFlags.Initialized,
                        new ObjectTriplet(plugin, code), this,
                        clientData, null, null, ref result);
#endif
                }
                catch (Exception e)
                {
                    result = String.Format(
                        "caught exception while initializing plugin: {0}",
                        e);

                    code = ReturnCode.Error;
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }
            finally
            {
                if (code != ReturnCode.Ok)
                {
                    ReturnCode terminateCode;
                    Result terminateResult = null;

                    terminateCode = TerminatePlugin(
                        plugin, clientData, ref terminateResult);

                    if (terminateCode != ReturnCode.Ok)
                    {
                        DebugOps.Complain(this,
                            terminateCode, terminateResult);
                    }
                }
            }

            return code;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ICommand
        public ReturnCode GetCommandName(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                ICommand command = null; /* NOT USED */

                if (PrivateGetCommand(
                        token, lookupFlags, ref name, ref command,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid command token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid command token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetCommand(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref ICommand command,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetCommand(
                        token, lookupFlags, ref name, ref command,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid command token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid command token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetCommand(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref ICommand command,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetCommand(
                        name, lookupFlags, ref token, ref command,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid command name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid command name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ListCommands(
            CommandFlags hasFlags,
            CommandFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                Result localError = null;

                if (HasCommands(ref localError))
                {
                    if (AreNamespacesEnabled())
                    {
                        INamespace currentNamespace = null;

                        code = GetCurrentNamespaceViaResolvers(
                            null, LookupFlags.Default, ref currentNamespace,
                            ref error);

                        if (code == ReturnCode.Ok)
                        {
                            StringList[] localLists = { null, null };

                            code = commands.ToList(
                                hasFlags, notHasFlags, hasAll, notHasAll,
                                null, false, ref localLists[0], ref error);

                            if (code == ReturnCode.Ok)
                            {
                                code = MatchItems(
                                    currentNamespace, pattern, noCase,
                                    ref localLists, ref error);

                                if (list == null)
                                    list = localLists[1];
                                else
                                    list.AddRange(localLists[1]);
                            }
                        }
                    }
                    else
                    {
                        pattern = ScriptOps.MakeCommandName(pattern);

                        code = commands.ToList(
                            hasFlags, notHasFlags, hasAll, notHasAll,
                            pattern, noCase, ref list, ref error);
                    }
                }
                else if (strict)
                {
                    error = localError;
                }
                else
                {
                    if (list == null)
                        list = new StringList();

                    code = ReturnCode.Ok;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddExecuteCallback(
            string name,
            ExecuteCallback callback,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            return AddExecuteCallback(
                name, callback, clientData, null, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddExecuteCallback(
            string name,
            ICommand command,
            ExecuteCallback callback,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            //
            // NOTE: In order to add/replace the sub-command, both the name
            //       and command itself must be valid.
            //
            if (name == null)
            {
                result = "invalid sub-command name";
                return ReturnCode.Error;
            }

            if (command == null)
            {
                result = "invalid command";
                return ReturnCode.Error;
            }

            EnsembleDictionary subCommands = command.SubCommands;

            if (subCommands == null)
            {
                result = "sub-commands not available";
                return ReturnCode.Error;
            }

            //
            // NOTE: Synthesize a sub-command out of the clear blue sky and
            //       populate it with the callback supplied by the user.  We
            //       do not bother checking if the supplied callback is valid
            //       because we do not actually care.  The worst case is that
            //       the engine will call the Execute method of the default
            //       sub-command created here, which does nothing.
            //
            ISubCommand subCommand = ScriptOps.NewDefaultSubCommand(
                name, clientData, command, SubCommandFlags.None, null,
                DelegateFlags.None);

            subCommand.Callback = callback;
            subCommands[name] = subCommand;

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddExecuteCallbacks(
            IEnumerable<IExecuteCallbackData> collection, /* in */
            IPlugin plugin,                               /* in */
            IClientData clientData,                       /* in */
            bool ignoreNull,                              /* in */
            bool stopOnError,                             /* in */
            ref int errorCount,                           /* in, out */
            ref Result result                             /* out */
            )
        {
            CheckDisposed();

            if (collection == null)
            {
                result = "invalid enumerable";
                return ReturnCode.Error;
            }

            ReturnCode code = ReturnCode.Ok;
            ResultList results = null;

            foreach (IExecuteCallbackData executeData in collection)
            {
                if (executeData == null)
                {
                    if (!ignoreNull)
                    {
                        errorCount++;

                        if (results == null)
                            results = new ResultList();

                        results.Add("invalid execute callback data");

                        if (stopOnError)
                        {
                            code = ReturnCode.Error;
                            break;
                        }
                    }

                    continue;
                }

                long token = executeData.Token;

                if (token != 0) /* NOTE: Refuse to overwrite. */
                {
                    errorCount++;

                    if (results == null)
                        results = new ResultList();

                    results.Add("invalid execute callback token");

                    if (stopOnError)
                    {
                        code = ReturnCode.Error;
                        break;
                    }

                    continue;
                }

                Result localResult = null;

                code = AddExecuteCallback(
                    executeData.Name, executeData.Callback,
                    executeData.ClientData, plugin, ref token,
                    ref localResult);

                if (localResult != null)
                {
                    localResult.ReturnCode = code;

                    if (results == null)
                        results = new ResultList();

                    results.Add(localResult);
                }

                if (code == ReturnCode.Ok)
                {
                    executeData.Token = token;
                }
                else
                {
                    errorCount++;

                    if (stopOnError)
                        break;
                    else
                        code = ReturnCode.Ok;
                }
            }

            if (results != null)
                result = results;

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddSubCommand(
            string name,
            ICommand command,
            StringList scriptCommand,
            int? nameIndex,
            IClientData clientData,
            SubCommandFlags subCommandFlags,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            //
            // NOTE: In order to add/replace the sub-command, both the name
            //       and command itself must be valid.
            //
            if (name == null)
            {
                result = "invalid sub-command name";
                return ReturnCode.Error;
            }

            if (command == null)
            {
                result = "invalid command";
                return ReturnCode.Error;
            }

            EnsembleDictionary subCommands = command.SubCommands;

            if (subCommands == null)
            {
                result = "sub-commands not available";
                return ReturnCode.Error;
            }

            int localNameIndex;

            if (nameIndex != null)
                localNameIndex = (int)nameIndex;
            else
                localNameIndex = ScriptOps.GetSubCommandNameIndex();

            ISubCommand subCommand = ScriptOps.NewCommandSubCommand(
                name, clientData, command, scriptCommand, localNameIndex,
                subCommandFlags);

            subCommands[name] = subCommand;

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddCommand(
            ICommand command,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (command == null)
                {
                    result = "invalid command";
                    return ReturnCode.Error;
                }

                string name = command.Name;

                if (name == null)
                {
                    result = "invalid command name";
                    return ReturnCode.Error;
                }

                if (!HasCommands(ref result))
                    return ReturnCode.Error;

                //
                // WARNING: Currently, if somebody adds an ICommand that shadows an
                //          IExecute or procedure (by name), it will basically be
                //          ignored in favor of the IExecute or procedure, which
                //          have higher priority.  This behavior could be prevented
                //          here by changing this check to be DoesAnyExecuteExist
                //          instead of DoesCommandExist; however, I am not convinced
                //          that task should be the responsibility of this method
                //          (i.e. why should a method that deals with commands need
                //          to know about IExecute or procedure objects?).  The spirit
                //          of this check is basically "can we physically add the
                //          object in question?".
                //
                /* EXEMPT */
                if (FlagOps.HasFlags(interpreterFlags,
                        InterpreterFlags.DoesAnythingExist, true))
                {
                    if (DoesIExecuteExistViaResolvers(name) == ReturnCode.Ok)
                    {
                        result = String.Format(
                            "can't add {0}: something already exists",
                            FormatOps.WrapOrNull(name));

                        return ReturnCode.Error;
                    }
                }
                else
                {
                    if (DoesCommandExist(name) == ReturnCode.Ok)
                    {
                        result = String.Format(
                            "can't add {0}: command already exists",
                            FormatOps.WrapOrNull(name));

                        return ReturnCode.Error;
                    }
                }

                Result localError = null;

                if (AreNamespacesEnabled() && (NamespaceOps.LookupParent(
                        this, name, false, true, true, ref localError) == null))
                {
                    result = String.Format(
                        "can't add command {0}: {1}",
                        FormatOps.WrapOrNull(name),
                        localError);

                    return ReturnCode.Error;
                }

                ReturnCode code = ReturnCode.Ok;

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    try
                    {
                        try
                        {
                            code = command.Initialize(this,
                                (clientData != null) ? clientData : command.ClientData,
                                ref result);
                        }
                        catch (Exception e)
                        {
                            result = String.Format(
                                "caught exception while initializing command: {0}",
                                e);

                            code = ReturnCode.Error;
                        }
                    }
                    finally
                    {
                        if (code != ReturnCode.Ok)
                        {
                            ReturnCode terminateCode;
                            Result terminateResult = null;

                            terminateCode = TerminateCommand(
                                command, clientData, ref terminateResult);

                            if (terminateCode != ReturnCode.Ok)
                            {
                                DebugOps.Complain(
                                    this, terminateCode, terminateResult);
                            }
                        }
                    }

                    if (code != ReturnCode.Ok)
                        return code;

                    bool success = false;
                    _Wrappers.Command wrapper = null;

                    try
                    {
                        long id = EntityOps.NextTokenIdNoThrow(command);
                        wrapper = new _Wrappers.Command(id, command);

                        //
                        // NOTE: Are we allowed to assist in managing the command
                        //       token via the associated plugin?
                        //
                        long newToken = EntityOps.GetToken(wrapper); /* throw */

                        if (!EntityOps.IsNoToken(command))
                        {
                            //
                            // NOTE: Store the command token so that we can remove
                            //       them later without using their names (which
                            //       can change).
                            //
                            IPluginData pluginData = command.Plugin;

                            if (pluginData != null)
                            {
                                LongList tokens = pluginData.CommandTokens;

                                if ((tokens != null) && !tokens.Contains(newToken))
                                {
                                    tokens.Add(newToken);

#if ISOLATED_PLUGINS
                                    //
                                    // HACK: Force the command tokens for the
                                    //       isolated plugin to be updated.
                                    //
                                    if (AppDomainOps.IsIsolated(pluginData))
                                        pluginData.CommandTokens = tokens;
#endif
                                }
                            }
                        }

                        EntityOps.SetToken(command, newToken);

                        commands.Add(name, wrapper);
                        success = true;

#if EXECUTE_CACHE
                        AddOrUpdateIExecuteToCache(name, wrapper, false, false);
#endif

#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Command, NotifyFlags.Added,
                            new ObjectPair(command, newToken), this,
                            clientData, null, null, ref result);
#endif

                        token = newToken;
                    }
                    finally
                    {
                        if (!success && (wrapper != null))
                        {
                            wrapper.Dispose();
                            wrapper = null;
                        }
                    }
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }

                return code;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RenameCommand(
            string oldName,
            string newName,
            bool delete,
            ref Result result
            )
        {
            CheckDisposed();

            return PrivateRenameCommand(oldName, newName, false, delete, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RenameHiddenCommand(
            string oldName,
            string newName,
            bool delete,
            ref Result result
            )
        {
            CheckDisposed();

            return PrivateRenameHiddenCommand(oldName, newName, false, delete, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveExecuteCallbacks(
            IEnumerable<IExecuteCallbackData> collection, /* in */
            IClientData clientData,                       /* in */
            bool ignoreNull,                              /* in */
            bool stopOnError,                             /* in */
            ref int errorCount,                           /* in, out */
            ref Result result                             /* out */
            )
        {
            CheckDisposed();

            if (collection == null)
            {
                result = "invalid enumerable";
                return ReturnCode.Error;
            }

            ReturnCode code = ReturnCode.Ok;
            ResultList results = null;

            foreach (IExecuteCallbackData executeData in collection)
            {
                if (executeData == null)
                {
                    if (!ignoreNull)
                    {
                        errorCount++;

                        if (results == null)
                            results = new ResultList();

                        results.Add("invalid execute callback data");

                        if (stopOnError)
                        {
                            code = ReturnCode.Error;
                            break;
                        }
                    }

                    continue;
                }

                long token = executeData.Token;

                if (token == 0)
                {
                    errorCount++;

                    if (results == null)
                        results = new ResultList();

                    results.Add("invalid execute callback token");

                    if (stopOnError)
                    {
                        code = ReturnCode.Error;
                        break;
                    }

                    continue;
                }

                Result localResult = null;

                code = RemoveCommand(
                    token, executeData.ClientData,
                    ref localResult);

                if (localResult != null)
                {
                    localResult.ReturnCode = code;

                    if (results == null)
                        results = new ResultList();

                    results.Add(localResult);
                }

                if (code == ReturnCode.Ok)
                {
                    executeData.Token = 0;
                }
                else
                {
                    errorCount++;

                    if (stopOnError)
                        break;
                    else
                        code = ReturnCode.Ok;
                }
            }

            if (results != null)
                result = results;

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveCommand(
            long token,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasCommands(ref result))
                {
                    string name = null;
                    ICommand command = null;

                    if (GetCommand(token, LookupFlags.Remove, ref name,
                            ref command, ref result) == ReturnCode.Ok)
                    {
                        if (!EntityOps.IsReadOnly(command))
                        {
                            if (EntityOps.IsNoRemove(command))
                                return ReturnCode.Ok;

                            return PrivateRemoveCommand(
                                name, token, command, clientData,
                                false, ref result);
                        }
                        else
                        {
                            result = "command is read-only";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveCommand(
            string name,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasCommands(ref result))
                {
                    long token = 0;
                    ICommand command = null;

                    if (GetCommand(name, LookupFlags.Remove, ref token,
                            ref command, ref result) == ReturnCode.Ok)
                    {
                        if (!EntityOps.IsReadOnly(command))
                        {
                            if (EntityOps.IsNoRemove(command))
                                return ReturnCode.Ok;

                            return PrivateRemoveCommand(
                                name, token, command, clientData,
                                false, ref result);
                        }
                        else
                        {
                            result = "command is read-only";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode MatchCommand(
            EngineFlags engineFlags,
            string name,
            LookupFlags lookupFlags,
            ref bool ambiguous,
            ref long token,
            ref ICommand command,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool useHidden = EngineFlagOps.HasUseHidden(engineFlags);
                bool matchHidden = EngineFlagOps.HasMatchHidden(engineFlags);

                CommandWrapperDictionary localCommands =
                    useHidden ? hiddenCommands : commands;

                if (localCommands != null)
                {
                    //
                    // NOTE: *WARNING* Empty command/procedure names are allowed,
                    //       please do not change this to "!String.IsNullOrEmpty".
                    //
                    if (name != null)
                    {
                        if (localCommands.Count > 0)
                        {
                            _Wrappers.Command localCommand;
                            string exactName = null;
                            StringList list = new StringList();

                            if (localCommands.TryGetValue(name, out localCommand) &&
                                (matchHidden || !EntityOps.IsHidden(localCommand)))
                            {
                                //
                                // NOTE: Exact command match.
                                //
                                exactName = name;

                                //
                                // NOTE: Store the exact command match in the result
                                //       list.
                                //
                                list.Add(name);
                            }
                            else
                            {
                                foreach (KeyValuePair<string, _Wrappers.Command> pair in localCommands)
                                {
                                    if (SharedStringOps.SystemEquals(pair.Key, 0, name, 0, name.Length))
                                    {
                                        //
                                        // NOTE: Is the command visible or are we allowed to
                                        //       find hidden command?
                                        //
                                        if (matchHidden || !EntityOps.IsHidden(pair.Value))
                                        {
                                            //
                                            // NOTE: Was the key valid (this should always succeed).
                                            //
                                            if (pair.Key != null)
                                            {
                                                //
                                                // NOTE: It was a match; however, was it an exact match?
                                                //
                                                if (pair.Key.Length == name.Length)
                                                    //
                                                    // NOTE: Preserve match, it may differ in case.
                                                    //
                                                    exactName = pair.Key;

                                                //
                                                // NOTE: Was it an exact match or did we match at least one
                                                //       character in a partial match?
                                                //
                                                if ((pair.Key.Length == name.Length) || (name.Length > 0))
                                                    //
                                                    // NOTE: Store the exact or partial match in the results
                                                    //       dictionary.
                                                    //
                                                    list.Add(pair.Key);
                                            }
                                        }
                                    }
                                }
                            }

                            //
                            // NOTE: If there was an exact match, just use it.
                            //
                            if (exactName != null)
                            {
                                //
                                // NOTE: No need to change the caller's variable,
                                //       it already contains the correct value.
                                //
                                if ((useHidden && PrivateGetHiddenCommand(
                                        exactName, lookupFlags, ref token,
                                        ref command, ref error) == ReturnCode.Ok) ||
                                    (!useHidden && PrivateGetCommand(
                                        exactName, lookupFlags, ref token,
                                        ref command, ref error) == ReturnCode.Ok))
                                {
#if NOTIFY
                                    /* IGNORED */
                                    CheckNotification(
                                        useHidden ? NotifyType.HiddenCommand : NotifyType.Command,
                                        NotifyFlags.Matched | (useHidden ? NotifyFlags.Hidden : NotifyFlags.None),
                                        new ObjectList(engineFlags, name, exactName, command, token), this, null, null,
                                        null, ref error);
#endif

                                    return ReturnCode.Ok;
                                }
                            }
                            else if (list.Count == 1)
                            {
                                //
                                // NOTE: Normal case, exactly one command matched.
                                //
                                if ((useHidden && PrivateGetHiddenCommand(
                                        list[0], lookupFlags, ref token,
                                        ref command, ref error) == ReturnCode.Ok) ||
                                    (!useHidden && PrivateGetCommand(
                                        list[0], lookupFlags, ref token,
                                        ref command, ref error) == ReturnCode.Ok))
                                {
#if NOTIFY
                                    /* IGNORED */
                                    CheckNotification(
                                        useHidden ? NotifyType.HiddenCommand : NotifyType.Command,
                                        NotifyFlags.Matched | (useHidden ? NotifyFlags.Hidden : NotifyFlags.None),
                                        new ObjectList(engineFlags, name, list[0], command, token), this, null, null,
                                        null, ref error);
#endif

                                    return ReturnCode.Ok;
                                }
                            }
                            else if (list.Count > 1)
                            {
                                error = FlagOps.HasFlags(
                                    lookupFlags, LookupFlags.Verbose, true) ?
                                    ScriptOps.BadValue(
                                        "ambiguous", "command", name, list,
                                        null, null) :
                                    (Result)"ambiguous command";

                                ambiguous = true;
                            }
                            else
                            {
                                error = FlagOps.HasFlags(
                                    lookupFlags, LookupFlags.Verbose, true) ?
                                    ScriptOps.BadValue(
                                        null, "command", name, localCommands.Keys,
                                        null, null) :
                                    (Result)"bad command";
                            }
                        }
                        else
                        {
                            error = "no commands defined";
                        }
                    }
                    else
                    {
                        error = "invalid command name";
                    }
                }
                else
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "{0}commands not available",
                            useHidden ? "hidden " : String.Empty) :
                        "commands not available";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal ReturnCode CommandsToList(
            CommandFlags hasFlags,
            CommandFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            ref StringList list,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (commands != null)
                {
                    return commands.ToList(
                        hasFlags, notHasFlags, hasAll, notHasAll,
                        pattern, noCase, ref list, ref error);
                }
            }

            error = "commands not available";
            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ListEnsembleCommands(
            string pattern,
            bool noCase,
            ref StringList list,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (commands != null)
                {
                    StringList localList = new StringList();

                    foreach (KeyValuePair<string, _Wrappers.Command> pair in commands)
                    {
                        ICommand command = pair.Value;

                        if (command == null)
                            continue;

                        //
                        // BUGFIX: Do not include aliases, e.g. to [object invoke].
                        //
                        if (FlagOps.HasFlags(command.Flags, CommandFlags.Alias, true))
                            continue;

                        EnsembleDictionary subCommands = PolicyOps.GetSubCommandsUnsafe(
                            command); /* COUNT ONLY */

                        if ((subCommands != null) && (subCommands.Count > 0))
                            localList.Add(pair.Key);
                    }

                    bool absolute = false;

                    pattern = NamespaceOps.TrimLeading(pattern, ref absolute);

                    if (absolute || !AreNamespacesEnabled())
                    {
                        if (pattern == null)
                        {
                            list = localList;
                        }
                        else
                        {
                            if (list == null)
                                list = new StringList();

                            foreach (string element in localList)
                            {
                                if (StringOps.Match(
                                        this, MatchMode.Glob, element,
                                        pattern, noCase))
                                {
                                    list.Add(element);
                                }
                            }
                        }

                        return ReturnCode.Ok;
                    }
                    else
                    {
                        bool qualified = NamespaceOps.IsQualifiedName(pattern);

                        return NamespaceOps.MatchItems(
                            this, null, localList, pattern, noCase,
                            false, !qualified, qualified, false,
                            ref list, ref error);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal StringList GetCommandsReadOnly(
            string pattern,
            bool noCase,
            bool readOnly
            )
        {
            StringList result = new StringList();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (commands != null)
                {
                    foreach (KeyValuePair<string, _Wrappers.Command> pair in commands)
                    {
                        ICommand command = pair.Value;

                        if (command == null)
                            continue;

                        if ((pattern != null) && !StringOps.Match(
                                this, StringOps.DefaultMatchMode, pair.Key,
                                pattern, noCase))
                        {
                            continue;
                        }

                        if (EntityOps.IsReadOnly(command) == readOnly)
                            result.Add(pair.Key);
                    }
                }
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int SetCommandsReadOnly(
            string pattern,
            bool noCase,
            bool readOnly
            )
        {
            int result = 0;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (commands != null)
                {
                    foreach (KeyValuePair<string, _Wrappers.Command> pair in commands)
                    {
                        ICommand command = pair.Value;

                        if (command == null)
                            continue;

                        if ((pattern != null) && !StringOps.Match(
                                this, StringOps.DefaultMatchMode, pair.Key,
                                pattern, noCase))
                        {
                            continue;
                        }

                        if (EntityOps.IsReadOnly(command) == readOnly)
                            continue;

                        if (EntityOps.SetReadOnly(command, readOnly))
                            result++;
                    }
                }
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetCommand(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref ICommand command,
            ref Result error
            )
        {
            if (!HasCommands(ref error))
                return ReturnCode.Error;

            _Wrappers.Command wrapper;

            if (!commands.TryGetValue(token, out wrapper))
            {
                error = "command not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                command = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((command == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid command";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid command wrapper";
                    return ReturnCode.Error;
                }

                command = wrapper.command;
                name = EntityOps.GetName(command);

                if ((command == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid command";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetCommand(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref ICommand command,
            ref Result error
            )
        {
            if (!HasCommands(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid command name";
                return ReturnCode.Error;
            }

            _Wrappers.Command wrapper;

            if (!commands.TryGetValue(name, out wrapper))
            {
                error = "command not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                command = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((command == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid command";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid command wrapper";
                    return ReturnCode.Error;
                }

                command = wrapper.command;
                token = EntityOps.GetToken(command);

                if ((command == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid command";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetCommand(
            long token,
            LookupFlags lookupFlags,
            ref ICommand command
            )
        {
            Result error = null;

            return GetCommand(token, lookupFlags, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetCommand(
            long token,
            LookupFlags lookupFlags,
            ref ICommand command,
            ref Result error
            )
        {
            string name = null;

            return GetCommand(token, lookupFlags, ref name, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetCommand(
            string name,
            LookupFlags lookupFlags,
            ref ICommand command
            )
        {
            Result error = null;

            return GetCommand(name, lookupFlags, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetCommand(
            string name,
            LookupFlags lookupFlags,
            ref ICommand command,
            ref Result error
            )
        {
            long token = 0;

            return GetCommand(name, lookupFlags, ref token, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetCommand(
            Type type,
            LookupFlags lookupFlags,
            ref ICommand command
            )
        {
            Result error = null;

            return GetCommand(type, lookupFlags, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetCommand(
            Type type,
            LookupFlags lookupFlags,
            ref ICommand command,
            ref Result error
            )
        {
            string name = null;

            return GetCommand(type, lookupFlags, ref name, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetCommand(
            Type type,
            LookupFlags lookupFlags,
            ref string name,
            ref ICommand command,
            ref Result error
            )
        {
            long token = 0;

            return GetCommand(type, lookupFlags, ref name, ref token, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetCommand(
            Type type,
            LookupFlags lookupFlags,
            ref string name,
            ref long token,
            ref ICommand command,
            ref Result error
            )
        {
            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if ((code != ReturnCode.Ok) && HasCommands() &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Visible, true))
                {
                    if ((type != null) && (commands.Count > 0))
                    {
                        foreach (KeyValuePair<string, _Wrappers.Command> pair in commands)
                        {
                            _Wrappers.Command wrapper = pair.Value;

                            if (wrapper == null)
                                continue;

                            if (type.IsInstanceOfType(wrapper.command))
                            {
                                name = pair.Key;

                                if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
                                    command = wrapper;
                                else
                                    command = wrapper.command;

                                token = EntityOps.GetToken(wrapper);

                                if ((command != null) ||
                                    !FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                                {
                                    code = ReturnCode.Ok;
                                }

                                break;
                            }
                        }
                    }
                }

                if ((code != ReturnCode.Ok) && HasHiddenCommands() &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Invisible, true))
                {
                    if ((type != null) && (hiddenCommands.Count > 0))
                    {
                        foreach (KeyValuePair<string, _Wrappers.Command> pair in hiddenCommands)
                        {
                            _Wrappers.Command wrapper = pair.Value;

                            if (wrapper == null)
                                continue;

                            if (type.IsInstanceOfType(wrapper.command))
                            {
                                name = pair.Key;

                                if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
                                    command = wrapper;
                                else
                                    command = wrapper.command;

                                token = EntityOps.GetToken(wrapper);

                                if ((command != null) ||
                                    !FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                                {
                                    code = ReturnCode.Ok;
                                }

                                break;
                            }
                        }
                    }
                }

                if (code != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid command type {0}",
                            FormatOps.TypeName(type)) :
                        "invalid command type";
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ListCommands(
            CommandFlags hasFlags,
            CommandFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list
            )
        {
            Result error = null;

            return ListCommands(
                hasFlags, notHasFlags, hasAll, notHasAll, pattern, noCase,
                strict, ref list, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddCommand(
            ICommand command,
            IClientData clientData,
            ref Result result
            )
        {
            long token = 0;

            return AddCommand(command, clientData, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddExecuteCallback(
            string name,
            ExecuteCallback callback,
            IClientData clientData,
            IPlugin plugin,
            ref long token,
            ref Result result
            )
        {
            // CheckDisposed();

            //
            // NOTE: Synthesize a command out of the clear blue sky and
            //       populate it with the callback supplied by the user.
            //       We do not bother checking if the supplied callback
            //       is valid because we do not actually care.  In the
            //       worst case, the engine will call the Execute method
            //       of the default command created here, which does not
            //       do anything.
            //
            ICommand command = new _Commands.Default(new CommandData(
                ScriptOps.MakeCommandName(name), null, null, clientData,
                typeof(_Commands.Default).FullName, CommandFlags.None,
                plugin, 0));

            command.Callback = callback;

            return AddCommand(command, clientData, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRenameCommand(
            string oldName,
            string newName,
            bool noNamespaces,
            bool delete,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasCommands(ref result))
                {
                    if (!delete || !String.IsNullOrEmpty(newName))
                    {
                        ICommand oldCommand = null;

                        if (GetCommand(oldName, LookupFlags.Default, ref oldCommand, ref result) == ReturnCode.Ok)
                        {
                            if (!EntityOps.IsReadOnly(oldCommand))
                            {
                                if (EntityOps.IsNoRename(oldCommand))
                                    return ReturnCode.Ok;

                                _Wrappers.Command oldWrapper = oldCommand as _Wrappers.Command;

                                if (oldWrapper != null)
                                {
                                    IAlias oldAlias = oldWrapper.command as IAlias;

                                    if (PreventAliasLoop(oldAlias, newName, ref result) == ReturnCode.Ok)
                                    {
                                        if (IsValidAnyIExecuteName(newName, noNamespaces, ref result) == ReturnCode.Ok)
                                        {
                                            bool useNamespaces = !noNamespaces && AreNamespacesEnabled();

                                            if (!useNamespaces ||
                                                RenameImportInNamespaces(oldName, newName, ref result) == ReturnCode.Ok)
                                            {
                                                //
                                                // NOTE: New name, same token.
                                                //
                                                oldWrapper.Name = newName;

                                                /* IGNORED */
                                                commands.Rename(oldName, newName);

#if EXECUTE_CACHE
                                                RenameIExecuteInCache(oldName, newName, oldWrapper, false, false);
#endif

#if NOTIFY
                                                /* IGNORED */
                                                CheckNotification(
                                                    NotifyType.Command, NotifyFlags.Renamed,
                                                    new ObjectTriplet(oldCommand, oldName, newName), this,
                                                    null, null, null, ref result);
#endif

                                                result = String.Empty;
                                                return ReturnCode.Ok;
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    result = String.Format(
                                        "can't rename {0}: invalid command wrapper",
                                        FormatOps.WrapOrNull(oldName));
                                }
                            }
                            else
                            {
                                result = String.Format(
                                    "can't rename {0}: command is read-only",
                                    FormatOps.WrapOrNull(oldName));
                            }
                        }
                        else
                        {
                            result = String.Format(
                                "can't rename {0}: command doesn't exist",
                                FormatOps.WrapOrNull(oldName));
                        }
                    }
                    else
                    {
                        return RemoveCommand(oldName, null, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRemoveCommand(
            string name,
            long token,
            ICommand command,
            IClientData clientData,
            bool hidden,
            ref Result result
            )
        {
            if (name == null)
            {
                result = "invalid command name";
                return ReturnCode.Error;
            }

            GlobalState.PushActiveInterpreter(this);

            try
            {
                if (AreNamespacesEnabled() &&
                    RemoveImportFromNamespaces(name, ref result) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }

                if (
#if NATIVE && TCL
                    ((command == null) ||
                    (DisposeTclBridges(IntPtr.Zero, command, null, false, ref result) == ReturnCode.Ok)) &&
#endif
                    ((command == null) ||
                    (TerminateCommand(command, clientData, ref result) == ReturnCode.Ok)))
                {
                    if (hidden)
                        /* IGNORED */
                        hiddenCommands.Remove(name, token);
                    else
                        /* IGNORED */
                        commands.Remove(name, token);

#if EXECUTE_CACHE
                    RemoveIExecuteFromCache(name, hidden, false);
#endif

                    if (command != null)
                    {
                        //
                        // NOTE: Are we allowed to assist in managing the command
                        //       token via the associated plugin?
                        //
                        bool noToken = EntityOps.IsNoToken(command);

                        if (!noToken)
                        {
                            //
                            // NOTE: If this command is being managed by a plugin,
                            //       remove the associated token from said plugin.
                            //
                            IPluginData pluginData = command.Plugin;

                            if (pluginData != null)
                            {
                                LongList tokens = pluginData.CommandTokens;

                                if ((tokens != null) && tokens.Contains(token))
                                {
                                    tokens.Remove(token);

#if ISOLATED_PLUGINS
                                    //
                                    // HACK: Force the command tokens for the
                                    //       isolated plugin to be updated.
                                    //
                                    if (AppDomainOps.IsIsolated(pluginData))
                                        pluginData.CommandTokens = tokens;
#endif
                                }
                            }
                        }
                    }

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(hidden ?
                        NotifyType.HiddenCommand : NotifyType.Command,
                        NotifyFlags.Removed, new ObjectTriplet(command,
                            name, token), this, clientData, null, null,
                        ref result);
#endif

                    return ReturnCode.Ok;
                }

                return ReturnCode.Error;
            }
            catch (Exception e)
            {
                result = String.Format(
                    "caught exception while removing {0}command: {1}",
                    hidden ? "hidden " : String.Empty, e);

                return ReturnCode.Error;
            }
            finally
            {
                /* IGNORED */
                GlobalState.PopActiveInterpreter();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode TerminateCommand(
            ICommand command,
            IClientData clientData,
            ref Result result
            )
        {
            if (command == null)
            {
                result = "invalid command";
                return ReturnCode.Error;
            }

            bool savedImmutable = BeginMutableExecution();

            ReturnCode code;

            try
            {
                code = command.Terminate(this,
                    (clientData != null) ? clientData : command.ClientData,
                    ref result);

#if NOTIFY
                /* IGNORED */
                CheckNotification(
                    NotifyType.Command, NotifyFlags.Terminated,
                    new ObjectTriplet(command, code), this,
                    clientData, null, null, ref result);
#endif
            }
            catch (Exception e)
            {
                result = String.Format(
                    "caught exception while terminating command: {0}",
                    e);

                code = ReturnCode.Error;
            }
            finally
            {
                EndMutableExecution(savedImmutable);
            }

            return code;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ISubCommand
        public ReturnCode AddSubCommands(
            string name,                          /* in */
            Type type,                            /* in: OPTIONAL with "object" */
            object @object,                       /* in: OPTIONAL with "type" */
            IPlugin plugin,                       /* in: OPTIONAL */
            IClientData clientData,               /* in: OPTIONAL */
            NewDelegateNameCallback nameCallback, /* in: OPTIONAL */
            DelegateFlags delegateFlags,          /* in */
            ref long token,                       /* out */
            ref Result result                     /* out */
            )
        {
            CheckDisposed();

            if (name == null)
            {
                result = "invalid command name";
                return ReturnCode.Error;
            }

            if (@object != null)
            {
                Type objectType = AppDomainOps.MaybeGetType(@object);

                if (type != null)
                {
                    if ((objectType != null) &&
                        !MarshalOps.IsSameTypeName(objectType, type))
                    {
                        result = String.Format(
                            "object type {0} does not match type {1}",
                            FormatOps.TypeName(objectType),
                            FormatOps.TypeName(type));

                        return ReturnCode.Error;
                    }
                }
                else
                {
                    type = objectType;
                }
            }

            if (type == null)
            {
                result = "invalid type";
                return ReturnCode.Error;
            }

            ResultList errors; /* REUSED */
            MethodInfoList methodInfoList = null;

            errors = null;

            if (RuntimeOps.GetDelegateMethods(
                    type, delegateFlags, ref methodInfoList,
                    ref errors) != ReturnCode.Ok)
            {
                result = errors;
                return ReturnCode.Error;
            }

            DelegateDictionary delegates = null;

            errors = null;

            if (RuntimeOps.CreateDelegates(
                    this, type, @object, methodInfoList,
                    nameCallback, clientData, delegateFlags,
                    ref delegates, ref errors) != ReturnCode.Ok)
            {
                result = errors;
                return ReturnCode.Error;
            }

            return AddSubCommands(
                name, delegates, plugin, clientData, delegateFlags,
                ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddSubCommands(
            string name,                  /* in */
            DelegateDictionary delegates, /* in */
            IPlugin plugin,               /* in: OPTIONAL */
            IClientData clientData,       /* in: OPTIONAL */
            DelegateFlags delegateFlags,  /* in */
            ref long token,               /* out */
            ref Result result             /* out */
            )
        {
            CheckDisposed();

            if (name == null)
            {
                result = "invalid command name";
                return ReturnCode.Error;
            }

            if (delegates == null)
            {
                result = "invalid delegates";
                return ReturnCode.Error;
            }

            ICommand command = ScriptOps.NewSubDelegateCommand(
                name, clientData, plugin);

            EnsembleDictionary subCommands = new EnsembleDictionary();

            foreach (KeyValuePair<string, Delegate> pair in delegates)
            {
                ISubCommand subCommand = ScriptOps.NewDefaultSubCommand(
                    pair.Key, clientData, command, SubCommandFlags.None,
                    pair.Value, delegateFlags);

                subCommands[pair.Key] = subCommand;
            }

            command.SubCommands = subCommands;

            return AddCommand(command, clientData, ref token, ref result);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IPolicy
        public ReturnCode GetPolicy(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IPolicy policy,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetPolicy(
                        token, lookupFlags, ref name, ref policy,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid policy token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid policy token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetPolicy(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IPolicy policy,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetPolicy(
                        name, lookupFlags, ref token, ref policy,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid policy name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid policy name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddPolicy(
            ExecuteCallback callback,
            IPlugin plugin,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            IPolicy policy = PolicyOps.NewCore(
                callback, clientData, PolicyFlags.None, plugin,
                ref result);

            if (policy != null)
            {
                if (AddPolicy(
                        policy, clientData, ref token,
                        ref result) == ReturnCode.Ok)
                {
                    result = policy.Name;
                    return ReturnCode.Ok;
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddPolicy(
            IPolicy policy,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (policy == null)
                {
                    result = "invalid policy";
                    return ReturnCode.Error;
                }

                string name = policy.Name;

                if (name == null)
                {
                    result = "invalid policy name";
                    return ReturnCode.Error;
                }

                if (!HasPolicies(ref result))
                    return ReturnCode.Error;

                if (DoesPolicyExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: policy already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    bool success = false;
                    _Wrappers.Policy wrapper = null;

                    try
                    {
                        long id = EntityOps.NextTokenIdNoThrow(policy);
                        wrapper = new _Wrappers.Policy(id, policy);

                        //
                        // NOTE: Are we allowed to assist in managing the policy
                        //       token via the associated plugin?
                        //
                        long newToken = EntityOps.GetToken(wrapper);

                        if (!EntityOps.IsNoToken(policy))
                        {
                            //
                            // NOTE: Store the policy token so that we can remove
                            //       them later without using their names (which
                            //       can change).
                            //
                            IPluginData pluginData = policy.Plugin;

                            if (pluginData != null)
                            {
                                LongList tokens = pluginData.PolicyTokens;

                                if ((tokens != null) && !tokens.Contains(newToken))
                                {
                                    tokens.Add(newToken);

#if ISOLATED_PLUGINS
                                    //
                                    // HACK: Force the policy tokens for the
                                    //       isolated plugin to be updated.
                                    //
                                    if (AppDomainOps.IsIsolated(pluginData))
                                        pluginData.PolicyTokens = tokens;
#endif
                                }
                            }
                        }

                        EntityOps.SetToken(policy, newToken);

                        policies.Add(name, wrapper);
                        success = true;

#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Policy, NotifyFlags.Added,
                            new ObjectPair(policy, newToken), this,
                            clientData, null, null, ref result);
#endif

                        token = newToken;
                    }
                    finally
                    {
                        if (!success && (wrapper != null))
                        {
                            wrapper.Dispose();
                            wrapper = null;
                        }
                    }
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddScriptPolicy(
            IScriptPolicy scriptPolicy,
            IPlugin plugin,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            if (scriptPolicy != null)
                return AddPolicy(scriptPolicy.Execute, plugin, clientData, ref token, ref result);
            else
                result = "invalid script policy";

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemovePolicy(
            long token,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasPolicies(ref result))
                {
                    string name = null;
                    IPolicy policy = null;

                    if (GetPolicy(token, LookupFlags.Remove, ref name,
                            ref policy, ref result) == ReturnCode.Ok)
                    {
                        if (!EntityOps.IsReadOnly(policy))
                        {
                            return PrivateRemovePolicy(
                                name, token, policy, clientData, ref result);
                        }
                        else
                        {
                            result = "policy is read-only";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemovePolicy(
            string name,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasPolicies(ref result))
                {
                    long token = 0;
                    IPolicy policy = null;

                    if (GetPolicy(name, LookupFlags.Remove, ref token,
                            ref policy, ref result) == ReturnCode.Ok)
                    {
                        if (!EntityOps.IsReadOnly(policy))
                        {
                            return PrivateRemovePolicy(
                                name, token, policy, clientData, ref result);
                        }
                        else
                        {
                            result = "policy is read-only";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal string PoliciesToString(
            string pattern,
            bool noCase
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (policies != null)
                    return policies.ToString(pattern, noCase);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal PolicyWrapperDictionary CopyPolicies()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (policies != null)
                    return new PolicyWrapperDictionary(policies);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetPolicy(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IPolicy policy,
            ref Result error
            )
        {
            if (!HasPolicies(ref error))
                return ReturnCode.Error;

            _Wrappers.Policy wrapper;

            if (!policies.TryGetValue(token, out wrapper))
            {
                error = "policy not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                policy = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((policy == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid policy";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid policy wrapper";
                    return ReturnCode.Error;
                }

                policy = wrapper.policy;
                name = EntityOps.GetName(policy);

                if ((policy == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid policy";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetPolicy(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IPolicy policy,
            ref Result error
            )
        {
            if (!HasPolicies(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid policy name";
                return ReturnCode.Error;
            }

            _Wrappers.Policy wrapper;

            if (!policies.TryGetValue(name, out wrapper))
            {
                error = "policy not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                policy = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((policy == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid policy";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid policy wrapper";
                    return ReturnCode.Error;
                }

                policy = wrapper.policy;
                token = EntityOps.GetToken(policy);

                if ((policy == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid policy";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetPolicy(
            string name,
            LookupFlags lookupFlags,
            ref IPolicy policy,
            ref Result error
            )
        {
            long token = 0;

            return GetPolicy(name, lookupFlags, ref token, ref policy, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddPolicy(
            ExecuteCallback callback,
            IPlugin plugin,
            IClientData clientData,
            ref Result result
            )
        {
            long token = 0;

            return AddPolicy(callback, plugin, clientData, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddScriptPolicy(
            PolicyFlags flags,
            Type commandType,
            long commandToken,
            Interpreter policyInterpreter,
            string text,
            IPlugin plugin,
            IClientData clientData,
            ref Result result
            )
        {
            long token = 0;

            return AddScriptPolicy(
                ScriptPolicy.Create(flags, commandType, commandToken, policyInterpreter, text),
                plugin, clientData, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRemovePolicy(
            string name,
            long token,
            IPolicy policy,
            IClientData clientData,
            ref Result result
            )
        {
            if (name == null)
            {
                result = "invalid policy name";
                return ReturnCode.Error;
            }

            policies.Remove(name, token);

            if (policy != null)
            {
                //
                // NOTE: Are we allowed to assist in managing the policy
                //       token via the associated plugin?
                //
                bool noToken = EntityOps.IsNoToken(policy);

                if (!noToken)
                {
                    //
                    // NOTE: If this policy is being managed by a plugin,
                    //       remove the associated token from said plugin.
                    //
                    IPluginData pluginData = policy.Plugin;

                    if (pluginData != null)
                    {
                        LongList tokens = pluginData.PolicyTokens;

                        if ((tokens != null) && tokens.Contains(token))
                        {
                            tokens.Remove(token);

#if ISOLATED_PLUGINS
                            //
                            // HACK: Force the policy tokens for the
                            //       isolated plugin to be updated.
                            //
                            if (AppDomainOps.IsIsolated(pluginData))
                                pluginData.PolicyTokens = tokens;
#endif
                        }
                    }
                }
            }

#if NOTIFY
            /* IGNORED */
            CheckNotification(
                NotifyType.Policy, NotifyFlags.Removed,
                new ObjectTriplet(policy, name, token), this,
                clientData, null, null, ref result);
#endif

            return ReturnCode.Ok;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ITrace
        public ReturnCode GetTrace(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref ITrace trace,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetTrace(
                        token, lookupFlags, ref name, ref trace,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid trace token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid trace token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetTrace(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref ITrace trace,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetTrace(
                        name, lookupFlags, ref token, ref trace,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid trace name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid trace name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: All traces added via this method overload are global (i.e.
        //       interpreter-wide).
        //
        public ReturnCode AddTrace(
            TraceCallback callback,
            IPlugin plugin,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                ITrace trace = ScriptOps.NewCoreTrace(
                    callback, clientData, TraceFlags.Global, plugin,
                    ref result);

                if (traces != null)
                {
                    if (AddTrace(
                            trace, clientData, ref token,
                            ref result) == ReturnCode.Ok)
                    {
                        result = trace.Name;
                        return ReturnCode.Ok;
                    }
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddTrace(
            ITrace trace,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (trace == null)
                {
                    result = "invalid trace";
                    return ReturnCode.Error;
                }

                string name = trace.Name;

                if (name == null)
                {
                    result = "invalid trace name";
                    return ReturnCode.Error;
                }

                if (!HasTraces(ref result))
                    return ReturnCode.Error;

                if (DoesTraceExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: trace already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    bool success = false;
                    _Wrappers.Trace wrapper = null;

                    try
                    {
                        long id = EntityOps.NextTokenIdNoThrow(trace);
                        wrapper = new _Wrappers.Trace(id, trace);

                        //
                        // NOTE: Are we allowed to assist in managing the trace
                        //       token via the associated plugin?
                        //
                        long newToken = EntityOps.GetToken(wrapper);

                        if (!EntityOps.IsNoToken(trace))
                        {
                            //
                            // NOTE: Store the trace token so that we can remove
                            //       them later without using their names (which
                            //       can change).
                            //
                            IPluginData pluginData = trace.Plugin;

                            if (pluginData != null)
                            {
                                LongList tokens = pluginData.TraceTokens;

                                if ((tokens != null) && !tokens.Contains(newToken))
                                {
                                    tokens.Add(newToken);

#if ISOLATED_PLUGINS
                                    //
                                    // HACK: Force the trace tokens for the
                                    //       isolated plugin to be updated.
                                    //
                                    if (AppDomainOps.IsIsolated(pluginData))
                                        pluginData.TraceTokens = tokens;
#endif
                                }
                            }
                        }

                        EntityOps.SetToken(trace, newToken);

                        traces.Add(name, wrapper);
                        success = true;

#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Trace, NotifyFlags.Added,
                            new ObjectPair(trace, newToken), this,
                            clientData, null, null, ref result);
#endif

                        token = newToken;
                    }
                    finally
                    {
                        if (!success && (wrapper != null))
                        {
                            wrapper.Dispose();
                            wrapper = null;
                        }
                    }
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveTrace(
            long token,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasTraces(ref result))
                {
                    string name = null;
                    ITrace trace = null;

                    if (GetTrace(token, LookupFlags.Remove, ref name,
                            ref trace, ref result) == ReturnCode.Ok)
                    {
                        if (!EntityOps.IsReadOnly(trace))
                        {
                            return PrivateRemoveTrace(
                                name, token, trace, clientData, ref result);
                        }
                        else
                        {
                            result = "trace is read-only";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveTrace(
            string name,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasTraces(ref result))
                {
                    long token = 0;
                    ITrace trace = null;

                    if (GetTrace(name, LookupFlags.Remove, ref token,
                            ref trace, ref result) == ReturnCode.Ok)
                    {
                        if (!EntityOps.IsReadOnly(trace))
                        {
                            return PrivateRemoveTrace(
                                name, token, trace, clientData, ref result);
                        }
                        else
                        {
                            result = "trace is read-only";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private ReturnCode PrivateGetTrace(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref ITrace trace,
            ref Result error
            )
        {
            if (!HasTraces(ref error))
                return ReturnCode.Error;

            _Wrappers.Trace wrapper;

            if (!traces.TryGetValue(token, out wrapper))
            {
                error = "trace not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                trace = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((trace == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid trace";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid trace wrapper";
                    return ReturnCode.Error;
                }

                trace = wrapper.trace;
                name = EntityOps.GetName(trace);

                if ((trace == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid trace";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetTrace(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref ITrace trace,
            ref Result error
            )
        {
            if (!HasTraces(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid trace name";
                return ReturnCode.Error;
            }

            _Wrappers.Trace wrapper;

            if (!traces.TryGetValue(name, out wrapper))
            {
                error = "trace not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                trace = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((trace == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid trace";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid trace wrapper";
                    return ReturnCode.Error;
                }

                trace = wrapper.trace;
                token = EntityOps.GetToken(trace);

                if ((trace == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid trace";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetTrace(
            string name,
            LookupFlags lookupFlags,
            ref ITrace trace,
            ref Result error
            )
        {
            long token = 0;

            return GetTrace(name, lookupFlags, ref token, ref trace, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddTrace(
            ITrace trace,
            IClientData clientData,
            ref Result result
            )
        {
            long token = 0;

            return AddTrace(trace, clientData, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRemoveTrace(
            string name,
            long token,
            ITrace trace,
            IClientData clientData,
            ref Result result
            )
        {
            if (name == null)
            {
                result = "invalid trace name";
                return ReturnCode.Error;
            }

            traces.Remove(name, token);

            if (trace != null)
            {
                //
                // NOTE: Are we allowed to assist in managing the trace
                //       token via the associated plugin?
                //
                bool noToken = EntityOps.IsNoToken(trace);

                if (!noToken)
                {
                    //
                    // NOTE: If this trace is being managed by a plugin,
                    //       remove the associated token from said plugin.
                    //
                    IPluginData pluginData = trace.Plugin;

                    if (pluginData != null)
                    {
                        LongList tokens = pluginData.TraceTokens;

                        if ((tokens != null) && tokens.Contains(token))
                        {
                            tokens.Remove(token);

#if ISOLATED_PLUGINS
                            //
                            // HACK: Force the trace tokens for the
                            //       isolated plugin to be updated.
                            //
                            if (AppDomainOps.IsIsolated(pluginData))
                                pluginData.TraceTokens = tokens;
#endif
                        }
                    }
                }
            }

#if NOTIFY
            /* IGNORED */
            CheckNotification(
                NotifyType.Trace, NotifyFlags.Removed,
                new ObjectTriplet(trace, name, token), this,
                clientData, null, null, ref result);
#endif

            return ReturnCode.Ok;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IAlias
        public ReturnCode GetAlias(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IAlias alias,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetAlias(
                        token, lookupFlags, ref name, ref alias,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid alias token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid alias token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetAlias(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IAlias alias,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetAlias(
                        name, lookupFlags, ref token, ref alias,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid alias name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid alias name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddAlias(
            string name,
            CommandFlags commandFlags,
            AliasFlags aliasFlags,
            IClientData clientData,
            Interpreter targetInterpreter,
            IExecute target,
            ArgumentList arguments,
            OptionDictionary options,
            int startIndex,
            ref long token,
            ref IAlias alias,
            ref Result result
            )
        {
            CheckDisposed();

            INamespace currentNamespace = null;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (AreNamespacesEnabled())
                {
                    if (GetCurrentNamespaceViaResolvers(
                            null, LookupFlags.Default, ref currentNamespace,
                            ref result) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }
                }
            }

            //
            // NOTE: Create the new alias with a unique name token (which may
            //       be the same as the name).
            //
            IAlias newAlias = RuntimeOps.NewAlias(
                ScriptOps.MakeCommandName(name), commandFlags, aliasFlags,
                clientData, GetAliasNameToken(name), this, targetInterpreter,
                currentNamespace, currentNamespace, target, arguments, options,
                startIndex);

            //
            // NOTE: For now, rely entirely upon the logic in AddCommand.
            //       Eventually, we may want to perform some specialized
            //       argument validation here, especially if safe interpreters
            //       are going to be implemented.
            //
            ReturnCode code = AddAliasAndCommand(
                newAlias, null, ref token, ref result);

            if (code == ReturnCode.Ok)
            {
                alias = newAlias;
                result = newAlias.NameToken;
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddAlias(
            IAlias alias,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (alias == null)
                {
                    result = "invalid alias";
                    return ReturnCode.Error;
                }

                string name = alias.NameToken;

                if (name == null)
                {
                    result = "invalid alias name";
                    return ReturnCode.Error;
                }

                if (!HasAliases(ref result))
                    return ReturnCode.Error;

                if (DoesAliasExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: alias already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    bool success = false;
                    _Wrappers.Alias wrapper = null;

                    try
                    {
                        long id = EntityOps.NextTokenIdNoThrow(alias);
                        wrapper = new _Wrappers.Alias(id, alias);

                        aliases.Add(name, wrapper);
                        success = true;

                        long newToken = EntityOps.GetToken(wrapper);
                        EntityOps.SetToken(alias, newToken);

#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Alias, NotifyFlags.Added,
                            new ObjectPair(alias, newToken), this,
                            clientData, null, null, ref result);
#endif

                        token = newToken;
                    }
                    finally
                    {
                        if (!success && (wrapper != null))
                        {
                            wrapper.Dispose();
                            wrapper = null;
                        }
                    }
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal ReturnCode ListAliases(
            string pattern,
            bool noCase,
            bool all,
            ref StringList list,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasAliases(ref error))
                {
                    AliasFlags notHasFlags = all ?
                        AliasFlags.None : AliasFlags.Namespace;

                    return aliases.ToList(
                        AliasFlags.None, notHasFlags, false, false, pattern,
                        noCase, ref list, ref error);
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetAlias(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IAlias alias,
            ref Result error
            )
        {
            if (!HasAliases(ref error))
                return ReturnCode.Error;

            _Wrappers.Alias wrapper;

            if (!aliases.TryGetValue(token, out wrapper))
            {
                error = "alias not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                alias = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((alias == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid alias";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid alias wrapper";
                    return ReturnCode.Error;
                }

                alias = wrapper.alias;
                name = EntityOps.GetName(alias);

                if ((alias == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid alias";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetAlias(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IAlias alias,
            ref Result error
            )
        {
            if (!HasAliases(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid alias name";
                return ReturnCode.Error;
            }

            _Wrappers.Alias wrapper;

            if (!aliases.TryGetValue(name, out wrapper))
            {
                error = "alias not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                alias = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((alias == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid alias";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid alias wrapper";
                    return ReturnCode.Error;
                }

                alias = wrapper.alias;
                token = EntityOps.GetToken(alias);

                if ((alias == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid alias";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetAlias(
            string name,
            LookupFlags lookupFlags,
            ref IAlias alias
            )
        {
            Result error = null;

            return GetAlias(name, lookupFlags, ref alias, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetAlias(
            string name,
            LookupFlags lookupFlags,
            ref IAlias alias,
            ref Result error
            )
        {
            long token = 0;

            return GetAlias(name, lookupFlags, ref token, ref alias, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddAlias(
            string name,
            CommandFlags commandFlags,
            AliasFlags aliasFlags,
            IClientData clientData,
            Interpreter targetInterpreter,
            IExecute target,
            ArgumentList arguments,
            OptionDictionary options,
            int startIndex,
            ref Result result
            )
        {
            long token = 0;

            return AddAlias(
                name, commandFlags, aliasFlags, clientData, targetInterpreter,
                target, arguments, options, startIndex, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddAlias(
            string name,
            CommandFlags commandFlags,
            AliasFlags aliasFlags,
            IClientData clientData,
            Interpreter targetInterpreter,
            IExecute target,
            ArgumentList arguments,
            OptionDictionary options,
            int startIndex,
            ref long token,
            ref Result result
            )
        {
            IAlias alias = null;

            return AddAlias(
                name, commandFlags, aliasFlags, clientData, targetInterpreter, target,
                arguments, options, startIndex, ref token, ref alias, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddAlias(
            string name,
            CommandFlags commandFlags,
            AliasFlags aliasFlags,
            IClientData clientData,
            Interpreter targetInterpreter,
            IExecute target,
            ArgumentList arguments,
            OptionDictionary options,
            int startIndex,
            ref IAlias alias,
            ref Result result
            )
        {
            long token = 0;

            return AddAlias(
                name, commandFlags, aliasFlags, clientData, targetInterpreter, target,
                arguments, options, startIndex, ref token, ref alias, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RenameAlias(
            IAlias alias,
            string newName,
            ref Result result
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (alias == null)
                {
                    result = "invalid alias";
                    return ReturnCode.Error;
                }

                string oldName = alias.NameToken; /* HACK: Confusing. */

                if (oldName == null)
                {
                    result = "invalid old alias name";
                    return ReturnCode.Error;
                }

                if (newName == null)
                {
                    result = "invalid new object name";
                    return ReturnCode.Error;
                }

                if (!HasAliases(ref result))
                    return ReturnCode.Error;

                if (DoesAliasExist(newName) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't rename {0}: alias already exists",
                        FormatOps.WrapOrNull(newName));

                    return ReturnCode.Error;
                }

                string oldNameToken = oldName;
                _Wrappers.Alias wrapper;

                if (!aliases.TryGetValue(oldNameToken, out wrapper))
                {
                    result = String.Format(
                        "can't rename {0}: alias does not exist",
                        FormatOps.WrapOrNull(oldNameToken));

                    return ReturnCode.Error;
                }

                IAlias localAlias = wrapper.alias;

                if (!Object.ReferenceEquals(alias, localAlias))
                {
                    result = String.Format(
                        "can't rename {0}: alias mismatch",
                        FormatOps.WrapOrNull(oldNameToken));

                    return ReturnCode.Error;
                }

                string newNameToken = GetAliasNameToken(newName);

                alias.Name = newName;
                alias.NameToken = newNameToken;

                /* IGNORED */
                aliases.Rename(oldNameToken, newNameToken);

#if NOTIFY
                /* IGNORED */
                CheckNotification(
                    NotifyType.Alias, NotifyFlags.Renamed,
                    new ObjectTriplet(alias, oldNameToken, newNameToken),
                    this, clientData, null, null, ref result);
#endif
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRemoveAlias(
            string name,
            long token,
            IAlias alias,
            IClientData clientData,
            ref Result result
            )
        {
            if (name == null)
            {
                result = "invalid alias name";
                return ReturnCode.Error;
            }

            if ((alias != null) &&
                FlagOps.HasFlags(alias.AliasFlags, AliasFlags.Reference, true))
            {
                if (RemoveObjectReference(
                        ReturnCode.Ok, name, ObjectReferenceType.Command,
                        false, ref result) == ReturnCode.Ok)
                {
                    alias.AliasFlags &= ~AliasFlags.Reference;
                }
                else
                {
                    return ReturnCode.Error;
                }
            }

            //
            // BUGFIX: Remove the interpreter disposal callback delegate for this
            //         alias from the list of interpreter disposal callbacks in
            //         the target interpreter since the alias is being removed.
            //
            RemoveTargetDisposeCallback(alias);
            aliases.Remove(name, token);

            if (alias != null)
            {
                //
                // NOTE: Prevent the command from trying to cleanup
                //       the alias since it has now been deleted.
                //
                alias.NameToken = null;
            }

#if NOTIFY
            /* IGNORED */
            CheckNotification(
                NotifyType.Alias, NotifyFlags.Removed,
                new ObjectTriplet(alias, name, token), this,
                clientData, null, null, ref result);
#endif

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveAlias(
            long token,
            IClientData clientData,
            ref Result result
            ) /* NOT USED */
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasAliases(ref result))
                {
                    string name = null;
                    IAlias alias = null;

                    if (GetAlias(token, LookupFlags.Remove, ref name,
                            ref alias, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemoveAlias(
                            name, token, alias, clientData, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveAlias(
            string name,
            IClientData clientData,
            ref Result result
            )
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasAliases(ref result))
                {
                    long token = 0;
                    IAlias alias = null;

                    if (GetAlias(name, LookupFlags.Remove, ref token,
                            ref alias, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemoveAlias(
                            name, token, alias, clientData, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IFunction
        public ReturnCode GetFunction(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IFunction function,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetFunction(
                        token, lookupFlags, ref name, ref function,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid function token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid function token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetFunction(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IFunction function,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetFunction(
                        name, lookupFlags, ref token, ref function,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid function name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid function name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ListFunctions(
            FunctionFlags hasFlags,
            FunctionFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                Result localError = null;

                if (HasFunctions(ref localError))
                {
                    code = functions.ToList(
                        hasFlags, notHasFlags, hasAll, notHasAll,
                        pattern, noCase, ref list, ref error);
                }
                else if (strict)
                {
                    error = localError;
                }
                else
                {
                    if (list == null)
                        list = new StringList();

                    code = ReturnCode.Ok;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddFunction(
            Type type,
            string name,
            int arguments,
            TypeList types,
            FunctionFlags flags,
            IPlugin plugin,
            IClientData clientData,
            bool strict,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            if (type == null)
            {
                type = Type.GetType(
                    FormatOps.FunctionTypeName(name, false), false,
                    true);
            }

            if (type == null)
            {
                type = Type.GetType(FormatOps.FunctionTypeName(
                    Characters.Underscore + name, false), false,
                    true);
            }

            if (type != null)
            {
                FunctionFlags functionFlags =
                    AttributeOps.GetFunctionFlags(type) | flags;

                AddEntityClientData addEntityClientData =
                    new AddEntityClientData(null, this);

                bool createSafe = addEntityClientData.CreateSafe;
                bool createStandard = addEntityClientData.CreateStandard;

                //
                // NOTE: Check if this function has been marked as "safe" or
                //       "unsafe" by its author.
                //
                bool safe = FlagOps.HasFlags(functionFlags,
                        FunctionFlags.Safe, true) &&
                    !FlagOps.HasFlags(functionFlags,
                        FunctionFlags.Unsafe, true);

                //
                // NOTE: If the interpreter is "safe", make sure we only add
                //       functions that are marked as "safe" and NOT marked
                //       as "unsafe" unless we are merely hiding functions
                //       not considered to be "safe".  In that case, we add
                //       all functions, hidden them as necessary.
                //
                if (safe || !createSafe)
                {
                    //
                    // NOTE: Check if this function is part of the "Tcl Standard"
                    //       (i.e. it is largely (or completely) compatible with
                    //       an identically named function from Tcl/Tk 8.4, 8.5,
                    //       and/or 8.6).
                    //
                    bool standard = FlagOps.HasFlags(
                        functionFlags, FunctionFlags.Standard, true);

                    //
                    // NOTE: If the interpreter is "standard", make sure we only
                    //       add functions that are marked as "standard" and NOT
                    //       marked as "non-standard" unless we are merely hiding
                    //       functions not considered to be "standard".  In that
                    //       case, we add all functions, hidden them as necessary.
                    //
                    if (standard || !createStandard)
                    {
                        try
                        {
                            if (arguments == (int)Arity.Automatic)
                                arguments = AttributeOps.GetArguments(type);

                            object[] args = {
                                new FunctionData(
                                    name, null, null, clientData, type.FullName,
                                    arguments, types, flags, plugin, 0)
                            };

                            IFunction function =
                                (IFunction)Activator.CreateInstance(type, args);

                            return AddFunction(
                                function, null, ref token, ref result);
                        }
                        catch (Exception e)
                        {
                            result = e;
                        }
                    }
                    else if (strict)
                    {
                        result = "cannot add non-standard function to standard interpreter";
                    }
                    else
                    {
                        return ReturnCode.Ok;
                    }
                }
                else if (strict)
                {
                    result = "cannot add unsafe function to safe interpreter";
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                result = String.Format(
                    "function {0} not found",
                    FormatOps.FunctionTypeName(name, true));
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddFunction(
            IFunction function,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (function == null)
                {
                    result = "invalid function";
                    return ReturnCode.Error;
                }

                string name = function.Name;

                if (name == null)
                {
                    result = "invalid function name";
                    return ReturnCode.Error;
                }

                if (!HasFunctions(ref result))
                    return ReturnCode.Error;

                if (DoesFunctionExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: function already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                //
                // HACK: Due to how the expression parser works, we cannot allow a
                //       function to be added that has the name of an existing
                //       operator.
                //
                if (DoesOperatorExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: operator already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                if (!FlagOps.HasFlags(
                        function.Flags, FunctionFlags.NoTclMathFunction, true) &&
                    /* EXEMPT */
                    FlagOps.HasFlags(
                        interpreterFlags, InterpreterFlags.TclMathFunctions, true))
                {
                    //
                    // HACK: This is part of an ugly hack to add "tcl::mathfunc::*" and
                    //       "tcl::mathop::*" support for [expr] functions and operators
                    //       to Eagle, respectively.  This can only be done for function
                    //       instances that also implmement the IExecute interface.
                    //
                    IExecute execute = function as IExecute;
                    long token2; /* REUSED */

                    if (execute != null)
                    {
                        if (AreNamespacesEnabled())
                        {
                            INamespace @namespace = NamespaceOps.Lookup(
                                this, TclVars.Namespace.MathFunctionName, true, true,
                                ref result);

                            if (@namespace == null)
                                return ReturnCode.Error;

                            string qualifiedName = NamespaceOps.MakeQualifiedName(
                                this, @namespace, name);

                            if (ApplyRuleSet(IdentifierKind.Command,
                                    ScriptOps.MakeCommandName(qualifiedName)))
                            {
                                token2 = 0; /* NOT USED */

                                if (AddIExecute(
                                        qualifiedName, execute, clientData,
                                        ref token2, ref result) != ReturnCode.Ok)
                                {
                                    return ReturnCode.Error;
                                }
                            }
                        }
                        else
                        {
                            string unqualifiedName = NamespaceOps.MakeName(
                                TclVars.Namespace.MathFunctionName, name, true,
                                false);

                            if (ApplyRuleSet(IdentifierKind.Command,
                                    ScriptOps.MakeCommandName(unqualifiedName)))
                            {
                                token2 = 0; /* NOT USED */

                                if (AddIExecute(
                                        unqualifiedName, execute, clientData,
                                        ref token2, ref result) != ReturnCode.Ok)
                                {
                                    return ReturnCode.Error;
                                }
                            }
                        }
                    }
                }

                ReturnCode code = ReturnCode.Ok;

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    try
                    {
                        try
                        {
                            code = function.Initialize(this,
                                (clientData != null) ? clientData : function.ClientData,
                                ref result);
                        }
                        catch (Exception e)
                        {
                            result = String.Format(
                                "caught exception while initializing function: {0}",
                                e);

                            code = ReturnCode.Error;
                        }
                    }
                    finally
                    {
                        if (code != ReturnCode.Ok)
                        {
                            ReturnCode terminateCode;
                            Result terminateResult = null;

                            terminateCode = TerminateFunction(
                                function, clientData, ref terminateResult);

                            if (terminateCode != ReturnCode.Ok)
                            {
                                DebugOps.Complain(
                                    this, terminateCode, terminateResult);
                            }
                        }
                    }

                    if (code != ReturnCode.Ok)
                        return code;

                    bool success = false;
                    _Wrappers.Function wrapper = null;

                    try
                    {
                        long id = EntityOps.NextTokenIdNoThrow(function);
                        wrapper = new _Wrappers.Function(id, function);

                        //
                        // NOTE: Are we allowed to assist in managing the function
                        //       token via the associated plugin?
                        //
                        long newToken = EntityOps.GetToken(wrapper);

                        if (!EntityOps.IsNoToken(function))
                        {
                            //
                            // NOTE: Store the function token so that we can remove
                            //       them later without using their names (which
                            //       can change).
                            //
                            IPluginData pluginData = function.Plugin;

                            if (pluginData != null)
                            {
                                LongList tokens = pluginData.FunctionTokens;

                                if ((tokens != null) && !tokens.Contains(newToken))
                                {
                                    tokens.Add(newToken);

#if ISOLATED_PLUGINS
                                    //
                                    // HACK: Force the function tokens for the
                                    //       isolated plugin to be updated.
                                    //
                                    if (AppDomainOps.IsIsolated(pluginData))
                                        pluginData.FunctionTokens = tokens;
#endif
                                }
                            }
                        }

                        EntityOps.SetToken(function, newToken);

                        functions.Add(name, wrapper);
                        success = true;

#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Function, NotifyFlags.Added,
                            new ObjectPair(function, newToken), this,
                            clientData, null, null, ref result);
#endif

                        token = newToken;
                    }
                    finally
                    {
                        if (!success && (wrapper != null))
                        {
                            wrapper.Dispose();
                            wrapper = null;
                        }
                    }
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }

                return code;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveFunction(
            long token,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasFunctions(ref result))
                {
                    string name = null;
                    IFunction function = null;

                    if (GetFunction(token, LookupFlags.Remove, ref name,
                            ref function, ref result) == ReturnCode.Ok)
                    {
                        if (!EntityOps.IsReadOnly(function))
                        {
                            return PrivateRemoveFunction(
                                name, token, function, clientData, ref result);
                        }
                        else
                        {
                            result = "function is read-only";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveFunction(
            string name,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasFunctions(ref result))
                {
                    long token = 0;
                    IFunction function = null;

                    if (GetFunction(name, LookupFlags.Remove, ref token,
                            ref function, ref result) == ReturnCode.Ok)
                    {
                        if (!EntityOps.IsReadOnly(function))
                        {
                            return PrivateRemoveFunction(
                                name, token, function, clientData, ref result);
                        }
                        else
                        {
                            result = "function is read-only";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private ReturnCode PrivateGetFunction(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IFunction function,
            ref Result error
            )
        {
            if (!HasFunctions(ref error))
                return ReturnCode.Error;

            _Wrappers.Function wrapper;

            if (!functions.TryGetValue(token, out wrapper))
            {
                error = "function not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                function = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((function == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid function wrapper";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid function wrapper";
                    return ReturnCode.Error;
                }

                function = wrapper.function;
                name = EntityOps.GetName(function);

                if ((function == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetFunction(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IFunction function,
            ref Result error
            )
        {
            if (!HasFunctions(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid function name";
                return ReturnCode.Error;
            }

            _Wrappers.Function wrapper;

            if (!functions.TryGetValue(name, out wrapper))
            {
                error = "function not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                function = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((function == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid function";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid function wrapper";
                    return ReturnCode.Error;
                }

                function = wrapper.function;
                token = EntityOps.GetToken(function);

                if ((function == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid function";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetFunction(
            string name,
            LookupFlags lookupFlags,
            ref IFunction function,
            ref Result error
            )
        {
            long token = 0;

            return GetFunction(name, lookupFlags, ref token, ref function, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetExpressionFunction(
            string name,
            ref IFunction function,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (functions == null)
                {
                    error = "functions not available";
                    return ReturnCode.Error;
                }

                if (name == null)
                {
                    error = "invalid function name";
                    return ReturnCode.Error;
                }

                _Wrappers.Function wrapper;

                if (!functions.TryGetValue(name, out wrapper))
                {
                    error = String.Format(
                        "invalid function name {0}",
                        FormatOps.DisplayName(name));

                    return ReturnCode.Error;
                }

                if (wrapper == null)
                {
                    error = "invalid function wrapper";
                    return ReturnCode.Error;
                }

                function = wrapper.function;

                if (function == null)
                {
                    error = "invalid function";
                    return ReturnCode.Error;
                }

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddFunction(
            IFunction function,
            IClientData clientData,
            ref Result result
            )
        {
            long token = 0;

            return AddFunction(function, clientData, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddFunction(
            Type type,
            string name,
            TypeList types,
            FunctionFlags flags,
            IPlugin plugin,
            IClientData clientData,
            bool strict,
            ref Result result
            )
        {
            long token = 0;

            return AddFunction(
                type, name, types, flags, plugin, clientData,
                strict, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddFunction(
            Type type,
            string name,
            TypeList types,
            FunctionFlags flags,
            IPlugin plugin,
            IClientData clientData,
            bool strict,
            ref long token,
            ref Result result
            )
        {
            return AddFunction(
                type, name, (int)Arity.Automatic, types, flags,
                plugin, clientData, strict, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRemoveFunction(
            string name,
            long token,
            IFunction function,
            IClientData clientData,
            ref Result result
            )
        {
            if (name == null)
            {
                result = "invalid function name";
                return ReturnCode.Error;
            }

            if (((function == null) || !FlagOps.HasFlags(
                    function.Flags, FunctionFlags.NoTclMathFunction, true)) &&
                /* EXEMPT */
                FlagOps.HasFlags(
                    interpreterFlags, InterpreterFlags.TclMathFunctions, true))
            {
                //
                // HACK: This is part of an ugly hack to add "tcl::mathfunc::*" and
                //       "tcl::mathop::*" support for [expr] functions and operators
                //       to Eagle, respectively.  This can only be done for function
                //       instances that also implmement the IExecute interface.
                //
                if (AreNamespacesEnabled())
                {
                    //
                    // BUGBUG: If any of the parent namespaces are already deleted,
                    //         we should skip doing removal of associated commands.
                    //         That checking should not be necessary; however, it
                    //         could be if any of those deleted namespaces are also
                    //         disposed.
                    //
                    INamespace @namespace = NamespaceOps.Lookup(
                        this, TclVars.Namespace.MathFunctionName, true, false);

                    if (@namespace != null)
                    {
                        string qualifiedName = NamespaceOps.MakeQualifiedName(
                            this, @namespace, name);

                        if ((DoesIExecuteExist(
                                qualifiedName) == ReturnCode.Ok) &&
                            (RemoveIExecute(
                                qualifiedName, clientData,
                                ref result) != ReturnCode.Ok))
                        {
                            return ReturnCode.Error;
                        }
                    }
                }
                else
                {
                    string unqualifiedName = NamespaceOps.MakeName(
                        TclVars.Namespace.MathFunctionName, name, true,
                        false);

                    if ((DoesIExecuteExist(
                            unqualifiedName) == ReturnCode.Ok) &&
                        (RemoveIExecute(
                            unqualifiedName, clientData,
                            ref result) != ReturnCode.Ok))
                    {
                        return ReturnCode.Error;
                    }
                }
            }

            GlobalState.PushActiveInterpreter(this);

            try
            {
                if ((function == null) || (TerminateFunction(
                        function, clientData, ref result) == ReturnCode.Ok))
                {
                    functions.Remove(name, token);

                    if (function != null)
                    {
                        //
                        // NOTE: Are we allowed to assist in managing the function
                        //       token via the associated plugin?
                        //
                        bool noToken = EntityOps.IsNoToken(function);

                        if (!noToken)
                        {
                            //
                            // NOTE: If this function is being managed by a plugin,
                            //       remove the associated token from said plugin.
                            //
                            IPluginData pluginData = function.Plugin;

                            if (pluginData != null)
                            {
                                LongList tokens = pluginData.FunctionTokens;

                                if ((tokens != null) && tokens.Contains(token))
                                {
                                    tokens.Remove(token);

#if ISOLATED_PLUGINS
                                    //
                                    // HACK: Force the function tokens for the
                                    //       isolated plugin to be updated.
                                    //
                                    if (AppDomainOps.IsIsolated(pluginData))
                                        pluginData.FunctionTokens = tokens;
#endif
                                }
                            }
                        }
                    }

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.Function, NotifyFlags.Removed,
                        new ObjectTriplet(function, name, token), this,
                        clientData, null, null, ref result);
#endif

                    return ReturnCode.Ok;
                }

                return ReturnCode.Error;
            }
            catch (Exception e)
            {
                result = String.Format(
                    "caught exception while removing function: {0}",
                    e);

                return ReturnCode.Error;
            }
            finally
            {
                /* IGNORED */
                GlobalState.PopActiveInterpreter();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode TerminateFunction(
            IFunction function,
            IClientData clientData,
            ref Result result
            )
        {
            if (function == null)
            {
                result = "invalid function";
                return ReturnCode.Error;
            }

            bool savedImmutable = BeginMutableExecution();

            ReturnCode code;

            try
            {
                code = function.Terminate(this,
                    (clientData != null) ? clientData : function.ClientData,
                    ref result);

#if NOTIFY
                /* IGNORED */
                CheckNotification(
                    NotifyType.Function, NotifyFlags.Terminated,
                    new ObjectTriplet(function, code), this,
                    clientData, null, null, ref result);
#endif
            }
            catch (Exception e)
            {
                result = String.Format(
                    "caught exception while terminating function: {0}",
                    e);

                code = ReturnCode.Error;
            }
            finally
            {
                EndMutableExecution(savedImmutable);
            }

            return code;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IProcedure
        public ReturnCode GetProcedure(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IProcedure procedure,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetProcedure(
                        token, lookupFlags, ref name, ref procedure,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid procedure token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid procedure token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetProcedure(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IProcedure procedure,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetProcedure(
                        name, lookupFlags, ref token, ref procedure,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid procedure name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid procedure name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ListProcedures(
            ProcedureFlags hasFlags,
            ProcedureFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                Result localError = null;

                if (HasProcedures(ref localError))
                {
                    if (AreNamespacesEnabled())
                    {
                        INamespace currentNamespace = null;

                        code = GetCurrentNamespaceViaResolvers(
                            null, LookupFlags.Default, ref currentNamespace,
                            ref error);

                        if (code == ReturnCode.Ok)
                        {
                            StringList[] localLists = { null, null };

                            code = procedures.ToList(
                                hasFlags, notHasFlags, hasAll, notHasAll,
                                null, false, ref localLists[0], ref error);

                            if (code == ReturnCode.Ok)
                            {
                                code = MatchItems(
                                    currentNamespace, pattern, noCase,
                                    ref localLists, ref error);

                                if (code == ReturnCode.Ok)
                                {
                                    if (list == null)
                                        list = localLists[1];
                                    else
                                        list.AddRange(localLists[1]);
                                }
                            }
                        }
                    }
                    else
                    {
                        pattern = ScriptOps.MakeCommandName(pattern);

                        code = procedures.ToList(
                            hasFlags, notHasFlags, hasAll, notHasAll,
                            pattern, noCase, ref list, ref error);
                    }
                }
                else if (strict)
                {
                    error = localError;
                }
                else
                {
                    if (list == null)
                        list = new StringList();

                    code = ReturnCode.Ok;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddOrUpdateProcedure(
            string name,
            ProcedureFlags procedureFlags,
            ArgumentList arguments,
            ArgumentDictionary namedArguments,
            string body,
            IScriptLocation location,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            CheckDisposed();

            IProcedure procedure;
            Result error = null;

            procedure = RuntimeOps.NewProcedure(
                this, ScriptOps.MakeCommandName(name), null, null,
                procedureFlags, arguments, namedArguments, body,
                location, clientData, ref error);

            if (procedure == null)
            {
                result = error;
                return ReturnCode.Error;
            }

            return AddOrUpdateProcedure(procedure, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RenameProcedure(
            string oldName,
            string newName,
            bool delete,
            ref Result result
            )
        {
            CheckDisposed();

            return PrivateRenameProcedure(oldName, newName, false, delete, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RenameHiddenProcedure(
            string oldName,
            string newName,
            bool delete,
            ref Result result
            )
        {
            CheckDisposed();

            return PrivateRenameHiddenProcedure(oldName, newName, false, delete, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveProcedure(
            long token,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                string name = null;
                IProcedure procedure = null;

                if (GetProcedure(token, LookupFlags.Default, ref name,
                        ref procedure, ref result) == ReturnCode.Ok)
                {
                    if (!EntityOps.IsReadOnly(procedure))
                    {
                        if (EntityOps.IsNoRemove(procedure))
                            return ReturnCode.Ok;

                        return PrivateRemoveProcedure(
                            name, token, procedure, clientData,
                            false, ref result);
                    }
                    else
                    {
                        result = "procedure is read-only";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveProcedure(
            string name,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                long token = 0;
                IProcedure procedure = null;

                if (GetProcedure(name, LookupFlags.Default, ref token,
                        ref procedure, ref result) == ReturnCode.Ok)
                {
                    if (!EntityOps.IsReadOnly(procedure))
                    {
                        if (EntityOps.IsNoRemove(procedure))
                            return ReturnCode.Ok;

                        return PrivateRemoveProcedure(
                            name, token, procedure, clientData,
                            false, ref result);
                    }
                    else
                    {
                        result = "procedure is read-only";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode MatchProcedure(
            EngineFlags engineFlags,
            string name,
            LookupFlags lookupFlags,
            ref bool ambiguous,
            ref long token,
            ref IProcedure procedure,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool useHidden = EngineFlagOps.HasUseHidden(engineFlags);
                bool matchHidden = EngineFlagOps.HasMatchHidden(engineFlags);

                ProcedureWrapperDictionary localProcedures =
                    useHidden ? hiddenProcedures : procedures;

                if (localProcedures != null)
                {
                    //
                    // NOTE: *WARNING* Empty command/procedure names are allowed,
                    //       please do not change this to "!String.IsNullOrEmpty".
                    //
                    if (name != null)
                    {
                        if (localProcedures.Count > 0)
                        {
                            _Wrappers.Procedure localProcedure;
                            string exactName = null;
                            StringList list = new StringList();

                            if (localProcedures.TryGetValue(name, out localProcedure) &&
                                (matchHidden || !EntityOps.IsHidden(localProcedure)))
                            {
                                //
                                // NOTE: Exact procedure match.
                                //
                                exactName = name;

                                //
                                // NOTE: Store the exact procedure match in the result
                                //       list.
                                //
                                list.Add(name);
                            }
                            else
                            {
                                foreach (KeyValuePair<string, _Wrappers.Procedure> pair in localProcedures)
                                {
                                    if (SharedStringOps.SystemEquals(pair.Key, 0, name, 0, name.Length))
                                    {
                                        //
                                        // NOTE: Is the procedure visible or are we allowed to
                                        //       find hidden procedures?
                                        //
                                        if (matchHidden || !EntityOps.IsHidden(pair.Value))
                                        {
                                            //
                                            // NOTE: Was the key valid (this should always succeed).
                                            //
                                            if (pair.Key != null)
                                            {
                                                //
                                                // NOTE: It was a match; however, was it an exact match?
                                                //
                                                if (pair.Key.Length == name.Length)
                                                    //
                                                    // NOTE: Preserve match, it may differ in case.
                                                    //
                                                    exactName = pair.Key;

                                                //
                                                // NOTE: Was it an exact match or did we match at least one
                                                //       character in a partial match?
                                                //
                                                if ((pair.Key.Length == name.Length) || (name.Length > 0))
                                                    //
                                                    // NOTE: Store the exact or partial match in the results
                                                    //       dictionary.
                                                    //
                                                    list.Add(pair.Key);
                                            }
                                        }
                                    }
                                }
                            }

                            //
                            // NOTE: If there was an exact match, just use it.
                            //
                            if (exactName != null)
                            {
                                //
                                // NOTE: No need to change the caller's variable,
                                //       it already contains the correct value.
                                //
                                if ((useHidden && PrivateGetHiddenProcedure(
                                        exactName, lookupFlags, ref token,
                                        ref procedure, ref error) == ReturnCode.Ok) ||
                                    (!useHidden && PrivateGetProcedure(
                                        exactName, lookupFlags, ref token,
                                        ref procedure, ref error) == ReturnCode.Ok))
                                {
#if NOTIFY
                                    /* IGNORED */
                                    CheckNotification(
                                        useHidden ? NotifyType.HiddenProcedure : NotifyType.Procedure,
                                        NotifyFlags.Matched | (useHidden ? NotifyFlags.Hidden : NotifyFlags.None),
                                        new ObjectList(engineFlags, name, exactName, procedure, token), this, null, null,
                                        null, ref error);
#endif

                                    return ReturnCode.Ok;
                                }
                            }
                            else if (list.Count == 1)
                            {
                                //
                                // NOTE: Normal case, exactly one procedure matched.
                                //
                                if ((useHidden && PrivateGetHiddenProcedure(
                                        list[0], lookupFlags, ref token,
                                        ref procedure, ref error) == ReturnCode.Ok) ||
                                    (!useHidden && PrivateGetProcedure(
                                        list[0], lookupFlags, ref token,
                                        ref procedure, ref error) == ReturnCode.Ok))
                                {
#if NOTIFY
                                    /* IGNORED */
                                    CheckNotification(
                                        useHidden ? NotifyType.HiddenProcedure : NotifyType.Procedure,
                                        NotifyFlags.Matched | (useHidden ? NotifyFlags.Hidden : NotifyFlags.None),
                                        new ObjectList(engineFlags, name, list[0], procedure, token), this, null, null,
                                        null, ref error);
#endif

                                    return ReturnCode.Ok;
                                }
                            }
                            else if (list.Count > 1)
                            {
                                error = FlagOps.HasFlags(
                                    lookupFlags, LookupFlags.Verbose, true) ?
                                    ScriptOps.BadValue(
                                        "ambiguous", "procedure", name, list,
                                        null, null) :
                                    (Result)"ambiguous procedure";

                                ambiguous = true;
                            }
                            else
                            {
                                error = FlagOps.HasFlags(
                                    lookupFlags, LookupFlags.Verbose, true) ?
                                    ScriptOps.BadValue(
                                        null, "procedure", name, localProcedures.Keys,
                                        null, null) :
                                    (Result)"bad procedure";
                            }
                        }
                        else
                        {
                            error = "no procedures defined";
                        }
                    }
                    else
                    {
                        error = "invalid procedure name";
                    }
                }
                else
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "{0}procedures not available",
                            useHidden ? "hidden " : String.Empty) :
                        "procedures not available";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode MakeProcedureFast(
            string name,
            bool fast,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                IProcedure procedure = null;

                code = GetProcedure(
                    name, LookupFlags.Default, ref procedure, ref error);

                if (code == ReturnCode.Ok)
                {
                    if (fast)
                        procedure.Flags |= ProcedureFlags.Fast;
                    else
                        procedure.Flags &= ~ProcedureFlags.Fast;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode MakeProcedureAtomic(
            string name,
            bool atomic,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                IProcedure procedure = null;

                code = GetProcedure(
                    name, LookupFlags.Default, ref procedure, ref error);

                if (code == ReturnCode.Ok)
                {
                    if (atomic)
                        procedure.Flags |= ProcedureFlags.Atomic;
                    else
                        procedure.Flags &= ~ProcedureFlags.Atomic;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE || PARSE_CACHE
        public ReturnCode MakeProcedureNonCaching(
            string name,
            bool nonCaching,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                IProcedure procedure = null;

                code = GetProcedure(
                    name, LookupFlags.Default, ref procedure, ref error);

                if (code == ReturnCode.Ok)
                {
                    if (nonCaching)
                        procedure.Flags |= ProcedureFlags.NonCaching;
                    else
                        procedure.Flags &= ~ProcedureFlags.NonCaching;
                }
            }

            return code;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal ReturnCode ProceduresToList(
            ProcedureFlags hasFlags,
            ProcedureFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            ref StringList list,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (procedures != null)
                {
                    return procedures.ToList(
                        hasFlags, notHasFlags, hasAll, notHasAll,
                        pattern, noCase, ref list, ref error);
                }
            }

            error = "procedures not available";
            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal StringList GetProceduresReadOnly(
            string pattern,
            bool noCase,
            bool readOnly
            )
        {
            StringList result = new StringList();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (procedures != null)
                {
                    foreach (KeyValuePair<string, _Wrappers.Procedure> pair in procedures)
                    {
                        IProcedure procedure = pair.Value;

                        if (procedure == null)
                            continue;

                        if ((pattern != null) && !StringOps.Match(this,
                                StringOps.DefaultMatchMode, pair.Key,
                                pattern, noCase))
                        {
                            continue;
                        }

                        if (EntityOps.IsReadOnly(procedure) == readOnly)
                            result.Add(pair.Key);
                    }
                }
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int SetProceduresReadOnly(
            string pattern,
            bool noCase,
            bool readOnly
            )
        {
            int result = 0;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (procedures != null)
                {
                    foreach (KeyValuePair<string, _Wrappers.Procedure> pair in procedures)
                    {
                        IProcedure procedure = pair.Value;

                        if (procedure == null)
                            continue;

                        if ((pattern != null) && !StringOps.Match(this,
                                StringOps.DefaultMatchMode, pair.Key,
                                pattern, noCase))
                        {
                            continue;
                        }

                        if (EntityOps.IsReadOnly(procedure) == readOnly)
                            continue;

                        if (EntityOps.SetReadOnly(procedure, readOnly))
                            result++;
                    }
                }
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetProcedure(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IProcedure procedure,
            ref Result error
            )
        {
            if (!HasProcedures(ref error))
                return ReturnCode.Error;

            _Wrappers.Procedure wrapper;

            if (!procedures.TryGetValue(token, out wrapper))
            {
                error = "procedure not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                procedure = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((procedure == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid procedure";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid procedure wrapper";
                    return ReturnCode.Error;
                }

                procedure = wrapper.procedure;
                name = EntityOps.GetName(procedure);

                if ((procedure == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid procedure";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetProcedure(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IProcedure procedure,
            ref Result error
            )
        {
            if (!HasProcedures(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid procedure name";
                return ReturnCode.Error;
            }

            _Wrappers.Procedure wrapper;

            if (!procedures.TryGetValue(name, out wrapper))
            {
                error = "procedure not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                procedure = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((procedure == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid procedure";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid procedure wrapper";
                    return ReturnCode.Error;
                }

                procedure = wrapper.procedure;
                token = EntityOps.GetToken(procedure);

                if ((procedure == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid procedure";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetProcedure(
            string name,
            LookupFlags lookupFlags,
            ref IProcedure procedure
            )
        {
            Result error = null;

            return GetProcedure(name, lookupFlags, ref procedure, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetProcedure(
            string name,
            LookupFlags lookupFlags,
            ref IProcedure procedure,
            ref Result error
            )
        {
            long token = 0;

            return GetProcedure(name, lookupFlags, ref token, ref procedure, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ListProcedures(
            ProcedureFlags hasFlags,
            ProcedureFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list
            )
        {
            Result error = null;

            return ListProcedures(
                hasFlags, notHasFlags, hasAll, notHasAll, pattern, noCase,
                strict, ref list, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ListHiddenProcedures(
            ProcedureFlags hasFlags,
            ProcedureFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list
            )
        {
            Result error = null;

            return ListHiddenProcedures(
                hasFlags, notHasFlags, hasAll, notHasAll, pattern, noCase,
                strict, ref list, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ListHiddenProcedures(
            ProcedureFlags hasFlags,
            ProcedureFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list,
            ref Result error
            )
        {
            // CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                Result localError = null;

                if (HasHiddenProcedures(ref localError))
                {
                    if (AreNamespacesEnabled())
                    {
                        INamespace currentNamespace = null;

                        code = GetCurrentNamespaceViaResolvers(
                            null, LookupFlags.Default, ref currentNamespace,
                            ref error);

                        if (code == ReturnCode.Ok)
                        {
                            StringList[] localLists = { null, null };

                            code = hiddenProcedures.ToList(
                                hasFlags, notHasFlags, hasAll, notHasAll,
                                null, false, ref localLists[0], ref error);

                            if (code == ReturnCode.Ok)
                            {
                                code = MatchItems(
                                    currentNamespace, pattern, noCase,
                                    ref localLists, ref error);

                                if (list == null)
                                    list = localLists[1];
                                else
                                    list.AddRange(localLists[1]);
                            }
                        }
                    }
                    else
                    {
                        pattern = ScriptOps.MakeCommandName(pattern);

                        code = hiddenProcedures.ToList(
                            hasFlags, notHasFlags, hasAll, notHasAll,
                            pattern, noCase, ref list, ref error);
                    }
                }
                else if (strict)
                {
                    error = localError;
                }
                else
                {
                    if (list == null)
                        list = new StringList();

                    code = ReturnCode.Ok;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddOrUpdateProcedureWithReplace(
            IProcedure procedure,
            IClientData clientData,
            ref Result result
            )
        {
            long token = 0;

            return AddOrUpdateProcedureWithReplace(
                procedure, clientData, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddOrUpdateProcedureWithReplace(
            IProcedure procedure,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            if (procedure != null)
            {
                ReturnCode code = AddOrUpdateProcedure(procedure, ref token, ref result);

                if (code == ReturnCode.Ok)
                {
                    try
                    {
                        string name = procedure.Name;

                        if ((code == ReturnCode.Ok) &&
                            (DoesIExecuteExist(name) == ReturnCode.Ok))
                        {
                            code = RemoveIExecute(name, clientData, ref result);
                        }

                        if ((code == ReturnCode.Ok) &&
                            (DoesCommandExist(name) == ReturnCode.Ok))
                        {
                            code = RemoveCommand(name, clientData, ref result);
                        }
                    }
                    finally
                    {
                        //
                        // BUGFIX: If we fail to remove an ICommand or IExecute,
                        //         we must still remove the procedure we just
                        //         added.
                        //
                        if (code != ReturnCode.Ok)
                        {
                            ReturnCode removeCode;
                            Result removeResult = null;

                            removeCode = RemoveProcedure(token, clientData, ref removeResult);

                            if (removeCode != ReturnCode.Ok)
                                DebugOps.Complain(this, removeCode, removeResult);
                        }
                    }
                }

                return code;
            }
            else
            {
                result = "invalid procedure";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddOrUpdateProcedure(
            IProcedure procedure,
            ref long token,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (procedure == null)
                {
                    result = "invalid procedure";
                    return ReturnCode.Error;
                }

                string name = procedure.Name;

                if (name == null)
                {
                    result = "invalid procedure name";
                    return ReturnCode.Error;
                }

                if (!HasProcedures(ref result))
                    return ReturnCode.Error;

                /* EXEMPT */
                if (FlagOps.HasFlags(interpreterFlags,
                        InterpreterFlags.DoesNonProcedureExist, true))
                {
                    IdentifierKind kind = IdentifierKind.None;

                    if ((DoesIExecuteExistViaResolvers(
                            name, ref kind) == ReturnCode.Ok) &&
                        !EntityOps.IsProcedure(kind))
                    {
                        result = String.Format(
                            "can't add {0}: non-procedure already exists",
                            FormatOps.WrapOrNull(name));

                        return ReturnCode.Error;
                    }
                }

                Result localError = null;

                if (AreNamespacesEnabled() && (NamespaceOps.LookupParent(
                        this, name, false, true, false, ref localError) == null))
                {
                    result = String.Format(
                        "can't add procedure {0}: {1}",
                        FormatOps.WrapOrNull(name),
                        localError);

                    return ReturnCode.Error;
                }

                _Wrappers.Procedure oldProcedureWrapper = null;
                bool exists = procedures.TryGetValue(name, out oldProcedureWrapper);

                if (exists)
                {
                    if (immutable)
                    {
                        result = "interpreter is immutable";
                        return ReturnCode.Error;
                    }

                    if (EntityOps.IsReadOnly(oldProcedureWrapper))
                    {
                        result = "procedure is read-only";
                        return ReturnCode.Error;
                    }

                    if (EntityOps.IsNoReplace(oldProcedureWrapper))
                        return ReturnCode.Ok;
                }

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    bool success = false;
                    _Wrappers.Procedure wrapper = null;

                    try
                    {
                        long id = EntityOps.NextTokenIdNoThrow(procedure);
                        wrapper = new _Wrappers.Procedure(id, procedure);

                        long newToken = EntityOps.GetToken(wrapper);
                        EntityOps.SetToken(procedure, newToken);

                        if (exists)
                        {
                            procedures[name] = wrapper;
                            success = true;

#if EXECUTE_CACHE
                            AddOrUpdateIExecuteToCache(name, wrapper, false, false);
#endif

#if NOTIFY
                            /* IGNORED */
                            CheckNotification(
                                NotifyType.Procedure, NotifyFlags.Updated,
                                new ObjectPair(oldProcedureWrapper, procedure), this,
                                null, null, null, ref result);
#endif
                        }
                        else if ((procedureLimit == 0) || (procedures.Count < procedureLimit))
                        {
                            procedures.Add(name, wrapper);
                            success = true;

#if EXECUTE_CACHE
                            AddOrUpdateIExecuteToCache(name, wrapper, false, false);
#endif

#if NOTIFY
                            /* IGNORED */
                            CheckNotification(
                                NotifyType.Procedure, NotifyFlags.Added,
                                new ObjectPair(procedure, newToken), this,
                                null, null, null, ref result);
#endif
                        }
                        else
                        {
                            result = String.Format(
                                "can't add procedure {0}: limit exceeded",
                                FormatOps.WrapOrNull(name));

                            return ReturnCode.Error;
                        }

                        token = newToken;
                    }
                    finally
                    {
                        if (!success && (wrapper != null))
                        {
                            wrapper.Dispose();
                            wrapper = null;
                        }
                    }
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRenameProcedure(
            string oldName,
            string newName,
            bool noNamespaces,
            bool delete,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasProcedures(ref result))
                {
                    if (!delete || !String.IsNullOrEmpty(newName))
                    {
                        IProcedure oldProcedure = null;

                        if (GetProcedure(oldName, LookupFlags.Default, ref oldProcedure, ref result) == ReturnCode.Ok)
                        {
                            if (!EntityOps.IsReadOnly(oldProcedure))
                            {
                                if (EntityOps.IsNoRename(oldProcedure))
                                    return ReturnCode.Ok;

                                _Wrappers.Procedure oldWrapper = oldProcedure as _Wrappers.Procedure;

                                if (oldWrapper != null)
                                {
                                    IAlias oldAlias = oldWrapper.procedure as IAlias;

                                    if (PreventAliasLoop(oldAlias, newName, ref result) == ReturnCode.Ok)
                                    {
                                        if (IsValidAnyIExecuteName(newName, noNamespaces, ref result) == ReturnCode.Ok)
                                        {
                                            bool useNamespaces = !noNamespaces && AreNamespacesEnabled();

                                            if (!useNamespaces ||
                                                RenameImportInNamespaces(oldName, newName, ref result) == ReturnCode.Ok)
                                            {
                                                //
                                                // NOTE: New name, same token.
                                                //
                                                oldWrapper.Name = newName;

                                                /* IGNORED */
                                                procedures.Rename(oldName, newName);

#if EXECUTE_CACHE
                                                RenameIExecuteInCache(oldName, newName, oldWrapper, false, false);
#endif

#if NOTIFY
                                                /* IGNORED */
                                                CheckNotification(
                                                    NotifyType.Procedure, NotifyFlags.Renamed,
                                                    new ObjectTriplet(oldProcedure, oldName, newName), this,
                                                    null, null, null, ref result);
#endif

                                                result = String.Empty;
                                                return ReturnCode.Ok;
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    result = String.Format(
                                        "can't rename {0}: invalid procedure wrapper",
                                        FormatOps.WrapOrNull(oldName));
                                }
                            }
                            else
                            {
                                result = "procedure is read-only";
                            }
                        }
                        else
                        {
                            result = String.Format(
                                "can't rename {0}: procedure doesn't exist",
                                FormatOps.WrapOrNull(oldName));
                        }
                    }
                    else
                    {
                        return RemoveProcedure(oldName, null, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRemoveProcedure(
            string name,
            long token,
            IProcedure procedure,
            IClientData clientData,
            bool hidden,
            ref Result result
            )
        {
            if (name == null)
            {
                result = "invalid procedure name";
                return ReturnCode.Error;
            }

            GlobalState.PushActiveInterpreter(this);

            try
            {
                if (AreNamespacesEnabled() &&
                    RemoveImportFromNamespaces(name, ref result) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }

#if NATIVE && TCL
                if ((procedure == null) ||
                    (DisposeTclBridges(IntPtr.Zero, procedure, null, false, ref result) == ReturnCode.Ok))
#endif
                {
                    if (hidden)
                        /* IGNORED */
                        hiddenProcedures.Remove(name, token);
                    else
                        /* IGNORED */
                        procedures.Remove(name, token);

#if EXECUTE_CACHE
                    RemoveIExecuteFromCache(name, hidden, false);
#endif

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(hidden ?
                        NotifyType.HiddenProcedure : NotifyType.Procedure,
                        NotifyFlags.Removed, new ObjectTriplet(procedure,
                            name, token), this, clientData, null, null,
                        ref result);
#endif

                    return ReturnCode.Ok;
                }

#if NATIVE && TCL
                return ReturnCode.Error;
#endif
            }
            catch (Exception e)
            {
                result = String.Format(
                    "caught exception while removing {0}procedure: {1}",
                    hidden ? "hidden " : String.Empty, e);

                return ReturnCode.Error;
            }
            finally
            {
                /* IGNORED */
                GlobalState.PopActiveInterpreter();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode MakeProcedureFast( /* NOTE: For script library only. */
            string name,
            bool fast
            )
        {
            Result error = null;

            return MakeProcedureFast(name, fast, ref error);
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IOperator
        public ReturnCode ListOperators(
            OperatorFlags hasFlags,
            OperatorFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                Result localError = null;

                if (HasOperators(ref localError))
                {
                    code = operators.ToList(
                        hasFlags, notHasFlags, hasAll, notHasAll,
                        pattern, noCase, ref list, ref error);
                }
                else if (strict)
                {
                    error = localError;
                }
                else
                {
                    if (list == null)
                        list = new StringList();

                    code = ReturnCode.Ok;
                }
            }

            return code;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Channel
        public bool IsStreamForChannel(
            string name,
            ChannelType channelType,
            Stream stream
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                string channelId = RuntimeOps.ChannelTypeToName(
                    name, channelType);

                if ((channelId == null) || (stream == null))
                    return false;

                if (!InternalHasChannels())
                    return false;

                IChannel channel;

                if (!channels.TryGetValue(channelId, out channel))
                    return false;

                if (channel == null)
                    return false;

                ChannelStream channelStream = channel.GetStream();

                if (channelStream == null)
                    return false;

                Stream innerStream = channelStream.GetStream();

                return Object.ReferenceEquals(stream, innerStream);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ListChannels(
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                Result localError = null;

                if (PrivateHasChannels(ref localError))
                {
                    code = channels.ToList(
                        pattern, noCase, ref list, ref error);
                }
                else if (strict)
                {
                    error = localError;
                }
                else
                {
                    if (list == null)
                        list = new StringList();

                    code = ReturnCode.Ok;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddChannel(
            string name,
            ChannelType channelType,
            Stream stream,
            OptionDictionary options,
            StreamFlags streamFlags,
            StreamTranslation inTranslation,
            StreamTranslation outTranslation,
            Encoding encoding,
            bool nullEncoding,
            bool appendMode,
            bool autoFlush,
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return AddChannel(
                name, channelType, stream, options, streamFlags, inTranslation,
                outTranslation, encoding, null, nullEncoding, appendMode,
                autoFlush, clientData, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveChannel(
            string name,
            ChannelType channelType,
            bool flush,
            bool close,
            bool strict,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                string channelId = RuntimeOps.ChannelTypeToName(
                    name, channelType);

                if (channelId == null)
                {
                    error = "invalid channel name";
                    return ReturnCode.Error;
                }

                if (!PrivateHasChannels(ref error))
                    return ReturnCode.Error;

                IChannel channel;

                if (channels.TryGetValue(channelId, out channel))
                {
                    if (flush && (channel != null))
                    {
                        try
                        {
                            //
                            // NOTE: Attempt to flush the channel.
                            //
                            channel.Flush(); /* throw */
                        }
                        catch (Exception e)
                        {
                            if (strict)
                            {
                                error = e;
                                return ReturnCode.Error;
                            }
                        }
                    }

                    if (close && (channel != null))
                    {
                        try
                        {
                            //
                            // NOTE: Attempt to close the channel.
                            //
                            channel.Close(); /* throw */
                        }
                        catch (Exception e)
                        {
                            if (strict)
                            {
                                error = e;
                                return ReturnCode.Error;
                            }
                        }
                    }

                    channels.Remove(channelId);

                    return ReturnCode.Ok;
                }
                else if (strict)
                {
                    error = String.Format(
                        "can not find channel named {0}",
                        FormatOps.WrapOrNull(channelId));

                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SetChannelEncoding(
            string name,
            ChannelType channelType,
            Encoding encoding,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                string channelId = RuntimeOps.ChannelTypeToName(
                    name, channelType);

                if (channelId == null)
                {
                    error = "invalid channel name";
                    return ReturnCode.Error;
                }

                if (!PrivateHasChannels(ref error))
                    return ReturnCode.Error;

                IChannel channel;

                if (channels.TryGetValue(channelId, out channel))
                {
                    if (channel != null)
                    {
                        try
                        {
                            channel.SetEncoding(encoding);
                            return ReturnCode.Ok;
                        }
                        catch (Exception e)
                        {
                            error = e;
                            return ReturnCode.Error;
                        }
                    }
                    else
                    {
                        error = String.Format(
                            "invalid channel {0}",
                            FormatOps.WrapOrNull(channelId));

                        return ReturnCode.Error;
                    }
                }
                else
                {
                    error = String.Format(
                        "can not find channel named {0}",
                        FormatOps.WrapOrNull(channelId));

                    return ReturnCode.Error;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SetChannelTranslation(
            string name,
            ChannelType channelType,
            StreamTranslation inTranslation,
            StreamTranslation outTranslation,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                string channelId = RuntimeOps.ChannelTypeToName(
                    name, channelType);

                if (channelId == null)
                {
                    error = "invalid channel name";
                    return ReturnCode.Error;
                }

                if (!PrivateHasChannels(ref error))
                    return ReturnCode.Error;

                IChannel channel;

                if (channels.TryGetValue(channelId, out channel))
                {
                    if (channel != null)
                    {
                        try
                        {
                            channel.SetTranslation(
                                new StreamTranslationList(
                                    inTranslation, outTranslation));

                            return ReturnCode.Ok;
                        }
                        catch (Exception e)
                        {
                            error = e;
                            return ReturnCode.Error;
                        }
                    }
                    else
                    {
                        error = String.Format(
                            "invalid channel {0}",
                            FormatOps.WrapOrNull(channelId));

                        return ReturnCode.Error;
                    }
                }
                else
                {
                    error = String.Format(
                        "can not find channel named {0}",
                        FormatOps.WrapOrNull(channelId));

                    return ReturnCode.Error;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private ReturnCode AddChannel(
            string name,
            ChannelType channelType,
            Stream stream,
            OptionDictionary options,
            StreamFlags streamFlags,
            StreamTranslation inTranslation,
            StreamTranslation outTranslation,
            Encoding encoding,
            int? availableTimeout,
            bool nullEncoding,
            bool appendMode,
            bool autoFlush,
            IClientData clientData,
            ref Result error
            )
        {
            // CheckDisposed();

            ReturnCode code = ReturnCode.Ok;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref error))
                    return ReturnCode.Error;

                string channelId = RuntimeOps.ChannelTypeToName(
                    name, channelType);

                if (channelId == null)
                {
                    error = "invalid channel name";
                    return ReturnCode.Error;
                }

                if (!PrivateHasChannels(ref error))
                    return ReturnCode.Error;

                if (channels.ContainsKey(channelId)) /* EXEMPT */
                {
                    error = String.Format(
                        "can't add {0}: channel already exists",
                        FormatOps.WrapOrNull(channelId));

                    return ReturnCode.Error;
                }

                ChannelStream channelStream = null;
                IChannel channel = null;

                try
                {
                    channelStream = new ChannelStream(
                        stream, channelType, options, streamFlags,
                        inTranslation, outTranslation);

                    channel = Channel.Create(
                        channelStream, encoding, nullEncoding,
                        appendMode, autoFlush, clientData);

                    if (channelStream != null)
                    {
#if NETWORK
                        channelStream.AvailableTimeout = availableTimeout;
#endif

                        if (channelStream.NeedBuffer && (channel != null))
                            channel.NewBuffer();
                    }

                    channels.Add(name, channel);

                    code = ReturnCode.Ok;
                }
                catch (Exception e)
                {
                    error = e;
                    code = ReturnCode.Error;
                }
                finally
                {
                    if (code != ReturnCode.Ok)
                    {
                        if (channelStream != null)
                        {
                            channelStream.PreventClose = false;
                            channelStream.Close();
                            channelStream = null;
                        }

                        if (channel != null)
                        {
                            channel.Close();
                            channel = null;
                        }
                    }
                }
            }

            return code;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ICallFrame (Scope)
        public ReturnCode GetScope(
            string name,
            LookupFlags lookupFlags,
            ref ICallFrame frame,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasScopes(ref error))
                {
                    //
                    // NOTE: *WARNING* Empty scope names are technically allowed,
                    //       please do not change this to "!String.IsNullOrEmpty".
                    //
                    //       That being said, we actually block them for practical
                    //       reasons in the [scope] command itself.
                    //
                    if (name != null)
                    {
                        ICallFrame localFrame;

                        if (scopes.TryGetValue(name, out localFrame))
                        {
                            bool noUsable = FlagOps.HasFlags(
                                lookupFlags, LookupFlags.NoUsable, true);

                            if (noUsable || (localFrame == null) ||
                                localFrame.IsUsable(ref error))
                            {
                                frame = localFrame;
                                return ReturnCode.Ok;
                            }
                        }
                        else
                        {
                            error = FlagOps.HasFlags(
                                lookupFlags, LookupFlags.Verbose, true) ?
                                String.Format(
                                    "scope {0} not found",
                                    FormatOps.WrapOrNull(name)) :
                                "scope not found";
                        }
                    }
                    else
                    {
                        error = "invalid scope name";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode LockScope(
            string name,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasScopes(ref error))
                    return ReturnCode.Error;

                ICallFrame frame = null;

                if (GetScope(name,
                        LookupFlags.Default | LookupFlags.NoUsable,
                        ref frame, ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }

                if (frame == null)
                {
                    error = "invalid call frame";
                    return ReturnCode.Error;
                }

                if (!frame.Lock(ref error))
                    return ReturnCode.Error;

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode UnlockScope(
            string name,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasScopes(ref error))
                    return ReturnCode.Error;

                ICallFrame frame = null;

                if (GetScope(name,
                        LookupFlags.Default | LookupFlags.NoUsable,
                        ref frame, ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }

                if (frame == null)
                {
                    error = "invalid call frame";
                    return ReturnCode.Error;
                }

                if (!frame.Unlock(ref error))
                    return ReturnCode.Error;

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal bool HasScopes()
        {
            Result error = null;

            return HasScopes(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetScope(
            string name,
            LookupFlags lookupFlags,
            ref ICallFrame frame
            )
        {
            Result error = null;

            return GetScope(name, lookupFlags, ref frame, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ScopesToString(
            string pattern,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasScopes())
                    result = scopes.ToString(pattern, false); /* EXEMPT */
                else
                    result = String.Empty;
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddScope(
            ICallFrame frame,
            IClientData clientData,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (frame == null)
                {
                    result = "invalid scope";
                    return ReturnCode.Error;
                }

                if (!frame.IsUsable(ref result))
                    return ReturnCode.Error;

                string name = frame.Name;

                if (name == null)
                {
                    result = "invalid scope name";
                    return ReturnCode.Error;
                }

                if (!HasScopes(ref result))
                    return ReturnCode.Error;

                if (DoesScopeExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: scope already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                //
                // HACK: For now, use the procedure limit as a proxy for the
                //       scope limit (i.e. since they are both "containers"
                //       for variables).
                //
                if ((procedureLimit != 0) && (scopes.Count >= procedureLimit))
                {
                    result = String.Format(
                        "can't add {0}: scope limit exceeded",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                scopes.Add(name, frame);
                result = String.Empty;
            }

#if NOTIFY
            //
            // NOTE: This must be done outside of the lock statement (above),
            //       because the code called may have arbitrary side-effects.
            //
            /* IGNORED */
            CheckNotification(
                NotifyType.CallFrame, NotifyFlags.Added,
                frame, this, clientData, null, null,
                ref result);
#endif

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveScope(
            string name,
            IClientData clientData,
            ref Result result
            )
        {
            ICallFrame frame = null; /* REUSED */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (String.IsNullOrEmpty(name))
                {
                    result = "invalid scope name";
                    return ReturnCode.Error;
                }

                if (!HasScopes(ref result))
                    return ReturnCode.Error;

                //
                // NOTE: If the specified scope call frame was used with
                //       the [scope global] sub-command, unset it now.
                //
                frame = GlobalScopeFrame;

                if ((frame != null) &&
                    SharedStringOps.SystemEquals(frame.Name, name))
                {
                    if (!frame.IsUsable(ref result))
                        return ReturnCode.Error;

                    if (UnsetGlobalScopeCallFrame(
                            true, ref result) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }
                }

                frame = null;

                if (GetScopeCallFrame(
                        name, LookupFlags.RemoveNoVerbose, true, true,
                        ref frame) == ReturnCode.Ok)
                {
                    //
                    // NOTE: We destroyed the current scope call frame
                    //       (after popping it).
                    //
                    // BUGFIX: Cannot return here, need to cleanup references
                    //         via the notification at the end of the method.
                    //
                    result = String.Empty;
                }
                else
                {
                    //
                    // NOTE: Make sure the scope exists and return an error
                    //       if it does not.
                    //
                    frame = null;

                    if (GetScope(
                            name, LookupFlags.Remove, ref frame,
                            ref result) == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Remove the scope from the interpreter.
                        //
                        scopes.Remove(name);
                        result = String.Empty;
                    }
                    else
                    {
                        return ReturnCode.Error;
                    }
                }
            }

#if NOTIFY || NOTIFY_OBJECT
            //
            // NOTE: This must be done outside of the lock statement (above),
            //       because the code called may have arbitrary side-effects.
            //
            /* IGNORED */
            CheckNotification(
                NotifyType.CallFrame, NotifyFlags.Deleted,
                frame, this, clientData, null, null,
                ref result);
#endif

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode InvokeInEachScope(
            CallFrameCallback callback,
            IClientData clientData,
            bool errorOnLocked,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (callback == null)
                {
                    error = "invalid callback";
                    return ReturnCode.Error;
                }

                if (!HasScopes(ref error))
                    return ReturnCode.Error;

                ReturnCode code = ReturnCode.Ok;
                Result localError; /* REUSED */

                foreach (KeyValuePair<string, ICallFrame> pair in scopes)
                {
                    ICallFrame frame = pair.Value;

                    if (frame == null)
                        continue;

                    localError = null;

                    if (!frame.IsUsable(ref localError))
                    {
                        if (errorOnLocked)
                        {
                            error = localError;
                            code = ReturnCode.Error;

                            break;
                        }
                        else
                        {
                            continue;
                        }
                    }

                    localError = null;

                    code = callback(frame, clientData, ref localError);

                    if (code != ReturnCode.Ok)
                    {
                        error = localError;
                        break;
                    }
                }

                return code;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by [scope eval] sub-command implementation only.
        //
        internal ReturnCode InternalLockScope(
            EventWaitFlags eventWaitFlags, /* in */
            string name,                   /* in */
            long microseconds,             /* in */
            EventWaitHandle @event,        /* in, optional */
            ref ICallFrame frame,          /* out */
            ref Result error               /* out */
            ) /* THREAD-SAFE */
        {
            if (microseconds < 0)
            {
                error = "number of microseconds cannot be negative";
                return ReturnCode.Error;
            }

            //
            // TODO: Maybe make this more adjustable?
            //
            int readyMilliseconds = (microseconds != 0) ?
                DefaultReadyTimeout : 0;

            bool noTimeout = (readyMilliseconds <= 0) || FlagOps.HasFlags(
                eventWaitFlags, EventWaitFlags.NoTimeout, true);

            bool noCancel = FlagOps.HasFlags(
                eventWaitFlags, EventWaitFlags.NoCancel, true);

            bool noGlobalCancel = FlagOps.HasFlags(
                eventWaitFlags, EventWaitFlags.NoGlobalCancel, true);

            bool noWindows = FlagOps.HasFlags(
                eventWaitFlags, EventWaitFlags.NoWindows, true);

            bool noWait = FlagOps.HasFlags(
                eventWaitFlags, EventWaitFlags.NoWait, true);

            bool noSleep = FlagOps.HasFlags(
                eventWaitFlags, EventWaitFlags.NoSleep, true);

            long startCount = PerformanceOps.GetCount();

            long slopMicroseconds = EventOps.GetSlopMicroseconds(
                microseconds);

            int sleepMilliseconds = GetMinimumSleepTime(
                SleepType.Variable, EventOps.GetMilliseconds(
                microseconds));

            Result localError = null; /* REUSED */

            while ((microseconds == 0) || !PerformanceOps.HasElapsed(
                    startCount, microseconds, slopMicroseconds))
            {
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    ICallFrame localFrame = null;

                    localError = null;

                    if (GetScope(
                            name, LookupFlags.Default | LookupFlags.NoUsable,
                            ref localFrame, ref localError) != ReturnCode.Ok)
                    {
                        error = localError;
                        break;
                    }

                    localError = null;

                    if (localFrame.Lock(ref localError))
                    {
                        frame = localFrame;
                        return ReturnCode.Ok;
                    }

                    if (noWait)
                    {
                        error = localError;
                        return ReturnCode.Error;
                    }
                }

                if (!noSleep) // NOTE: Somewhat dangerous for CPU usage.
                {
                    localError = null;

                    if (EventOps.Wait(
                            this, @event, PerformanceOps.GetMicroseconds(
                            sleepMilliseconds), PerformanceOps.GetMicroseconds(
                            readyMilliseconds), !noTimeout, noWindows, noCancel,
                            noGlobalCancel, ref localError) != ReturnCode.Ok)
                    {
                        error = localError;
                        break;
                    }
                }
            }

            if (localError != null)
            {
                error = localError;
            }
            else
            {
                error = String.Format(
                    "timed out attempting to lock scope {0}",
                    FormatOps.DisplayName(name));
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by [scope eval] sub-command implementation only.
        //
        internal ReturnCode InternalUnlockScope(
            ICallFrame frame,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (frame == null)
                {
                    error = "invalid call frame";
                    return ReturnCode.Error;
                }

                if (!frame.Unlock(ref error))
                    return ReturnCode.Error;

                return ReturnCode.Ok;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IDbConnection / IDbTransaction
#if DATA
        public ReturnCode GetDbConnection(
            string name,
            LookupFlags lookupFlags,
            ref IDbConnection connection,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasDbConnections(ref error))
                {
                    //
                    // NOTE: *WARNING* Empty database connection names are allowed,
                    //       please do not change this to "!String.IsNullOrEmpty".
                    //
                    if (name != null)
                    {
                        if (connections.TryGetValue(name, out connection))
                        {
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            error = FlagOps.HasFlags(
                                lookupFlags, LookupFlags.Verbose, true) ?
                                String.Format(
                                    "database connection {0} not found",
                                    FormatOps.WrapOrNull(name)) :
                                "database connection not found";
                        }
                    }
                    else
                    {
                        error = "invalid database connection name";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetDbTransaction(
            string name,
            LookupFlags lookupFlags,
            ref IDbTransaction transaction,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasDbTransactions(ref error))
                {
                    //
                    // NOTE: *WARNING* Empty database transaction names are allowed,
                    //       please do not change this to "!String.IsNullOrEmpty".
                    //
                    if (name != null)
                    {
                        if (transactions.TryGetValue(name, out transaction))
                        {
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            error = FlagOps.HasFlags(
                                lookupFlags, LookupFlags.Verbose, true) ?
                                String.Format(
                                    "database transaction {0} not found",
                                    FormatOps.WrapOrNull(name)) :
                                "database transaction not found";
                        }
                    }
                    else
                    {
                        error = "invalid database transaction name";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal string DbConnectionsToString(
            string pattern,
            bool noCase
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (connections != null)
                    return connections.ToString(pattern, noCase);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void AddDbConnection(
            string name,
            IDbConnection connection
            )
        {
            if (name != null)
            {
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    if (connections != null)
                        connections.Add(name, connection);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool RemoveDbConnection(
            string name
            )
        {
            if (name != null)
            {
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    if (connections != null)
                        return connections.Remove(name);
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string DbTransactionsToString(
            string pattern,
            bool noCase
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (transactions != null)
                    return transactions.ToString(pattern, noCase);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void AddDbTransaction(
            string name,
            IDbTransaction Transaction
            )
        {
            if (name != null)
            {
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    if (transactions != null)
                        transactions.Add(name, Transaction);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool RemoveDbTransaction(
            string name
            )
        {
            if (name != null)
            {
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    if (transactions != null)
                        return transactions.Remove(name);
                }
            }

            return false;
        }
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Encoding
        public ReturnCode GetEncoding(
            string name,             /* in */
            LookupFlags lookupFlags, /* in */
            ref Encoding encoding,   /* out */
            ref Result error         /* out */
            )
        {
            CheckDisposed();

            if (name == null)
            {
                encoding = null;
                return ReturnCode.Ok;
            }

            lock (syncRoot) /* TRANSACTIONAL */
            {
                try
                {
                    Encoding localEncoding = null;

                    if (encodings != null)
                    {
                        //
                        // NOTE: We failed to find the one they specified
                        //       in our collection.  Maybe try to fallback
                        //       to the .NET Framework encoding matching
                        //       their specified name?
                        //
                        if (!encodings.TryGetValue(name, out localEncoding))
                        {
                            if (FlagOps.HasFlags(
                                    lookupFlags, LookupFlags.Strict, true))
                            {
                                error = String.Format(
                                    "encoding {0} was not found",
                                    FormatOps.WrapOrNull(name));

                                return ReturnCode.Error;
                            }
                            else
                            {
                                localEncoding = StringOps.GetEncoding(name);
                            }
                        }
                    }
                    else
                    {
                        //
                        // HACK: The strict flag does not matter because
                        //       there is no internal list of encodings.
                        //       In this case, only the Validate flag is
                        //       used.
                        //
                        localEncoding = StringOps.GetEncoding(name);
                    }

                    if ((localEncoding == null) && FlagOps.HasFlags(
                            lookupFlags, LookupFlags.Validate, true))
                    {
                        error = "invalid encoding";
                        return ReturnCode.Error;
                    }

                    encoding = localEncoding;
                    return ReturnCode.Ok;
                }
                catch (Exception e)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        e : (Result)"invalid encoding";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetEncodingOrDefault(
            string name,             /* in */
            LookupFlags lookupFlags, /* in */
            ref Encoding encoding,   /* out */
            ref Result error         /* out */
            )
        {
            CheckDisposed();

            if (StringOps.IsDefaultEncodingName(name))
            {
                encoding = DefaultEncoding;
                return ReturnCode.Ok;
            }

            ReturnCode code;
            Encoding localEncoding = null;

            code = GetEncoding(
                name, lookupFlags, ref localEncoding, ref error);

            if (code != ReturnCode.Ok)
                return code;

            encoding = localEncoding;
            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal void GetEncodings(
            ref EncodingDictionary encodings /* in, out */
            )
        {
            if (encodings == null)
                encodings = new EncodingDictionary();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                EncodingDictionary localEncodings = this.encodings;

                if (localEncodings != null)
                {
                    foreach (KeyValuePair<string, Encoding> pair
                            in localEncodings)
                    {
                        encodings[pair.Key] = pair.Value;
                    }
                }
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        #region IRuleSet
        internal bool ApplyRuleSet(
            IdentifierKind kind,
            string text
            )
        {
            IRuleSet localRuleSet;

            lock (syncRoot)
            {
                localRuleSet = ruleSet;
            }

            if (localRuleSet == null)
                return true;

            return localRuleSet.ApplyRules(this, kind, text);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Hidden ICommand
        internal ReturnCode HiddenCommandsToList(
            CommandFlags hasFlags,
            CommandFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            ref StringList list,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (hiddenCommands != null)
                {
                    return hiddenCommands.ToList(
                        hasFlags, notHasFlags, hasAll, notHasAll,
                        pattern, noCase, ref list, ref error);
                }
            }

            error = "hidden commands not available";
            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HasHiddenCommands()
        {
            Result error = null;

            return HasHiddenCommands(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HasHiddenCommands(ref Result error)
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (hiddenCommands != null);

                if (!result)
                    error = "hidden commands not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesHiddenCommandExist(long token)
        {
            string name = null;
            ICommand command = null;
            Result error = null;

            return GetHiddenCommand(token, LookupFlags.Exists, ref name, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesHiddenCommandExist(string name)
        {
            ICommand command = null;
            Result error = null;

            return GetHiddenCommand(name, LookupFlags.Exists, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetHiddenCommand(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref ICommand command,
            ref Result error
            )
        {
            if (!HasHiddenCommands(ref error))
                return ReturnCode.Error;

            _Wrappers.Command wrapper;

            if (!hiddenCommands.TryGetValue(token, out wrapper))
            {
                error = "hidden command not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                command = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((command == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid hidden command";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid hidden command wrapper";
                    return ReturnCode.Error;
                }

                command = wrapper.command;
                name = EntityOps.GetName(command);

                if ((command == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid hidden command";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetHiddenCommand(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref ICommand command,
            ref Result error
            )
        {
            if (!HasHiddenCommands(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid hidden command name";
                return ReturnCode.Error;
            }

            _Wrappers.Command wrapper;

            if (!hiddenCommands.TryGetValue(name, out wrapper))
            {
                error = "hidden command not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                command = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((command == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid hidden command";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid command wrapper";
                    return ReturnCode.Error;
                }

                command = wrapper.command;
                token = EntityOps.GetToken(command);

                if ((command == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid hidden command";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetHiddenCommand(
            long token,
            LookupFlags lookupFlags,
            ref ICommand command
            )
        {
            Result error = null;

            return GetHiddenCommand(token, lookupFlags, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetHiddenCommand(
            long token,
            LookupFlags lookupFlags,
            ref ICommand command,
            ref Result error
            )
        {
            string name = null;

            return GetHiddenCommand(token, lookupFlags, ref name, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetHiddenCommand(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref ICommand command,
            ref Result error
            )
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetHiddenCommand(
                        token, lookupFlags, ref name, ref command,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid hidden command token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid hidden command token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetHiddenCommand(
            string name,
            LookupFlags lookupFlags,
            ref ICommand command
            )
        {
            Result error = null;

            return GetHiddenCommand(name, lookupFlags, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetHiddenCommand(
            string name,
            LookupFlags lookupFlags,
            ref ICommand command,
            ref Result error
            )
        {
            long token = 0;

            return GetHiddenCommand(name, lookupFlags, ref token, ref command, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetHiddenCommand(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref ICommand command,
            ref Result error
            )
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetHiddenCommand(
                        name, lookupFlags, ref token, ref command,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid hidden command name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid hidden command name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ListHiddenCommands(
            CommandFlags hasFlags,
            CommandFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list
            )
        {
            Result error = null;

            return ListHiddenCommands(
                hasFlags, notHasFlags, hasAll, notHasAll, pattern, noCase,
                strict, ref list, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ListHiddenCommands(
            CommandFlags hasFlags,
            CommandFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            bool strict,
            ref StringList list,
            ref Result error
            )
        {
            // CheckDisposed();

            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                Result localError = null;

                if (HasHiddenCommands(ref localError))
                {
                    if (AreNamespacesEnabled())
                    {
                        INamespace currentNamespace = null;

                        code = GetCurrentNamespaceViaResolvers(
                            null, LookupFlags.Default, ref currentNamespace,
                            ref error);

                        if (code == ReturnCode.Ok)
                        {
                            StringList[] localLists = { null, null };

                            code = hiddenCommands.ToList(
                                hasFlags, notHasFlags, hasAll, notHasAll,
                                null, false, ref localLists[0], ref error);

                            if (code == ReturnCode.Ok)
                            {
                                code = MatchItems(
                                    currentNamespace, pattern, noCase,
                                    ref localLists, ref error);

                                if (list == null)
                                    list = localLists[1];
                                else
                                    list.AddRange(localLists[1]);
                            }
                        }
                    }
                    else
                    {
                        pattern = ScriptOps.MakeCommandName(pattern);

                        code = hiddenCommands.ToList(
                            hasFlags, notHasFlags, hasAll, notHasAll,
                            pattern, noCase, ref list, ref error);
                    }
                }
                else if (strict)
                {
                    error = localError;
                }
                else
                {
                    if (list == null)
                        list = new StringList();

                    code = ReturnCode.Ok;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRenameHiddenCommand(
            string oldName,
            string newName,
            bool noNamespaces,
            bool delete,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasHiddenCommands(ref result))
                {
                    if (!delete || !String.IsNullOrEmpty(newName))
                    {
                        ICommand oldCommand = null;

                        if (GetHiddenCommand(oldName, LookupFlags.Default, ref oldCommand, ref result) == ReturnCode.Ok)
                        {
                            if (!EntityOps.IsReadOnly(oldCommand))
                            {
                                if (EntityOps.IsNoRename(oldCommand))
                                    return ReturnCode.Ok;

                                _Wrappers.Command oldWrapper = oldCommand as _Wrappers.Command;

                                if (oldWrapper != null)
                                {
                                    IAlias oldAlias = oldWrapper.command as IAlias;

                                    if (PreventAliasLoop(oldAlias, newName, ref result) == ReturnCode.Ok)
                                    {
                                        if (IsValidAnyHiddenIExecuteName(newName, noNamespaces, ref result) == ReturnCode.Ok)
                                        {
                                            bool useNamespaces = !noNamespaces && AreNamespacesEnabled();

                                            if (!useNamespaces ||
                                                RenameImportInNamespaces(oldName, newName, ref result) == ReturnCode.Ok)
                                            {
                                                //
                                                // NOTE: New name, same token.
                                                //
                                                oldWrapper.Name = newName;

                                                /* IGNORED */
                                                hiddenCommands.Rename(oldName, newName);

#if EXECUTE_CACHE
                                                RenameIExecuteInCache(oldName, newName, oldWrapper, true, false);
#endif

#if NOTIFY
                                                /* IGNORED */
                                                CheckNotification(
                                                    NotifyType.HiddenCommand, NotifyFlags.Renamed,
                                                    new ObjectTriplet(oldCommand, oldName, newName), this,
                                                    null, null, null, ref result);
#endif

                                                result = String.Empty;
                                                return ReturnCode.Ok;
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    result = String.Format(
                                        "can't rename {0}: invalid hidden command wrapper",
                                        FormatOps.WrapOrNull(oldName));
                                }
                            }
                            else
                            {
                                result = String.Format(
                                    "can't rename {0}: hidden command is read-only",
                                    FormatOps.WrapOrNull(oldName));
                            }
                        }
                        else
                        {
                            result = String.Format(
                                "can't rename {0}: hidden command doesn't exist",
                                FormatOps.WrapOrNull(oldName));
                        }
                    }
                    else
                    {
                        return RemoveHiddenCommand(oldName, null, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveHiddenCommand(
            long token,
            IClientData clientData,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasHiddenCommands(ref result))
                {
                    string name = null;
                    ICommand command = null;

                    if (GetHiddenCommand(token, LookupFlags.Remove, ref name,
                            ref command, ref result) == ReturnCode.Ok)
                    {
                        if (!EntityOps.IsReadOnly(command))
                        {
                            if (EntityOps.IsNoRemove(command))
                                return ReturnCode.Ok;

                            return PrivateRemoveCommand(
                                name, token, command, clientData,
                                true, ref result);
                        }
                        else
                        {
                            result = "hidden command is read-only";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RemoveHiddenCommand(
            string name,
            IClientData clientData,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasHiddenCommands(ref result))
                {
                    long token = 0;
                    ICommand command = null;

                    if (GetHiddenCommand(name, LookupFlags.Remove, ref token,
                            ref command, ref result) == ReturnCode.Ok)
                    {
                        if (!EntityOps.IsReadOnly(command))
                        {
                            if (EntityOps.IsNoRemove(command))
                                return ReturnCode.Ok;

                            return PrivateRemoveCommand(
                                name, token, command, clientData,
                                true, ref result);
                        }
                        else
                        {
                            result = "hidden command is read-only";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesAnyCommandExist(long token)
        {
            /* CheckDisposed(); */

            if ((DoesCommandExist(token) == ReturnCode.Ok) ||
                (DoesHiddenCommandExist(token) == ReturnCode.Ok))
            {
                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesAnyCommandExist(string name)
        {
            /* CheckDisposed(); */

            if ((DoesCommandExist(name) == ReturnCode.Ok) ||
                (DoesHiddenCommandExist(name) == ReturnCode.Ok))
            {
                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Hidden IProcedure
        internal ReturnCode HiddenProceduresToList(
            ProcedureFlags hasFlags,
            ProcedureFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            ref StringList list,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (hiddenProcedures != null)
                {
                    return hiddenProcedures.ToList(
                        hasFlags, notHasFlags, hasAll, notHasAll,
                        pattern, noCase, ref list, ref error);
                }
            }

            error = "hidden procedures not available";
            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HasHiddenProcedures(ref Result error)
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (hiddenProcedures != null);

                if (!result)
                    error = "hidden procedures not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private ReturnCode DoesHiddenProcedureExist(long token)
        {
            string name = null;
            IProcedure procedure = null;
            Result error = null;

            return GetHiddenProcedure(token, LookupFlags.Exists, ref name, ref procedure, ref error);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesHiddenProcedureExist(string name)
        {
            IProcedure procedure = null;
            Result error = null;

            return GetHiddenProcedure(name, LookupFlags.Exists, ref procedure, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetHiddenProcedure(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IProcedure procedure,
            ref Result error
            )
        {
            if (!HasHiddenProcedures(ref error))
                return ReturnCode.Error;

            _Wrappers.Procedure wrapper;

            if (!hiddenProcedures.TryGetValue(token, out wrapper))
            {
                error = "hidden procedure not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                procedure = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((procedure == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid hidden procedure";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid hidden procedure wrapper";
                    return ReturnCode.Error;
                }

                procedure = wrapper.procedure;
                name = EntityOps.GetName(procedure);

                if ((procedure == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid hidden procedure";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetHiddenProcedure(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IProcedure procedure,
            ref Result error
            )
        {
            if (!HasHiddenProcedures(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid hidden procedure name";
                return ReturnCode.Error;
            }

            _Wrappers.Procedure wrapper;

            if (!hiddenProcedures.TryGetValue(name, out wrapper))
            {
                error = "hidden procedure not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                procedure = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((procedure == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid hidden procedure";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid hidden procedure wrapper";
                    return ReturnCode.Error;
                }

                procedure = wrapper.procedure;
                token = EntityOps.GetToken(procedure);

                if ((procedure == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid hidden procedure";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetHiddenProcedure(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IProcedure procedure,
            ref Result error
            )
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetHiddenProcedure(
                        token, lookupFlags, ref name, ref procedure,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid hidden procedure token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid hidden procedure token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetHiddenProcedure(
            string name,
            LookupFlags lookupFlags,
            ref IProcedure procedure
            )
        {
            Result error = null;

            return GetHiddenProcedure(name, lookupFlags, ref procedure, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetHiddenProcedure(
            string name,
            LookupFlags lookupFlags,
            ref IProcedure procedure,
            ref Result error
            )
        {
            long token = 0;

            return GetHiddenProcedure(name, lookupFlags, ref token, ref procedure, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetHiddenProcedure(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IProcedure procedure,
            ref Result error
            )
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetHiddenProcedure(
                        name, lookupFlags, ref token, ref procedure,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid hidden procedure name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid hidden procedure name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRenameHiddenProcedure(
            string oldName,
            string newName,
            bool noNamespaces,
            bool delete,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasHiddenProcedures(ref result))
                {
                    if (!delete || !String.IsNullOrEmpty(newName))
                    {
                        IProcedure oldProcedure = null;

                        if (GetHiddenProcedure(oldName, LookupFlags.Default, ref oldProcedure, ref result) == ReturnCode.Ok)
                        {
                            if (!EntityOps.IsReadOnly(oldProcedure))
                            {
                                if (EntityOps.IsNoRename(oldProcedure))
                                    return ReturnCode.Ok;

                                _Wrappers.Procedure oldWrapper = oldProcedure as _Wrappers.Procedure;

                                if (oldWrapper != null)
                                {
                                    IAlias oldAlias = oldWrapper.procedure as IAlias;

                                    if (PreventAliasLoop(oldAlias, newName, ref result) == ReturnCode.Ok)
                                    {
                                        if (IsValidAnyHiddenIExecuteName(newName, noNamespaces, ref result) == ReturnCode.Ok)
                                        {
                                            bool useNamespaces = !noNamespaces && AreNamespacesEnabled();

                                            if (!useNamespaces ||
                                                RenameImportInNamespaces(oldName, newName, ref result) == ReturnCode.Ok)
                                            {
                                                //
                                                // NOTE: New name, same token.
                                                //
                                                oldWrapper.Name = newName;

                                                /* IGNORED */
                                                hiddenProcedures.Rename(oldName, newName);

#if EXECUTE_CACHE
                                                RenameIExecuteInCache(oldName, newName, oldWrapper, true, false);
#endif

#if NOTIFY
                                                /* IGNORED */
                                                CheckNotification(
                                                    NotifyType.HiddenProcedure, NotifyFlags.Renamed,
                                                    new ObjectTriplet(oldProcedure, oldName, newName), this,
                                                    null, null, null, ref result);
#endif

                                                result = String.Empty;
                                                return ReturnCode.Ok;
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    result = String.Format(
                                        "can't rename {0}: invalid hidden procedure wrapper",
                                        FormatOps.WrapOrNull(oldName));
                                }
                            }
                            else
                            {
                                result = "hidden procedure is read-only";
                            }
                        }
                        else
                        {
                            result = String.Format(
                                "can't rename {0}: hidden procedure doesn't exist",
                                FormatOps.WrapOrNull(oldName));
                        }
                    }
                    else
                    {
                        return RemoveHiddenProcedure(oldName, null, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveHiddenProcedure(
            long token,
            IClientData clientData,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasHiddenProcedures(ref result))
                {
                    string name = null;
                    IProcedure procedure = null;

                    if (GetHiddenProcedure(token, LookupFlags.Remove, ref name,
                            ref procedure, ref result) == ReturnCode.Ok)
                    {
                        if (!EntityOps.IsReadOnly(procedure))
                        {
                            return PrivateRemoveProcedure(
                                name, token, procedure, clientData,
                                true, ref result);
                        }
                        else
                        {
                            result = "hidden procedure is read-only";
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RemoveHiddenProcedure(
            string name,
            IClientData clientData,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                long token = 0;
                IProcedure procedure = null;

                if (GetHiddenProcedure(name, LookupFlags.Default, ref token,
                        ref procedure, ref result) == ReturnCode.Ok)
                {
                    if (!EntityOps.IsReadOnly(procedure))
                    {
                        if (EntityOps.IsNoRemove(procedure))
                            return ReturnCode.Ok;

                        return PrivateRemoveProcedure(
                            name, token, procedure, clientData,
                            true, ref result);
                    }
                    else
                    {
                        result = "hidden procedure is read-only";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private ReturnCode DoesAnyProcedureExist(long token)
        {
            /* CheckDisposed(); */

            if ((DoesProcedureExist(token) == ReturnCode.Ok) ||
                (DoesHiddenProcedureExist(token) == ReturnCode.Ok))
            {
                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesAnyProcedureExist(string name)
        {
            /* CheckDisposed(); */

            if ((DoesProcedureExist(name) == ReturnCode.Ok) ||
                (DoesHiddenProcedureExist(name) == ReturnCode.Ok))
            {
                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Hidden IExecute
        private bool HasHiddenIExecutes(ref Result error)
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (hiddenExecutes != null);

                if (!result)
                    error = "hidden executes not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private ReturnCode DoesHiddenIExecuteExist(long token)
        {
            string name = null;
            IExecute execute = null;
            Result error = null;

            return GetHiddenIExecute(token, LookupFlags.Exists, ref name, ref execute, ref error);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesHiddenIExecuteExist(string name)
        {
            IExecute execute = null;
            Result error = null;

            return GetHiddenIExecute(name, LookupFlags.Exists, ref execute, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetHiddenIExecute(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IExecute execute,
            ref Result error
            )
        {
            if (!HasHiddenIExecutes(ref error))
                return ReturnCode.Error;

            _Wrappers._Execute wrapper;

            if (!hiddenExecutes.TryGetValue(token, out wrapper))
            {
                error = "hidden execute not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                execute = wrapper;
                name = EntityOps.GetName(execute as IIdentifierName);

                if ((execute == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid hidden execute";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid hidden execute wrapper";
                    return ReturnCode.Error;
                }

                execute = wrapper.execute;
                name = EntityOps.GetName(execute as IIdentifierName);

                if ((execute == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid hidden execute";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetHiddenIExecute(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IExecute execute,
            ref Result error
            )
        {
            if (!HasHiddenIExecutes(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid hidden execute name";
                return ReturnCode.Error;
            }

            _Wrappers._Execute wrapper;

            if (!hiddenExecutes.TryGetValue(name, out wrapper))
            {
                error = "hidden execute not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                execute = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((execute == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid hidden execute";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid hidden execute wrapper";
                    return ReturnCode.Error;
                }

                execute = wrapper.execute;

                //
                // WARNING: Cannot grab the token from the IExecute here
                //          because that interface does not inherit from
                //          IWrapperData.
                //
                token = EntityOps.GetToken(wrapper);

                if ((execute == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid hidden execute";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetHiddenIExecute(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IExecute execute,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetHiddenIExecute(
                        token, lookupFlags, ref name, ref execute,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid hidden execute token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid hidden execute token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetHiddenIExecute(
            string name,
            LookupFlags lookupFlags,
            ref IExecute execute
            )
        {
            Result error = null;

            return GetHiddenIExecute(name, lookupFlags, ref execute, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetHiddenIExecute(
            string name,
            LookupFlags lookupFlags,
            ref IExecute execute,
            ref Result error
            )
        {
            long token = 0;

            return GetHiddenIExecute(name, lookupFlags, ref token, ref execute, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetHiddenIExecute(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IExecute execute,
            ref Result error
            )
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetHiddenIExecute(
                        name, lookupFlags, ref token, ref execute,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid hidden execute name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid hidden execute name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRenameHiddenIExecute(
            string oldName,
            string newName,
            bool noNamespaces,
            bool delete,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasHiddenIExecutes(ref result))
                {
                    if (!delete || !String.IsNullOrEmpty(newName))
                    {
                        IExecute oldExecute = null;

                        if (GetHiddenIExecute(oldName, LookupFlags.Default, ref oldExecute, ref result) == ReturnCode.Ok)
                        {
                            _Wrappers._Execute oldWrapper = oldExecute as _Wrappers._Execute;

                            if (oldWrapper != null)
                            {
                                IAlias oldAlias = oldWrapper.execute as IAlias;

                                if (PreventAliasLoop(oldAlias, newName, ref result) == ReturnCode.Ok)
                                {
                                    if (IsValidAnyHiddenIExecuteName(newName, noNamespaces, ref result) == ReturnCode.Ok)
                                    {
                                        bool useNamespaces = !noNamespaces && AreNamespacesEnabled();

                                        if (!useNamespaces ||
                                            RenameImportInNamespaces(oldName, newName, ref result) == ReturnCode.Ok)
                                        {
                                            /* IGNORED */
                                            hiddenExecutes.Rename(oldName, newName);

#if EXECUTE_CACHE
                                            RenameIExecuteInCache(oldName, newName, oldWrapper, true, false);
#endif

#if NOTIFY
                                            /* IGNORED */
                                            CheckNotification(
                                                NotifyType.HiddenIExecute, NotifyFlags.Renamed,
                                                new ObjectTriplet(oldExecute, oldName, newName), this,
                                                null, null, null, ref result);
#endif

                                            result = String.Empty;
                                            return ReturnCode.Ok;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                result = String.Format(
                                    "can't rename {0}: invalid hidden execute wrapper",
                                    FormatOps.WrapOrNull(oldName));
                            }
                        }
                        else
                        {
                            result = String.Format(
                                "can't rename {0}: hidden execute doesn't exist",
                                FormatOps.WrapOrNull(oldName));
                        }
                    }
                    else
                    {
                        return RemoveHiddenIExecute(oldName, null, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveHiddenIExecute(
            long token,
            IClientData clientData,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasHiddenIExecutes(ref result))
                {
                    string name = null;
                    IExecute execute = null;

                    if (GetHiddenIExecute(token, LookupFlags.Remove, ref name,
                            ref execute, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemoveIExecute(
                            name, token, execute, clientData, true,
                            ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RemoveHiddenIExecute(
            string name,
            IClientData clientData /* NOT USED */,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasHiddenIExecutes(ref result))
                {
                    long token = 0;
                    IExecute execute = null;

                    if (GetHiddenIExecute(name, LookupFlags.Remove, ref token,
                            ref execute, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemoveIExecute(
                            name, token, execute, clientData, true,
                            ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private ReturnCode DoesAnyIExecuteExist(long token)
        {
            /* CheckDisposed(); */

            if ((DoesIExecuteExist(token) == ReturnCode.Ok) ||
                (DoesHiddenIExecuteExist(token) == ReturnCode.Ok))
            {
                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesAnyIExecuteExist(string name)
        {
            /* CheckDisposed(); */

            if ((DoesIExecuteExist(name) == ReturnCode.Ok) ||
                (DoesHiddenIExecuteExist(name) == ReturnCode.Ok))
            {
                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ILambda
        #region Dead Code
#if DEAD_CODE
        internal ReturnCode LambdasToList(
            ProcedureFlags hasFlags,
            ProcedureFlags notHasFlags,
            bool hasAll,
            bool notHasAll,
            string pattern,
            bool noCase,
            ref StringList list,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (lambdas != null)
                {
                    return lambdas.ToList(
                        hasFlags, notHasFlags, hasAll, notHasAll,
                        pattern, noCase, ref list, ref error);
                }
            }

            error = "lambdas not available";
            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HasLambdas(ref Result error)
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (lambdas != null);

                if (!result)
                    error = "lambdas not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetLambda(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref ILambda lambda,
            ref Result error
            )
        {
            if (!HasLambdas(ref error))
                return ReturnCode.Error;

            _Wrappers.Lambda wrapper;

            if (!lambdas.TryGetValue(token, out wrapper))
            {
                error = "lambda not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                lambda = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((lambda == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid lambda";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid lambda wrapper";
                    return ReturnCode.Error;
                }

                lambda = wrapper.lambda;
                name = EntityOps.GetName(lambda);

                if ((lambda == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid lambda";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetLambda(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref ILambda lambda,
            ref Result error
            )
        {
            if (!HasLambdas(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid lambda name";
                return ReturnCode.Error;
            }

            _Wrappers.Lambda wrapper;

            if (!lambdas.TryGetValue(name, out wrapper))
            {
                error = "lambda not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                lambda = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((lambda == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid lambda";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid lambda wrapper";
                    return ReturnCode.Error;
                }

                lambda = wrapper.lambda;
                token = EntityOps.GetToken(lambda);

                if ((lambda == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid lambda";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetLambda(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref ILambda lambda,
            ref Result error
            )
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetLambda(
                        token, lookupFlags, ref name, ref lambda,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid lambda token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid lambda token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetLambda(
            string name,
            LookupFlags lookupFlags,
            ref ILambda lambda
            )
        {
            Result error = null;

            return GetLambda(name, lookupFlags, ref lambda, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetLambda(
            string name,
            LookupFlags lookupFlags,
            ref ILambda lambda,
            ref Result error
            )
        {
            long token = 0;

            return GetLambda(name, lookupFlags, ref token, ref lambda, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetLambda(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref ILambda lambda,
            ref Result error
            )
        {
            /* CheckDisposed(); */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetLambda(
                        name, lookupFlags, ref token, ref lambda,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid lambda name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid lambda name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IOperator
        private ReturnCode PrivateGetOperator(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IOperator @operator,
            ref Result error
            )
        {
            if (!HasOperators(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid operator name";
                return ReturnCode.Error;
            }

            _Wrappers.Operator wrapper;

            if (!operators.TryGetValue(name, out wrapper))
            {
                error = "operator not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                @operator = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((@operator == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid operator";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid operator wrapper";
                    return ReturnCode.Error;
                }

                @operator = wrapper.@operator;
                token = EntityOps.GetToken(@operator);

                if ((@operator == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid operator";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetOperator(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IOperator @operator,
            ref Result error
            )
        {
            if (!HasOperators(ref error))
                return ReturnCode.Error;

            _Wrappers.Operator wrapper;

            if (!operators.TryGetValue(token, out wrapper))
            {
                error = "operator not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                @operator = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((@operator == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid operator";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid operator wrapper";
                    return ReturnCode.Error;
                }

                @operator = wrapper.@operator;
                name = EntityOps.GetName(@operator);

                if ((@operator == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid operator";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetOperator(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IOperator @operator,
            ref Result error
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetOperator(
                        token, lookupFlags, ref name, ref @operator,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid operator token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid operator token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int ClearOperatorCache(
            bool reset
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                int count = 0;

                if (operatorCache != null)
                {
                    int length = operatorCache.Length;

                    for (int index = 0; index < length; index++)
                    {
                        if (operatorCache[index] == null)
                            continue;

                        operatorCache[index] = null;
                        count++;
                    }

                    if (reset)
                        operatorCache = null;
                }

                return count;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool ClearOperatorCacheEntry(
            Lexeme lexeme
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (operatorCache == null)
                    return false;

                int length = operatorCache.Length;

                if ((lexeme < 0) || ((int)lexeme >= length))
                    return false;

                if (operatorCache[(int)lexeme] == null)
                    return false;

                operatorCache[(int)lexeme] = null;
                return true;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetExpressionOperator(
            Lexeme lexeme,
            string name,
            ref IOperator @operator
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (operatorCache != null)
                {
                    @operator = operatorCache[(int)lexeme]; /* throw */

                    if (@operator != null)
                        return ReturnCode.Ok;
                }

                if (operators == null)
                    return ReturnCode.Error;

                if (name == null)
                    return ReturnCode.Error;

                _Wrappers.Operator wrapper;

                if (!operators.TryGetValue(name, out wrapper))
                    return ReturnCode.Error;

                if (wrapper == null)
                    return ReturnCode.Error;

                @operator = wrapper.@operator;

                if (@operator == null)
                    return ReturnCode.Error;

                if (operatorCache != null)
                    operatorCache[(int)lexeme] = @operator; /* throw */

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetOperator(
            string name,
            LookupFlags lookupFlags,
            ref IOperator @operator,
            ref Result error
            )
        {
            long token = 0;

            return GetOperator(name, lookupFlags, ref token, ref @operator, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetOperator(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IOperator @operator,
            ref Result error
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetOperator(
                        name, lookupFlags, ref token, ref @operator,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid operator name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid operator name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private ReturnCode AddOperator(
            Type type,
            string name,
            Lexeme lexeme,
            int operands,
            TypeList types,
            OperatorFlags flags,
            IPlugin plugin,
            IClientData clientData,
            bool strict,
            ref long token,
            ref Result result
            )
        {
            // CheckDisposed(); /* NOTE: This API may be public someday. */

            if (type == null)
            {
                type = Type.GetType(
                    FormatOps.OperatorTypeName(name, false), false,
                    true);
            }

            if (type == null)
            {
                type = Type.GetType(FormatOps.OperatorTypeName(
                    Characters.Underscore + name, false), false,
                    true);
            }

            if (type != null)
            {
                OperatorFlags operatorFlags =
                    AttributeOps.GetOperatorFlags(type) | flags;

                AddEntityClientData addEntityClientData =
                    new AddEntityClientData(null, this);

                bool createStandard = addEntityClientData.CreateStandard;

                StringComparison comparisonType =
                    addEntityClientData.OperatorComparisonType;

                //
                // NOTE: Check if this operator is part of the "Tcl Standard"
                //       (i.e. it is largely (or completely) compatible with
                //       an identically named operator from Tcl/Tk 8.4, 8.5,
                //       and/or 8.6).
                //
                bool standard = FlagOps.HasFlags(
                    operatorFlags, OperatorFlags.Standard, true);

                //
                // NOTE: If the interpreter is "standard", make sure we only
                //       add operators that are marked as "standard" and NOT
                //       marked as "non-standard" unless we are merely hiding
                //       operators not considered to be "standard".  In that
                //       case, we add all operators, hidden them as necessary.
                //
                if (standard || !createStandard)
                {
                    try
                    {
                        if (operands == (int)Arity.Automatic)
                            operands = AttributeOps.GetOperands(type);

                        object[] args = {
                            new OperatorData(
                                name, null, null, clientData, type.FullName,
                                lexeme, operands, types, flags, comparisonType,
                                plugin, 0)
                        };

                        IOperator @operator =
                            (IOperator)Activator.CreateInstance(type, args);

                        return AddOperator(
                            @operator, null, ref token, ref result);
                    }
                    catch (Exception e)
                    {
                        result = e;
                    }
                }
                else if (strict)
                {
                    result = "cannot add non-standard operator to standard interpreter";
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                result = String.Format(
                    "operator {0} not found",
                    FormatOps.OperatorTypeName(name, true));
            }

            return ReturnCode.Error;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddOperator(
            IOperator @operator,
            IClientData clientData,
            ref Result result
            )
        {
            long token = 0;

            return AddOperator(@operator, clientData, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddOperator(
            IOperator @operator,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (@operator == null)
                {
                    result = "invalid operator";
                    return ReturnCode.Error;
                }

                string name = @operator.Name;

                if (name == null)
                {
                    result = "invalid operator name";
                    return ReturnCode.Error;
                }

                if (!HasOperators(ref result))
                    return ReturnCode.Error;

                if (DoesOperatorExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: operator already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                //
                // HACK: Due to how the expression parser works, we cannot allow an
                //       operator to be added that has the name of an existing
                //       function.
                //
                if (DoesFunctionExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: function already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                if (!FlagOps.HasFlags(
                        @operator.Flags, OperatorFlags.NoTclMathOperator, true) &&
                    /* EXEMPT */
                    FlagOps.HasFlags(
                        interpreterFlags, InterpreterFlags.TclMathOperators, true))
                {
                    //
                    // HACK: This is part of an ugly hack to add "tcl::mathfunc::*" and
                    //       "tcl::mathop::*" support for [expr] functions and operators
                    //       to Eagle, respectively.  This can only be done for operator
                    //       instances that also implmement the IExecute interface.
                    //
                    IExecute execute = @operator as IExecute;
                    long token2; /* REUSED */

                    if (execute != null)
                    {
                        if (AreNamespacesEnabled())
                        {
                            INamespace @namespace = NamespaceOps.Lookup(
                                this, TclVars.Namespace.MathOperatorName, true, true,
                                ref result);

                            if (@namespace == null)
                                return ReturnCode.Error;

                            string qualifiedName = NamespaceOps.MakeQualifiedName(
                                this, @namespace, name);

                            if (ApplyRuleSet(IdentifierKind.Command,
                                    ScriptOps.MakeCommandName(qualifiedName)))
                            {
                                token2 = 0; /* NOT USED */

                                if (AddIExecute(
                                        qualifiedName, execute, clientData,
                                        ref token2, ref result) != ReturnCode.Ok)
                                {
                                    return ReturnCode.Error;
                                }
                            }
                        }
                        else
                        {
                            string unqualifiedName = NamespaceOps.MakeName(
                                TclVars.Namespace.MathOperatorName, name, true,
                                false);

                            if (ApplyRuleSet(IdentifierKind.Command,
                                    ScriptOps.MakeCommandName(unqualifiedName)))
                            {
                                token2 = 0; /* NOT USED */

                                if (AddIExecute(
                                        unqualifiedName, execute, clientData,
                                        ref token2, ref result) != ReturnCode.Ok)
                                {
                                    return ReturnCode.Error;
                                }
                            }
                        }
                    }
                }

                ReturnCode code = ReturnCode.Ok;

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    try
                    {
                        try
                        {
                            code = @operator.Initialize(this,
                                (clientData != null) ? clientData : @operator.ClientData,
                                ref result);
                        }
                        catch (Exception e)
                        {
                            result = String.Format(
                                "caught exception while initializing operator: {0}",
                                e);

                            code = ReturnCode.Error;
                        }
                    }
                    finally
                    {
                        if (code != ReturnCode.Ok)
                        {
                            ReturnCode terminateCode;
                            Result terminateResult = null;

                            terminateCode = TerminateOperator(
                                @operator, clientData, ref terminateResult);

                            if (terminateCode != ReturnCode.Ok)
                            {
                                DebugOps.Complain(
                                    this, terminateCode, terminateResult);
                            }
                        }
                    }

                    if (code != ReturnCode.Ok)
                        return code;

                    bool success = false;
                    _Wrappers.Operator wrapper = null;

                    try
                    {
                        long id = EntityOps.NextTokenIdNoThrow(@operator);
                        wrapper = new _Wrappers.Operator(id, @operator);

                        operators.Add(name, wrapper);
                        success = true;

                        long newToken = EntityOps.GetToken(wrapper);
                        EntityOps.SetToken(@operator, newToken);

#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Operator, NotifyFlags.Added,
                            new ObjectPair(@operator, newToken), this,
                            clientData, null, null, ref result);
#endif

                        token = newToken;
                    }
                    finally
                    {
                        if (!success && (wrapper != null))
                        {
                            wrapper.Dispose();
                            wrapper = null;
                        }
                    }
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }

                return code;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode TerminateOperator(
            IOperator @operator,
            IClientData clientData,
            ref Result result
            )
        {
            if (@operator == null)
            {
                result = "invalid operator";
                return ReturnCode.Error;
            }

            bool savedImmutable = BeginMutableExecution();

            ReturnCode code;

            try
            {
                code = @operator.Terminate(this,
                    (clientData != null) ? clientData : @operator.ClientData,
                    ref result);

#if NOTIFY
                /* IGNORED */
                CheckNotification(
                    NotifyType.Operator, NotifyFlags.Terminated,
                    new ObjectTriplet(@operator, code), this,
                    clientData, null, null, ref result);
#endif
            }
            catch (Exception e)
            {
                result = String.Format(
                    "caught exception while terminating operator: {0}",
                    e);

                code = ReturnCode.Error;
            }
            finally
            {
                EndMutableExecution(savedImmutable);
            }

            return code;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IModule
#if EMIT && NATIVE && LIBRARY
        internal string ModulesToString(
            string pattern,
            bool noCase
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (modules != null)
                    return modules.ToString(pattern, noCase);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetModule(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IModule module,
            ref Result error
            )
        {
            if (!HasModules(ref error))
                return ReturnCode.Error;

            _Wrappers._Module wrapper;

            if (!modules.TryGetValue(token, out wrapper))
            {
                error = "module not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                module = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((module == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid module";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid module wrapper";
                    return ReturnCode.Error;
                }

                module = wrapper.module;
                name = EntityOps.GetName(module);

                if ((module == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid module";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetModule(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IModule module,
            ref Result error
            )
        {
            if (!HasModules(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid module name";
                return ReturnCode.Error;
            }

            _Wrappers._Module wrapper;

            if (!modules.TryGetValue(name, out wrapper))
            {
                error = "module not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                module = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((module == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid module";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid module wrapper";
                    return ReturnCode.Error;
                }

                module = wrapper.module;
                token = EntityOps.GetToken(module);

                if ((module == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid module";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetModule(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IModule module,
            ref Result error
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetModule(
                        token, lookupFlags, ref name, ref module,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid module token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid module token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetModule(
            string name,
            LookupFlags lookupFlags,
            ref IModule module,
            ref Result error
            )
        {
            long token = 0;

            return GetModule(name, lookupFlags, ref token, ref module, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetModule(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IModule module,
            ref Result error
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetModule(
                        name, lookupFlags, ref token, ref module,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid module name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid module name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetModuleByFileName(
            string fileName,
            LookupFlags lookupFlags,
            ref string name
            )
        {
            Result error = null;

            return GetModuleByFileName(
                fileName, lookupFlags, ref name, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetModuleByFileName(
            string fileName,
            LookupFlags lookupFlags,
            ref string name,
            ref Result error
            )
        {
            long token = 0;
            IModule module = null;

            return GetModuleByFileName(
                fileName, lookupFlags, ref name, ref token, ref module,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetModuleByFileName(
            string fileName,
            LookupFlags lookupFlags,
            ref string name,
            ref long token,
            ref IModule module,
            ref Result error
            )
        {
            ReturnCode code = ReturnCode.Error;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasModules(ref error))
                {
                    if (modules.Count > 0)
                    {
                        foreach (KeyValuePair<string, _Wrappers._Module> pair in modules)
                        {
                            _Wrappers._Module wrapper = pair.Value;

                            if (wrapper == null)
                                continue;

                            if (PathOps.IsSameFile(this, fileName, wrapper.FileName))
                            {
                                name = pair.Key;

                                if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
                                    module = wrapper;
                                else
                                    module = wrapper.module;

                                token = EntityOps.GetToken(wrapper);

                                if ((module != null) ||
                                    !FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                                {
                                    code = ReturnCode.Ok;
                                }
                                break;
                            }
                        }
                    }

                    if (code != ReturnCode.Ok)
                    {
                        error = FlagOps.HasFlags(
                            lookupFlags, LookupFlags.Verbose, true) ?
                            String.Format(
                                "invalid module file name {0}",
                                FormatOps.DisplayName(fileName)) :
                            "invalid module file name";
                    }
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddModule(
            IModule module,
            IClientData clientData,
            ref Result result
            )
        {
            long token = 0;

            return AddModule(module, clientData, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddModule(
            IModule module,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (module == null)
                {
                    result = "invalid module";
                    return ReturnCode.Error;
                }

                string name = module.Name;

                if (name == null)
                {
                    result = "invalid module name";
                    return ReturnCode.Error;
                }

                if (!HasModules(ref result))
                    return ReturnCode.Error;

                if (DoesModuleExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: module already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    bool success = false;
                    _Wrappers._Module wrapper = null;

                    try
                    {
                        long id = EntityOps.NextTokenIdNoThrow(module);
                        wrapper = new _Wrappers._Module(id, module);

                        modules.Add(name, wrapper);
                        success = true;

                        long newToken = EntityOps.GetToken(wrapper);
                        EntityOps.SetToken(module, newToken);

#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Module, NotifyFlags.Added,
                            new ObjectPair(module, newToken), this,
                            clientData, null, null, ref result);
#endif

                        token = newToken;
                    }
                    finally
                    {
                        if (!success && (wrapper != null))
                        {
                            wrapper.Dispose();
                            wrapper = null;
                        }
                    }
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRemoveModule(
            string name,
            long token,
            IModule module,
            IClientData clientData,
            bool synchronous,
            ref bool dispose,
            ref Result result
            )
        {
            if (dispose)
            {
                if (module != null)
                {
                    if (!FlagOps.HasFlags(module.Flags, ModuleFlags.NoRemove, true))
                    {
                        GlobalState.PushActiveInterpreter(this);

                        try
                        {
                            if (ObjectOps.TryDispose<IModule>(ref module,
                                    ref dispose, ref result) == ReturnCode.Ok)
                            {
                                module = null;

                                if (synchronous)
                                    ObjectOps.CollectGarbage(); /* throw */
                            }
                            else
                            {
                                return ReturnCode.Error;
                            }
                        }
                        catch (Exception e)
                        {
                            result = String.Format(
                                "caught exception while disposing module: {0}",
                                e);

                            return ReturnCode.Error;
                        }
                        finally
                        {
                            /* IGNORED */
                            GlobalState.PopActiveInterpreter();
                        }
                    }
                    else
                    {
                        result = "cannot dispose or remove module";

                        return ReturnCode.Error;
                    }
                }
            }

            modules.Remove(name, token);

#if NOTIFY
            /* IGNORED */
            CheckNotification(
                NotifyType.Module, NotifyFlags.Removed,
                new ObjectTriplet(module, name, token), this,
                clientData, null, null, ref result);
#endif

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveModule(
            string name,
            IClientData clientData /* NOT USED */,
            bool synchronous,
            ref Result result
            )
        {
            bool dispose = ObjectOps.GetDefaultDispose();

            return RemoveModule(name, clientData, synchronous, ref dispose, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RemoveModule(
            string name,
            IClientData clientData /* NOT USED */,
            bool synchronous,
            ref bool dispose,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasModules(ref result))
                {
                    long token = 0;
                    IModule module = null;

                    if (GetModule(name, LookupFlags.Remove, ref token,
                            ref module, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemoveModule(
                            name, token, module, clientData, synchronous,
                            ref dispose, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveModule(
            long token,
            IClientData clientData, /* NOT USED */
            ref bool dispose,
            ref Result result
            )
        {
            return RemoveModule(
                token, clientData, ObjectOps.GetDefaultSynchronous(), ref dispose, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RemoveModule(
            long token,
            IClientData clientData, /* NOT USED */
            bool synchronous,
            ref bool dispose,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasModules(ref result))
                {
                    string name = null;
                    IModule module = null;

                    if (GetModule(token, LookupFlags.Remove, ref name,
                            ref module, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemoveModule(
                            name, token, module, clientData, synchronous,
                            ref dispose, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IDelegate
#if EMIT && NATIVE && LIBRARY
        internal string DelegatesToString(
            string pattern,
            bool noCase
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (delegates != null)
                    return delegates.ToString(pattern, noCase);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetDelegate(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IDelegate @delegate,
            ref Result error
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetDelegate(
                        token, lookupFlags, ref name, ref @delegate,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid delegate token {0}",
                            FormatOps.WrapOrNull(token)) :
                        "invalid delegate token";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetDelegate(
            long token,
            LookupFlags lookupFlags,
            ref string name,
            ref IDelegate @delegate,
            ref Result error
            )
        {
            if (!HasDelegates(ref error))
                return ReturnCode.Error;

            _Wrappers.Delegate wrapper;

            if (!delegates.TryGetValue(token, out wrapper))
            {
                error = "delegate not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                @delegate = wrapper;
                name = EntityOps.GetName(wrapper);

                if ((@delegate == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid delegate";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid delegate wrapper";
                    return ReturnCode.Error;
                }

                @delegate = wrapper.@delegate;
                name = EntityOps.GetName(@delegate);

                if ((@delegate == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid delegate";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetDelegate(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IDelegate @delegate,
            ref Result error
            )
        {
            if (!HasDelegates(ref error))
                return ReturnCode.Error;

            if (name == null)
            {
                error = "invalid delegate name";
                return ReturnCode.Error;
            }

            _Wrappers.Delegate wrapper;

            if (!delegates.TryGetValue(name, out wrapper))
            {
                error = "delegate not found";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                @delegate = wrapper;
                token = EntityOps.GetToken(wrapper);

                if ((@delegate == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid delegate";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
            else
            {
                if (wrapper == null)
                {
                    error = "invalid delegate wrapper";
                    return ReturnCode.Error;
                }

                @delegate = wrapper.@delegate;
                token = EntityOps.GetToken(@delegate);

                if ((@delegate == null) &&
                    FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                {
                    error = "invalid delegate";
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetDelegate(
            string name,
            LookupFlags lookupFlags,
            ref IDelegate @delegate,
            ref Result error
            )
        {
            long token = 0;

            return GetDelegate(name, lookupFlags, ref token, ref @delegate, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetDelegate(
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IDelegate @delegate,
            ref Result error
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (PrivateGetDelegate(
                        name, lookupFlags, ref token, ref @delegate,
                        ref error) != ReturnCode.Ok)
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "invalid delegate name {0}",
                            FormatOps.DisplayName(name)) :
                        "invalid delegate name";

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddDelegate(
            IDelegate @delegate,
            IClientData clientData,
            ref Result result
            )
        {
            long token = 0;

            return AddDelegate(@delegate, clientData, ref token, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddDelegate(
            IDelegate @delegate,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (@delegate == null)
                {
                    result = "invalid delegate";
                    return ReturnCode.Error;
                }

                string name = @delegate.Name;

                if (name == null)
                {
                    result = "invalid delegate name";
                    return ReturnCode.Error;
                }

                if (!HasDelegates(ref result))
                    return ReturnCode.Error;

                if (DoesDelegateExist(name) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: delegate already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    bool success = false;
                    _Wrappers.Delegate wrapper = null;

                    try
                    {
                        long id = EntityOps.NextTokenIdNoThrow(@delegate);
                        wrapper = new _Wrappers.Delegate(id, @delegate);

                        delegates.Add(name, wrapper);
                        success = true;

                        long newToken = EntityOps.GetToken(wrapper);
                        EntityOps.SetToken(@delegate, newToken);

#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Delegate, NotifyFlags.Added,
                            new ObjectPair(@delegate, newToken), this,
                            clientData, null, null, ref result);
#endif

                        token = newToken;
                    }
                    finally
                    {
                        if (!success && (wrapper != null))
                        {
                            wrapper.Dispose();
                            wrapper = null;
                        }
                    }
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateRemoveDelegate(
            string name,
            long token,
            IDelegate @delegate,
            IClientData clientData,
            bool synchronous,
            ref bool dispose,
            ref Result result
            )
        {
            if (name == null)
            {
                result = "invalid delegate name";
                return ReturnCode.Error;
            }

            if (dispose)
            {
                if (@delegate != null)
                {
                    GlobalState.PushActiveInterpreter(this);

                    try
                    {
                        if (ObjectOps.TryDispose<IDelegate>(ref @delegate,
                                ref dispose, ref result) == ReturnCode.Ok)
                        {
                            @delegate = null;

                            if (synchronous)
                                ObjectOps.CollectGarbage(); /* throw */
                        }
                        else
                        {
                            return ReturnCode.Error;
                        }
                    }
                    catch (Exception e)
                    {
                        result = String.Format(
                            "caught exception while disposing delegate: {0}",
                            e);

                        return ReturnCode.Error;
                    }
                    finally
                    {
                        /* IGNORED */
                        GlobalState.PopActiveInterpreter();
                    }
                }
            }

            delegates.Remove(name, token);

#if NOTIFY
            /* IGNORED */
            CheckNotification(
                NotifyType.Delegate, NotifyFlags.Removed,
                new ObjectTriplet(@delegate, name, token), this,
                clientData, null, null, ref result);
#endif

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveDelegate(
            string name,
            IClientData clientData /* NOT USED */,
            bool synchronous,
            ref Result result
            )
        {
            bool dispose = ObjectOps.GetDefaultDispose();

            return RemoveDelegate(name, clientData, synchronous, ref dispose, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RemoveDelegate(
            string name,
            IClientData clientData /* NOT USED */,
            bool synchronous,
            ref bool dispose,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasDelegates(ref result))
                {
                    long token = 0;
                    IDelegate @delegate = null;

                    if (GetDelegate(name, LookupFlags.Remove, ref token,
                            ref @delegate, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemoveDelegate(
                            name, token, @delegate, clientData, synchronous,
                            ref dispose, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveDelegate(
            long token,
            IClientData clientData, /* NOT USED */
            ref bool dispose,
            ref Result result
            )
        {
            return RemoveDelegate(
                token, clientData, ObjectOps.GetDefaultSynchronous(), ref dispose, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RemoveDelegate(
            long token,
            IClientData clientData, /* NOT USED */
            bool synchronous,
            ref bool dispose,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (HasDelegates(ref result))
                {
                    string name = null;
                    IDelegate @delegate = null;

                    if (GetDelegate(token, LookupFlags.Remove, ref name,
                            ref @delegate, ref result) == ReturnCode.Ok)
                    {
                        return PrivateRemoveDelegate(
                            name, token, @delegate, clientData, synchronous,
                            ref dispose, ref result);
                    }
                }
            }

            return ReturnCode.Error;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Cleanup Paths
        internal ReturnCode ListCleanupPaths(
            string pattern,
            bool noCase,
            ref StringList list,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (cleanupPaths == null)
                {
                    error = "cleanup paths not available";
                    return ReturnCode.Error;
                }

                IEnumerable<CleanupPathPair> pairs =
                    cleanupPaths.GetPairsInOrder(true);

                if (pairs == null)
                {
                    error = "cannot get cleanup paths in order";
                    return ReturnCode.Error;
                }

                StringList localList = null;

                foreach (CleanupPathPair pair in pairs)
                {
                    string path = pair.Key;

                    if (String.IsNullOrEmpty(path))
                        continue;

                    if ((pattern != null) && !StringOps.Match(
                            this, MatchMode.Glob, path, pattern,
                            noCase))
                    {
                        continue;
                    }

                    CleanupPathClientData clientData = pair.Value;

                    if ((clientData == null) ||
                        !clientData.MatchPathType(path))
                    {
                        continue;
                    }

                    if (localList == null)
                        localList = new StringList();

                    localList.Add(path);
                    localList.Add(clientData.ToString());
                }

                list = localList;
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddCleanupPath(
            string path,
            PathType pathType,
            bool recursive,
            bool force,
            bool noComplain,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (path == null)
                {
                    error = "invalid path";
                    return ReturnCode.Error;
                }

                if (cleanupPaths == null)
                {
                    error = "cleanup paths not available";
                    return ReturnCode.Error;
                }

                CleanupPathClientData clientData;

                /* IGNORED */
                cleanupPaths.TryGetValue(path, out clientData);

                if (clientData == null)
                    clientData = new CleanupPathClientData();

                clientData.PathType = pathType;
                clientData.Recursive = recursive;
                clientData.Force = force;
                clientData.NoComplain = noComplain;

                cleanupPaths[path] = clientData;
                return ReturnCode.Ok;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Channel
        private IChannel GetChannel(
            string name
            )
        {
            Result error = null;

            return GetChannel(name, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IChannel GetChannel(
            string name,
            ref Result error
            )
        {
            if (name == null)
            {
                error = "invalid channel name";
                return null;
            }

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!PrivateHasChannels(ref error))
                    return null;

                IChannel channel;

                if (channels.TryGetValue(name, out channel))
                {
                    if (channel == null)
                    {
                        error = String.Format(
                            "invalid channel {0}",
                            FormatOps.WrapOrNull(name));
                    }
                }
                else
                {
                    error = String.Format(
                        "can not find channel named {0}",
                        FormatOps.WrapOrNull(name));
                }

                return channel;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Virtual Output
        internal StringBuilder GetChannelVirtualOutput(
            string name
            )
        {
            StringBuilder builder = null;
            Result error = null;

            if (GetChannelVirtualOutput(
                    name, false, ref builder,
                    ref error) == ReturnCode.Ok)
            {
                return builder;
            }

            return null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetChannelVirtualOutput(
            string name,
            bool copy,
            ref StringBuilder builder,
            ref Result error
            )
        {
            IChannel channel = GetChannel(name, ref error);

            if (channel != null)
            {
                if (channel.VirtualOutput != null)
                {
                    if (copy)
                    {
                        builder = StringOps.CopyStringBuilder(
                            channel.VirtualOutput);
                    }
                    else
                    {
                        builder = channel.VirtualOutput;
                    }

                    return ReturnCode.Ok;
                }

                error = String.Format(
                    "virtual output is not enabled for channel named {0}",
                    FormatOps.WrapOrNull(name));
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SetChannelVirtualOutput(
            string name,
            bool enable,
            ref Result result
            )
        {
            IChannel channel = GetChannel(name, ref result);

            if (channel != null)
            {
                if (enable)
                    channel.VirtualOutput = StringOps.NewStringBuilder();
                else
                    channel.VirtualOutput = null;

                result = String.Format(
                    "virtual output {0} for channel {1}",
                    ConversionOps.ToEnabled(enable),
                    FormatOps.WrapOrNull(name));

                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Adding Channels
        internal ReturnCode AddFileOrSocketChannel(
            string name,
            Stream stream,
            OptionDictionary options,
            StreamFlags flags,
            int? availableTimeout,
            bool nullEncoding,
            bool appendMode,
            bool autoFlush,
            IClientData clientData,
            ref Result error
            )
        {
            return AddChannel(
                name, ChannelType.None, stream, options, flags,
                StreamTranslation.auto, StreamTranslation.auto,
                StringOps.GetEncoding(EncodingType.Channel),
                availableTimeout, nullEncoding, appendMode,
                autoFlush, clientData, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NETWORK
        internal ReturnCode AddTcpListenerChannel(
            string name,
            ChannelType channelType,
            TcpListener listener,
            SocketClientData clientData,
            ref bool added,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref error))
                    return ReturnCode.Error;

                string channelId = RuntimeOps.ChannelTypeToName(
                    name, channelType);

                if (channelId == null)
                {
                    error = "invalid channel name";
                    return ReturnCode.Error;
                }

                if (!PrivateHasChannels(ref error))
                    return ReturnCode.Error;

                if (channels.ContainsKey(channelId)) /* EXEMPT */
                {
                    error = String.Format(
                        "can't add {0}: channel already exists",
                        FormatOps.WrapOrNull(channelId));

                    return ReturnCode.Error;
                }

                OptionDictionary options = (clientData != null) ?
                    clientData.Options : null;

                channels.Add(channelId, Channel.CreateListener(
                    listener, channelType, options,
                    StreamFlags.ListenSocket, clientData));

                added = true;
            }

            return ReturnCode.Ok;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Standard Channels
        internal ReturnCode ModifyStandardChannels(
            IStreamHost streamHost,
            string name, /* NOTE: Cannot be non-null when adding multiple channels. */
            ChannelType channelType,
            ref Result error
            )
        {
            bool locked = false; /* REUSED */

            if ((streamHost == null) && FlagOps.HasFlags(
                    channelType, ChannelType.UseHost, true))
            {
                try
                {
                    InternalHardTryLock(ref locked);

                    if (locked)
                    {
                        streamHost = host; /* FIELD */
                    }
                    else
                    {
                        error = "unable to acquire lock";
                        return ReturnCode.Error;
                    }
                }
                finally
                {
                    InternalExitLock(ref locked);
                }
            }

            if (streamHost == null)
            {
                error = "interpreter host not available";
                return ReturnCode.Error;
            }

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    if (!PrivateHasChannels(ref error))
                        return ReturnCode.Error;

                    //
                    // HACK: For the built-in console host only,
                    //       temporarily disable the throwing of
                    //       exceptions due to the console being
                    //       closed.  This is necessary because
                    //       we need to access several properties
                    //       of the host while [re-]adding the
                    //       standard channels (e.g. from the
                    //       [host reset -channels] sub-command).
                    //       See the test "host-1.1" for details.
                    //
#if CONSOLE
                    bool throwOnMustBeOpen = false;

                    //
                    // NOTE: Is the host providing the underlying
                    //       streams actually the console host?
                    //
                    if (streamHost is _Hosts.Console)
                    {
                        //
                        // NOTE: Mark added channels as belonging
                        //       to the System.Console.
                        //
                        channelType |= ChannelType.Console;

                        //
                        // NOTE: Make sure that exceptions are
                        //       not thrown when the console is
                        //       not open during an attempt to
                        //       make use of it.
                        //
                        _Hosts.Console.ThrowOnMustBeOpen = false;
                        throwOnMustBeOpen = true;
                    }
                    else
                    {
                        //
                        // NOTE: Make sure that added channels,
                        //       if any, are -NOT- marked as
                        //       belonging to the System.Console.
                        //
                        channelType &= ~ChannelType.Console;
                    }

                    try
                    {
#endif
                        bool allowExist = FlagOps.HasFlags(
                            channelType, ChannelType.AllowExist, true);

                        bool allowProxy = FlagOps.HasFlags(
                            channelType, ChannelType.AllowProxy, true);

                        bool beginContext = FlagOps.HasFlags(
                            channelType, ChannelType.BeginContext, true);

                        bool endContext = FlagOps.HasFlags(
                            channelType, ChannelType.EndContext, true);

                        bool errorOnExist = FlagOps.HasFlags(
                            channelType, ChannelType.ErrorOnExist, true);

                        bool errorOnNotExist = FlagOps.HasFlags(
                            channelType, ChannelType.ErrorOnNotExist, true);

                        bool errorOnNull = FlagOps.HasFlags(
                            channelType, ChannelType.ErrorOnNull, true);

                        bool errorOnProxy = FlagOps.HasFlags(
                            channelType, ChannelType.ErrorOnProxy, true);

                        bool useCurrent = FlagOps.HasFlags(
                            channelType, ChannelType.UseCurrent, true);

                        bool skipGetStream = FlagOps.HasFlags(
                            channelType, ChannelType.SkipGetStream, true);

                        bool closeOnEndContext = FlagOps.HasFlags(
                            channelType, ChannelType.CloseOnEndContext, true);

                        try
                        {
                            //
                            // NOTE: When doing BeginContext and/or EndContext, we
                            //       (may) need the current interpreter host, which
                            //       may be different than the one specified by our
                            //       caller.
                            //
                            IStreamHost currentStreamHost = null;

                            if (beginContext || endContext)
                                currentStreamHost = host; /* FIELD */

                            ChannelType currentChannelType = channelType;

#if CONSOLE
                            bool throwOnMustBeOpen2 = false;

                            //
                            // NOTE: Is the current host providing the underlying
                            //       streams actually the console host?
                            //
                            if (currentStreamHost is _Hosts.Console)
                            {
                                //
                                // NOTE: Mark added channels as belonging
                                //       to the System.Console.
                                //
                                currentChannelType |= ChannelType.Console;

                                //
                                // NOTE: Make sure that exceptions are
                                //       thrown when the console is not
                                //       open during an attempt to make
                                //       use of it.
                                //
                                _Hosts.Console.ThrowOnMustBeOpen = false;
                                throwOnMustBeOpen2 = true;
                            }
                            else
                            {
                                //
                                // NOTE: Make sure that added channels,
                                //       if any, are -NOT- marked as
                                //       belonging to the System.Console.
                                //
                                currentChannelType &= ~ChannelType.Console;
                            }

                            try
                            {
#endif
                                HostFlags hostFlags = streamHost.GetHostFlags();

                                ///////////////////////////////////////////////////////////////////////

                                bool modifiedIn = false;

                                if (FlagOps.HasFlags(channelType, ChannelType.Input, true))
                                {
                                    string channelId = (name != null) ?
                                        name : StandardChannel.Input;

                                    IChannel oldChannel;

                                    bool contains = channels.TryGetValue(
                                        channelId, out oldChannel);

                                    if (allowExist || !contains)
                                    {
                                        Stream stream;
                                        Result streamError = null;

                                        stream = skipGetStream ? null :
                                            ChannelOps.GetStream(streamHost,
                                                (channelType & ~ChannelType.StandardChannels) |
                                                ChannelType.Input, useCurrent, ref streamError);

                                        if (skipGetStream || (stream != null))
                                        {
                                            if (allowProxy || (stream == null) ||
                                                !AppDomainOps.IsTransparentProxy(stream))
                                            {
                                                if (beginContext || endContext)
                                                {
                                                    IChannel contextChannel;
                                                    Result contextError; /* REUSED */
                                                    bool contextDispose;

                                                    if (contains)
                                                    {
                                                        contextError = null;
                                                        contextChannel = oldChannel;
                                                        contextDispose = false;
                                                    }
                                                    else
                                                    {
                                                        contextError = null;

                                                        contextChannel = ChannelOps.CreateInput(
                                                            currentStreamHost, currentChannelType,
                                                            ChannelOps.GetStreamFlags(),
                                                            useCurrent, ref contextError);

                                                        contextDispose = true;
                                                    }

                                                    if (contextChannel != null)
                                                    {
                                                        if (endContext)
                                                        {
                                                            contextError = null;

                                                            if (!contextChannel.EndContext(
                                                                    closeOnEndContext,
                                                                    ref contextError))
                                                            {
                                                                if (contextDispose)
                                                                {
                                                                    ObjectOps.TryDisposeOrComplain<IChannel>(
                                                                        this, ref contextChannel);
                                                                }

                                                                error = contextError;
                                                                return ReturnCode.Error;
                                                            }
                                                        }

                                                        if (beginContext)
                                                        {
                                                            contextError = null;

                                                            if (!contextChannel.BeginContext(
                                                                    stream, ref contextError))
                                                            {
                                                                if (contextDispose)
                                                                {
                                                                    ObjectOps.TryDisposeOrComplain<IChannel>(
                                                                        this, ref contextChannel);
                                                                }

                                                                error = contextError;
                                                                return ReturnCode.Error;
                                                            }
                                                        }

                                                        if (!contains)
                                                            channels.Add(channelId, contextChannel);
                                                    }
                                                    else if (errorOnNull)
                                                    {
                                                        if (contextError != null)
                                                        {
                                                            error = contextError;
                                                        }
                                                        else
                                                        {
                                                            error = String.Format(
                                                                "can't begin/end context for " +
                                                                "{0}: channel not available",
                                                                FormatOps.WrapOrNull(channelId));
                                                        }

                                                        return ReturnCode.Error;
                                                    }
                                                }
                                                else
                                                {
                                                    IChannel newChannel = Channel.CreateInput(
                                                        stream, channelType,
                                                        ChannelOps.GetStreamFlags(),
                                                        streamHost.InputEncoding);

                                                    if (contains)
                                                    {
                                                        ObjectOps.TryDisposeOrComplain<IChannel>(
                                                            this, ref oldChannel);

                                                        channels[channelId] = newChannel;
                                                    }
                                                    else if (errorOnNotExist)
                                                    {
                                                        ObjectOps.TryDisposeOrComplain<IChannel>(
                                                            this, ref newChannel);

                                                        error = String.Format(
                                                            "can't update {0}: channel does not exist",
                                                            FormatOps.WrapOrNull(channelId));

                                                        return ReturnCode.Error;
                                                    }
                                                    else
                                                    {
                                                        channels.Add(channelId, newChannel);
                                                    }
                                                }

                                                modifiedIn = true;
                                            }
                                            else if (errorOnProxy)
                                            {
                                                error = String.Format(
                                                    "can't {0} {1}: stream is a proxy",
                                                    contains ? "update" : "add",
                                                    FormatOps.WrapOrNull(channelId));

                                                return ReturnCode.Error;
                                            }
                                        }
                                        else if (errorOnNull)
                                        {
                                            if (streamError != null)
                                            {
                                                error = streamError;
                                            }
                                            else
                                            {
                                                error = String.Format(
                                                    "can't {0} {1}: stream not available",
                                                    contains ? "update" : "add",
                                                    FormatOps.WrapOrNull(channelId));
                                            }

                                            return ReturnCode.Error;
                                        }
                                    }
                                    else if (errorOnExist)
                                    {
                                        error = String.Format(
                                            "can't {0} {1}: channel already exists",
                                            contains ? "update" : "add",
                                            FormatOps.WrapOrNull(channelId));

                                        return ReturnCode.Error;
                                    }
                                }

                                ///////////////////////////////////////////////////////////////////////

                                bool modifiedOut = false;

                                if (FlagOps.HasFlags(channelType, ChannelType.Output, true))
                                {
                                    string channelId = (name != null) ?
                                        name : StandardChannel.Output;

                                    IChannel oldChannel;

                                    bool contains = channels.TryGetValue(
                                        channelId, out oldChannel);

                                    if (allowExist || !contains)
                                    {
                                        Stream stream;
                                        Result streamError = null;

                                        stream = skipGetStream ? null :
                                            ChannelOps.GetStream(streamHost,
                                                (channelType & ~ChannelType.StandardChannels) |
                                                ChannelType.Output, useCurrent, ref streamError);

                                        if (skipGetStream || (stream != null))
                                        {
                                            if (allowProxy || (stream == null) ||
                                                !AppDomainOps.IsTransparentProxy(stream))
                                            {
                                                if (beginContext || endContext)
                                                {
                                                    IChannel contextChannel;
                                                    Result contextError; /* REUSED */
                                                    bool contextDispose;

                                                    if (contains)
                                                    {
                                                        contextError = null;
                                                        contextChannel = oldChannel;
                                                        contextDispose = false;
                                                    }
                                                    else
                                                    {
                                                        contextError = null;

                                                        contextChannel = ChannelOps.CreateOutput(
                                                            currentStreamHost, currentChannelType,
                                                            StreamFlags.None, useCurrent,
                                                            FlagOps.HasFlags(hostFlags,
                                                            HostFlags.AutoFlushOutput, true),
                                                            ref contextError);

                                                        contextDispose = true;
                                                    }

                                                    if (contextChannel != null)
                                                    {
                                                        if (endContext)
                                                        {
                                                            contextError = null;

                                                            if (!contextChannel.EndContext(
                                                                    closeOnEndContext,
                                                                    ref contextError))
                                                            {
                                                                if (contextDispose)
                                                                {
                                                                    ObjectOps.TryDisposeOrComplain<IChannel>(
                                                                        this, ref contextChannel);
                                                                }

                                                                error = contextError;
                                                                return ReturnCode.Error;
                                                            }
                                                        }

                                                        if (beginContext)
                                                        {
                                                            contextError = null;

                                                            if (!contextChannel.BeginContext(
                                                                    stream, ref contextError))
                                                            {
                                                                if (contextDispose)
                                                                {
                                                                    ObjectOps.TryDisposeOrComplain<IChannel>(
                                                                        this, ref contextChannel);
                                                                }

                                                                error = contextError;
                                                                return ReturnCode.Error;
                                                            }
                                                        }

                                                        if (!contains)
                                                            channels.Add(channelId, contextChannel);
                                                    }
                                                    else if (errorOnNull)
                                                    {
                                                        if (contextError != null)
                                                        {
                                                            error = contextError;
                                                        }
                                                        else
                                                        {
                                                            error = String.Format(
                                                                "can't begin/end context for " +
                                                                "{0}: channel not available",
                                                                FormatOps.WrapOrNull(channelId));
                                                        }

                                                        return ReturnCode.Error;
                                                    }
                                                }
                                                else
                                                {
                                                    IChannel newChannel = Channel.CreateOutput(
                                                        stream, channelType, StreamFlags.None,
                                                        streamHost.OutputEncoding, FlagOps.HasFlags(
                                                        hostFlags, HostFlags.AutoFlushOutput, true));

                                                    if (contains)
                                                    {
                                                        ObjectOps.TryDisposeOrComplain<IChannel>(
                                                            this, ref oldChannel);

                                                        channels[channelId] = newChannel;
                                                    }
                                                    else if (errorOnNotExist)
                                                    {
                                                        ObjectOps.TryDisposeOrComplain<IChannel>(
                                                            this, ref newChannel);

                                                        error = String.Format(
                                                            "can't update {0}: channel does not exist",
                                                            FormatOps.WrapOrNull(channelId));

                                                        return ReturnCode.Error;
                                                    }
                                                    else
                                                    {
                                                        channels.Add(channelId, newChannel);
                                                    }
                                                }

                                                modifiedOut = true;
                                            }
                                            else if (errorOnProxy)
                                            {
                                                error = String.Format(
                                                    "can't {0} {1}: stream is a proxy",
                                                    contains ? "update" : "add",
                                                    FormatOps.WrapOrNull(channelId));

                                                return ReturnCode.Error;
                                            }
                                        }
                                        else if (errorOnNull)
                                        {
                                            if (streamError != null)
                                            {
                                                error = streamError;
                                            }
                                            else
                                            {
                                                error = String.Format(
                                                    "can't {0} {1}: stream not available",
                                                    contains ? "update" : "add",
                                                    FormatOps.WrapOrNull(channelId));
                                            }

                                            return ReturnCode.Error;
                                        }
                                    }
                                    else if (errorOnExist)
                                    {
                                        error = String.Format(
                                            "can't {0} {1}: channel already exists",
                                            contains ? "update" : "add",
                                            FormatOps.WrapOrNull(channelId));

                                        return ReturnCode.Error;
                                    }
                                }

                                ///////////////////////////////////////////////////////////////////////

                                bool modifiedError = false;

                                if (FlagOps.HasFlags(channelType, ChannelType.Error, true))
                                {
                                    string channelId = (name != null) ?
                                        name : StandardChannel.Error;

                                    IChannel oldChannel;

                                    bool contains = channels.TryGetValue(
                                        channelId, out oldChannel);

                                    if (allowExist || !contains)
                                    {
                                        Stream stream;
                                        Result streamError = null;

                                        stream = skipGetStream ? null :
                                            ChannelOps.GetStream(streamHost,
                                                (channelType & ~ChannelType.StandardChannels) |
                                                ChannelType.Error, useCurrent, ref streamError);

                                        if (skipGetStream || (stream != null))
                                        {
                                            if (allowProxy || (stream == null) ||
                                                !AppDomainOps.IsTransparentProxy(stream))
                                            {
                                                if (beginContext || endContext)
                                                {
                                                    IChannel contextChannel;
                                                    Result contextError; /* REUSED */
                                                    bool contextDispose;

                                                    if (contains)
                                                    {
                                                        contextError = null;
                                                        contextChannel = oldChannel;
                                                        contextDispose = false;
                                                    }
                                                    else
                                                    {
                                                        contextError = null;

                                                        contextChannel = ChannelOps.CreateError(
                                                            currentStreamHost, currentChannelType,
                                                            StreamFlags.None, useCurrent,
                                                            FlagOps.HasFlags(hostFlags,
                                                            HostFlags.AutoFlushOutput, true),
                                                            ref contextError);

                                                        contextDispose = true;
                                                    }

                                                    if (contextChannel != null)
                                                    {
                                                        if (endContext)
                                                        {
                                                            contextError = null;

                                                            if (!contextChannel.EndContext(
                                                                    closeOnEndContext,
                                                                    ref contextError))
                                                            {
                                                                if (contextDispose)
                                                                {
                                                                    ObjectOps.TryDisposeOrComplain<IChannel>(
                                                                        this, ref contextChannel);
                                                                }

                                                                error = contextError;
                                                                return ReturnCode.Error;
                                                            }
                                                        }

                                                        if (beginContext)
                                                        {
                                                            contextError = null;

                                                            if (!contextChannel.BeginContext(
                                                                    stream, ref contextError))
                                                            {
                                                                if (contextDispose)
                                                                {
                                                                    ObjectOps.TryDisposeOrComplain<IChannel>(
                                                                        this, ref contextChannel);
                                                                }

                                                                error = contextError;
                                                                return ReturnCode.Error;
                                                            }
                                                        }

                                                        if (!contains)
                                                            channels.Add(channelId, contextChannel);
                                                    }
                                                    else if (errorOnNull)
                                                    {
                                                        if (contextError != null)
                                                        {
                                                            error = contextError;
                                                        }
                                                        else
                                                        {
                                                            error = String.Format(
                                                                "can't begin/end context for " +
                                                                "{0}: channel not available",
                                                                FormatOps.WrapOrNull(channelId));
                                                        }

                                                        return ReturnCode.Error;
                                                    }
                                                }
                                                else
                                                {
                                                    IChannel newChannel = Channel.CreateError(
                                                        stream, channelType, StreamFlags.None,
                                                        streamHost.ErrorEncoding, FlagOps.HasFlags(
                                                        hostFlags, HostFlags.AutoFlushError, true));

                                                    if (contains)
                                                    {
                                                        ObjectOps.TryDisposeOrComplain<IChannel>(
                                                            this, ref oldChannel);

                                                        channels[channelId] = newChannel;
                                                    }
                                                    else if (errorOnNotExist)
                                                    {
                                                        ObjectOps.TryDisposeOrComplain<IChannel>(
                                                            this, ref newChannel);

                                                        error = String.Format(
                                                            "can't update {0}: channel does not exist",
                                                            FormatOps.WrapOrNull(channelId));

                                                        return ReturnCode.Error;
                                                    }
                                                    else
                                                    {
                                                        channels.Add(channelId, newChannel);
                                                    }
                                                }

                                                modifiedError = true;
                                            }
                                            else if (errorOnProxy)
                                            {
                                                error = String.Format(
                                                    "can't {0} {1}: stream is a proxy",
                                                    contains ? "update" : "add",
                                                    FormatOps.WrapOrNull(channelId));

                                                return ReturnCode.Error;
                                            }
                                        }
                                        else if (errorOnNull)
                                        {
                                            if (streamError != null)
                                            {
                                                error = streamError;
                                            }
                                            else
                                            {
                                                error = String.Format(
                                                    "can't {0} {1}: stream not available",
                                                    contains ? "update" : "add",
                                                    FormatOps.WrapOrNull(channelId));
                                            }

                                            return ReturnCode.Error;
                                        }
                                    }
                                    else if (errorOnExist)
                                    {
                                        error = String.Format(
                                            "can't {0} {1}: channel already exists",
                                            contains ? "update" : "add",
                                            FormatOps.WrapOrNull(channelId));

                                        return ReturnCode.Error;
                                    }
                                }

                                ///////////////////////////////////////////////////////////////////////////

                                if (modifiedIn || modifiedOut || modifiedError)
                                {
                                    /* IGNORED */
                                    streamHost.SetupChannels();
                                }

                                ///////////////////////////////////////////////////////////////////////////

                                return ReturnCode.Ok;
#if CONSOLE
                            }
                            finally
                            {
                                if (throwOnMustBeOpen2)
                                {
                                    _Hosts.Console.ThrowOnMustBeOpen = true;
                                    throwOnMustBeOpen2 = false;
                                }
                            }
#endif
                        }
                        catch (Exception e)
                        {
                            error = e;
                            return ReturnCode.Error;
                        }
#if CONSOLE
                    }
                    finally
                    {
                        if (throwOnMustBeOpen)
                        {
                            _Hosts.Console.ThrowOnMustBeOpen = true;
                            throwOnMustBeOpen = false;
                        }
                    }
#endif
                }
                else
                {
                    error = "unable to acquire lock";
                    return ReturnCode.Error;
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ResetStandardChannels(
            IStreamHost streamHost,
            ref Result error
            )
        {
            return ModifyStandardChannels(
                streamHost, null, ChannelType.StandardChannels |
                ChannelType.AllowExist, ref error);
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region AppDomain
#if APPDOMAINS
        private ReturnCode AddAppDomain(
            string friendlyName,
            string baseDirectory,
            string packagePath,
#if CAS_POLICY
            Evidence evidence,
#endif
            IClientData clientData,
            bool useBasePath,
            bool verifyCoreAssembly,
            bool useEntryAssembly,
            bool optionalEntryAssembly,
            bool copyConfiguration,
            ref AppDomain appDomain,
            ref Result error
            )
        {
            //
            // NOTE: *WARNING* Empty application domain names are allowed,
            //       please do not change this to "!String.IsNullOrEmpty".
            //
            if (friendlyName != null)
            {
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    if (appDomains != null)
                    {
                        if (AppDomainOps.Create(
                                this, friendlyName, baseDirectory, packagePath,
#if CAS_POLICY
                                evidence,
#endif
                                clientData, useBasePath, verifyCoreAssembly,
                                useEntryAssembly, optionalEntryAssembly,
                                ref appDomain, ref error) == ReturnCode.Ok)
                        {
                            Result localError = null;

                            if (copyConfiguration &&
                                AppDomainOps.TransferStaticInformation(
                                    appDomain, typeof(TraceOps), null, null,
                                    false, ref localError) != ReturnCode.Ok)
                            {
                                TraceOps.DebugTrace(String.Format(
                                    "AddAppDomain: failed to copy TraceOps " +
                                    "static configuration: {0}", localError),
                                    typeof(Interpreter).Name,
                                    TracePriority.MarshalError);
                            }

                            appDomains.Add(friendlyName, appDomain);

#if NOTIFY
                            /* IGNORED */
                            CheckNotification(
                                NotifyType.AppDomain, NotifyFlags.Added,
                                new ObjectPair(friendlyName, appDomain), this,
                                clientData, null, null, ref error);
#endif

                            return ReturnCode.Ok;
                        }
                    }
                    else
                    {
                        error = "application domains not available";
                    }
                }
            }
            else
            {
                error = "invalid friendly name";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RemoveAppDomain(
            string friendlyName,
            IClientData clientData,
            ref Result error
            )
        {
            //
            // NOTE: *WARNING* Empty application domain names are allowed,
            //       please do not change this to "!String.IsNullOrEmpty".
            //
            if (friendlyName != null)
            {
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    if (appDomains != null)
                    {
                        AppDomain appDomain;

                        if (appDomains.TryGetValue(friendlyName, out appDomain))
                        {
                            if (AppDomainOps.Unload(
                                    friendlyName, appDomain, clientData,
                                    ref error) == ReturnCode.Ok)
                            {
                                appDomains.Remove(friendlyName);

#if NOTIFY
                                /* IGNORED */
                                CheckNotification(
                                    NotifyType.AppDomain, NotifyFlags.Removed,
                                    new ObjectPair(friendlyName, appDomain), this,
                                    clientData, null, null, ref error);
#endif

                                return ReturnCode.Ok;
                            }
                        }
                        else
                        {
                            error = String.Format(
                                "invalid application domain name {0}",
                                FormatOps.DisplayName(friendlyName));
                        }
                    }
                    else
                    {
                        error = "application domains not available";
                    }
                }
            }
            else
            {
                error = "invalid friendly name";
            }

            return ReturnCode.Error;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region CLR Integration
        //
        // NOTE: For System.Type short-name to long-name lookups (i.e. TypeDefs).
        //
        internal StringDictionary ObjectTypes
        {
            get
            {
                lock (syncRoot)
                {
                    return objectTypes;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For System.Type objects, not related to Tcl namespaces.
        //
        internal StringLongPairStringDictionary ObjectNamespaces
        {
            get
            {
                lock (syncRoot)
                {
                    return objectNamespaces;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For COM interop assemblies, we keep track of interfaces.
        //
        internal TypePairDictionary<string, long> ObjectInterfaces
        {
            get
            {
                lock (syncRoot)
                {
                    return objectInterfaces;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Keep track of the namespaces that should be used for aliased
        //       object commands that use types from a particular assembly.
        //
        internal StringDictionary ObjectAliasNamespaces
        {
            get
            {
                lock (syncRoot)
                {
                    return objectAliasNamespaces;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HasObjectTypes(ref Result error)
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (objectTypes != null);

                if (!result)
                    error = "object types not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HasObjectNamespaces(ref Result error)
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (objectNamespaces != null);

                if (!result)
                    error = "object namespaces not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HasObjectInterfaces(ref Result error)
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (objectInterfaces != null);

                if (!result)
                    error = "interfaces not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HasObjectAliasNamespaces(ref Result error)
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (objectAliasNamespaces != null);

                if (!result)
                    error = "alias namespaces not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddObjectTypes(
            StringList list,
            MatchMode mode,
            string pattern,
            bool noCase,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // HACK: Potentially modifies object types instead of purely
                //       adding.
                //
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                if (HasObjectTypes(ref error))
                {
                    if (list != null)
                    {
                        if ((list.Count % 2) == 0)
                        {
                            for (int index = 0; index < list.Count; index += 2)
                            {
                                string key = list[index];

                                if (key != null) // empty string allowed.
                                {
                                    string value = list[index + 1];

                                    if ((mode == MatchMode.None) ||
                                        StringOps.Match(this, mode, key, pattern, noCase))
                                    {
                                        objectTypes[key] = value;
                                    }
                                }
                            }

                            return ReturnCode.Ok;
                        }
                        else
                        {
                            error = "type list must have an even number of elements";
                        }
                    }
                    else
                    {
                        error = "invalid type list";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveObjectTypes(
            MatchMode mode,
            string pattern,
            bool noCase,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                if (HasObjectTypes(ref error))
                {
                    StringList keys = new StringList();

                    //
                    // NOTE: Cleanup, PASS #1, collect the list of keys we need to remove
                    //       from the types dictionary in the containing interpreter.
                    //
                    foreach (KeyValuePair<string, string> pair in objectTypes)
                    {
                        string type = pair.Key;

                        if ((mode == MatchMode.None) ||
                            StringOps.Match(this, mode, type, pattern, noCase))
                        {
                            keys.Add(type);
                        }
                    }

                    //
                    // NOTE: Cleanup, PASS #2, and remove all the types we found from
                    //       PASS #1 (above).
                    //
                    foreach (string key in keys)
                        objectTypes.Remove(key);

                    //
                    // NOTE: Ok, we were successful.
                    //
                    return ReturnCode.Ok;
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode MatchObjectNamespace(
            MatchMode mode,  /* in */
            string pattern,  /* in */
            bool noCase,     /* in */
            bool values,     /* in */
            ref int matched, /* in, out */
            ref Result error /* out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasObjectNamespaces(ref error))
                    return ReturnCode.Error;

                foreach (KeyValuePair<StringLongPair, string> pair in objectNamespaces)
                {
                    if (values)
                    {
                        string value = pair.Value;

                        if (value == null)
                            continue;

                        if ((mode == MatchMode.None) ||
                            StringOps.Match(this, mode, value, pattern, noCase))
                        {
                            matched++;
                        }
                    }
                    else
                    {
                        StringLongPair anyPair = pair.Key;

                        if (anyPair == null)
                            continue;

                        string key = anyPair.X;

                        if (key == null)
                            continue;

                        if ((mode == MatchMode.None) ||
                            StringOps.Match(this, mode, key, pattern, noCase))
                        {
                            matched++;
                        }
                    }
                }

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddObjectNamespaces(
            StringLongPairStringDictionary dictionary, /* in */
            MatchMode mode,                            /* in */
            string pattern,                            /* in */
            bool noCase,                               /* in */
            ref Result error                           /* out */
            )
        {
            int added = 0;

            return AddObjectNamespaces(
                dictionary, mode, pattern, noCase, ref added,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddObjectNamespaces(
            StringLongPairStringDictionary dictionary, /* in */
            MatchMode mode,                            /* in */
            string pattern,                            /* in */
            bool noCase,                               /* in */
            ref int added,                             /* in, out */
            ref Result error                           /* out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref error))
                    return ReturnCode.Error;

                if (HasObjectNamespaces(ref error))
                {
                    if (dictionary != null)
                    {
                        foreach (KeyValuePair<StringLongPair, string> pair in dictionary)
                        {
                            StringLongPair anyPair = pair.Key;

                            if (anyPair == null)
                                continue;

                            string key = anyPair.X;

                            if (key == null)
                                continue;

                            if ((mode == MatchMode.None) ||
                                StringOps.Match(this, mode, key, pattern, noCase))
                            {
                                if (!objectNamespaces.ContainsKey(key)) /* EXEMPT */
                                {
                                    string value = pair.Value;

                                    objectNamespaces.Add(key, value);
                                    added++;
                                }
                            }
                        }

                        return ReturnCode.Ok;
                    }
                    else
                    {
                        error = "invalid namespace list";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddObjectNamespaces(
            IEnumerable<Type> types,
            bool nonPublic,
            MatchMode mode,
            string pattern,
            bool noCase,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref error))
                    return ReturnCode.Error;

                if (!HasObjectNamespaces(ref error))
                    return ReturnCode.Error;

                if (types == null)
                {
                    error = "invalid type list";
                    return ReturnCode.Error;
                }

                foreach (Type type in types)
                {
                    if (type == null)
                        continue;

                    if (!nonPublic && !type.IsPublic)
                        continue;

                    string typeNamespace = type.Namespace;

                    if (String.IsNullOrEmpty(typeNamespace))
                        continue;

                    if ((mode == MatchMode.None) || StringOps.Match(
                            this, mode, typeNamespace, pattern, noCase))
                    {
                        if (!objectNamespaces.ContainsKey(
                                typeNamespace)) /* EXEMPT */
                        {
                            objectNamespaces.Add(typeNamespace,
                                AssemblyOps.GetFullName(type));
                        }
                    }
                }

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddObjectNamespaces(
            Assembly assembly,
            bool nonPublic,
            MatchMode mode,
            string pattern,
            bool noCase,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref error))
                    return ReturnCode.Error;

                if (!HasObjectNamespaces(ref error))
                    return ReturnCode.Error;

                if (assembly == null)
                {
                    error = "invalid assembly";
                    return ReturnCode.Error;
                }

                try
                {
                    Type[] types = assembly.GetTypes(); /* throw */

                    return AddObjectNamespaces(
                        types, nonPublic, mode, pattern, noCase, ref error);
                }
                catch (Exception e)
                {
                    error = e;
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveObjectNamespaces(
            MatchMode mode,
            string pattern,
            bool noCase,
            bool values,
            ref Result error
            )
        {
            int removed = 0;

            return RemoveObjectNamespaces(
                mode, pattern, noCase, values, ref removed, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveObjectNamespaces(
            MatchMode mode,
            string pattern,
            bool noCase,
            bool values,
            ref int removed,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                if (!HasObjectNamespaces(ref error))
                    return ReturnCode.Error;

                StringList keys = new StringList();

                //
                // NOTE: Cleanup, PASS #1, collect the list of keys we need to remove
                //       from the namespaces collection in the containing interpreter.
                //
                foreach (KeyValuePair<StringLongPair, string> pair in objectNamespaces)
                {
                    StringLongPair anyPair = pair.Key;

                    if (anyPair == null)
                        continue;

                    string namespaceName = anyPair.X;

                    if (namespaceName == null)
                        continue;

                    if (values)
                    {
                        string assemblyName = pair.Value;

                        if ((mode == MatchMode.None) ||
                            StringOps.Match(this, mode, assemblyName, pattern, noCase))
                        {
                            keys.Add(namespaceName);
                        }
                    }
                    else
                    {
                        if ((mode == MatchMode.None) ||
                            StringOps.Match(this, mode, namespaceName, pattern, noCase))
                        {
                            keys.Add(namespaceName);
                        }
                    }
                }

                //
                // NOTE: Cleanup, PASS #2, and remove all the namespaces we found from
                //       PASS #1 (above).
                //
                foreach (string key in keys)
                    if (objectNamespaces.Remove(key))
                        removed++;

                //
                // NOTE: Ok, we were successful.
                //
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddObjectInterfaces(
            IEnumerable<Type> types,
            bool nonPublic,
            MatchMode mode,
            string pattern,
            bool noCase,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref error))
                    return ReturnCode.Error;

                if (HasObjectInterfaces(ref error))
                {
                    if (types != null)
                    {
                        foreach (Type type in types)
                        {
                            if ((type != null) &&
                                type.IsInterface &&
                                (nonPublic || type.IsPublic))
                            {
                                if ((mode == MatchMode.None) ||
                                    StringOps.Match(this, mode, type.FullName, pattern, noCase))
                                {
                                    if (!objectInterfaces.ContainsKey(type)) /* EXEMPT */
                                    {
                                        objectInterfaces.Add(type,
                                            new AnyPair<string, long>(
                                                AssemblyOps.GetFullName(type),
                                                NextId()));
                                    }
                                }
                            }
                        }

                        return ReturnCode.Ok;
                    }
                    else
                    {
                        error = "invalid interface list";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddObjectInterfaces(
            Assembly assembly,
            bool nonPublic,
            MatchMode mode,
            string pattern,
            bool noCase,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref error))
                    return ReturnCode.Error;

                if (HasObjectInterfaces(ref error))
                {
                    if (assembly != null)
                    {
                        try
                        {
                            Type[] types = assembly.GetTypes();

                            return AddObjectInterfaces(
                                types, nonPublic, mode, pattern, noCase,
                                ref error);
                        }
                        catch (Exception e)
                        {
                            error = e;
                        }
                    }
                    else
                    {
                        error = "invalid assembly";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveObjectInterfaces(
            MatchMode mode,
            string pattern,
            bool noCase,
            bool values,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                if (HasObjectInterfaces(ref error))
                {
                    TypeList keys = new TypeList();

                    //
                    // NOTE: Cleanup, PASS #1, collect the list of keys we need to remove
                    //       from the interfaces collection in the containing interpreter.
                    //
                    foreach (KeyValuePair<Type, IAnyPair<string, long>> pair in objectInterfaces)
                    {
                        Type @interface = pair.Key;

                        if (@interface != null)
                        {
                            if (values)
                            {
                                IAnyPair<string, long> anyPair = pair.Value;

                                if (anyPair != null)
                                {
                                    string assemblyName = anyPair.X;

                                    if ((mode == MatchMode.None) ||
                                        StringOps.Match(this, mode, assemblyName, pattern, noCase))
                                    {
                                        keys.Add(@interface);
                                    }
                                }
                            }
                            else
                            {
                                if ((mode == MatchMode.None) ||
                                    StringOps.Match(this, mode, @interface.FullName, pattern, noCase))
                                {
                                    keys.Add(@interface);
                                }
                            }
                        }
                    }

                    //
                    // NOTE: Cleanup, PASS #2, and remove all the interfaces we found from
                    //       PASS #1 (above).
                    //
                    foreach (Type key in keys)
                        objectInterfaces.Remove(key);

                    //
                    // NOTE: Ok, we were successful.
                    //
                    return ReturnCode.Ok;
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static string GetObjectAliasName(
            string objectName,
            string aliasName
            )
        {
            return (aliasName != null) ? aliasName : objectName;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private string GetObjectAliasName(
            IObject @object,
            string name
            )
        {
            if (@object == null)
                return name;

            object objectValue = @object.Value;

            if (objectValue == null)
                return name;

            Type type = AppDomainOps.MaybeGetTypeOrNull(objectValue);

            return GetObjectAliasName(type, name, name);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string GetObjectAliasName(
            Type type,
            string name,
            string @default
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if ((type == null) || String.IsNullOrEmpty(name))
                    return @default;

                if (!AreNamespacesEnabled())
                    return @default;

                Assembly assembly = type.Assembly;

                if (assembly == null)
                    return @default;

                string assemblyName = assembly.FullName;

                if (assemblyName == null)
                    return @default;

                string namespaceName;

                if (!objectAliasNamespaces.TryGetValue(
                        assemblyName, out namespaceName))
                {
                    return @default;
                }

                return NamespaceOps.MakeName(namespaceName, name, true, true);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddObjectAliasNamespace(
            Assembly assembly,
            INamespace @namespace,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref error))
                    return ReturnCode.Error;

                if (!HasObjectAliasNamespaces(ref error))
                    return ReturnCode.Error;

                if (!AreNamespacesEnabled())
                {
                    error = "namespaces not available";
                    return ReturnCode.Error;
                }

                if (assembly == null)
                {
                    error = "invalid assembly";
                    return ReturnCode.Error;
                }

                if (@namespace == null)
                {
                    error = "invalid namespace";
                    return ReturnCode.Error;
                }

                string assemblyName = assembly.FullName;

                if (assemblyName == null)
                {
                    error = "invalid assembly name";
                    return ReturnCode.Error;
                }

                string namespaceName;

                if (!objectAliasNamespaces.TryGetValue(
                        assemblyName, out namespaceName))
                {
                    objectAliasNamespaces.Add(
                        assemblyName, @namespace.QualifiedName);

                    return ReturnCode.Ok;
                }
                else if (SharedStringOps.SystemEquals(
                        namespaceName, @namespace.QualifiedName))
                {
                    //
                    // NOTE: Already added, same namespace name.  This
                    //       is allowed.
                    //
                    return ReturnCode.Ok;
                }
                else
                {
                    //
                    // NOTE: Already added, different namespace name.
                    //       This is an error.
                    //
                    error = String.Format(
                        "assembly {0} already mapped to namespace {1}",
                        FormatOps.DisplayName(assemblyName),
                        FormatOps.DisplayName(namespaceName));
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveObjectAliasNamespaces(
            MatchMode mode,
            string pattern,
            bool noCase,
            bool values,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                if (HasObjectAliasNamespaces(ref error))
                {
                    StringList keys = new StringList();

                    //
                    // NOTE: Cleanup, PASS #1, collect the list of keys we need to remove
                    //       from the namespaces collection in the containing interpreter.
                    //
                    foreach (KeyValuePair<string, string> pair in objectAliasNamespaces)
                    {
                        string assemblyName = pair.Key;

                        if (values)
                        {
                            string namespaceName = pair.Value;

                            if ((mode == MatchMode.None) ||
                                StringOps.Match(this, mode, namespaceName, pattern, noCase))
                            {
                                keys.Add(assemblyName);
                            }
                        }
                        else
                        {
                            if ((mode == MatchMode.None) ||
                                StringOps.Match(this, mode, assemblyName, pattern, noCase))
                            {
                                keys.Add(assemblyName);
                            }
                        }
                    }

                    //
                    // NOTE: Cleanup, PASS #2, and remove all the namespaces we found from
                    //       PASS #1 (above).
                    //
                    foreach (string key in keys)
                        objectAliasNamespaces.Remove(key);

                    //
                    // NOTE: Ok, we were successful.
                    //
                    return ReturnCode.Ok;
                }
            }

            return ReturnCode.Error;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region INamespace
        internal INamespace GlobalNamespace
        {
            get { /* NO-LOCK */ return globalNamespace; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal StringDictionary NamespaceMappings
        {
            get { /* NO-LOCK */ return namespaceMappings; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Namespace Command Support
        private ReturnCode MatchItems(
            INamespace currentNamespace,
            string pattern,
            bool noCase,
            ref StringList[] localLists,
            ref Result error
            )
        {
            bool simple = NamespaceOps.ShouldUseSimpleMatching(this,
                currentNamespace, pattern, false);

            bool qualified = NamespaceOps.IsQualifiedName(pattern);

            if (simple)
            {
                if (NamespaceOps.MatchItems(
                        this, null, localLists[0],
                        pattern, noCase, false, !qualified,
                        qualified, false, ref localLists[1],
                        ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }
            }
            else
            {
                if ((pattern != null) && !qualified &&
                    !IsGlobalNamespace(currentNamespace))
                {
                    if (NamespaceOps.MatchItems(
                            this, currentNamespace, localLists[0],
                            pattern, noCase, true, !qualified,
                            qualified, false, ref localLists[1],
                            ref error) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }
                }

                if (NamespaceOps.MatchItems(
                        this, currentNamespace, localLists[0],
                        pattern, noCase, false, !qualified,
                        qualified, false, ref localLists[1],
                        ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Namespace Variable Support
        internal bool MaybeSetQualifiedName(
            IVariable variable
            )
        {
            //
            // NOTE: If the variable is invalid -OR- namespaces are not
            //       enabled, do nothing and return false.
            //
            if ((variable == null) || !AreNamespacesEnabled())
                return false;

            //
            // HACK: Do not overwrite any existing [manually specified?]
            //       qualified name that may be stored for the variable.
            //
            string oldQualifiedName = variable.QualifiedName;

            if (oldQualifiedName != null)
                return false;

            //
            // NOTE: Grab the call frame for the variable.  If this is a scope
            //       call frame, do nothing and return false (i.e. there is no
            //       way to form a qualified name for such a variable).  This
            //       is subject to change in the future.  If this is null, the
            //       current namespace will be used; otherwise, the namespace
            //       associated with the call frame will be used.
            //
            ICallFrame frame = variable.Frame;

            if (CallFrameOps.IsScope(frame))
                return false;

            //
            // NOTE: Update the qualified name for the variable, based on the
            //       namespace for the associated call frame -OR- the current
            //       namespace (extremely rarely, if ever).
            //
            if (frame != null)
            {
                INamespace @namespace = NamespaceOps.GetCurrent(this, frame);

                variable.QualifiedName = NamespaceOps.MakeAbsoluteName(
                    NamespaceOps.MakeQualifiedName(this, @namespace,
                    variable.Name));
            }
            else
            {
                variable.QualifiedName = NamespaceOps.MakeQualifiedName(
                    this, variable.Name, true);
            }

            return true;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Namespace Status Support
        internal bool AreNamespacesEnabled()
        {
            return RuntimeOps.AreNamespacesEnabled(createFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsNamespaceInUse(
            INamespace @namespace
            )
        {
            if (@namespace != null)
            {
                //
                // NOTE: Namespaces are considered to be "in-use"
                //       until they no longer have any outstanding
                //       references.
                //
                if (@namespace.ReferenceCount > 0)
                    return true;

                //
                // NOTE: Non-global namespaces are not considered to
                //       be "in-use" just because the call stack for
                //       the interpreter is not completely unwound.
                //
                if (!IsGlobalNamespace(@namespace))
                    return false;
            }

            //
            // NOTE: The global namespace is "in-use" until the call
            //       stack for the interpreter is completely unwound.
            //
            return InternalIsBusy;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool CanRenameNamespace( /* EXPERIMENTAL */
            INamespace @namespace
            )
        {
            return !IsNamespaceInUse(@namespace);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool CanDeleteNamespace(
            INamespace @namespace
            )
        {
            return !IsNamespaceInUse(@namespace);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Namespace Traversal Support
        #region For Namespace Diagnostic Use Only
#if SHELL
        private ReturnCode ShowNamespaces(
            bool imports,
            bool exports,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (globalNamespace == null)
                {
                    error = "invalid global namespace";
                    return ReturnCode.Error;
                }

                try
                {
                    return globalNamespace.Traverse(
                        ShowNamespace, new ClientData(new Pair<bool>(
                        imports, exports)), ref error);
                }
                catch (Exception e)
                {
                    error = e;
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode ShowNamespace(
            INamespace @namespace,
            IClientData clientData,
            ref Result error
            ) /* NamespaceCallback */
        {
            if (@namespace == null)
            {
                error = "invalid namespace";
                return ReturnCode.Error;
            }

            if (clientData == null)
            {
                error = "invalid clientData";
                return ReturnCode.Error;
            }

            IPair<bool> pair = clientData.Data as IPair<bool>;

            if (pair == null)
            {
                error = "invalid boolean pair";
                return ReturnCode.Error;
            }

            bool imports = pair.X;
            bool exports = pair.Y;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                IInteractiveHost interactiveHost = GetInteractiveHost();

                if (interactiveHost == null)
                {
                    error = "interpreter host not available";
                    return ReturnCode.Error;
                }

                if (!interactiveHost.WriteLine(String.Format(
                        "NAMESPACE {0}",
                        FormatOps.DisplayValue(@namespace.QualifiedName))))
                {
                    error = "write to host failed";
                    return ReturnCode.Error;
                }

                if (imports)
                {
                    foreach (string importName in
                            @namespace.GetImportNames(null, true, false))
                    {
                        if (!interactiveHost.WriteLine(String.Format(
                                "IMPORT-SOURCE {0}",
                                FormatOps.DisplayValue(importName))))
                        {
                            error = "write to host failed";
                            return ReturnCode.Error;
                        }
                    }

                    foreach (string importName in
                            @namespace.GetImportNames(null, false, false))
                    {
                        if (!interactiveHost.WriteLine(String.Format(
                                "IMPORT-TARGET {0}",
                                FormatOps.DisplayValue(importName))))
                        {
                            error = "write to host failed";
                            return ReturnCode.Error;
                        }
                    }
                }

                if (exports)
                {
                    StringList exportNames = @namespace.GetExportNames(null);

                    if (exportNames == null)
                    {
                        error = "invalid namespace export names list";
                        return ReturnCode.Error;
                    }

                    foreach (string exportName in exportNames)
                    {
                        if (!interactiveHost.WriteLine(String.Format(
                                "EXPORT {0}",
                                FormatOps.DisplayValue(exportName))))
                        {
                            error = "write to host failed";
                            return ReturnCode.Error;
                        }
                    }
                }

                return ReturnCode.Ok;
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region For Namespace Import Renaming
        private ReturnCode RenameImportInNamespaces(
            string oldName,
            string newName,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (globalNamespace == null)
                {
                    error = "invalid global namespace";
                    return ReturnCode.Error;
                }

                try
                {
                    return globalNamespace.Traverse(
                        RenameImportInNamespace, new ClientData(
                        new StringPair(oldName, newName)), ref error);
                }
                catch (Exception e)
                {
                    error = e;
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RenameImportInNamespace(
            INamespace @namespace,
            IClientData clientData,
            ref Result error
            ) /* NamespaceCallback */
        {
            if (@namespace == null)
            {
                error = "invalid namespace";
                return ReturnCode.Error;
            }

            if (clientData == null)
            {
                error = "invalid clientData";
                return ReturnCode.Error;
            }

            IPair<string> pair = clientData.Data as IPair<string>;

            if (pair == null)
            {
                error = "invalid string pair";
                return ReturnCode.Error;
            }

            string oldName = pair.X;

            if (oldName == null)
            {
                error = "invalid old command name";
                return ReturnCode.Error;
            }

            string newName = pair.Y;

            if (newName == null)
            {
                error = "invalid new command name";
                return ReturnCode.Error;
            }

            if (@namespace.RenameImport(
                    oldName, newName, false, ref error) != ReturnCode.Ok)
            {
                return ReturnCode.Error;
            }

            return ReturnCode.Ok;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region For Namespace Import Removal
        private ReturnCode RemoveImportFromNamespaces(
            string name,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (globalNamespace == null)
                {
                    error = "invalid global namespace";
                    return ReturnCode.Error;
                }

                try
                {
                    return globalNamespace.Traverse(
                        RemoveImportFromNamespace, new ClientData(name),
                        ref error);
                }
                catch (InterpreterDisposedException)
                {
                    //
                    // NOTE: This method is called (indirectly) via the
                    //       disposal pipeline (i.e. also possibly on a
                    //       GC thread); therefore, just ignore this
                    //       exception.
                    //
                    return ReturnCode.Ok;
                }
                catch (Exception e)
                {
                    error = e;
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RemoveImportFromNamespace(
            INamespace @namespace,
            IClientData clientData,
            ref Result error
            ) /* NamespaceCallback */
        {
            if (@namespace == null)
            {
                error = "invalid namespace";
                return ReturnCode.Error;
            }

            if (clientData == null)
            {
                error = "invalid clientData";
                return ReturnCode.Error;
            }

            string name = clientData.Data as string;

            if (name == null)
            {
                error = "invalid command name";
                return ReturnCode.Error;
            }

            if (@namespace.RemoveImports(
                    name, false, ref error) != ReturnCode.Ok)
            {
                return ReturnCode.Error;
            }

            return ReturnCode.Ok;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region For Generic Namespace Traversal
        internal ReturnCode InvokeInEachNamespace(
            NamespaceCallback callback,
            IClientData clientData,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (globalNamespace == null)
                {
                    error = "invalid global namespace";
                    return ReturnCode.Error;
                }

                try
                {
                    return globalNamespace.Traverse(
                        callback, clientData, ref error);
                }
                catch (Exception e)
                {
                    error = e;
                }

                return ReturnCode.Error;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Namespace Deletion Support
        internal ReturnCode CleanupNamespaces(
            VariableFlags flags,
            bool force,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool pendingCleanup = IsPendingCleanup();

                if (pendingCleanup && AreNamespacesEnabled())
                {
                    if (pendingNamespaces == null)
                    {
                        result = "namespaces pending cleanup not available";
                        return ReturnCode.Error;
                    }

                    //
                    // NOTE: This foreach cannot simply iterate over the pending
                    //       namespace dictionary itself because it is modified
                    //       by the contained DeleteNamespace method.
                    //
                    Result localResult = null;
                    StringList keys = new StringList(pendingNamespaces.Keys);

                    foreach (string key in keys)
                    {
                        INamespace @namespace;

                        if (!pendingNamespaces.TryGetValue(key, out @namespace))
                            continue;

                        if (@namespace == null)
                            continue;

                        //
                        // HACK: If the namespace was somehow "undeleted" prior
                        //       to this cleanup method running, then do *NOT*
                        //       delete it; however, we still want to remove it
                        //       from the pending cleanup list.
                        //
                        if (@namespace.Deleted && DeleteNamespace(
                                flags, @namespace, force,
                                ref localResult) != ReturnCode.Ok)
                        {
                            break;
                        }
                    }

                    //
                    // NOTE: In this context, "success" means that there should
                    //       be no more namespaces pending deletion af this
                    //       point.
                    //
                    if (pendingNamespaces.Count == 0)
                    {
                        UnsetPendingCleanup();
                        return ReturnCode.Ok;
                    }

                    //
                    // NOTE: If there is a local result, use it; otherwise,
                    //       return a generic error message.
                    //
                    if (localResult != null)
                        result = localResult;
                    else
                        result = "some namespaces pending cleanup not deleted";

                    return ReturnCode.Error;
                }
                else if (pendingCleanup)
                {
                    //
                    // NOTE: Namespace support is disabled; therefore, just
                    //       delete the global namespace now.
                    //
                    if (DeleteNamespace(
                            flags, (INamespace)null, false,
                            ref result) == ReturnCode.Ok)
                    {
                        UnsetPendingCleanup();
                        return ReturnCode.Ok;
                    }

                    return ReturnCode.Error;
                }
                else
                {
                    //
                    // NOTE: Namespace support is disabled and the pending
                    //       cleanup flag for the interpreter is not set,
                    //       do nothing.
                    //
                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RenameNamespace( /* EXPERIMENTAL */
            string oldName,
            string newName,
            bool globalOk,
            bool inUseOk,
            ref Result result
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (AreNamespacesEnabled())
                {
                    INamespace @namespace = NamespaceOps.Lookup(
                        this, oldName, false, false);

                    if (@namespace == null)
                    {
                        result = String.Format(
                            "unknown namespace {0} in namespace rename command",
                            FormatOps.DisplayName(oldName));

                        return ReturnCode.Error;
                    }

                    if (NamespaceOps.Lookup(
                            this, newName, false, false) != null)
                    {
                        result = String.Format(
                            "can't rename to {0}: namespace already exists",
                            FormatOps.DisplayName(newName));

                        return ReturnCode.Error;
                    }

                    return RenameNamespace(
                        @namespace, newName, globalOk, inUseOk, ref result);
                }
                else
                {
                    result = "namespaces not available";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RenameNamespace( /* EXPERIMENTAL */
            INamespace oldNamespace,
            string newName,
            bool globalOk,
            bool inUseOk,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // NOTE: Phase 0: Verify all parameters and initial state.
                //
                if (!AreNamespacesEnabled())
                {
                    result = "namespaces not available";
                    return ReturnCode.Error;
                }

                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                if (oldNamespace == null)
                {
                    result = "invalid namespace";
                    return ReturnCode.Error;
                }

                //
                // NOTE: Renaming the global namespace is generally not a very
                //       good idea; however, it is technically possible with
                //       one major limiation:
                //
                //       Any global variables that exist before the rename will
                //       continue to exist after the rename [and they will also
                //       continue to be global variables].  Furthermore, the
                //       global call frame itself will be completely unchanged.
                //
                if (!globalOk && IsGlobalNamespace(oldNamespace))
                {
                    result = String.Format(
                        "can't rename {0}: namespace is global",
                        FormatOps.DisplayName(oldNamespace.QualifiedName));

                    return ReturnCode.Error;
                }

                //
                // NOTE: Renaming any namespace that is in use is a very bad
                //       idea; however, it is technically possible; however,
                //       it is highly likely that the script in progress may
                //       return an error, due to moved commands or variables
                //       being seen as "missing".
                //
                if (!inUseOk && !CanRenameNamespace(oldNamespace))
                {
                    result = String.Format(
                        "can't rename {0}: namespace in use",
                        FormatOps.DisplayName(oldNamespace.QualifiedName));

                    return ReturnCode.Error;
                }

                //
                // NOTE: Phase 1: Lookup (or create) the parent of the target
                //       namespace.
                //
                INamespace newParentNamespace = NamespaceOps.LookupParent(
                    this, newName, false, false, true, ref result);

                if (newParentNamespace == null)
                    return ReturnCode.Error;

                //
                // TODO: For now, raise a script error when trying to rename a
                //       namespace to a position that would be beneath itself
                //       in the tree.  In the future, this restriction may be
                //       relaxed.
                //
                if (NamespaceOps.IsDescendant(
                        newParentNamespace, oldNamespace))
                {
                    result = String.Format(
                        "can't rename {0}: new parent is descendant",
                        FormatOps.DisplayName(oldNamespace.QualifiedName));

                    return ReturnCode.Error;
                }

                //
                // NOTE: Phase 2: Create the target namespace and link it with
                //       its parent.
                //
                bool success = false;
                INamespace newNamespace = null;
                string newLocalName = NamespaceOps.TailOnly(newName);

                try
                {
                    newNamespace = NamespaceOps.CreateFrom(
                        newLocalName, null, this, newParentNamespace, null,
                        oldNamespace, oldNamespace.Unknown, null, false);

                    if (newNamespace == null)
                    {
                        result = String.Format(
                            "creation of namespace {0} in " +
                            "{1} failed", FormatOps.WrapOrNull(
                            newLocalName), FormatOps.WrapOrNull(
                            newParentNamespace.QualifiedName));

                        return ReturnCode.Error;
                    }

                    if (newParentNamespace.AddChild(
                            newNamespace, ref result) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }

                    success = true;
                }
                finally
                {
                    if (!success && (newNamespace != null))
                        NamespaceOps.Dispose(this, ref newNamespace);
                }

                //
                // NOTE: Phase 3: Find all matching IExecute-derived entities
                //       from the source namespace (and its children) and then
                //       move (rename) them into the target namespace tree.
                //
                IList<IPair<string>> oldAndNewNames = null;

                if (RenameNamespaceIExecutes(
                        oldNamespace, newNamespace, true, false,
                        ref oldAndNewNames, ref result) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }

                //
                // NOTE: The following handling applies only to those source
                //       namespaces that are not global.
                //
                if (!IsGlobalNamespace(oldNamespace))
                {
                    //
                    // NOTE: Phase 4: Move all child namespaces from the source
                    //       namespace to the target namespace.  This makes no
                    //       sense if the source namespace is global.
                    //
                    if (newNamespace.MoveAllChildren(
                            oldNamespace, ref result) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }

                    //
                    // NOTE: Phase 5: Delete the source namespace unless it is
                    //       the global namespace -OR- an ancestor of the target
                    //       one.
                    //
                    if (!NamespaceOps.IsDescendant(newNamespace, oldNamespace))
                    {
                        Result localResult = null;

                        if (DeleteNamespace(
                                VariableFlags.None, oldNamespace, inUseOk,
                                ref localResult) != ReturnCode.Ok)
                        {
                            result = localResult;
                            return ReturnCode.Error;
                        }
                    }
                }

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RenameNamespaceIExecutes(
            INamespace oldNamespace,
            INamespace newNamespace,
            bool noNamespaces,
            bool delete,
            ref IList<IPair<string>> oldAndNewNames,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                if (oldNamespace == null)
                {
                    error = "invalid old namespace";
                    return ReturnCode.Error;
                }

                if (newNamespace == null)
                {
                    error = "invalid new namespace";
                    return ReturnCode.Error;
                }

                string pattern = NamespaceOps.MakeQualifiedPattern(
                    this, oldNamespace, null, false);

                ObjectDictionary dictionary = null;

                if (ListAnyIExecute(pattern, false, true, false,
                        ref dictionary, ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }

                StringList list = new StringList(dictionary.Keys);

                foreach (string oldItemName in list)
                {
                    if (oldItemName == null)
                        continue;

                    string oldQualifiedName = ScriptOps.MakeCommandPrefix(
                        oldNamespace.QualifiedName);

                    if (oldQualifiedName == null)
                        continue;

                    if (!oldItemName.StartsWith(oldQualifiedName,
                            SharedStringOps.SystemComparisonType))
                    {
                        continue;
                    }

                    string newQualifiedName = ScriptOps.MakeCommandPrefix(
                        newNamespace.QualifiedName);

                    if (newQualifiedName == null)
                        continue;

                    string newItemName = NamespaceOps.MakeQualifiedName(
                        newQualifiedName, oldItemName.Substring(
                        oldQualifiedName.Length), true);

                    Result localResult = null;

                    if (RenameAnyIExecute(
                            oldItemName, newItemName, null,
                            IdentifierKind.None, noNamespaces, delete,
                            true, false, ref localResult) != ReturnCode.Ok)
                    {
                        error = localResult;
                        return ReturnCode.Error;
                    }

                    //
                    // NOTE: Record the name change for later use when
                    //       dealing with imports/exports.
                    //
                    if (oldAndNewNames == null)
                        oldAndNewNames = new List<IPair<string>>();

                    oldAndNewNames.Add(new Pair<string>(
                        oldItemName, newItemName));
                }

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DeleteNamespace(
            VariableFlags flags,
            string name,
            bool force,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                INamespace @namespace = null;

                if (AreNamespacesEnabled())
                {
                    @namespace = NamespaceOps.Lookup(this, name, false, false);

                    if (@namespace == null)
                    {
                        result = String.Format(
                            "unknown namespace {0} in namespace delete command",
                            FormatOps.DisplayName(name)); /* COMPAT: Tcl. */

                        return ReturnCode.Error;
                    }
                }

                return DeleteNamespace(flags, @namespace, force, ref result);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DeleteNamespace(
            VariableFlags flags,
            INamespace @namespace,
            bool force,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref result))
                    return ReturnCode.Error;

                bool useNamespaces = AreNamespacesEnabled();

                if (useNamespaces && (@namespace == null))
                {
                    result = "invalid namespace";
                    return ReturnCode.Error;
                }

                //
                // NOTE: Grab the fully qualified name for the namespace now
                //       as it is needed in several places in this method.
                //
                string qualifiedName = (@namespace != null) ?
                    @namespace.QualifiedName : null;

                //
                // NOTE: See if we can delete the namespace immediately -OR-
                //       if we have to wait until the evluation stack for the
                //       namespace is completely unwound.
                //
                if (force || CanDeleteNamespace(@namespace))
                {
                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Delete all children of the namespace first.
                    //
                    if (@namespace != null)
                    {
                        foreach (INamespace childNamespace in
                                /* ALL */ @namespace.GetChildren(null, true))
                        {
                            if (childNamespace == null)
                                continue;

                            if (DeleteNamespace(
                                    flags, childNamespace, force,
                                    ref result) != ReturnCode.Ok) /* RECURSIVE */
                            {
                                return ReturnCode.Error;
                            }
                        }
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Remove all commands that were imported into the
                    //       namespace now.  Each imported command actually
                    //       corresponds to an alias name token in the target
                    //       interpreter.
                    //
                    if (@namespace != null)
                    {
                        if (@namespace.RemoveAllImports(
                                false, ref result) != ReturnCode.Ok)
                        {
                            return ReturnCode.Error;
                        }
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Remove all exported commands belonging to this
                    //       namespace from all other namespaces now.
                    //
                    if (@namespace != null)
                    {
                        if (RemoveImportFromNamespaces(
                                NamespaceOps.MakeQualifiedPattern(
                                this, @namespace, null, false),
                                ref result) != ReturnCode.Ok)
                        {
                            return ReturnCode.Error;
                        }
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Apparently, hidden commands should only be deleted
                    //       from non-global namespaces (COMPAT: Tcl).
                    //
                    bool deleteHidden = !useNamespaces || !IsGlobalNamespace(
                        @namespace);

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Remove all hidden IExecute objects in the
                    //       namespace now.
                    //
                    if (deleteHidden && (hiddenExecutes != null))
                    {
                        StringList keys = null;

                        if (useNamespaces)
                        {
                            if (NamespaceOps.MatchItems(
                                    this, @namespace, hiddenExecutes.Keys,
                                    null, false, false, false, false, false,
                                    ref keys, ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }
                        }
                        else
                        {
                            keys = new StringList(hiddenExecutes.Keys);
                        }

                        foreach (string key in keys)
                            hiddenExecutes.Remove(key);

#if EXECUTE_CACHE
                        //
                        // BUGFIX: Everything may have just gone away,
                        //         clear the caches now.
                        //
                        ClearExecuteCache();
#endif
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Remove all non-hidden IExecute objects in the
                    //       namespace now.
                    //
                    if (executes != null)
                    {
                        StringList keys = null;

                        if (useNamespaces)
                        {
                            if (NamespaceOps.MatchItems(
                                    this, @namespace, executes.Keys,
                                    null, false, false, false, false, false,
                                    ref keys, ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }
                        }
                        else
                        {
                            keys = new StringList(executes.Keys);
                        }

                        foreach (string key in keys)
                            executes.Remove(key);

#if EXECUTE_CACHE
                        //
                        // BUGFIX: Everything may have just gone away,
                        //         clear the caches now.
                        //
                        ClearExecuteCache();
#endif
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Remove hidden all procedures in the namespace
                    //       now.
                    //
                    if (deleteHidden && (hiddenProcedures != null))
                    {
                        StringList keys = null;

                        if (useNamespaces)
                        {
                            if (NamespaceOps.MatchItems(
                                    this, @namespace, hiddenProcedures.Keys,
                                    null, false, false, false, false, false,
                                    ref keys, ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }
                        }
                        else
                        {
                            keys = new StringList(hiddenProcedures.Keys);
                        }

                        foreach (string key in keys)
                        {
                            IProcedure procedure = hiddenProcedures[key];

                            if (procedure == null)
                            {
                                hiddenProcedures.Remove(key);
                                continue;
                            }

                            //
                            // BUGFIX: Skip deleting read-only procedures.
                            //
                            if (EntityOps.IsReadOnly(procedure) ||
                                EntityOps.IsNoRemove(procedure))
                            {
                                continue;
                            }

                            hiddenProcedures.Remove(key);
                        }

#if EXECUTE_CACHE
                        //
                        // BUGFIX: Everything may have just gone away,
                        //         clear the caches now.
                        //
                        ClearExecuteCache();
#endif
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Remove non-hidden all procedures in the namespace
                    //       now.
                    //
                    if (procedures != null)
                    {
                        StringList keys = null;

                        if (useNamespaces)
                        {
                            if (NamespaceOps.MatchItems(
                                    this, @namespace, procedures.Keys,
                                    null, false, false, false, false, false,
                                    ref keys, ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }
                        }
                        else
                        {
                            keys = new StringList(procedures.Keys);
                        }

                        foreach (string key in keys)
                        {
                            IProcedure procedure = procedures[key];

                            if (procedure == null)
                            {
                                procedures.Remove(key);
                                continue;
                            }

                            //
                            // BUGFIX: Skip deleting read-only procedures.
                            //
                            if (EntityOps.IsReadOnly(procedure) ||
                                EntityOps.IsNoRemove(procedure))
                            {
                                continue;
                            }

                            procedures.Remove(key);
                        }

#if EXECUTE_CACHE
                        //
                        // BUGFIX: Everything may have just gone away,
                        //         clear the caches now.
                        //
                        ClearExecuteCache();
#endif
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Attempt to terminate and remove all hidden
                    //       commands for the namespace now.
                    //
                    if (deleteHidden && (hiddenCommands != null))
                    {
                        StringList keys = null;

                        if (useNamespaces)
                        {
                            if (NamespaceOps.MatchItems(
                                    this, @namespace, hiddenCommands.Keys,
                                    null, false, false, false, false, false,
                                    ref keys, ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }
                        }
                        else
                        {
                            keys = new StringList(hiddenCommands.Keys);
                        }

                        foreach (string key in keys)
                        {
                            ICommand command = hiddenCommands[key];

                            if (command == null)
                            {
                                hiddenCommands.Remove(key);
                                continue;
                            }

                            //
                            // BUGFIX: Skip deleting read-only commands.
                            //
                            if (EntityOps.IsReadOnly(command))
                                continue;

                            string commandName = null;

                            ReturnCode code;

                            GlobalState.PushActiveInterpreter(this);

                            try
                            {
                                commandName = EntityOps.GetNameNoThrow(command);

                                code = TerminateCommand(command, null, ref result);
                            }
                            catch (Exception e)
                            {
                                result = String.Format(
                                    "caught exception while deleting hidden command {0}: {1}",
                                     FormatOps.WrapOrNull(commandName), e);

                                code = ReturnCode.Error;
                            }
                            finally
                            {
                                /* IGNORED */
                                GlobalState.PopActiveInterpreter();
                            }

                            if (code == ReturnCode.Ok)
                            {
                                //
                                // NOTE: Command terminated, remove it.
                                //
                                hiddenCommands.Remove(key);

                                TraceOps.DebugTrace(String.Format(
                                    "DeleteNamespace: deleted hidden command {0}",
                                    FormatOps.WrapOrNull(commandName)),
                                    typeof(Interpreter).Name,
                                    TracePriority.CleanupDebug);
                            }
                            else
                            {
                                //
                                // NOTE: Failure, halt deletion.
                                //
                                return code;
                            }
                        }

#if EXECUTE_CACHE
                        //
                        // BUGFIX: Everything may have just gone away,
                        //         clear the caches now.
                        //
                        ClearExecuteCache();
#endif
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Attempt to terminate and remove all non-hidden
                    //       commands for the namespace now.
                    //
                    if (commands != null)
                    {
                        StringList keys = null;

                        if (useNamespaces)
                        {
                            if (NamespaceOps.MatchItems(
                                    this, @namespace, commands.Keys,
                                    null, false, false, false, false, false,
                                    ref keys, ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }
                        }
                        else
                        {
                            keys = new StringList(commands.Keys);
                        }

                        foreach (string key in keys)
                        {
                            ICommand command = commands[key];

                            if (command == null)
                            {
                                commands.Remove(key);
                                continue;
                            }

                            //
                            // BUGFIX: Skip deleting read-only commands.
                            //
                            if (EntityOps.IsReadOnly(command))
                                continue;

                            string commandName = null;

                            ReturnCode code;

                            GlobalState.PushActiveInterpreter(this);

                            try
                            {
                                commandName = EntityOps.GetNameNoThrow(command);

                                code = TerminateCommand(command, null, ref result);
                            }
                            catch (Exception e)
                            {
                                result = String.Format(
                                    "caught exception while deleting command {0}: {1}",
                                    FormatOps.WrapOrNull(commandName), e);

                                code = ReturnCode.Error;
                            }
                            finally
                            {
                                /* IGNORED */
                                GlobalState.PopActiveInterpreter();
                            }

                            if (code == ReturnCode.Ok)
                            {
                                //
                                // NOTE: Command terminated, remove it.
                                //
                                commands.Remove(key);

                                TraceOps.DebugTrace(String.Format(
                                    "DeleteNamespace: deleted command {0}",
                                    FormatOps.WrapOrNull(commandName)),
                                    typeof(Interpreter).Name,
                                    TracePriority.CleanupDebug);
                            }
                            else
                            {
                                //
                                // NOTE: Failure, halt deletion.
                                //
                                return code;
                            }
                        }

#if EXECUTE_CACHE
                        //
                        // BUGFIX: Everything may have just gone away,
                        //         clear the caches now.
                        //
                        ClearExecuteCache();
#endif
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Next, remove all variables in the namespace now.
                    //       This step may remove all global variables (i.e.
                    //       if the global namespace is being deleted).
                    //
                    ICallFrame frame;

                    if (!useNamespaces || IsGlobalNamespace(@namespace))
                        frame = CurrentGlobalFrame;
                    else
                        frame = @namespace.VariableFrame;

                    if (frame != null)
                    {
                        VariableDictionary variables = frame.Variables;

                        if (variables != null)
                        {
#if NOTIFY || NOTIFY_OBJECT
                            //
                            // NOTE: *SPECIAL* This notification must be
                            //       done before the variables are marked
                            //       as "Undefined" because that is what
                            //       the ObjectTraceCallback method
                            //       expects for the BeforeVariableUnset
                            //       breakpoint type.
                            //
                            /* IGNORED */
                            CheckNotification(
                                NotifyType.CallFrame, NotifyFlags.Deleted |
                                    NotifyFlags.Force, frame, this, null,
                                null, null, ref result);
#endif

                            bool reset = FlagOps.HasFlags(
                                flags, VariableFlags.ResetValue, true);

                            bool zero = HasZeroString() && HasZeroString(flags);

                            foreach (KeyValuePair<string, IVariable> pair in variables)
                            {
                                IVariable variable = pair.Value;

                                if (variable == null)
                                    continue;

                                //
                                // BUGFIX: Skip deleting any undefined,
                                //         read-only, or "invariant"
                                //         variables.
                                //
                                if (EntityOps.IsUndefined(variable) ||
                                    EntityOps.IsReadOnly(variable) ||
                                    EntityOps.IsInvariant(variable))
                                {
                                    continue;
                                }

                                //
                                // NOTE: The variable is now dead.
                                //
                                if (reset && (variable is Variable))
                                {
                                    ((Variable)variable).ResetValue(
                                        this, zero);
                                }

                                EntityOps.SetUndefined(variable, true);

                                //
                                // NOTE: Remove any pending array searches
                                //       that may exist for this variable.
                                //
                                CleanupArraySearches(variable);

                                //
                                // BUGFIX: Mark the variable as "dirty"
                                //         AFTER the actual modifications
                                //         have been completed.
                                //
                                EntityOps.SignalDirty(variable, null);
                            }
                        }

                        //
                        // BUGFIX: The call frame is no longer usable.  Clean
                        //         it up now and mark it as undefined *unless*
                        //         it is the global call frame.  It should be
                        //         noted that native Tcl appears to use some
                        //         fundamentally different semantics here.
                        //         They leave the global frame in a state that
                        //         is completely unusable.  Since there is no
                        //         point in doing that, we do not.
                        //
                        /* IGNORED */
                        CallFrameOps.Cleanup(
                            CurrentFrame, frame, !IsGlobalCallFrame(frame));
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Remove namespace being deleted from its parent
                    //       unless its parent namespace is already deleted.
                    //
                    if (@namespace != null)
                    {
                        INamespace parentNamespace = @namespace.Parent;

                        if (parentNamespace != null)
                        {
                            ReturnCode removeCode;
                            Result removeError = null;

                            removeCode = parentNamespace.RemoveChild(
                                @namespace.Name, ref removeError);

                            if (removeCode != ReturnCode.Ok)
                                DebugOps.Complain(this, removeCode, removeError);
                        }
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Next, make sure the namespace is removed from the
                    //       pending deletion list, if applicable.  This needs
                    //       to be done prior to actually disposing the object
                    //       itself because the object disposal can fail and
                    //       even if it does, we never want to try and delete
                    //       this namespace again.
                    //
                    if ((pendingNamespaces != null) &&
                        (qualifiedName != null))
                    {
                        /* IGNORED */
                        pendingNamespaces.Remove(qualifiedName);
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: Finally, dispose of the namespace itself.  For
                    //       the global namespace, this is not done unless
                    //       the interpreter is being disposed.
                    //
                    if ((@namespace != null) && !IsGlobalNamespace(@namespace))
                    {
                        //
                        // BUGFIX: When deleting any namespace, make sure to
                        //         remove the references to it from the call
                        //         frames.
                        //
                        ReturnCode clearCode;
                        Result clearError = null;

                        clearCode = NamespaceOps.ClearCurrentForAll(
                            this, CallStack, @namespace, ref clearError);

                        if (clearCode != ReturnCode.Ok)
                        {
                            result = String.Format(
                                "failed while clearing namespace {0}: {1}",
                                FormatOps.WrapOrNull(qualifiedName),
                                clearError);

                            return clearCode;
                        }

                        ReturnCode disposeCode;
                        Result disposeError = null;

                        disposeCode = NamespaceOps.Dispose(
                            this, ref @namespace, ref disposeError);

                        if (disposeCode != ReturnCode.Ok)
                        {
                            result = String.Format(
                                "caught exception while disposing namespace {0}: {1}",
                                FormatOps.WrapOrNull(qualifiedName), disposeError);

                            return disposeCode;
                        }
                    }
                }
                else
                {
                    //
                    // NOTE: Mark the namespace as requiring cleanup after the
                    //       current evaluation stack unwinds.
                    //
                    if (@namespace != null)
                    {
                        if ((pendingNamespaces != null) && (qualifiedName != null) &&
                            !pendingNamespaces.ContainsKey(qualifiedName)) /* EXEMPT */
                        {
                            pendingNamespaces.Add(qualifiedName, @namespace);
                        }

                        @namespace.MarkDeleted();
                    }

                    SetPendingCleanup();
                }

                return ReturnCode.Ok;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region PendingCleanup Flag
        public static bool IsPendingCleanup( /* EXTERNAL USE ONLY. */
            Interpreter interpreter
            )
        {
            if (interpreter != null)
            {
                lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
                {
                    return interpreter.IsPendingCleanup();
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsPendingCleanup()
        {
            //
            // NOTE: Check the pending cleanup flag.
            //
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.PendingCleanup, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void SetPendingCleanup()
        {
            //
            // NOTE: Set the pending cleanup flag.
            //
            interpreterStateFlags |= InterpreterStateFlags.PendingCleanup;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void UnsetPendingCleanup()
        {
            //
            // NOTE: Clear the pending cleanup flag.
            //
            interpreterStateFlags &= ~InterpreterStateFlags.PendingCleanup;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region TraceTextWriterOwned Flag
        private bool IsTraceTextWriterOwned()
        {
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.TraceTextWriterOwned, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void SetTraceTextWriterOwned()
        {
            interpreterStateFlags |= InterpreterStateFlags.TraceTextWriterOwned;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void UnsetTraceTextWriterOwned()
        {
            interpreterStateFlags &= ~InterpreterStateFlags.TraceTextWriterOwned;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region DebugTextWriterOwned Flag
        private bool IsDebugTextWriterOwned()
        {
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.DebugTextWriterOwned, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void SetDebugTextWriterOwned()
        {
            interpreterStateFlags |= InterpreterStateFlags.DebugTextWriterOwned;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void UnsetDebugTextWriterOwned()
        {
            interpreterStateFlags &= ~InterpreterStateFlags.DebugTextWriterOwned;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region PackageScanWhatIf Flag
        private bool IsPackageScanWhatIf()
        {
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.PackageScanWhatIf, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void SetPackageScanWhatIf()
        {
            interpreterStateFlags |= InterpreterStateFlags.PackageScanWhatIf;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void UnsetPackageScanWhatIf()
        {
            interpreterStateFlags &= ~InterpreterStateFlags.PackageScanWhatIf;
        }
        #endregion
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Entity Metrics
        public ReturnCode GetUsageData(
            IdentifierKind kind,
            UsageType type,
            ref StringDictionary dictionary,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (dictionary == null)
                    dictionary = new StringDictionary();

                ///////////////////////////////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(kind, IdentifierKind.Command, true) &&
                    (commands != null))
                {
                    foreach (KeyValuePair<string, _Wrappers.Command> pair
                            in commands)
                    {
                        ICommand command = pair.Value;

                        if (command == null)
                            continue;

                        long value = 0;

                        if (!command.GetUsage(type, ref value))
                            continue;

                        string key = String.Format(
                            "{0}{1}{2}{1}{3}", IdentifierKind.Command,
                            Characters.HorizontalTab, type, pair.Key);

                        dictionary[key] = value.ToString();
                    }
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(kind, IdentifierKind.Function, true) &&
                    (functions != null))
                {
                    foreach (KeyValuePair<string, _Wrappers.Function> pair
                            in functions)
                    {
                        IFunction function = pair.Value;

                        if (function == null)
                            continue;

                        long value = 0;

                        if (!function.GetUsage(type, ref value))
                            continue;

                        string key = String.Format(
                            "{0}{1}{2}{1}{3}", IdentifierKind.Function,
                            Characters.HorizontalTab, type, pair.Key);

                        dictionary[key] = value.ToString();
                    }
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(kind, IdentifierKind.Procedure, true) &&
                    (procedures != null))
                {
                    foreach (KeyValuePair<string, _Wrappers.Procedure> pair
                            in procedures)
                    {
                        IProcedure procedure = pair.Value;

                        if (procedure == null)
                            continue;

                        long value = 0;

                        if (!procedure.GetUsage(type, ref value))
                            continue;

                        string key = String.Format(
                            "{0}{1}{2}{1}{3}", IdentifierKind.Procedure,
                            Characters.HorizontalTab, type, pair.Key);

                        dictionary[key] = value.ToString();
                    }
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(kind, IdentifierKind.Operator, true) &&
                    (operators != null))
                {
                    foreach (KeyValuePair<string, _Wrappers.Operator> pair
                            in operators)
                    {
                        IOperator @operator = pair.Value;

                        if (@operator == null)
                            continue;

                        long value = 0;

                        if (!@operator.GetUsage(type, ref value))
                            continue;

                        string key = String.Format(
                            "{0}{1}{2}{1}{3}", IdentifierKind.Operator,
                            Characters.HorizontalTab, type, pair.Key);

                        dictionary[key] = value.ToString();
                    }
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                return ReturnCode.Ok;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IInterpreterManager Members
        public bool PushActive(
            IClientData clientData
            )
        {
            CheckDisposed();

            /* NO RESULT */
            GlobalState.PushActiveInterpreter(this, clientData);

            return true;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool PopActive()
        {
            CheckDisposed();

            return GlobalState.MaybePopActiveInterpreter(this) != null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool? SetDisposalEnabled(
            bool noComplain,
            bool? enabled
            )
        {
            if (!noComplain)
                CheckDisposed(); /* EXEMPT */

            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // NOTE: If the interpreter is already disposed, there is nothing
                //       more we can do.  Return a special value to the caller to
                //       indicate this problem.
                //
                if (PrivateDisposed)
                    return null;

                InterpreterStateFlags flags = InterpreterStateFlags.NoDispose;
                bool result = FlagOps.HasFlags(interpreterStateFlags, flags, true);

                if (enabled != null)
                {
                    string wasEnabled = String.Format(
                        "still {0}", result ? "DISABLED" : "ENABLED");

                    int referenceCount;
                    bool wasChanged = false;

                    if ((bool)enabled)
                    {
                        referenceCount = Interlocked.Decrement(ref disposalDisableCount);

                        if (referenceCount <= 0)
                        {
                            interpreterStateFlags &= ~flags;
                            wasChanged = true;
                        }

                        TraceOps.DebugTrace(String.Format(
                            "SetDisposalEnabled: ENABLE interpreter {0}, disposal {1} (-{2})",
                            PrivateId, wasChanged ? "now ENABLED" : wasEnabled, referenceCount),
                            typeof(Interpreter).Name, TracePriority.CleanupDebug2);
                    }
                    else
                    {
                        referenceCount = Interlocked.Increment(ref disposalDisableCount);

                        if (referenceCount == 1)
                        {
                            interpreterStateFlags |= flags;
                            wasChanged = true;
                        }

                        TraceOps.DebugTrace(String.Format(
                            "SetDisposalEnabled: DISABLE interpreter {0}, disposal {1} (+{2})",
                            PrivateId, wasChanged ? "now DISABLED" : wasEnabled, referenceCount),
                            typeof(Interpreter).Name, TracePriority.CleanupDebug2);
                    }

                    result = wasChanged ? (result == (bool)enabled) : false;
                }
                else
                {
                    result = !result;
                }

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsOrphanInterpreter()
        {
            CheckDisposed();

            return (parentInterpreter == null);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasChildInterpreters(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (childInterpreters != null);

                if (!result)
                    error = "child interpreters not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesChildInterpreterExist(string path)
        {
            CheckDisposed();

            return DoesChildInterpreterExist(path, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetChildInterpreter(
            string path,
            LookupFlags lookupFlags,
            bool nested,
            bool create,
            ref Interpreter interpreter,
            ref string name,
            ref Result error
            )
        {
            CheckDisposed();

            if (nested)
                return GetNestedChildInterpreter(path, lookupFlags, create,
                    ref interpreter, ref name, ref error);
            else
                return GetChildInterpreter(path, lookupFlags, ref interpreter,
                    ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode CreateChildInterpreter(
            string path,
            IClientData clientData,
            InterpreterSettings interpreterSettings,
            bool isolated,
            bool security,
            ref Result result
            )
        {
            CheckDisposed();

            if (interpreterSettings == null)
            {
                result = "invalid interpreter settings";
                return ReturnCode.Error;
            }

            return CreateChildInterpreter(
                path, clientData,
                interpreterSettings.RuleSet,
                interpreterSettings.CreateFlags,
                interpreterSettings.HostCreateFlags,
                interpreterSettings.InitializeFlags,
                interpreterSettings.ScriptFlags,
                interpreterSettings.InterpreterFlags,
                interpreterSettings.PluginFlags,
                isolated, security, false, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddChildInterpreter(
            string name,
            Interpreter interpreter,
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref error))
                    return ReturnCode.Error;

                if (interpreter == null)
                {
                    error = "invalid interpreter";
                    return ReturnCode.Error;
                }

                if (name == null)
                {
                    error = "invalid interpreter name";
                    return ReturnCode.Error;
                }

                if (!HasChildInterpreters(ref error))
                    return ReturnCode.Error;

                if (Object.ReferenceEquals(interpreter, this))
                {
                    error = String.Format(
                        "can't add {0}: same as current interpreter",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                if (DoesChildInterpreterExist(name, false) == ReturnCode.Ok)
                {
                    error = String.Format(
                        "can't add {0}: child interpreter already exists",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                childInterpreters.Add(name, interpreter);

#if NOTIFY && NOTIFY_GLOBAL
                if (this.PrivateGlobalNotify)
                {
                    /* IGNORED */
                    CheckNotifications(
                        null, false,
                        NotifyType.Interpreter, NotifyFlags.Added,
                        //
                        // BUGBUG: In order to use this class for notification
                        //         parameters, it really should probably be
                        //         made public.
                        //
                        new ObjectList(name), interpreter,
                        clientData, null, null, ref error);
                }
#endif
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveChildInterpreter(
            string name,
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            return RemoveChildInterpreter(
                name, clientData, ObjectOps.GetDefaultSynchronous(),
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveChildInterpreter(
            string name,
            IClientData clientData,
            bool synchronous,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                if (HasChildInterpreters(ref error))
                {
                    Interpreter interpreter = null;

                    if (GetChildInterpreter(
                            name, LookupFlags.Interpreter, ref interpreter,
                            ref error) == ReturnCode.Ok)
                    {
                        if ((interpreter != null) &&
                            !Object.ReferenceEquals(interpreter, this) &&
                            !interpreter.IsShared())
                        {
                            GlobalState.PushActiveInterpreter(this);

                            try
                            {
#if APPDOMAINS && ISOLATED_INTERPRETERS
                                string appDomainName = interpreter.ChildAppDomainName;
#endif

                                ///////////////////////////////////////////////////////////////////

                                Interpreter parentInterpreter = interpreter.ParentInterpreter;

                                if ((parentInterpreter != null) &&
                                    parentInterpreter.HasInterpreterAlias(name) == ReturnCode.Ok)
                                {
                                    Result localResult = null;

                                    if (parentInterpreter.RemoveAliasAndCommand(
                                            name, clientData, false,
                                            ref localResult) != ReturnCode.Ok)
                                    {
                                        error = localResult;
                                        return ReturnCode.Error;
                                    }
                                }

                                ///////////////////////////////////////////////////////////////////

                                if (ObjectOps.TryDispose<Interpreter>(
                                        ref interpreter, ref error) == ReturnCode.Ok)
                                {
                                    interpreter = null;

                                    if (synchronous)
                                        ObjectOps.CollectGarbage(); /* throw */
                                }
                                else
                                {
                                    return ReturnCode.Error;
                                }

                                ///////////////////////////////////////////////////////////////////

#if APPDOMAINS && ISOLATED_INTERPRETERS
                                if (appDomainName != null)
                                {
                                    ReturnCode removeCode;
                                    Result removeError = null;

                                    removeCode = RemoveAppDomain(
                                        appDomainName, clientData, ref removeError);

                                    if (removeCode == ReturnCode.Ok)
                                    {
                                        if (synchronous)
                                            ObjectOps.CollectGarbage(); /* throw */
                                    }
                                    else
                                    {
                                        //
                                        // NOTE: Not much we can do at this point.  The child
                                        //       interpreter itself was successfully disposed
                                        //       and must be removed from the collection.  The
                                        //       application domain can still be disposed during
                                        //       the disposal of this interpreter.
                                        //
                                        DebugOps.Complain(this, removeCode, removeError);
                                    }
                                }
#endif
                            }
                            catch (Exception e)
                            {
                                error = String.Format(
                                    "caught exception while disposing child interpreter: {0}",
                                    e);

                                return ReturnCode.Error;
                            }
                            finally
                            {
                                /* IGNORED */
                                GlobalState.PopActiveInterpreter();
                            }
                        }

                        childInterpreters.Remove(name);

#if NOTIFY && NOTIFY_GLOBAL
                        if (this.PrivateGlobalNotify)
                        {
                            /* IGNORED */
                            CheckNotifications(
                                null, false,
                                NotifyType.Interpreter, NotifyFlags.Removed,
                                //
                                // BUGBUG: In order to use this class for notification
                                //         parameters, it really should probably be
                                //         made public.
                                //
                                new ObjectList(name), interpreter,
                                clientData, null, null, ref error);
                        }
#endif

                        return ReturnCode.Ok;
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal Interpreter ParentInterpreter
        {
            get { return parentInterpreter; }
            set { parentInterpreter = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string ChildName
        {
            get { return childName; }
            set { childName = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if APPDOMAINS && ISOLATED_INTERPRETERS
        internal string ChildAppDomainName
        {
            get { return childAppDomainName; }
            set { childAppDomainName = value; }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private InterpreterDictionary TryCopyChildInterpreters()
        {
            bool locked = false;

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    if (childInterpreters != null)
                    {
                        return new InterpreterDictionary(
                            childInterpreters);
                    }
                }

                return null;
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string ChildInterpretersToString(
            string pattern,
            bool noCase
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (childInterpreters != null)
                    return childInterpreters.ToString(pattern, noCase);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsParentInterpreter(
            Interpreter interpreter
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                return (interpreter != null) &&
                    Object.ReferenceEquals(interpreter, parentInterpreter);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsChildInterpreter(
            Interpreter interpreter
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                return (interpreter != null) && (childInterpreters != null) &&
                    childInterpreters.ContainsValue(interpreter);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsParentOrChildInterpreter(
            object value
            )
        {
            if (value == null)
                return false;

            //
            // BUGFIX: If this object happens to be a transparent proxy,
            //         do not try to cast it to an interpreter as that
            //         could cause an attempt to load its assembly into
            //         this AppDomain.
            //
            // BUGBUG: Perhaps this should use AppDomainOps.MaybeGetType
            //         instead here (i.e. to check if the type is really
            //         an Interpreter)?
            //
            if (AppDomainOps.IsTransparentProxy(value))
            {
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    if (Object.ReferenceEquals(value, parentInterpreter))
                        return true;

                    if (childInterpreters != null)
                    {
                        foreach (KeyValuePair<string, Interpreter> pair
                                in childInterpreters)
                        {
                            Interpreter childInterpreter = pair.Value;

                            if (childInterpreter == null)
                                continue;

                            if (Object.ReferenceEquals(
                                    value, childInterpreter))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            else
            {
                Interpreter interpreter = value as Interpreter;

                if (interpreter != null)
                {
                    lock (syncRoot) /* TRANSACTIONAL */
                    {
                        if (IsParentInterpreter(interpreter))
                            return true;

                        if (IsChildInterpreter(interpreter))
                            return true;
                    }
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesChildInterpreterExist(
            string path,
            bool nested
            )
        {
            string name = null;

            return DoesChildInterpreterExist(path, nested, ref name);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DoesChildInterpreterExist(
            string path,
            bool nested,
            ref string name
            )
        {
            Interpreter interpreter = null;
            Result error = null;

            return GetChildInterpreter(path, LookupFlags.Exists,
                nested, false, ref interpreter, ref name, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetChildInterpreter(
            string path,
            LookupFlags lookupFlags,
            bool nested,
            bool create,
            ref Interpreter interpreter,
            ref Result error
            )
        {
            string name = null;

            return GetChildInterpreter(path, lookupFlags, nested, create,
                ref interpreter, ref name, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetChildInterpreter(
            string name,
            LookupFlags lookupFlags,
            ref Interpreter interpreter,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasChildInterpreters(ref error))
                {
                    //
                    // NOTE: *WARNING* Empty interpreter names are technically allowed,
                    //       please do not change this to "!String.IsNullOrEmpty".
                    //
                    if (name != null)
                    {
                        if (name.Length > 0)
                        {
                            if (childInterpreters.TryGetValue(name, out interpreter))
                            {
                                if ((interpreter != null) ||
                                    !FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
                                {
                                    return ReturnCode.Ok;
                                }
                                else
                                {
                                    error = FlagOps.HasFlags(
                                        lookupFlags, LookupFlags.Verbose, true) ?
                                        String.Format(
                                            "invalid interpreter name {0}",
                                            FormatOps.DisplayName(name)) :
                                        "invalid interpreter name";
                                }
                            }
                            else
                            {
                                error = FlagOps.HasFlags(
                                    lookupFlags, LookupFlags.Verbose, true) ?
                                    String.Format(
                                        "could not find interpreter {0}",
                                        FormatOps.DisplayName(name)) :
                                    "could not find interpreter";
                            }
                        }
                        else
                        {
                            //
                            // NOTE: The empty string always represents the current
                            //       interpreter.
                            //
                            interpreter = this;

                            return ReturnCode.Ok;
                        }
                    }
                    else
                    {
                        error = "invalid interpreter name";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void RemoveChildInterpreterOrComplain(
            string name,
            IClientData clientData,
            bool synchronous
            )
        {
            ReturnCode code;
            Result error = null;

            code = RemoveChildInterpreter(
                name, clientData, synchronous, ref error);

            if (code != ReturnCode.Ok)
                DebugOps.Complain(this, code, error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Shared Interpreter Flag
        private bool IsShared()
        {
            //
            // NOTE: Check the shared interpreter flag.
            //
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.Shared, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void SetShared()
        {
            //
            // NOTE: Set the shared interpreter flag.
            //
            interpreterStateFlags |= InterpreterStateFlags.Shared;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private void UnsetShared()
        {
            //
            // NOTE: Clear the shared interpreter flag.
            //
            interpreterStateFlags &= ~InterpreterStateFlags.Shared;
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region NoNullArgument Interpreter Flag
        internal bool HasNoNullArgument(
            EngineFlags engineFlags
            )
        {
            if (EngineFlagOps.HasNoNullArgument(engineFlags))
                return true;

            /* EXEMPT */
            return FlagOps.HasFlags( /* NO-LOCK */
                interpreterFlags, InterpreterFlags.NoNullArgument,
                true);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ArgumentLocation Interpreter Flag
#if DEBUGGER && BREAKPOINTS
        internal bool HasArgumentLocation()
        {
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.ArgumentLocation, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void EnableArgumentLocation(
            bool? enable,
            bool? @lock
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (enable != null)
                {
                    if ((bool)enable)
                        interpreterStateFlags |= InterpreterStateFlags.ArgumentLocation;
                    else
                        interpreterStateFlags &= ~InterpreterStateFlags.ArgumentLocation;
                }

                if (@lock != null)
                {
                    if ((bool)@lock)
                        interpreterStateFlags |= InterpreterStateFlags.ArgumentLocationLock;
                    else
                        interpreterStateFlags &= ~InterpreterStateFlags.ArgumentLocationLock;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For the core [source] command implementation and
        //       the core script library ("init.eagle") use only.
        //
        internal void BeginArgumentLocation(
            ref InterpreterStateFlags savedInterpreterStateFlags
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!FlagOps.HasFlags(interpreterStateFlags,
                        InterpreterStateFlags.ArgumentLocationLock, true))
                {
                    savedInterpreterStateFlags = interpreterStateFlags;
                    interpreterStateFlags |= InterpreterStateFlags.ArgumentLocation;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For the core [source] command implementation and
        //       the core script library ("init.eagle") use only.
        //
        internal void EndArgumentLocation(
            ref InterpreterStateFlags savedInterpreterStateFlags
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!FlagOps.HasFlags(interpreterStateFlags,
                        InterpreterStateFlags.ArgumentLocationLock, true))
                {
                    interpreterStateFlags = savedInterpreterStateFlags;
                    savedInterpreterStateFlags = InterpreterStateFlags.None;
                }
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region NoIsolatedNotify Interpreter Flag
#if ISOLATED_PLUGINS
        private bool IsNoIsolatedNotify()
        {
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.NoIsolatedNotify, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private void SetNoIsolatedNotify()
        {
            interpreterStateFlags |= InterpreterStateFlags.NoIsolatedNotify;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void UnsetNoIsolatedNotify()
        {
            interpreterStateFlags &= ~InterpreterStateFlags.NoIsolatedNotify;
        }
#endif
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ResolveAssemblySearch Interpreter Flag
        internal bool HasResolveAssemblySearch()
        {
            return HasResolveAssemblySearch(interpreterFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool HasResolveAssemblySearch(
            InterpreterFlags interpreterFlags
            )
        {
            /* EXEMPT */
            return FlagOps.HasFlags(interpreterFlags,
                InterpreterFlags.ResolveAssemblySearch, true);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region HighPriority Interpreter Flag
#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
        private bool HasHighPriority()
        {
            return HasHighPriority(interpreterStateFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool HasHighPriority(
            InterpreterStateFlags interpreterStateFlags
            )
        {
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.HighPriority, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void SetHighPriority()
        {
            interpreterStateFlags |= InterpreterStateFlags.HighPriority;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void UnsetHighPriority()
        {
            interpreterStateFlags &= ~InterpreterStateFlags.HighPriority;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool? MaybeMakeHighPriority(
            bool highPriority
            )
        {
            if (highPriority != HasHighPriority())
            {
                if (highPriority)
                    SetHighPriority();
                else
                    UnsetHighPriority();

                InitializeCaches(true);

                return highPriority;
            }

            return null;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region AutoTraceObject Interpreter Flag
        private bool HasAutoTraceObject()
        {
            return HasAutoTraceObject(interpreterStateFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool HasAutoTraceObject(
            InterpreterStateFlags interpreterStateFlags
            )
        {
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.AutoTraceObject, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void SetAutoTraceObject()
        {
            interpreterStateFlags |= InterpreterStateFlags.AutoTraceObject;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void UnsetAutoTraceObject()
        {
            interpreterStateFlags &= ~InterpreterStateFlags.AutoTraceObject;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Kiosk Support
        #region KioskLock Flag
#if SHELL
        internal bool IsKioskLock()
        {
            //
            // NOTE: Check the kiosk lock flag.
            //
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.KioskLock, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void SetKioskLock()
        {
            //
            // NOTE: Set the kiosk lock flag.
            //
            interpreterStateFlags |= InterpreterStateFlags.KioskLock;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void UnsetKioskLock()
        {
            //
            // NOTE: Clear the kiosk lock flag.
            //
            interpreterStateFlags &= ~InterpreterStateFlags.KioskLock;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region KioskArgv Flag
#if SHELL
        internal bool IsKioskArgv()
        {
            //
            // NOTE: Check the kiosk argv flag.
            //
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.KioskArgv, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void SetKioskArgv()
        {
            //
            // NOTE: Set the kiosk argv flag.
            //
            interpreterStateFlags |= InterpreterStateFlags.KioskArgv;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void UnsetKioskArgv()
        {
            //
            // NOTE: Clear the kiosk argv flag.
            //
            interpreterStateFlags &= ~InterpreterStateFlags.KioskArgv;
        }
#endif
        #endregion
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IHaveCultureInfo Members
        public CultureInfo CultureInfo
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return InternalCultureInfo;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    InternalCultureInfo = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal CultureInfo InternalCultureInfo
        {
            get { /* NO-LOCK */ return cultureInfo; }
            set { /* NO-LOCK */ cultureInfo = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string CultureName
        {
            get { /* NO-LOCK */ return (cultureInfo != null) ? cultureInfo.Name : null; }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IHaveOwner Members
        public object Owner
        {
            get { CheckDisposed(); lock (syncRoot) { return owner; } }
            set { CheckDisposed(); lock (syncRoot) { owner = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasOwner()
        {
            CheckDisposed();

            lock (syncRoot)
            {
                return (owner != null);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsOwnerBusy(
            object owner
            )
        {
            CheckDisposed();

            return InternalIsOwnerBusy(owner);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal object GetOwner()
        {
            lock (syncRoot)
            {
                return owner;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalIsOwnerBusy(
            object owner
            )
        {
            ScriptThread scriptThread = owner as ScriptThread;

            if (scriptThread == null)
                return false;

            return scriptThread.PrivateIsBusy;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IErrorManager Members
        public int ErrorLine
        {
            get
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ErrorLine;
                else
                    return 0;
#else
                lock (syncRoot)
                {
                    return errorLine;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ErrorLine = value;
#else
                lock (syncRoot)
                {
                    errorLine = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ResetErrorInformation(
            VariableFlags flags,
            bool all,
            bool strict,
            ref ResultList errors
            )
        {
            CheckDisposed();

            return PrivateResetErrorInformation(flags, all, strict, ref errors);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode CopyErrorInformation(
            VariableFlags flags,
            ref Result result
            )
        {
            CheckDisposed();

            return InternalCopyErrorInformation(
                flags, false, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode CopyErrorInformation(
            VariableFlags flags,
            bool strict,
            ref Result result
            )
        {
            CheckDisposed();

            return InternalCopyErrorInformation(
                flags, strict, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode CopyErrorInformation(
            VariableFlags flags,
            bool strict,
            ref Result errorCode,
            ref Result errorInfo
            )
        {
            CheckDisposed();

            ResultList errors = null;

            return InternalCopyErrorInformation(
                flags, strict, ref errorCode, ref errorInfo, ref errors);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode CopyErrorInformation(
            VariableFlags flags,
            bool strict,
            ref Result errorCode,
            ref Result errorInfo,
            ref ResultList errors
            )
        {
            CheckDisposed();

            return InternalCopyErrorInformation(
                flags, strict, ref errorCode, ref errorInfo, ref errors);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal static int GetErrorLine(
            Interpreter interpreter
            )
        {
            if (interpreter == null)
                return 0;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return 0;

                return interpreter.ErrorLine; /* PER-THREAD */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void SetErrorLine(
            Interpreter interpreter,
            int errorLine
            )
        {
            if (interpreter == null)
                return;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return;

                interpreter.ErrorLine = errorLine; /* PER-THREAD */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateResetErrorInformation(
            VariableFlags flags,
            bool all,
            bool strict,
            ref ResultList errors
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                {
                    if (errors == null)
                        errors = new ResultList();

                    errors.Add("interpreter is disposed");
                    return ReturnCode.Error;
                }

                //
                // NOTE: For now, only allow flags related to disabling
                //       watches, and notifications, etc.  Since these
                //       variables are now (transparently) per-thread,
                //       their traces can no longer be disabled.
                //
                flags &= VariableFlags.FastNonInstanceTraceMask;

                //
                // NOTE: Keep track of any errors encountered while
                //       unsetting the error related variables and
                //       report them to the caller, even when in
                //       non-strict mode (i.e. when we would like
                //       to return Ok).
                //
                int errorCount = 0;
                Result error; /* REUSED */

                if (all)
                {
                    error = null;

                    if (ResetThreadVariable(
                            Engine.ErrorCodeVariableFlags | flags,
                            TclVars.Core.ErrorCode,
                            ref error) != ReturnCode.Ok)
                    {
                        if (error != null)
                        {
                            if (errors == null)
                                errors = new ResultList();

                            errors.Add(error);
                        }

                        errorCount++;
                    }

                    error = null;

                    if (ResetThreadVariable(
                            Engine.ErrorInfoVariableFlags | flags,
                            TclVars.Core.ErrorInfo,
                            ref error) != ReturnCode.Ok)
                    {
                        if (error != null)
                        {
                            if (errors == null)
                                errors = new ResultList();

                            errors.Add(error);
                        }

                        errorCount++;
                    }
                }
                else
                {
                    error = null;

                    if (UnsetVariable2(
                            Engine.ErrorCodeVariableFlags | flags,
                            TclVars.Core.ErrorCode, null,
                            ref error) != ReturnCode.Ok)
                    {
                        if (error != null)
                        {
                            if (errors == null)
                                errors = new ResultList();

                            errors.Add(error);
                        }

                        errorCount++;
                    }

                    error = null;

                    if (UnsetVariable2(
                            Engine.ErrorInfoVariableFlags | flags,
                            TclVars.Core.ErrorInfo, null,
                            ref error) != ReturnCode.Ok)
                    {
                        if (error != null)
                        {
                            if (errors == null)
                                errors = new ResultList();

                            errors.Add(error);
                        }

                        errorCount++;
                    }
                }

                //
                // NOTE: In strict mode, return Error if there were any
                //       errors querying the variables; otherwise, return
                //       Ok.
                //
                return strict ?
                    (errorCount > 0 ? ReturnCode.Error : ReturnCode.Ok) :
                    ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode InternalCopyErrorInformation(
            VariableFlags flags,
            bool strict,
            ref Result result
            )
        {
            ReturnCode code;
            Result errorCode = null;
            Result errorInfo = null;
            ResultList errors = null;

            code = InternalCopyErrorInformation(
                flags, strict, ref errorCode, ref errorInfo,
                ref errors);

            if (code == ReturnCode.Ok)
            {
                if (result == null)
                    result = String.Empty;

                result.ErrorCode = errorCode;
                result.ErrorInfo = errorInfo;
            }
            else
            {
                if (errors != null)
                    result = errors;
                else
                    result = "could not copy error information";
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode InternalCopyErrorInformation(
            VariableFlags flags,  /* in */
            bool strict,          /* in */
            ref Result errorCode, /* out */
            ref Result errorInfo, /* out */
            ref ResultList errors /* in, out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                {
                    if (errors == null)
                        errors = new ResultList();

                    errors.Add("interpreter is disposed");
                    return ReturnCode.Error;
                }

                //
                // NOTE: For now, only allow flags related to disabling
                //       watches, and notifications, etc.  Since these
                //       variables are now (transparently) per-thread,
                //       their traces can no longer be disabled without
                //       impacting the correctness of the values.
                //
                flags &= VariableFlags.FastNonInstanceTraceMask;

                //
                // NOTE: Keep track of any errors encountered while
                //       querying the error related variables and
                //       report them to the caller, even when in
                //       non-strict mode (i.e. when we would like
                //       to return Ok).
                //
                int errorCount = 0;
                Result error; /* REUSED */

                error = null;

                if (GetVariableValue(
                        Engine.ErrorCodeVariableFlags | flags,
                        TclVars.Core.ErrorCode, ref errorCode,
                        ref error) != ReturnCode.Ok)
                {
                    if (error != null)
                    {
                        if (errors == null)
                            errors = new ResultList();

                        errors.Add(error);
                    }

                    errorCount++;
                }

                error = null;

                if (GetVariableValue(
                        Engine.ErrorInfoVariableFlags | flags,
                        TclVars.Core.ErrorInfo, ref errorInfo,
                        ref error) != ReturnCode.Ok)
                {
                    if (error != null)
                    {
                        if (errors == null)
                            errors = new ResultList();

                        errors.Add(error);
                    }

                    errorCount++;
                }

                //
                // NOTE: In strict mode, return Error if there were any
                //       errors querying the variables; otherwise, return
                //       Ok.
                //
                return strict ?
                    (errorCount > 0 ? ReturnCode.Error : ReturnCode.Ok) :
                    ReturnCode.Ok;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IHistoryManager Members
#if HISTORY
        public bool History
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return history;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    history = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int HistoryLimit
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return historyLimit;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    historyLimit = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasHistory(ref Result error)
        {
            CheckDisposed();

            bool result = (_History != null); /* PROPERTY */

            if (!result)
                error = "history not available";

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public IHistoryData HistoryLoadData
        {
            get
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.HistoryLoadData;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return historyLoadData;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.HistoryLoadData = value;
#else
                lock (syncRoot)
                {
                    historyLoadData = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public IHistoryData HistorySaveData
        {
            get
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.HistorySaveData;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return historySaveData;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.HistorySaveData = value;
#else
                lock (syncRoot)
                {
                    historySaveData = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public IHistoryFilter HistoryEngineFilter
        {
            get
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.HistoryEngineFilter;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return historyEngineFilter;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.HistoryEngineFilter = value;
#else
                lock (syncRoot)
                {
                    historyEngineFilter = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public IHistoryFilter HistoryInfoFilter
        {
            get
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.HistoryInfoFilter;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return historyInfoFilter;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.HistoryInfoFilter = value;
#else
                lock (syncRoot)
                {
                    historyInfoFilter = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public IHistoryFilter HistoryLoadFilter
        {
            get
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.HistoryLoadFilter;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return historyLoadFilter;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.HistoryLoadFilter = value;
#else
                lock (syncRoot)
                {
                    historyLoadFilter = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public IHistoryFilter HistorySaveFilter
        {
            get
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.HistorySaveFilter;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return historySaveFilter;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.HistorySaveFilter = value;
#else
                lock (syncRoot)
                {
                    historySaveFilter = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string HistoryFileName
        {
            get
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.HistoryFileName;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return historyFileName;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.HistoryFileName = value;
#else
                lock (syncRoot)
                {
                    historyFileName = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ClearHistory(
            IHistoryFilter historyFilter, /* NOT USED */
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                if (!HasHistory(ref error))
                    return ReturnCode.Error;

                //
                // NOTE: Clear the history of executed commands.
                //
                _History.Clear();

#if NOTIFY
                /* IGNORED */
                CheckNotification(
                    NotifyType.History, NotifyFlags.Cleared,
                    null, this,
                    null, null, null, ref error);
#endif
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddHistory(
            ArgumentList arguments,
            IHistoryData historyData,
            IHistoryFilter historyFilter, /* NOT USED */
            ref Result error
            )
        {
            CheckDisposed();

            int levels;
            HistoryFlags flags;

            if (historyData != null)
            {
                levels = historyData.Levels;
                flags = historyData.Flags;
            }
            else
            {
                levels = Level.Invalid;
                flags = HistoryFlags.None;
            }

            return AddHistory(arguments, levels, flags, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode LoadHistory(
            Encoding encoding,
            string fileName,
            IHistoryData historyData,
            IHistoryFilter historyFilter, /* NOT USED */
            bool strict,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref error))
                    return ReturnCode.Error;

                if (String.IsNullOrEmpty(fileName))
                {
                    error = "invalid file name";
                    return ReturnCode.Error;
                }

                if (!File.Exists(fileName))
                {
                    error = String.Format(
                        "couldn't read file {0}: no such file or directory",
                        FormatOps.WrapOrNull(fileName));

                    return ReturnCode.Error;
                }

                if (!HasHistory(ref error))
                    return ReturnCode.Error;

                try
                {
                    if (encoding == null)
                        encoding = StringOps.GetEncoding(EncodingType.History);

                    using (StreamReader streamReader = new StreamReader(
                            new FileStream(fileName, FileMode.Open,
                                FileAccess.Read), encoding)) /* EXEMPT */
                    {
                        int levels;
                        HistoryFlags flags;

                        if (historyData != null)
                        {
                            levels = historyData.Levels;
                            flags = historyData.Flags;
                        }
                        else
                        {
                            levels = Level.Invalid;
                            flags = HistoryFlags.None;
                        }

                        while (!streamReader.EndOfStream)
                        {
                            StringList list = null;
                            Result localError = null;

                            if (ParserOps<string>.SplitList(
                                    this, streamReader.ReadLine(), 0,
                                    Length.Invalid, true, ref list,
                                    ref localError) == ReturnCode.Ok)
                            {
                                IClientData clientData = new HistoryClientData(
                                    null, new ArgumentList(list, ArgumentFlags.None),
                                    levels, flags & HistoryFlags.InstanceMask);

                                _History.AddLast(clientData);
                            }
                            else if (strict)
                            {
                                error = localError;
                                return ReturnCode.Error;
                            }
                        }
                    }

                    return ReturnCode.Ok;
                }
                catch (Exception e)
                {
                    error = e;
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SaveHistory(
            Encoding encoding,
            string fileName,
            IHistoryData historyData, /* NOT USED */
            IHistoryFilter historyFilter,
            bool strict,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (String.IsNullOrEmpty(fileName))
                {
                    error = "invalid file name";
                    return ReturnCode.Error;
                }

                if (!HasHistory(ref error))
                    return ReturnCode.Error;

                try
                {
                    if (encoding == null)
                        encoding = StringOps.GetEncoding(EncodingType.History);

                    using (StreamWriter streamWriter = new StreamWriter(
                            new FileStream(fileName, FileMode.Create,
                                FileAccess.Write), encoding)) /* EXEMPT */
                    {
                        foreach (IClientData clientData in _History)
                        {
                            HistoryClientData historyClientData =
                                clientData as HistoryClientData;

                            if (historyClientData != null)
                            {
                                if (HistoryOps.MatchData(
                                        historyClientData, historyFilter))
                                {
                                    ArgumentList arguments =
                                        historyClientData.Arguments;

                                    if (arguments != null)
                                        streamWriter.WriteLine(
                                            arguments.ToString());
                                }
                            }
                            else if (strict)
                            {
                                error = "invalid history data";
                                return ReturnCode.Error;
                            }
                        }
                    }

                    return ReturnCode.Ok;
                }
                catch (Exception e)
                {
                    error = e;
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal bool CanAddHistory()
        {
            // CheckDisposed();

            // lock (syncRoot) // BUGBUG: *PERF* Used by engine.
            {
                return history &&
#if THREADING
                    (_History != null);
#else
                    (_history != null);
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool HasHistory() // NOTE: For _Hosts.Default use only.
        {
#if THREADING
            return (_History != null);
#else
            return (_history != null);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddHistory(
            ArgumentList arguments,
            int levels,
            HistoryFlags flags
            )
        {
            Result error = null;

            return AddHistory(arguments, levels, flags, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddHistory(
            ArgumentList arguments,
            int levels,
            HistoryFlags flags,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref error))
                    return ReturnCode.Error;

                if (arguments == null)
                {
                    error = "invalid arguments";
                    return ReturnCode.Error;
                }

                if (!HasHistory(ref error))
                    return ReturnCode.Error;

                //
                // NOTE: Add the arguments to the history of executed commands.
                //
                IClientData clientData =
                    new HistoryClientData(null, arguments, levels, flags);

                _History.AddFirst(clientData);

#if NOTIFY
                /* IGNORED */
                CheckNotification(
                    NotifyType.History, NotifyFlags.Added,
                    clientData, this,
                    null, null, null, ref error);
#endif

                //
                // NOTE: Prevent the number of history items from exceeding the
                //       limit (unless the limit is -1).
                //
                int limit = historyLimit;

                if (limit >= 0)
                {
                    //
                    // NOTE: If the limit is zero, use the default limit.
                    //
                    if (limit == 0)
                        limit = DefaultHistoryLimit;

                    while (_History.Count > limit)
                    {
                        //
                        // NOTE: Remove old argument lists in FIFO style.
                        //
                        LinkedListNode<IClientData> last = _History.Last;

                        if (last == null)
                            break;

                        clientData = last.Value;
                        _History.RemoveLast();

#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.History, NotifyFlags.Removed,
                            clientData, this,
                            null, null, null, ref error);
#endif
                    }
                }
            }

            return ReturnCode.Ok;
        }
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IInteractiveManager Members
        public IInteractiveHost InteractiveHost
        {
            get { CheckDisposed(); lock (syncRoot) { return PrivateInteractiveHost; } }
            set { CheckDisposed(); lock (syncRoot) { PrivateInteractiveHost = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool Interactive // using interactive shell?
        {
            get { CheckDisposed(); return InternalInteractive; }
            set { CheckDisposed(); InternalInteractive = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string InteractiveInput
        {
            get
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.InteractiveInput;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return interactiveInput;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.InteractiveInput = value;
#else
                lock (syncRoot)
                {
                    interactiveInput = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string PreviousInteractiveInput
        {
            get
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.PreviousInteractiveInput;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return previousInteractiveInput;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.PreviousInteractiveInput = value;
#else
                lock (syncRoot)
                {
                    previousInteractiveInput = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string InteractiveMode
        {
            get
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.InteractiveMode;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return interactiveMode;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.InteractiveMode = value;
#else
                lock (syncRoot)
                {
                    interactiveMode = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public StringTransformCallback InteractiveCommandCallback
        {
            get
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.InteractiveCommandCallback;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return interactiveCommandCallback;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.InteractiveCommandCallback = value;
#else
                lock (syncRoot)
                {
                    interactiveCommandCallback = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
#if THREADING
        private IInteractiveContext GetInteractiveContext()
        {
            return (contextManager != null) ?
                contextManager.GetInteractiveContext(true) : null;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IInteractiveHost PrivateInteractiveHost
        {
            get { /* NO-LOCK */ return interactiveHost; }
            set { /* NO-LOCK */ interactiveHost = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool GetAndCheckInteractiveHost(
            ref IInteractiveHost interactiveHost /* in, out */
            )
        {
            interactiveHost = GetInteractiveHost();

            if (interactiveHost == null)
                return false;

            HostFlags hostFlags = HostOps.GetHostFlags(
                interactiveHost);

            return HostOps.IsOpen(
                this, null, ref hostFlags, ref interactiveHost);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IInteractiveHost GetInteractiveHost()
        {
            return GetInteractiveHost(null) as IInteractiveHost;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: First, check the PrivateInteractiveHost property, in case
        //       there is a special host setup for use by the interactive
        //       loop.  Then, if necessary, fallback to the InternalHost
        //       property.  This method should only be called by the code
        //       within the interactive loop subsystem -OR- code that is
        //       intended to interact directly with the user.  The lock is
        //       used to prevent internal race conditions; however, since
        //       this method is used from within the tracing subsystem, it
        //       must make use of the TryLock pattern to avoid deadlocks.
        //
        internal object GetInteractiveHost(
            Type type /* IHost, one of its derived types, or null. */
            )
        {
            bool locked = false;

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    if (disposed)
                        return null;

                    IInteractiveHost interactiveHost = PrivateInteractiveHost; /* PROPERTY */

                    if (interactiveHost != null)
                    {
                        //
                        // NOTE: If the caller does not care about the type -OR-
                        //       it is a proxy, just return it.
                        //
                        if (type == null)
                        {
                            TraceOps.DebugTrace(
                                "GetInteractiveHost: interactive host, no type",
                                typeof(Interpreter).Name, TracePriority.HostDebug);

                            return interactiveHost;
                        }

                        //
                        // NOTE: Grab the type of the interactive host and check
                        //       it against the requested interface type.
                        //
                        Type localType = AppDomainOps.MaybeGetTypeOrNull(
                            interactiveHost);

                        if (type.IsInterface)
                        {
                            if (RuntimeOps.DoesClassTypeSupportInterface(
                                    localType, type))
                            {
                                TraceOps.DebugTrace(String.Format(
                                    "GetInteractiveHost: interactive host, interface {0}",
                                    FormatOps.TypeName(type)), typeof(Interpreter).Name,
                                    TracePriority.HostDebug);

                                return interactiveHost;
                            }
                        }
                        else
                        {
                            if (RuntimeOps.IsClassTypeEqualOrSubClass(
                                    localType, type, true))
                            {
                                TraceOps.DebugTrace(String.Format(
                                    "GetInteractiveHost: interactive host, class {0}",
                                    FormatOps.TypeName(type)), typeof(Interpreter).Name,
                                    TracePriority.HostDebug);

                                return interactiveHost;
                            }
                        }
                    }

#if DEBUG && VERBOSE
                    //
                    // NOTE: IHost inherits from all interface types supported
                    //       by this method, so just return it.
                    //
                    TraceOps.DebugTrace(String.Format(
                        "GetInteractiveHost: fallback to normal host, type {0}",
                        FormatOps.TypeName(type)), typeof(Interpreter).Name,
                        TracePriority.HostDebug);
#endif

                    return InternalHost; /* PROPERTY */
                }
                else
                {
                    TraceOps.DebugTrace(
                        "GetInteractiveHost: unable to acquire lock",
                        typeof(Interpreter).Name, TracePriority.LockError);

                    return null;
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalInteractive
        {
            get
            {
#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.Interactive;
                else
                    return false;
#else
                lock (syncRoot)
                {
                    return interactive;
                }
#endif
            }
            set
            {
#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.Interactive = value;
#else
                lock (syncRoot)
                {
                    interactive = value;
                }
#endif

                if (IsPrimarySystemThread())
                {
                    VariableFlags flags = VariableFlags.ViaProperty;

                    //
                    // NOTE: Do not create the variable if we have been
                    //       prohibited from doing so.  This variable *IS*
                    //       allowed in "safe" interpreters, based on what
                    //       native Tcl allows.
                    //
                    if (PrivateIsNoVariables())
                        flags |= VariableFlags.NoCreate;

                    //
                    // NOTE: Update script-level informational variable.  This
                    //       variable is allowed in "safe" interpreters.
                    //
                    SetLibraryVariableValue(
                        flags, TclVars.Core.Interactive, value.ToString());
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL
        private int PushGlobalInteractiveLoopLevel()
        {
            return Interlocked.Increment(ref globalInteractiveLoops);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int PopGlobalInteractiveLoopLevel()
        {
            return Interlocked.Decrement(ref globalInteractiveLoops);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void PushLocalInteractiveLoopLevel(
            IInteractiveLoopData loopData,         /* in */
            bool saveThread,                       /* in */
            out Thread savedInteractiveThread,     /* out */
            out bool savedInteractive,             /* out */
            out IInteractiveLoopData savedLoopData /* out */
            )
        {
            //
            // NOTE: The thread for the interactive user is this one.  This
            //       can only be done in the primary application domain for
            //       the interpreter.
            //
            savedInteractiveThread = null;

            if (saveThread)
            {
                savedInteractiveThread = InteractiveThread;
                InteractiveThread = Thread.CurrentThread;
            }

            //
            // NOTE: Save the interactive "active" flag for this thread and
            //       then force it enabled because this is an interactive
            //       loop and absolutely requires user input; therefore, we
            //       are in interactive mode.
            //
            savedInteractive = InternalInteractive;
            InternalInteractive = true;

            //
            // NOTE: We are entering an[other] instance of the interactive
            //       loop; therefore, increase our tracking counts.
            //
            ActiveInteractiveLoops++; /* THREAD-SAFE */
            TotalInteractiveLoops++; /* THREAD-SAFE */

            //
            // NOTE: Save previous interactive loop data instance and then
            //       reset it to the (new?) one specified by the caller.
            //
            savedLoopData = InteractiveLoopData; /* THREAD-SAFE */
            InteractiveLoopData = loopData; /* THREAD-SAFE */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void PopLocalInteractiveLoopLevel(
            bool restoreThread,                    /* in */
            ref Thread savedInteractiveThread,     /* in, out */
            ref bool savedInteractive,             /* in, out */
            ref IInteractiveLoopData savedLoopData /* in, out */
            )
        {
            //
            // BUGFIX: There is no need to restore the interactive loop
            //         level if the interpreter has been disposed.
            //
            if (!disposed)
            {
                //
                // NOTE: Restore interactive loop data property to its
                //       previous value here.  This property is not used
                //       by the core library itself; however, others may
                //       rely on its correctly restored value.
                //
                InteractiveLoopData = savedLoopData;

                //
                // NOTE: We are exiting this instance of the interactive
                //       loop; therefore, decrease our tracking count.
                //
                ActiveInteractiveLoops--; /* THREAD-SAFE */

                //
                // BUGFIX: Restore interactive flag property to previous
                //         value here, do not simply set it to false.
                //
                InternalInteractive = savedInteractive;

                //
                // BUGFIX: Restore interactive thread property to its
                //         previous value here, do not simply set it to
                //         null.  This can only be done in the primary
                //         application domain for the interpreter.
                //
                if (restoreThread)
                    InteractiveThread = savedInteractiveThread;
            }

            savedLoopData = null;
            savedInteractive = false;
            savedInteractiveThread = null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool IsReadLineDisabled(
            Interpreter interpreter,
            bool @default
            )
        {
            if (interpreter == null)
                return @default;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return @default;

                return FlagOps.HasFlags(
                    interpreter.InterpreterStateFlags,
                    InterpreterStateFlags.ReadLineDisabled,
                    true);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void SetInteractiveInput(
            Interpreter interpreter,
            string interactiveInput
            )
        {
            if (interpreter == null)
                return;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return;

                interpreter.InteractiveInput = interactiveInput;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool ShouldInteractiveCommandCallback(
            ref string text /* in, out */
            )
        {
            if (String.IsNullOrEmpty(text))
                return true;

            string newPrefix = null;
            int nextIndex = Index.Invalid;

            if (!ShellOps.LooksLikeInteractiveVerbatimCommand(
                    text, ref newPrefix, ref nextIndex))
            {
                return true;
            }

            if (nextIndex != Index.Invalid)
            {
                if (newPrefix != null)
                    text = newPrefix + text.Substring(nextIndex);
                else
                    text = text.Substring(nextIndex);
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void RemoveInteractiveCommandCallback(
            Interpreter interpreter /* in */
            )
        {
            //
            // NOTE: If there is no interpreter context, do nothing.
            //
            if (interpreter == null)
                return;

            //
            // HACK: If the callback raises an exception, maybe it is
            //       no longer usable?  For now, we always treat this
            //       as an opportunity to unhook it.
            //
            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (!interpreter.PrivateDisposed)
                    interpreter.InteractiveCommandCallback = null;
            }

            //
            // NOTE: If possible, attempt to emit a message to the
            //       interpreter host showing that the interactive
            //       command callback is now dead.
            //
            try
            {
                IDebugHost debugHost = interpreter.Host;

                if (debugHost != null)
                {
                    debugHost.WriteResult(
                        ReturnCode.Exception, "Interactive command " +
                        "callback removed due to exception.", true);
                }
            }
            catch (Exception e)
            {
                TraceOps.DebugTrace(
                    e, typeof(Interpreter).Name,
                    TracePriority.HostError);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void GetInteractiveCommandCallback(
            Interpreter interpreter,             /* in */
            ref StringTransformCallback callback /* out */
            )
        {
            if (interpreter != null)
            {
                lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
                {
                    if (interpreter.PrivateDisposed)
                        return;

                    try
                    {
                        callback = interpreter.InteractiveCommandCallback; /* throw */
                    }
                    catch (Exception e)
                    {
                        TraceOps.DebugTrace(
                            e, typeof(Interpreter).Name,
                            TracePriority.CallbackError);

                        RemoveInteractiveCommandCallback(interpreter);
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void MaybeInteractiveCommandCallback(
            Interpreter interpreter, /* in */
            bool debug,              /* in */
            ref string text          /* in, out */
            )
        {
            if (interpreter == null)
                return;

            StringTransformCallback callback = null;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return;

                if (!ScriptOps.HasFlags(interpreter,
                        InterpreterFlags.AllowProxyCallback, true) &&
                    AppDomainOps.IsTransparentProxy(interpreter))
                {
                    return;
                }

#if DEBUGGER
                if (debug || interpreter.PrivateHaveDebuggerLoops())
                    return;
#endif

                GetInteractiveCommandCallback(interpreter, ref callback);
            }

            if (callback == null)
                return;

#if DEBUGGER
            //
            // BUGFIX: The interactive command callback may decide to evaluate
            //         a script (or it may be a dynamic delegate); therefore,
            //         disable breakpoints for the duration of its execution.
            //         This avoids some undesirable interactions between the
            //         interactive command callback, the script debugger, and
            //         the interactive loop.
            //
            EngineFlags savedEngineFlags = interpreter.ContextEngineFlags;
            interpreter.ContextEngineFlags |= EngineFlags.NoBreakpoint;

            try
            {
#endif
#if ARGUMENT_CACHE
                CacheFlags savedCacheFlags = CacheFlags.None;
                interpreter.BeginNoArgumentCache(ref savedCacheFlags);

                try
                {
#endif
                    try
                    {
                        text = callback(text); /* throw */
                    }
                    catch (ScriptException e)
                    {
                        //
                        // HACK: If the thrown "exception" was caused by the
                        //       interactive user simply hitting the Ctrl-C,
                        //       etc, e.g. in order to perform interactive
                        //       script cancellation, then the interactive
                        //       command callback should not be removed.
                        //
                        TraceOps.DebugTrace(
                            e, typeof(Interpreter).Name,
                            TracePriority.CallbackError);

                        if ((e == null) ||
                            (e.ReturnCode != ReturnCode.Error) ||
                            !SharedStringOps.SystemEquals(
                                e.Message, demandCancelResultFormat))
                        {
                            RemoveInteractiveCommandCallback(interpreter);
                        }
                    }
                    catch (Exception e)
                    {
                        TraceOps.DebugTrace(
                            e, typeof(Interpreter).Name,
                            TracePriority.CallbackError);

                        RemoveInteractiveCommandCallback(interpreter);
                    }
#if ARGUMENT_CACHE
                }
                finally
                {
                    interpreter.EndNoArgumentCache(ref savedCacheFlags);
                }
#endif
#if DEBUGGER
            }
            finally
            {
                interpreter.ContextEngineFlags = savedEngineFlags;
                savedEngineFlags = EngineFlags.None;
            }
#endif
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IInterpreter Members
        #region Identity & Affinity
        public long Id
        {
            get { CheckDisposed(); /* NO-LOCK */ return PrivateId; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public long GroupId
        {
            get { CheckDisposed(); /* NO-LOCK */ return PrivateGroupId; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public long CreateCount
        {
            get { CheckDisposed(); /* NO-LOCK */ return PrivateCreateCount; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public DateTime Created
        {
            get { CheckDisposed(); /* NO-LOCK */ return CreatedNoThrow; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public long ThreadId
        {
            get
            {
                CheckDisposed();

                /* NO-LOCK */
                return Interlocked.CompareExchange(ref threadId, 0, 0);
            }
            internal set
            {
                CheckDisposed(); /* NON-PUBLIC, SANITY */

                /* NO-LOCK */
                Interlocked.Exchange(ref threadId, value);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public Thread Thread
        {
            get
            {
                CheckDisposed();

                /* NO-LOCK */
                return Interlocked.CompareExchange(ref thread, null, null);
            }
            internal set
            {
                CheckDisposed(); /* NON-PUBLIC, SANITY */

                /* NO-LOCK */
                Interlocked.Exchange(ref thread, value);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL
        public Thread InteractiveThread
        {
            get
            {
                CheckDisposed();

                /* NO-LOCK */
                return Interlocked.CompareExchange(ref interactiveThread, null, null);
            }
            internal set
            {
                CheckDisposed(); /* NON-PUBLIC, SANITY */

                /* NO-LOCK */
                Interlocked.Exchange(ref interactiveThread, value);
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public EventWaitHandle VariableEvent
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return PrivateVariableEvent;
                }
            }
            internal set
            {
                CheckDisposed(); /* NON-PUBLIC, SANITY */

                lock (syncRoot)
                {
                    PrivateVariableEvent = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public EventWaitHandle SetupEvent
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return setupEvent;
                }
            }
            internal set
            {
                CheckDisposed(); /* NON-PUBLIC, SANITY */

                lock (syncRoot)
                {
                    setupEvent = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public long IdNoThrow
        {
            get
            {
                //
                // NOTE: This method may NOT throw exceptions.
                //
                /* CheckDisposed(); */

                /* NO-LOCK */
                return PrivateId;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public long GroupIdNoThrow
        {
            get
            {
                //
                // NOTE: This method may NOT throw exceptions.
                //
                /* CheckDisposed(); */

                /* NO-LOCK */
                return PrivateGroupId;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public long CreateCountNoThrow
        {
            get
            {
                //
                // NOTE: This method may NOT throw exceptions.
                //
                /* CheckDisposed(); */

                /* NO-LOCK */
                return PrivateCreateCount;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public DateTime CreatedNoThrow
        {
            get
            {
                //
                // NOTE: This method may NOT throw exceptions.
                //
                /* CheckDisposed(); */

                /* NO-LOCK */
                return created;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int GetHashCodeNoThrow()
        {
            //
            // NOTE: This method may NOT throw exceptions.
            //
            /* CheckDisposed(); */

            int Y = 0; /* NOTE: Low half. */
            int Z = 0; /* NOTE: High half. */

            ConversionOps.ToInts(PrivateId, ref Y, ref Z);
            return CommonOps.HashCodes.Combine(Y, Z);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public IRuleSet GetRuleSet()
        {
            CheckDisposed();

            // lock (syncRoot) /* NOT CHANGED */
            {
                return ruleSet;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public AppDomain GetAppDomain()
        {
            CheckDisposed();

            // lock (syncRoot) /* NOT CHANGED */
            {
                return appDomain;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string FormatAppDomainId(
            bool display
            )
        {
            CheckDisposed();

            // lock (syncRoot) /* NOT CHANGED */
            {
                string idString = AppDomainOps.GetIdString(
                    appDomain);

                return display ? String.Format(
                    "AppDomain:{0}", idString) : idString;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsSameAppDomain(
            AppDomain appDomain
            )
        {
            CheckDisposed();

            return AppDomainOps.IsSame(this, appDomain);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if CAS_POLICY
        public StrongName GetStrongName()
        {
            CheckDisposed();

            return AssemblyOps.GetStrongName(GlobalState.GetAssembly());
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public Hash GetHash()
        {
            CheckDisposed();

            return AssemblyOps.GetHash(GlobalState.GetAssembly());
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if !NET_STANDARD_20
        public X509Certificate GetCertificate()
        {
            CheckDisposed();

            return AssemblyOps.GetCertificate(GlobalState.GetAssembly());
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public void DemandStrongName() /* throw */
        {
#if CAS_POLICY
            CheckDisposed();

            StrongName strongName = null;

            DemandStrongName(ref strongName);
#else
            throw new NotImplementedException();
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if CAS_POLICY
        public void DemandStrongName(
            ref StrongName strongName
            ) /* throw */
        {
            CheckDisposed();

            strongName = GetStrongName();

            if (strongName == null)
                throw new NotSupportedException();

            new StrongNameIdentityPermission(
                (strongName != null) ? strongName.PublicKey : null,
                null, null).Demand(); /* throw */
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public void DemandCertificate() /* throw */
        {
#if CAS_POLICY && !NET_STANDARD_20
            CheckDisposed();

            X509Certificate certificate = null;

            DemandCertificate(ref certificate);
#else
            throw new NotImplementedException();
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if CAS_POLICY && !NET_STANDARD_20
        public void DemandCertificate(
            ref X509Certificate certificate
            ) /* throw */
        {
            CheckDisposed();

            certificate = GetCertificate();

            if (certificate == null)
                throw new NotSupportedException();

            new PublisherIdentityPermission(
                certificate).Demand(); /* throw */
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public long NextId() /* THREAD-SAFE */
        {
            CheckDisposed();

            long result;

            //
            // NOTE: This is our cheap per-interpreter unique Id
            //       generator for the various script visible
            //       identifiers (such as channel names, etc).
            //
            result = Interlocked.Increment(ref nextId);

            if (result < 0)
            {
                DebugOps.Complain(this, ReturnCode.Error,
                    "next identifier is negative");
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetFramework(
            Guid? id,             /* in */
            FrameworkFlags flags, /* in */
            ref Result result     /* out */
            )
        {
            CheckDisposed();

            return RuntimeOps.GetFramework(
                GlobalState.GetAssembly(), id, flags, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetContext(
            ref Result result
            )
        {
            CheckDisposed();

            ByteList bytes = null;

            if (AddEntropyToBytes(ref bytes, ref result))
            {
                if (bytes != null)
                {
                    /* NO RESULT */
                    AddContextToBytes(ref bytes);

                    //
                    // NOTE: Hash the entropy and context bytes together into
                    //       the final result.  The result should be the same
                    //       every time this method is called; however, the
                    //       resulting value cannot be predicted in advance
                    //       and/or have its constituent values determined by
                    //       a "safe" interpreter.
                    //
                    result = MathOps.HashFnv1UInt(bytes.ToArray(), true);
                    return ReturnCode.Ok;
                }
                else
                {
                    result = "invalid entropy bytes";
                }
            }
            else if (result == null)
            {
                result = "entropy bytes not available";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private long PrivateId
        {
            get { return id; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ulong? Token
        {
            get { return token; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private long PrivateGroupId
        {
            //
            // NOTE: For use by the GroupId property only.
            //
            get { return groupId; }
            //
            // NOTE: For use by the PutInGroup method only.
            //
            set { groupId = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsInGroup(
            long? groupId,
            bool @default
            )
        {
            if (groupId == null)
                return @default;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                return (this.groupId == (long)groupId);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void PutInGroup(
            Interpreter interpreter,
            Interpreter groupInterpreter
            )
        {
            if ((interpreter == null) || (groupInterpreter == null))
                return;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                interpreter.PrivateGroupId = groupInterpreter.PrivateId;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private long PrivateCreateCount
        {
            //
            // NOTE: For use by the CreateCount property only.
            //
            get { return Interlocked.CompareExchange(ref createCount, 0, 0); }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private long BumpCreateCount()
        {
            return Interlocked.Increment(ref createCount);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal long ManagedThreadId
        {
            get
            {
                // CheckDisposed();

                /* NO-LOCK */
                return Interlocked.CompareExchange(ref managedThreadId, 0, 0);
            }
            private set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
                /* NO-LOCK */
                Interlocked.Exchange(ref managedThreadId, value);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal long NativeThreadId
        {
            get
            {
                // CheckDisposed();

                /* NO-LOCK */
                return Interlocked.CompareExchange(ref nativeThreadId, 0, 0);
            }
            private set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
                /* NO-LOCK */
                Interlocked.Exchange(ref nativeThreadId, value);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsPrimarySystemThread()
        {
            return IsPrimarySystemThread(GlobalState.GetCurrentSystemThreadId());
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsPrimarySystemThread(long threadId)
        {
            return (threadId == Interlocked.CompareExchange(
                ref this.threadId, 0, 0));
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private bool IsPrimaryNativeThread()
        {
            return IsPrimaryNativeThread(GlobalState.GetCurrentNativeThreadId());
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsPrimaryNativeThread(long threadId)
        {
            return (threadId == Interlocked.CompareExchange(
                ref this.nativeThreadId, 0, 0));
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Variable Wait Support Members
        //
        // NOTE: For use by the IsVariableNameSignaled method
        //       and the VariableEvent property only.
        //
        private EventWaitHandle PrivateVariableEvent
        {
            get { /* NO-LOCK */ return variableEvent; }
            set { /* NO-LOCK */ variableEvent = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal EventWaitHandle TryGetVariableEvent(
            ref Result error
            )
        {
            return TryGetVariableEvent(
                DefaultVariableEventTimeout, true, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // TODO: When calling this method, be extremely careful when
        //       passing "false" as the "waitForLock" parameter; it
        //       should not be used when the caller cannot handle a
        //       null return value gracefully (e.g. from the method
        //       ShouldWaitVariable).  In this context, "gracefully"
        //       means that the caller would end up providing mostly
        //       the same functionality to its caller regardless of
        //       the return value of this method.
        //
        private EventWaitHandle TryGetVariableEvent(
            int timeout,
            bool waitForLock
            )
        {
            Result error = null;

            return TryGetVariableEvent(timeout, waitForLock, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // TODO: When calling this method, be extremely careful when
        //       passing "false" as the "waitForLock" parameter; it
        //       should not be used when the caller cannot handle a
        //       null return value gracefully (e.g. from the method
        //       ShouldWaitVariable).  In this context, "gracefully"
        //       means that the caller would end up providing mostly
        //       the same functionality to its caller regardless of
        //       the return value of this method.
        //
        private EventWaitHandle TryGetVariableEvent(
            int timeout,
            bool waitForLock,
            ref Result error
            )
        {
            bool locked = false;

            try
            {
                if (waitForLock)
                {
                    if (timeout != 0)
                    {
                        InternalTryLock(timeout, ref locked);
                    }
                    else
                    {
                        InternalHardTryLock(ref locked);
                    }
                }
                else
                {
                    InternalSoftTryLock(ref locked);
                }

                if (locked)
                {
                    return variableEvent;
                }
                else
                {
                    error = "unable to acquire lock";

                    TraceOps.DebugTrace(String.Format(
                        "TryGetVariableEvent: {0}", error),
                        typeof(Interpreter).Name,
                        TracePriority.LockError2);

                    return null;
                }
            }
            finally
            {
                InternalExitLock(ref locked);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void SignalVariableEvent()
        {
            ReturnCode code;
            Result error = null;

            code = SignalVariableEvent(ref error);

            if (code != ReturnCode.Ok)
                DebugOps.Complain(this, code, error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SignalVariableEvent(
            ref Result error
            )
        {
            EventWaitHandle variableEvent;
            Result localError = null;

            variableEvent = TryGetVariableEvent(ref localError);

            if (variableEvent != null)
            {
                if (ThreadOps.SetEvent(variableEvent))
                    return ReturnCode.Ok;
                else
                    error = "failed to signal variable event";
            }
            else if (localError != null)
            {
                error = localError;
            }
            else
            {
                error = "cannot signal variable event";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private void UnSignalVariableEvent()
        {
            ReturnCode code;
            Result error = null;

            code = UnSignalVariableEvent(ref error);

            if (code != ReturnCode.Ok)
                DebugOps.Complain(this, code, error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode UnSignalVariableEvent(
            ref Result error
            )
        {
            EventWaitHandle variableEvent;
            Result localError = null;

            variableEvent = TryGetVariableEvent(ref localError);

            if (variableEvent != null)
            {
                if (ThreadOps.ResetEvent(variableEvent))
                    return ReturnCode.Ok;
                else
                    error = "failed to unsignal variable event";
            }
            else if (localError != null)
            {
                error = localError;
            }
            else
            {
                error = "cannot unsignal variable event";
            }

            return ReturnCode.Error;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeVariableEvent()
        {
            ThreadOps.CloseEvent(ref variableEvent);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Setup Wait Support Members
        private EventWaitHandle TryGetSetupEvent(
            ref Result error
            )
        {
            return TryGetSetupEvent(
                DefaultSetupEventTimeout, true, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // TODO: When calling this method, be extremely careful when
        //       passing "false" as the "waitForLock" parameter; it
        //       should not be used when the caller cannot handle a
        //       null return value gracefully (e.g. from the method
        //       ShouldWaitVariable).  In this context, "gracefully"
        //       means that the caller would end up providing mostly
        //       the same functionality to its caller regardless of
        //       the return value of this method.
        //
        private EventWaitHandle TryGetSetupEvent(
            int timeout,
            bool waitForLock,
            ref Result error
            )
        {
            bool locked = false;

            try
            {
                if (waitForLock)
                {
                    if (timeout != 0)
                    {
                        InternalTryLock(timeout, ref locked);
                    }
                    else
                    {
                        InternalHardTryLock(ref locked);
                    }
                }
                else
                {
                    InternalSoftTryLock(ref locked);
                }

                if (locked)
                {
                    return setupEvent;
                }
                else
                {
                    error = "unable to acquire lock";

                    TraceOps.DebugTrace(String.Format(
                        "TryGetSetupEvent: {0}", error),
                        typeof(Interpreter).Name,
                        TracePriority.LockError2);

                    return null;
                }
            }
            finally
            {
                InternalExitLock(ref locked);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void SignalSetupEvent()
        {
            ReturnCode code;
            Result error = null;

            code = SignalSetupEvent(ref error);

            if (code != ReturnCode.Ok)
                DebugOps.Complain(this, code, error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SignalSetupEvent(
            ref Result error
            )
        {
            EventWaitHandle setupEvent;
            Result localError = null;

            setupEvent = TryGetSetupEvent(ref localError);

            if (setupEvent != null)
            {
                if (ThreadOps.SetEvent(setupEvent))
                    return ReturnCode.Ok;
                else
                    error = "failed to signal setup event";
            }
            else if (localError != null)
            {
                error = localError;
            }
            else
            {
                error = "cannot signal setup event";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private void UnSignalSetupEvent()
        {
            ReturnCode code;
            Result error = null;

            code = UnSignalSetupEvent(ref error);

            if (code != ReturnCode.Ok)
                DebugOps.Complain(this, code, error);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode UnSignalSetupEvent(
            ref Result error
            )
        {
            EventWaitHandle setupEvent;
            Result localError = null;

            setupEvent = TryGetSetupEvent(ref localError);

            if (setupEvent != null)
            {
                if (ThreadOps.ResetEvent(setupEvent))
                    return ReturnCode.Ok;
                else
                    error = "failed to unsignal setup event";
            }
            else if (localError != null)
            {
                error = localError;
            }
            else
            {
                error = "cannot unsignal setup event";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by the [checkForGetInstalledUpdates] test
        //          constraints helper procedure only.
        //
        private ReturnCode WaitSetupEvent(
            int timeout
            )
        {
            Result error = null;

            return WaitSetupEvent(timeout, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by the [checkForGetInstalledUpdates] test
        //          constraints helper procedure only (see above).
        //
        private ReturnCode WaitSetupEvent(
            int timeout,
            ref Result error
            )
        {
            EventWaitHandle setupEvent;
            Result localError = null;

            setupEvent = TryGetSetupEvent(ref localError);

            if (setupEvent != null)
            {
                if (ThreadOps.WaitEvent(setupEvent, timeout))
                    return ReturnCode.Ok;
                else
                    error = "failed to wait for setup event";
            }
            else if (localError != null)
            {
                error = localError;
            }
            else
            {
                error = "cannot wait for setup event";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeSetupEvent()
        {
            ThreadOps.CloseEvent(ref setupEvent);
        }
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Host & Script Environment
        #region Global Default Quiet Mode Setting
        internal static bool DefaultQuiet
        {
            get
            {
                lock (staticSyncRoot)
                {
                    return defaultQuiet;
                }
            }
            set
            {
                lock (staticSyncRoot)
                {
                    defaultQuiet = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static bool DefaultTraceStack
        {
            get
            {
                lock (staticSyncRoot)
                {
                    return defaultTraceStack;
                }
            }
            set
            {
                lock (staticSyncRoot)
                {
                    defaultTraceStack = value;
                }
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Global Lock
        internal static void InternalTryStaticLock( /* NOTE: For DebugOps USE ONLY. */
            ref bool locked
            )
        {
            if (staticSyncRoot == null)
                return;

            locked = Monitor.TryEnter(staticSyncRoot);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void PrivateTryStaticLock(
            int timeout,
            ref bool locked
            )
        {
            if (staticSyncRoot == null)
                return;

            locked = Monitor.TryEnter(staticSyncRoot, timeout);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void InternalExitStaticLock( /* NOTE: For DebugOps USE ONLY. */
            ref bool locked
            )
        {
            if (staticSyncRoot == null)
                return;

            if (locked)
            {
                Monitor.Exit(staticSyncRoot);
                locked = false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static void TryStaticLock( /* NOTE: For External USE ONLY. */
            ref bool locked
            )
        {
            InternalTryStaticLock(ref locked); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static void TryStaticLock( /* NOTE: For External USE ONLY. */
            int timeout,
            ref bool locked
            )
        {
            PrivateTryStaticLock(timeout, ref locked); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static void ExitStaticLock( /* NOTE: For External USE ONLY. */
            ref bool locked
            )
        {
            InternalExitStaticLock(ref locked); /* EXEMPT */
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Global Static Callbacks (New / Use / Free)
        public static EventCallback NewInterpreterCallback
        {
            get
            {
                lock (staticSyncRoot)
                {
                    return newInterpreterCallback;
                }
            }
            set
            {
                lock (staticSyncRoot)
                {
                    newInterpreterCallback = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static EventCallback UseInterpreterCallback
        {
            get
            {
                lock (staticSyncRoot)
                {
                    return useInterpreterCallback;
                }
            }
            set
            {
                lock (staticSyncRoot)
                {
                    useInterpreterCallback = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static EventCallback FreeInterpreterCallback
        {
            get
            {
                lock (staticSyncRoot)
                {
                    return freeInterpreterCallback;
                }
            }
            set
            {
                lock (staticSyncRoot)
                {
                    freeInterpreterCallback = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private static void FireFreeInterpreterCallbackOrTrace(
            Interpreter interpreter,
            IClientData clientData
            )
        {
            EventCallback callback = FreeInterpreterCallback;

            if (callback != null)
            {
                ReturnCode freeCode;
                Result freeResult = null;

                try
                {
                    freeCode = callback(
                        interpreter, clientData, ref freeResult);
                }
                catch (Exception e)
                {
                    freeResult = e;
                    freeCode = ReturnCode.Error;
                }

                if (freeCode != ReturnCode.Ok)
                {
                    TraceOps.DebugTrace(String.Format(
                        "FireFreeInterpreterCallbackOrTrace: code = {0}, result = {1}",
                        freeCode, FormatOps.WrapOrNull(freeResult)),
                        typeof(Interpreter).Name,
                        TracePriority.CleanupError);
                }
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Global New Host Callback
        public static NewHostCallback NewHostCallback
        {
            get
            {
                lock (staticSyncRoot)
                {
                    return newHostCallback;
                }
            }
            set
            {
                lock (staticSyncRoot)
                {
                    newHostCallback = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal static void BeginNoNewHostCallback(
            ref NewHostCallback savedNewHostCallback
            )
        {
            lock (staticSyncRoot) /* TRANSACTIONAL */
            {
                savedNewHostCallback = newHostCallback;
                newHostCallback = null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void EndNoNewHostCallback(
            ref NewHostCallback savedNewHostCallback
            )
        {
            lock (staticSyncRoot) /* TRANSACTIONAL */
            {
                newHostCallback = savedNewHostCallback;
                savedNewHostCallback = null;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Global Complain Callback
        public static ComplainCallback ComplainCallback
        {
            get
            {
                lock (staticSyncRoot)
                {
                    return complainCallback;
                }
            }
            set
            {
                lock (staticSyncRoot)
                {
                    complainCallback = value;
                }
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ScriptFlags ScriptFlags
        {
            get { CheckDisposed(); lock (syncRoot) { return scriptFlags; } }
            set { CheckDisposed(); lock (syncRoot) { scriptFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public IHost Host
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return host;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    IHost oldHost = host;
                    IHost newHost = value;

                    //
                    // BUGFIX: We may have just been handed a host that we have
                    //         never seen before.  Make sure it is setup properly.
                    //
                    ReturnCode code;
                    Result error = null;

                    if ((newHost != null) &&
                        !Object.ReferenceEquals(newHost, oldHost))
                    {
                        code = PreSetupHostColors(newHost, false, ref error);

                        if (code != ReturnCode.Ok)
                            DebugOps.Complain(this, code, error);

                        code = SetupHostChannels(newHost, interpreterFlags, ref error);

                        if (code != ReturnCode.Ok)
                            DebugOps.Complain(this, code, error);

#if DEBUGGER
                        code = SetupDebuggerHost(newHost, ref error);

                        if (code != ReturnCode.Ok)
                            DebugOps.Complain(this, code, error);
#endif
                    }

                    host = newHost;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public IBinder Binder
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return InternalBinder;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    InternalBinder = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Be relatively quiet (i.e. suppress complaints)?  This is
        //       exposed as a public property; however, it should only be
        //       used in circumstances where it is extremely undesirable
        //       to have any extraneous output sent to the interpreter
        //       host (e.g. the console) because it can prevent important
        //       warnings and other information from being displayed.  An
        //       example is that MSBuild (v3.5) appears to interpret output
        //       being sent to the standard error channel as an indication
        //       that an "Exec" task has failed, even if the exit code
        //       of the command is zero.
        //
        public bool Quiet
        {
            get
            {
                CheckDisposed();

                return InternalQuiet;
            }
            set
            {
                CheckDisposed();

                InternalQuiet = value;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if POLICY_TRACE
        public bool PolicyTrace
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return InternalPolicyTrace;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    InternalPolicyTrace = value;
                }
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public TraceFilterCallback TraceFilterCallback
        {
            get { CheckDisposed(); lock (syncRoot) { return InternalTraceFilterCallback; } }
            set { CheckDisposed(); lock (syncRoot) { InternalTraceFilterCallback = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public NewCommandCallback NewCommandCallback
        {
            get { CheckDisposed(); lock (syncRoot) { return newCommandCallback; } }
            set { CheckDisposed(); lock (syncRoot) { newCommandCallback = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public NewProcedureCallback NewProcedureCallback
        {
            get { CheckDisposed(); lock (syncRoot) { return newProcedureCallback; } }
            set { CheckDisposed(); lock (syncRoot) { newProcedureCallback = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public MatchCallback MatchCallback
        {
            get { CheckDisposed(); lock (syncRoot) { return InternalMatchCallback; } }
            set { CheckDisposed(); lock (syncRoot) { InternalMatchCallback = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReadyCallback ReadyCallback
        {
            get { CheckDisposed(); lock (syncRoot) { return InternalReadyCallback; } }
            set { CheckDisposed(); lock (syncRoot) { InternalReadyCallback = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public GetTimeoutCallback GetTimeoutCallback
        {
            get { CheckDisposed(); lock (syncRoot) { return InternalGetTimeoutCallback; } }
            set { CheckDisposed(); lock (syncRoot) { InternalGetTimeoutCallback = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NETWORK
        public PreWebClientCallback PreWebClientCallback
        {
            get { CheckDisposed(); lock (syncRoot) { return preWebClientCallback; } }
            set { CheckDisposed(); lock (syncRoot) { preWebClientCallback = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public NewWebClientCallback NewWebClientCallback
        {
            get { CheckDisposed(); lock (syncRoot) { return newWebClientCallback; } }
            set { CheckDisposed(); lock (syncRoot) { newWebClientCallback = value; } }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string BackgroundError
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return backgroundError;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    backgroundError = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string Unknown
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return PrivateUnknown;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    PrivateUnknown = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string GlobalUnknown
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return unknown;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    unknown = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string NamespaceUnknown
        {
            get
            {
                CheckDisposed();

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    INamespace currentNamespace = null;

                    if ((GetCurrentNamespaceViaResolvers(
                            null, LookupFlags.NoVerbose,
                            ref currentNamespace) == ReturnCode.Ok) &&
                        (currentNamespace != null))
                    {
                        return currentNamespace.Unknown;
                    }

                    return null;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    INamespace currentNamespace = null;

                    if ((GetCurrentNamespaceViaResolvers(
                            null, LookupFlags.NoVerbose,
                            ref currentNamespace) == ReturnCode.Ok) &&
                        (currentNamespace != null))
                    {
                        currentNamespace.Unknown = value;
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public UnknownCallback UnknownCallback
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return unknownCallback;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    unknownCallback = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public PackageCallback PackageFallback
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return packageFallback;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    packageFallback = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string PackageUnknown
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return packageUnknown;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    packageUnknown = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
#if ISOLATED_PLUGINS
        internal IHost IsolatedHost
        {
            get
            {
                // CheckDisposed();

                lock (syncRoot)
                {
                    return isolatedHost;
                }
            }
            set
            {
                // CheckDisposed();

                lock (syncRoot)
                {
                    isolatedHost = value;
                }
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IHost InternalHost
        {
            get { /* NO-LOCK */ return host; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IBinder InternalBinder
        {
            get { /* NO-LOCK */ return binder; }
            set { /* NO-LOCK */ binder = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private BindingFlags CreateInstanceBindingFlags
        {
            get { /* NO-LOCK */ return createInstanceBindingFlags; }
            set { /* NO-LOCK */ createInstanceBindingFlags = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if POLICY_TRACE
        internal bool InternalPolicyTrace
        {
            get { /* NO-LOCK */ return policyTrace; }
            set { /* NO-LOCK */ policyTrace = value; }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal TraceFilterCallback InternalTraceFilterCallback
        {
            get { /* NO-LOCK */ return traceFilterCallback; }
            set { /* NO-LOCK */ traceFilterCallback = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal MatchCallback InternalMatchCallback
        {
            get { /* NO-LOCK */ return matchCallback; }
            set { /* NO-LOCK */ matchCallback = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReadyCallback InternalReadyCallback
        {
            get { /* NO-LOCK */ return readyCallback; }
            set { /* NO-LOCK */ readyCallback = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal GetTimeoutCallback InternalGetTimeoutCallback
        {
            get { /* NO-LOCK */ return getTimeoutCallback; }
            set { /* NO-LOCK */ getTimeoutCallback = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private string PrivateUnknown /* WARNING: Assumes lock is held. */
        {
            get
            {
                if (!disposed && AreNamespacesEnabled())
                {
                    string result;
                    INamespace currentNamespace = null;

                    if ((GetCurrentNamespaceViaResolvers(
                            null, LookupFlags.NoVerbose,
                            ref currentNamespace) == ReturnCode.Ok) &&
                        (currentNamespace != null))
                    {
                        result = currentNamespace.Unknown;

                        if (result != null)
                            return result;
                    }

                    if (globalNamespace != null)
                    {
                        result = globalNamespace.Unknown;

                        if (result != null)
                            return result;
                    }
                }

                return unknown; /* NOTE: *COMPAT* Eagle beta. */
            }
            set
            {
                if (!disposed && AreNamespacesEnabled())
                {
                    INamespace currentNamespace = null;

                    if ((GetCurrentNamespaceViaResolvers(
                            null, LookupFlags.NoVerbose,
                            ref currentNamespace) == ReturnCode.Ok) &&
                        (currentNamespace != null))
                    {
                        currentNamespace.Unknown = value;
                        return;
                    }

                    if (globalNamespace != null)
                    {
                        globalNamespace.Unknown = value;
                        return;
                    }
                }

                unknown = value; /* NOTE: *COMPAT* Eagle beta. */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private string GetUnknown(
            EngineFlags engineFlags
            )
        {
            if (EngineFlagOps.HasGlobalOnly(engineFlags))
                return unknown; /* FIELD */

            return PrivateUnknown; /* PROPERTY */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // BUGFIX: The arguments parameter must be "ref" here due to
        //         cross-domain marshalling requirements, i.e. from
        //         the Engine class.
        //
        internal ReturnCode AttemptToUseUnknown(
            ReturnCode returnCode,      /* in */
            EngineFlags engineFlags,    /* in */
            LookupFlags lookupFlags,    /* in */
            ref ArgumentList arguments, /* in, out */
            ref IExecute execute,       /* out */
            ref bool useUnknown         /* out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                Interlocked.Increment(ref unknownCount);

                if (arguments != null)
                {
                    string unknownText = GetUnknown(engineFlags);

                    if ((unknownText != null) && (UnknownLevels == 0))
                    {
                        StringList unknownList = null;

                        if ((ParserOps<string>.SplitList(
                                this, unknownText, 0, Length.Invalid, true,
                                ref unknownList) == ReturnCode.Ok) &&
                            (unknownList.Count > 0))
                        {
                            if (GetIExecuteViaResolvers(
                                    engineFlags | EngineFlags.ToExecute,
                                    unknownList[0], arguments, lookupFlags,
                                    ref execute) == ReturnCode.Ok)
                            {
                                //
                                // NOTE: Prefix the argument list provided by the
                                //       caller with the unknown handler for this
                                //       namespace or interpreter.
                                //
                                arguments.InsertRange(0, unknownList);

                                //
                                // NOTE: Set the unknown flag so that the we can
                                //       properly modify the unknown nesting level
                                //       (below) prior to actually executing
                                //       [unknown]; otherwise, infinite recursion
                                //       may result.
                                //
                                useUnknown = true;

                                //
                                // NOTE: The unknown handler is available.  Have
                                //       the caller try to use it by indicating
                                //       success here.
                                //
                                return ReturnCode.Ok;
                            }
                        }
                    }
                }

                return returnCode;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalQuiet
        {
            get
            {
                lock (syncRoot)
                {
                    return InternalQuietNoLock;
                }
            }
            set
            {
                lock (syncRoot)
                {
                    InternalQuietNoLock = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalQuietNoLock
        {
            get { return quiet; }
            set { quiet = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool ShouldBeQuiet()
        {
            // CheckDisposed();

            return ShouldBeQuiet(DebugOps.GetDefaultQuiet(DefaultQuiet));
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method uses more-or-less the same general idea as the
        //       SafeGetQuiet method of the DebugOps class; however, this one
        //       avoids causing an exception to be thrown (and caught) by
        //       accessing the quiet field directly instead of via the property.
        //
        internal bool ShouldBeQuiet(
            bool @default
            )
        {
            // CheckDisposed();

            lock (syncRoot)
            {
                if (quiet) /* FIELD */
                    return true;
            }

            //
            // HOOK: Allow the test suite (and others components) to override
            //       the quietness setting via the environment.
            //
            if (CommonOps.Environment.DoesVariableExist(EnvVars.Quiet))
                return true;

            return @default;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool HasNoBackgroundError()
        {
            /* EXEMPT */
            return FlagOps.HasFlags(interpreterFlags,
                InterpreterFlags.NoBackgroundError, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void SetNoBackgroundError(
            bool noBackgroundError
            )
        {
            if (noBackgroundError)
                interpreterFlags |= InterpreterFlags.NoBackgroundError;
            else
                interpreterFlags &= ~InterpreterFlags.NoBackgroundError;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool HasTraceStack()
        {
            /* EXEMPT */
            return FlagOps.HasFlags(interpreterFlags,
                InterpreterFlags.TraceStack, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private void SetTraceStack(
            bool traceStack
            )
        {
            if (traceStack)
                interpreterFlags |= InterpreterFlags.TraceStack;
            else
                interpreterFlags &= ~InterpreterFlags.TraceStack;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool HasTraceToHost()
        {
            /* EXEMPT */
            return FlagOps.HasFlags(interpreterFlags,
                InterpreterFlags.TraceToHost, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private void SetTraceToHost(
            bool traceToHost
            )
        {
            if (traceToHost)
                interpreterFlags |= InterpreterFlags.TraceToHost;
            else
                interpreterFlags &= ~InterpreterFlags.TraceToHost;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool HasComplainViaTest()
        {
            /* EXEMPT */
            return FlagOps.HasFlags(interpreterFlags,
                InterpreterFlags.ComplainViaTest, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private void SetComplainViaTest(
            bool complainViaTest
            )
        {
            if (complainViaTest)
                interpreterFlags |= InterpreterFlags.ComplainViaTest;
            else
                interpreterFlags &= ~InterpreterFlags.ComplainViaTest;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool HasComplainViaTrace()
        {
            /* EXEMPT */
            return FlagOps.HasFlags(interpreterFlags,
                InterpreterFlags.ComplainViaTrace, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private void SetComplainViaTrace(
            bool complainViaTrace
            )
        {
            if (complainViaTrace)
                interpreterFlags |= InterpreterFlags.ComplainViaTrace;
            else
                interpreterFlags &= ~InterpreterFlags.ComplainViaTrace;
        }
#endif
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Xml Data Handling
#if XML
        public XmlErrorTypes RetryXml
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return retryXml;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    retryXml = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool ValidateXml
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return validateXml;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    validateXml = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool RelaxedXml
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return relaxedXml;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    relaxedXml = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool AllXml
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return allXml;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    allXml = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal void QueryXmlProperties(
            ref XmlErrorTypes retryXml,
            ref bool validateXml,
            ref bool relaxedXml,
            ref bool allXml
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                retryXml = this.retryXml;
                validateXml = this.validateXml;
                relaxedXml = this.relaxedXml;
                allXml = this.allXml;
            }
        }
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Initialization & Termination
        public bool ExitNoThrow
        {
            get
            {
                // CheckDisposed(); /* EXEMPT */

                /* NO-LOCK */
                return PrivateExit;
            }
            set
            {
                // CheckDisposed(); /* EXEMPT */

                /* NO-LOCK */
                PrivateExit = value;

#if NOTIFY
                /* IGNORED */
                CheckNotification(
                    NotifyType.Interpreter, NotifyFlags.Exit,
                    PrivateExit, this,
                    null, null, null);
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool Exit
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return ExitNoThrow;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    ExitNoThrow = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ExitCode ExitCodeNoThrow
        {
            get
            {
                // CheckDisposed(); /* EXEMPT */

                /* NO-LOCK */
                return PrivateExitCode;
            }
            set
            {
                // CheckDisposed(); /* EXEMPT */

                /* NO-LOCK */
                PrivateExitCode = value;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ExitCode ExitCode
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return ExitCodeNoThrow;
                }

            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    ExitCodeNoThrow = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal bool InternalExit
        {
            get { return PrivateExit; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateExit
        {
            get { /* NO-LOCK */ return exit; }
            set { /* NO-LOCK */ exit = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ExitCode InternalExitCode
        {
            get { return PrivateExitCode; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ExitCode PrivateExitCode
        {
            get { /* NO-LOCK */ return exitCode; }
            set { /* NO-LOCK */ exitCode = value; }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Watchdog Support
        public ReturnCode WatchdogControl(
            WatchdogType watchdogType,
            WatchdogOperation watchdogOperation,
            IClientData clientData,
            int? timeout,
            ref Result result
            )
        {
            CheckDisposed();

            return InternalWatchdogControl(
                watchdogType, watchdogOperation,
                TimeoutFlags.WatchdogControl,
                clientData, timeout, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private ReturnCode WatchdogHealthControl(
            WatchdogOperation watchdogOperation,
            IClientData clientData,
            int? timeout,
            bool mustBeAlive,
            bool forceStart,
            bool strictStart,
            bool noAbort,
            bool strictStop,
            bool noName,
            bool verbose,
            ref Result result
            )
        {
            ICoreClientData coreClientData = clientData as ICoreClientData;

            switch (watchdogOperation)
            {
                case WatchdogOperation.Check:
                    {
                        result = HasHealthThread(mustBeAlive);
                        return ReturnCode.Ok;
                    }
                case WatchdogOperation.Fetch:
                    {
                        if (coreClientData == null)
                        {
                            result = "invalid core clientData";
                            return ReturnCode.Error;
                        }

                        if (coreClientData.DataNoThrow != null)
                        {
                            result = "core clientData in use";
                            return ReturnCode.Error;
                        }

                        lock (syncRoot) /* TRANSACTIONAL */
                        {
                            coreClientData.DataNoThrow = healthThread;

                            if (verbose)
                                result = "health thread fetched";
                            else
                                result = String.Empty;

                            return ReturnCode.Ok;
                        }
                    }
                case WatchdogOperation.Start:
                    {
                        Result localResult = null;

                        if (StartHealthThread(timeout,
                                forceStart, mustBeAlive, strictStart,
                                ref localResult) != ReturnCode.Ok)
                        {
                            if (localResult != null)
                                result = localResult;
                            else
                                result = "failed to start health thread";

                            return ReturnCode.Error;
                        }
                        else if (verbose)
                        {
                            result = localResult;
                        }
                        else
                        {
                            result = String.Empty;
                        }

                        return ReturnCode.Ok;
                    }
                case WatchdogOperation.Stop:
                    {
                        Result localResult = null;

                        if (InterruptHealthThread(
                                timeout, noAbort, strictStop,
                                ref localResult) != ReturnCode.Ok)
                        {
                            if (localResult != null)
                                result = localResult;
                            else
                                result = "failed to interrupt health thread";

                            return ReturnCode.Error;
                        }
                        else if (verbose)
                        {
                            result = localResult;
                        }
                        else
                        {
                            result = String.Empty;
                        }

                        return ReturnCode.Ok;
                    }
                case WatchdogOperation.Restart:
                    {
                        bool sawError = false;
                        ResultList results = null;
                        Result localResult; /* REUSED */

                        localResult = null;

                        if (InterruptHealthThread(
                                timeout, noAbort, strictStop,
                                ref localResult) != ReturnCode.Ok)
                        {
                            sawError = true;

                            if (results == null)
                                results = new ResultList();

                            if (localResult != null)
                            {
                                results.Add(localResult);
                            }
                            else
                            {
                                results.Add(
                                    "failed to interrupt health thread");
                            }
                        }
                        else if (verbose)
                        {
                            if (results == null)
                                results = new ResultList();

                            if (localResult != null)
                            {
                                results.Add(localResult);
                            }
                            else
                            {
                                results.Add(
                                    "interrupted health thread");
                            }
                        }

                        localResult = null;

                        if (StartHealthThread(timeout,
                                forceStart, mustBeAlive, strictStart,
                                ref localResult) != ReturnCode.Ok)
                        {
                            sawError = true;

                            if (results == null)
                                results = new ResultList();

                            if (localResult != null)
                            {
                                results.Add(localResult);
                            }
                            else
                            {
                                results.Add(
                                    "failed to start health thread");
                            }
                        }
                        else if (verbose)
                        {
                            if (results == null)
                                results = new ResultList();

                            if (localResult != null)
                            {
                                results.Add(localResult);
                            }
                            else
                            {
                                results.Add(
                                    "started health thread");
                            }
                        }

                        result = (results != null) ?
                            results : (Result)String.Empty;

                        return sawError ?
                            ReturnCode.Error : ReturnCode.Ok;
                    }
                case WatchdogOperation.Attach:
                    {
                        if (coreClientData == null)
                        {
                            result = "invalid core clientData";
                            return ReturnCode.Error;
                        }

                        Thread localThread = coreClientData.DataNoThrow as Thread;

                        if (localThread == null)
                        {
                            result = "core clientData is not a thread";
                            return ReturnCode.Error;
                        }

                        if (!noName && !StringOps.Match(
                                this, MatchMode.Glob, localThread.Name,
                                "healthThread: *", false))
                        {
                            result = "thread is not for health";
                            return ReturnCode.Error;
                        }

                        lock (syncRoot) /* TRANSACTIONAL */
                        {
                            if (healthThread == null)
                            {
                                healthThread = localThread;
                                coreClientData.DataNoThrow = null;

                                if (verbose)
                                    result = "health thread attached";
                                else
                                    result = String.Empty;

                                return ReturnCode.Ok;
                            }
                            else
                            {
                                result = "health thread already attached";
                                return ReturnCode.Error;
                            }
                        }
                    }
                case WatchdogOperation.Detach:
                    {
                        if (coreClientData == null)
                        {
                            result = "invalid core clientData";
                            return ReturnCode.Error;
                        }

                        if (coreClientData.DataNoThrow != null)
                        {
                            result = "core clientData in use";
                            return ReturnCode.Error;
                        }

                        lock (syncRoot) /* TRANSACTIONAL */
                        {
                            if (healthThread != null)
                            {
                                coreClientData.DataNoThrow = healthThread;
                                healthThread = null;

                                if (verbose)
                                    result = "health thread detached";
                                else
                                    result = String.Empty;

                                return ReturnCode.Ok;
                            }
                            else
                            {
                                result = "health thread already detached";
                                return ReturnCode.Error;
                            }
                        }
                    }
                default:
                    {
                        result = String.Format(
                            "unsupported watchdog operation: {0}",
                            watchdogOperation);

                        return ReturnCode.Error;
                    }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode WatchdogTimeoutControl(
            WatchdogOperation watchdogOperation,
            IClientData clientData,
            int? timeout,
            TimeoutFlags timeoutFlags,
            bool mustBeAlive,
            bool forceStart,
            bool strictStart,
            bool noAbort,
            bool strictStop,
            bool noName,
            bool verbose,
            ref Result result
            )
        {
            ICoreClientData coreClientData = clientData as ICoreClientData;

            switch (watchdogOperation)
            {
                case WatchdogOperation.Check:
                    {
                        result = HasTimeoutThread(mustBeAlive);
                        return ReturnCode.Ok;
                    }
                case WatchdogOperation.Fetch:
                    {
                        if (coreClientData == null)
                        {
                            result = "invalid core clientData";
                            return ReturnCode.Error;
                        }

                        if (coreClientData.DataNoThrow != null)
                        {
                            result = "core clientData in use";
                            return ReturnCode.Error;
                        }

                        lock (syncRoot) /* TRANSACTIONAL */
                        {
                            coreClientData.DataNoThrow = timeoutThread;

                            if (verbose)
                                result = "timeout thread fetched";
                            else
                                result = String.Empty;

                            return ReturnCode.Ok;
                        }
                    }
                case WatchdogOperation.Start:
                    {
                        Result localResult = null;

                        if (StartTimeoutThread(
                                timeout, timeoutFlags, forceStart,
                                mustBeAlive, strictStart,
                                ref localResult) != ReturnCode.Ok)
                        {
                            if (localResult != null)
                                result = localResult;
                            else
                                result = "failed to start timeout thread";

                            return ReturnCode.Error;
                        }
                        else if (verbose)
                        {
                            result = localResult;
                        }
                        else
                        {
                            result = String.Empty;
                        }

                        return ReturnCode.Ok;
                    }
                case WatchdogOperation.Stop:
                    {
                        Result localResult = null;

                        if (InterruptTimeoutThread(
                                timeout, noAbort, strictStop,
                                ref localResult) != ReturnCode.Ok)
                        {
                            if (localResult != null)
                                result = localResult;
                            else
                                result = "failed to interrupt timeout thread";

                            return ReturnCode.Error;
                        }
                        else if (verbose)
                        {
                            result = localResult;
                        }
                        else
                        {
                            result = String.Empty;
                        }

                        return ReturnCode.Ok;
                    }
                case WatchdogOperation.Restart:
                    {
                        bool sawError = false;
                        ResultList results = null;
                        Result localResult; /* REUSED */

                        localResult = null;

                        if (InterruptTimeoutThread(
                                timeout, noAbort, strictStop,
                                ref localResult) != ReturnCode.Ok)
                        {
                            sawError = true;

                            if (results == null)
                                results = new ResultList();

                            if (localResult != null)
                            {
                                results.Add(localResult);
                            }
                            else
                            {
                                results.Add(
                                    "failed to interrupt timeout thread");
                            }
                        }
                        else if (verbose)
                        {
                            if (results == null)
                                results = new ResultList();

                            if (localResult != null)
                            {
                                results.Add(localResult);
                            }
                            else
                            {
                                results.Add(
                                    "interrupted timeout thread");
                            }
                        }

                        localResult = null;

                        if (StartTimeoutThread(
                                timeout, timeoutFlags, forceStart,
                                mustBeAlive, strictStart,
                                ref localResult) != ReturnCode.Ok)
                        {
                            sawError = true;

                            if (results == null)
                                results = new ResultList();

                            if (localResult != null)
                            {
                                results.Add(localResult);
                            }
                            else
                            {
                                results.Add(
                                    "failed to start timeout thread");
                            }
                        }
                        else if (verbose)
                        {
                            if (results == null)
                                results = new ResultList();

                            if (localResult != null)
                            {
                                results.Add(localResult);
                            }
                            else
                            {
                                results.Add(
                                    "started timeout thread");
                            }
                        }

                        result = (results != null) ?
                            results : (Result)String.Empty;

                        return sawError ?
                            ReturnCode.Error : ReturnCode.Ok;
                    }
                case WatchdogOperation.Attach:
                    {
                        if (coreClientData == null)
                        {
                            result = "invalid core clientData";
                            return ReturnCode.Error;
                        }

                        Thread localThread = coreClientData.DataNoThrow as Thread;

                        if (localThread == null)
                        {
                            result = "core clientData is not a thread";
                            return ReturnCode.Error;
                        }

                        if (!noName && !StringOps.Match(
                                this, MatchMode.Glob, localThread.Name,
                                "timeoutThread: *", false))
                        {
                            result = "thread is not for timeout";
                            return ReturnCode.Error;
                        }

                        lock (syncRoot) /* TRANSACTIONAL */
                        {
                            if (timeoutThread == null)
                            {
                                timeoutThread = localThread;
                                coreClientData.DataNoThrow = null;

                                if (verbose)
                                    result = "timeout thread attached";
                                else
                                    result = String.Empty;

                                return ReturnCode.Ok;
                            }
                            else
                            {
                                result = "timeout thread already attached";
                                return ReturnCode.Error;
                            }
                        }
                    }
                case WatchdogOperation.Detach:
                    {
                        if (coreClientData == null)
                        {
                            result = "invalid core clientData";
                            return ReturnCode.Error;
                        }

                        if (coreClientData.DataNoThrow != null)
                        {
                            result = "core clientData in use";
                            return ReturnCode.Error;
                        }

                        lock (syncRoot) /* TRANSACTIONAL */
                        {
                            if (timeoutThread != null)
                            {
                                coreClientData.DataNoThrow = timeoutThread;
                                timeoutThread = null;

                                if (verbose)
                                    result = "timeout thread detached";
                                else
                                    result = String.Empty;

                                return ReturnCode.Ok;
                            }
                            else
                            {
                                result = "timeout thread already detached";
                                return ReturnCode.Error;
                            }
                        }
                    }
                default:
                    {
                        result = String.Format(
                            "unsupported watchdog operation: {0}",
                            watchdogOperation);

                        return ReturnCode.Error;
                    }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode InternalWatchdogControl(
            WatchdogType watchdogType,
            WatchdogOperation watchdogOperation,
            TimeoutFlags timeoutFlags,
            IClientData clientData,
            int? timeout,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool interactiveStart = FlagOps.HasFlags(
                    watchdogOperation, WatchdogOperation.InteractiveStart, true);

                bool forceStart = FlagOps.HasFlags(
                    watchdogOperation, WatchdogOperation.ForceStart, true);

                bool mustBeAlive = FlagOps.HasFlags(
                    watchdogOperation, WatchdogOperation.MustBeAlive, true);

                bool strictStart = FlagOps.HasFlags(
                    watchdogOperation, WatchdogOperation.StrictStart, true);

                bool strictStop = FlagOps.HasFlags(
                    watchdogOperation, WatchdogOperation.StrictStop, true);

                bool noAbort = FlagOps.HasFlags(
                    watchdogOperation, WatchdogOperation.NoAbort, true);

                bool noName = FlagOps.HasFlags(
                    watchdogOperation, WatchdogOperation.NoName, true);

                bool verbose = FlagOps.HasFlags(
                    watchdogOperation, WatchdogOperation.Verbose, true);

                bool interrupt = FlagOps.HasFlags(
                    watchdogOperation, WatchdogOperation.Interrupt, true);

                TimeoutFlags localTimeoutFlags = timeoutFlags;

                if (interactiveStart)
                    localTimeoutFlags |= TimeoutFlags.Interactive;

                if (interrupt)
                    localTimeoutFlags |= TimeoutFlags.Interrupt;

                watchdogType &= WatchdogType.TypeMask;
                watchdogOperation &= ~WatchdogOperation.FlagsMask;

                switch (watchdogType)
                {
                    case WatchdogType.Timeout:
                        {
                            return WatchdogTimeoutControl(
                                watchdogOperation, clientData,
                                timeout, localTimeoutFlags,
                                mustBeAlive, forceStart,
                                strictStart, noAbort, strictStop,
                                noName, verbose, ref result);
                        }
                    case WatchdogType.Health:
                        {
                            return WatchdogHealthControl(
                                watchdogOperation, clientData,
                                timeout, mustBeAlive, forceStart,
                                strictStart, noAbort, strictStop,
                                noName, verbose, ref result);
                        }
                    default:
                        {
                            result = String.Format(
                                "unsupported watchdog type: {0}",
                                watchdogType);

                            return ReturnCode.Error;
                        }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateWatchdogControlNoThrow(
            WatchdogType watchdogType,
            WatchdogOperation watchdogOperation,
            TimeoutFlags timeoutFlags,
            IClientData clientData,
            int? timeout,
            ref Result result
            )
        {
            try
            {
                return InternalWatchdogControl(
                    watchdogType, watchdogOperation,
                    timeoutFlags, clientData, timeout,
                    ref result);
            }
            catch (Exception e)
            {
                result = e;
                return ReturnCode.Error;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Event Queue Management
        public int SleepTime
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return PrivateSleepTime;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    PrivateSleepTime = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public IEventManager EventManager
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return eventManager;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public EventFlags ServiceEventFlags
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return serviceEventFlags;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode QueueScript(
            DateTime dateTime,
            string text,
            ref Result error
            )
        {
            CheckDisposed();

            IEvent @event = null;

            return QueueScript(
                dateTime, text, EventFlags.FireAndForget, ref @event,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode QueueScript(
            DateTime dateTime,
            string text,
            ref IEvent @event,
            ref Result error
            )
        {
            CheckDisposed();

            return QueueScript(
                dateTime, text, EventFlags.None, ref @event, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Pending Wait Count
        public static bool IsPendingWait(
            Interpreter interpreter
            )
        {
            return (interpreter != null) ? interpreter.IsPendingWait() : false;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private int PrivateSleepTime
        {
            get { /* NO-LOCK */ return sleepTime; }
            set { /* NO-LOCK */ sleepTime = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal SleepWaitCallback SleepWaitCallback
        {
            get { /* NO-LOCK */ return sleepWaitCallback; }
            set { /* NO-LOCK */ sleepWaitCallback = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EventCount
        {
            get { /* NO-LOCK */ return eventCount; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NATIVE && TCL
        internal int TclEventCount
        {
            get { /* NO-LOCK */ return tclEventCount; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int TclSleepCount
        {
            get { /* NO-LOCK */ return tclSleepCount; }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int WaitCount
        {
            get { /* NO-LOCK */ return waitCount; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int WaitSpinCount
        {
            get { /* NO-LOCK */ return waitSpinCount; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IScript CreateAfterScript(
            string name,
            string group,
            string description,
            string type,
            string text,
            DateTime timeStamp,
            EngineMode engineMode,
            ScriptFlags scriptFlags,
            IClientData clientData,
            bool idle
            )
        {
            //
            // NOTE: *SECURITY* Do not use the EngineFlags, EngineFlagsNoLock,
            //       or ContextEngineFlags properties here because that could
            //       cause the queued script to be evaluated with elevated
            //       permissions.
            //
            return Script.Create(
                name, group, description, type, text,
                timeStamp, engineMode, scriptFlags,
                engineFlags | EngineFlags.EvaluateGlobal,
                substitutionFlags, afterEventFlags |
                    (idle ? EventFlags.Idle : EventFlags.None) |
                    EventFlags.Interpreter, expressionFlags,
                clientData);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal EventFlags CombineEngineEventFlags(
            EventFlags eventFlags
            )
        {
            return FlagOps.HasFlags(eventFlags, EventFlags.Interpreter, true) ?
                engineEventFlags | (eventFlags & ~EventFlags.DequeueMask) :
                eventFlags;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IEventManager Wait Support Members
        private IEventManager TryGetEventManager()
        {
            Result error = null;

            return TryGetEventManager(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IEventManager TryGetEventManager(
            ref Result error
            )
        {
            int limit = 0;

            return TryGetEventManager(ref limit, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IEventManager TryGetEventManager(
            ref int limit,
            ref Result error
            )
        {
            return TryGetEventManager(
                DefaultEventManagerTimeout, true, ref limit, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // TODO: When calling this method, be extremely careful when
        //       passing "false" as the "waitForLock" parameter; it
        //       should not be used when the caller cannot handle a
        //       null return value gracefully (e.g. from the method
        //       ShouldWaitVariable).  In this context, "gracefully"
        //       means that the caller would end up providing mostly
        //       the same functionality to its caller regardless of
        //       the return value of this method.
        //
        private IEventManager TryGetEventManager(
            int timeout,
            bool waitForLock
            )
        {
            int limit = 0;
            Result error = null;

            return TryGetEventManager(
                timeout, waitForLock, ref limit, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // TODO: When calling this method, be extremely careful when
        //       passing "false" as the "waitForLock" parameter; it
        //       should not be used when the caller cannot handle a
        //       null return value gracefully (e.g. from the method
        //       ShouldWaitVariable).  In this context, "gracefully"
        //       means that the caller would end up providing mostly
        //       the same functionality to its caller regardless of
        //       the return value of this method.
        //
        private IEventManager TryGetEventManager(
            int timeout,
            bool waitForLock,
            ref int limit,
            ref Result error
            )
        {
            bool locked = false;

            try
            {
                if (waitForLock)
                {
                    if (timeout != 0)
                    {
                        InternalTryLock(timeout, ref locked);
                    }
                    else
                    {
                        InternalHardTryLock(ref locked);
                    }
                }
                else
                {
                    InternalSoftTryLock(ref locked);
                }

                if (locked)
                {
                    limit = eventLimit;
                    return eventManager;
                }
                else
                {
                    error = "unable to acquire lock";

                    TraceOps.DebugTrace(String.Format(
                        "TryGetEventManager: {0}", error),
                        typeof(Interpreter).Name,
                        TracePriority.LockError2);

                    return null;
                }
            }
            finally
            {
                InternalExitLock(ref locked);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void ClearEvents()
        {
            ReturnCode code;
            Result error = null;

            code = ClearEvents(ref error);

            if (code != ReturnCode.Ok)
                DebugOps.Complain(this, code, error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode ClearEvents(
            ref Result error
            )
        {
            // CheckDisposed();

            //
            // BUGFIX: Prevent deadlock caused by holding the interpreter
            //         lock while calling the ClearEvents method, which
            //         acquires and holds the event manager lock.  The
            //         other thread holds the event manager lock via the
            //         DequeueAnyReadyEvent method and then ends up trying
            //         to acquire the interpreter lock while attempting to
            //         get the value of the NotifyFlags property via the
            //         CheckNotification method.
            //
            IEventManager eventManager;
            Result localError = null; /* REUSED */

            eventManager = TryGetEventManager(ref localError);

            if (EventOps.ManagerIsOk(eventManager))
            {
                ReturnCode code;

                localError = null;

                code = eventManager.ClearEvents(ref localError);

                if (code != ReturnCode.Error)
                    error = localError;

                return code;
            }
            else if (localError != null)
            {
                error = localError;
            }
            else
            {
                error = "event manager not available";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode QueueEvent( /* ScriptThread USE ONLY */
            DateTime dateTime,
            EventCallback callback,
            IClientData clientData,
            EventFlags eventFlags,
            ref Result error
            )
        {
            // CheckDisposed();

            //
            // BUGFIX: Prevent deadlock caused by holding the interpreter
            //         lock while calling the QueueScript method, which
            //         acquires and holds the event manager lock.  The
            //         other thread holds the event manager lock via the
            //         DequeueAnyReadyEvent method and then ends up trying
            //         to acquire the interpreter lock while attempting to
            //         get the value of the NotifyFlags property via the
            //         CheckNotification method.
            //
            IEventManager eventManager;
            int limit = 0;
            Result localError = null; /* REUSED */

            eventManager = TryGetEventManager(ref limit, ref localError);

            if (EventOps.ManagerIsOk(eventManager))
            {
                ReturnCode code;

                localError = null;

                code = eventManager.QueueEvent(
                    null, dateTime, callback, clientData, eventFlags,
                    EventPriority.QueueEvent, null, limit, ref localError);

                if (code != ReturnCode.Ok)
                    error = localError;

                return code;
            }
            else if (localError != null)
            {
                error = localError;
            }
            else
            {
                error = "event manager not available";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode QueueScript( /* ScriptThread USE ONLY */
            DateTime dateTime,
            string text,
            EventFlags eventFlags,
            ref Result error
            )
        {
            // CheckDisposed();

            //
            // BUGFIX: Prevent deadlock caused by holding the interpreter
            //         lock while calling the QueueScript method, which
            //         acquires and holds the event manager lock.  The
            //         other thread holds the event manager lock via the
            //         DequeueAnyReadyEvent method and then ends up trying
            //         to acquire the interpreter lock while attempting to
            //         get the value of the NotifyFlags property via the
            //         CheckNotification method.
            //
            IEventManager eventManager;
            int limit = 0;
            Result localError = null; /* REUSED */

            eventManager = TryGetEventManager(ref limit, ref localError);

            if (EventOps.ManagerIsOk(eventManager))
            {
                ReturnCode code;

                localError = null;

                code = eventManager.QueueScript(
                    dateTime, text, engineFlags, substitutionFlags,
                    eventFlags, expressionFlags, EventPriority.QueueScript,
                    null, limit, ref localError);

                if (code != ReturnCode.Ok)
                    error = localError;

                return code;
            }
            else if (localError != null)
            {
                error = localError;
            }
            else
            {
                error = "event manager not available";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode QueueScript( /* IInterpreter Event Queue use ONLY. */
            DateTime dateTime,
            string text,
            EventFlags eventFlags,
            ref IEvent @event,
            ref Result error
            )
        {
            // CheckDisposed();

            //
            // BUGFIX: Prevent deadlock caused by holding the interpreter
            //         lock while calling the QueueScript method, which
            //         acquires and holds the event manager lock.  The
            //         other thread holds the event manager lock via the
            //         DequeueAnyReadyEvent method and then ends up trying
            //         to acquire the interpreter lock while attempting to
            //         get the value of the NotifyFlags property via the
            //         CheckNotification method.
            //
            IEventManager eventManager;
            int limit = 0;
            Result localError = null; /* REUSED */

            eventManager = TryGetEventManager(ref limit, ref localError);

            if (EventOps.ManagerIsOk(eventManager))
            {
                ReturnCode code;

                localError = null;

                code = eventManager.QueueScript(
                    dateTime, text, engineFlags, substitutionFlags,
                    queueEventFlags | eventFlags, expressionFlags,
                    EventPriority.QueueScript, null, limit,
                    ref @event, ref localError);

                if (code != ReturnCode.Ok)
                    error = localError;

                return code;
            }
            else if (localError != null)
            {
                error = localError;
            }
            else
            {
                error = "event manager not available";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int GetSleepTime(
            SleepType sleepType
            )
        {
            //
            // BUGFIX: Prevent possible future deadlock caused by holding the
            //         interpreter lock while calling the GetSleepTime method,
            //         which may at some point acquire and hold the event
            //         manager lock.
            //
            IEventManager eventManager = TryGetEventManager(
                DefaultEventManagerTimeout, false);

            try
            {
                if (EventOps.ManagerIsOk(eventManager))
                    return eventManager.GetSleepTime(sleepType);
            }
            catch (InterpreterDisposedException)
            {
                // do nothing.
            }

            return _Public.EventManager.DefaultSleepTime;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int GetMinimumSleepTime(
            SleepType sleepType
            )
        {
            return GetMinimumSleepTime(
                sleepType, DefaultEventManagerTimeout);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int GetMinimumSleepTime(
            SleepType sleepType,
            int timeout
            )
        {
            //
            // BUGFIX: Prevent possible future deadlock caused by holding the
            //         interpreter lock while calling the GetMinimumSleepTime
            //         method, which may at some point acquire and hold the
            //         event manager lock.
            //
            IEventManager eventManager = TryGetEventManager(timeout, false);

            //
            // BUGFIX: Since this method is called from Dispose, do not attempt
            //         to access the event manager if it too has already been
            //         disposed.
            //
            try
            {
                if (EventOps.ManagerIsOk(eventManager))
                    return eventManager.GetMinimumSleepTime(sleepType);
            }
            catch (InterpreterDisposedException)
            {
                // do nothing.
            }

            return _Public.EventManager.MinimumSleepTime;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Pending Wait Count
        private bool IsPendingWait()
        {
            return (waitCount > 0);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterWait()
        {
            return Interlocked.Increment(ref waitCount);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitWait()
        {
            return Interlocked.Decrement(ref waitCount);
        }
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Entity Management
        public IEntityManager EntityManager
        {
            get
            {
                CheckDisposed();

                return this;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interpreter Management
        public IInterpreterManager InterpreterManager
        {
            get
            {
                CheckDisposed();

                return this;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Data Type Conversion
        public string DateTimeFormat
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return dateTimeFormat;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    dateTimeFormat = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public DateTimeKind DateTimeKind
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return dateTimeKind;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    dateTimeKind = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public DateTimeStyles DateTimeStyles
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return dateTimeStyles;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    dateTimeStyles = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public IEnumerable<string> TimeServers
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return timeServers;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    timeServers = value;
                }
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Expression Precision
        public int Precision /* throw */
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return precision;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    precision = value;
                }

                VariableFlags flags = VariableFlags.ViaProperty;

                //
                // NOTE: Do not create the variable if we have been prohibited
                //       from doing so.
                //
                if (InternalIsSafe() || PrivateIsNoVariables())
                    flags |= VariableFlags.NoCreate;

                //
                // NOTE: Update script-level informational variable.  This
                //       variable is NOT allowed in "safe" interpreters.
                //
                SetLibraryVariableValue(
                    flags, TclVars.Core.PrecisionName, value.ToString(),
                    precisionTraceList);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal static decimal FixIntermediatePrecision(
            decimal value
            )
        {
            return value; /* NOP */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static double FixIntermediatePrecision(
            double value
            )
        {
            return value; /* NOP */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal decimal FixFinalPrecision(
            decimal value
            ) /* throw */
        {
            int localPrecision = Interlocked.CompareExchange(
                ref precision, 0, 0);

            if (localPrecision > 0)
                return Math.Round(value, localPrecision);
            else if (localPrecision < 0)
                return Math.Round(value, 0);
            else
                return value;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal double FixFinalPrecision(
            double value
            ) /* throw */
        {
            int localPrecision = Interlocked.CompareExchange(
                ref precision, 0, 0);

            if (localPrecision > 0)
                return Math.Round(value, localPrecision);
            else if (localPrecision < 0)
                return Math.Round(value, 0);
            else
                return value;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Execution Limits
        //
        // NOTE: If this value is false, no evaluation [or substitution] requests
        //       can take place using this interpreter.
        //
        public bool Enabled
        {
            get
            {
                CheckDisposed();

                //
                // NOTE: Check both the global flags and the per-thread flags.
                //
                EngineFlags localEngineFlags = EngineFlags;

                return !EngineFlagOps.HasNoEvaluate(localEngineFlags) &&
                    !EngineFlagOps.HasNoSubstitute(localEngineFlags);
            }
            set
            {
                CheckDisposed();

                //
                // NOTE: Set the global flags only.
                //
                if (value)
                    engineFlags &= ~EngineFlags.EnabledMask;
                else
                    engineFlags |= EngineFlags.EnabledMask;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: If this value is true, no objects (commands, functions, procedures,
        //       etc) may be added, renamed, or removed and no variables may be added,
        //       set, or unset.
        //
        public bool ReadOnly
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return PrivateReadOnly;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    PrivateReadOnly = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: If this value is true, no objects (commands, functions, procedures, etc)
        //       may be renamed or removed and no variables may be changed or unset.
        //
        public bool Immutable
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return PrivateImmutable;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    PrivateImmutable = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int ReadyLimit
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return PrivateReadyLimit;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    PrivateReadyLimit = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int RecursionLimit
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return PrivateRecursionLimit;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    PrivateRecursionLimit = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int Timeout
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return InternalTimeout;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    InternalTimeout = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int FinallyTimeout
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return PrivateFinallyTimeout;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    PrivateFinallyTimeout = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int NetworkTimeout
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return InternalNetworkTimeout;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    InternalNetworkTimeout = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int ThreadStackSize
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return threadStackSize;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    threadStackSize = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int ExtraStackSpace
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return extraStackSpace;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    extraStackSpace = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if CALLBACK_QUEUE
        public int CallbackLimit
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return InternalCallbackLimit;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    InternalCallbackLimit = value;
                }
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int EventLimit
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return InternalEventLimit;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    InternalEventLimit = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int ProcedureLimit
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return InternalProcedureLimit;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    InternalProcedureLimit = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int VariableLimit
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return InternalVariableLimit;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    InternalVariableLimit = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int ArrayElementLimit
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return InternalArrayElementLimit;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    InternalArrayElementLimit = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if RESULT_LIMITS
        public int ExecuteResultLimit
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return InternalExecuteResultLimit;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    InternalExecuteResultLimit = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int NestedResultLimit
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return InternalNestedResultLimit;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    InternalNestedResultLimit = value;
                }
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private bool PrivateReadOnly
        {
            get { /* NO-LOCK */ return readOnly; }
            set { /* NO-LOCK */ readOnly = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateImmutable
        {
            get { /* NO-LOCK */ return immutable; }
            set { /* NO-LOCK */ immutable = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsModifiable(
            bool ignoreImmutable
            )
        {
            Result error = null;

            return IsModifiable(ignoreImmutable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsModifiable(
            bool ignoreImmutable,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                {
                    error = "interpreter is disposed";
                    return false;
                }

                if (readOnly)
                {
                    error = "interpreter is read-only";
                    return false;
                }

                if (!ignoreImmutable && immutable)
                {
                    error = "interpreter is immutable";
                    return false;
                }

                return true;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool BeginMutableExecution()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool savedImmutable = immutable;

                immutable = false;

                return savedImmutable;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void EndMutableExecution(
            bool savedImmutable
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                immutable = savedImmutable;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int BumpReadyCount()
        {
            int localReadyCount = Interlocked.Increment(ref readyCount);

            if (localReadyCount > 0)
                localReadyCount--;

            return localReadyCount;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int PrivateReadyLimit
        {
            get { /* NO-LOCK */ return readyLimit; }
            set { /* NO-LOCK */ readyLimit = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int PrivateRecursionLimit
        {
            get { /* NO-LOCK */ return recursionLimit; }
            set { /* NO-LOCK */ recursionLimit = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int InternalTimeout
        {
            get { /* NO-LOCK */ return timeout; }
            set { /* NO-LOCK */ timeout = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int PrivateFinallyTimeout
        {
            get { /* NO-LOCK */ return finallyTimeout; }
            set { /* NO-LOCK */ finallyTimeout = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int InternalNetworkTimeout
        {
            get { /* NO-LOCK */ return networkTimeout; }
            set { /* NO-LOCK */ networkTimeout = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int InternalThreadStackSize
        {
            get { /* NO-LOCK */ return threadStackSize; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ulong InternalExtraStackSpace
        {
            get
            {
                /* NO-LOCK */
                return (extraStackSpace > 0) ?
                    (ulong)extraStackSpace : 0;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if CALLBACK_QUEUE
        internal int InternalCallbackLimit
        {
            get { /* NO-LOCK */ return callbackLimit; }
            set { /* NO-LOCK */ callbackLimit = value; }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int InternalEventLimit
        {
            get { /* NO-LOCK */ return eventLimit; }
            set { /* NO-LOCK */ eventLimit = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int InternalProcedureLimit
        {
            get { /* NO-LOCK */ return procedureLimit; }
            set { /* NO-LOCK */ procedureLimit = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int InternalVariableLimit
        {
            get { /* NO-LOCK */ return variableLimit; }
            set { /* NO-LOCK */ variableLimit = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int InternalArrayElementLimit
        {
            get { /* NO-LOCK */ return arrayElementLimit; }
            set { /* NO-LOCK */ arrayElementLimit = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if RESULT_LIMITS
        internal static void GetDefaultResultLimits(
            Interpreter interpreter,
            out int executeResultLimit,
            out int nestedResultLimit
            )
        {
            if ((interpreter != null) && interpreter.InternalIsSafe())
            {
                executeResultLimit = DefaultSafeExecuteResultLimit;
                nestedResultLimit = DefaultSafeNestedResultLimit;
            }
            else
            {
                executeResultLimit = DefaultUnsafeExecuteResultLimit;
                nestedResultLimit = DefaultUnsafeNestedResultLimit;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int InternalExecuteResultLimit
        {
            get { /* NO-LOCK */ return executeResultLimit; }
            set { /* NO-LOCK */ executeResultLimit = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int InternalNestedResultLimit
        {
            get { /* NO-LOCK */ return nestedResultLimit; }
            set { /* NO-LOCK */ nestedResultLimit = value; }
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Notifications
#if NOTIFY || NOTIFY_OBJECT
        public ReturnCode FireNotification(
            IScriptEventArgs eventArgs,
            IClientData clientData,
            ArgumentList arguments,
            ref Result result
            )
        {
            CheckDisposed();

            return FireNotification(this, eventArgs, clientData, arguments, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private bool CanFireNotifications()
        {
            return (NotifyLevels == 0) &&
                !FlagOps.HasFlags(PrivateNotifyFlags, NotifyFlags.NoNotify, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool CheckNotifyTypesAndFlags(
            NotifyType type,         /* in */
            NotifyFlags flags        /* in */
            )
        {
            //
            // NOTE: Using the properties instead of the fields here takes
            //       into account the per-thread types and flags as well
            //       because the properties return a bitwise OR of the
            //       global types and flags with the per-thread values.
            //
            if (FlagOps.HasFlags(PrivateNotifyTypes, type & NotifyType.CheckMask, true) &&
                FlagOps.HasFlags(PrivateNotifyFlags, flags & NotifyFlags.CheckMask, true))
            {
                return true;
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReturnCode FireNotification(
            Interpreter interpreter,
            IScriptEventArgs eventArgs,
            IClientData clientData,
            ArgumentList arguments,
            ref Result result
            )
        {
            if (interpreter == null)
            {
                result = "invalid interpreter";
                return ReturnCode.Error;
            }

            if (!interpreter.CanFireNotifications())
            {
                //
                // NOTE: Either event notifications are disabled -OR-
                //       we are already processing one on this thread.
                //       Just return success.
                //
                return ReturnCode.Ok;
            }

            PluginWrapperDictionary plugins = interpreter.GetNotifyPlugins();

            if (plugins == null)
            {
                result = "plugins not available";
                return ReturnCode.Error;
            }

#if ISOLATED_PLUGINS
            //
            // NOTE: Check if we are forbidden from notifying any
            //       plugins that happen to be loaded into isolated
            //       application domains.
            //
            bool noIsolated = interpreter.IsNoIsolatedNotify();
#endif

            //
            // NOTE: Query the event arguments to figure out which
            //       notification types are currently being sent.
            //
            NotifyType hasTypes = (eventArgs != null) ?
                eventArgs.NotifyTypes : NotifyType.None;

            //
            // NOTE: Query the event arguments to figure out which
            //       notification sub-types are currently being sent.
            //
            NotifyFlags hasFlags = (eventArgs != null) ?
                eventArgs.NotifyFlags : NotifyFlags.None;

            //
            // NOTE: Prevent endless event notification recursion.
            //
            interpreter.NotifyFlags |= NotifyFlags.NoNotify;

            try
            {
                //
                // NOTE: Process each notification (as long as they
                //       all continue to succeed).
                //
                ReturnCode code = ReturnCode.Ok;

                foreach (KeyValuePair<string, _Wrappers.Plugin> pair
                        in plugins)
                {
                    _Wrappers.Plugin pluginWrapper = pair.Value;

                    if (pluginWrapper == null)
                        continue;

#if ISOLATED_PLUGINS
                    //
                    // HACK: *PERF* Possibly forbid any isolated plugins
                    //       from getting this notification.
                    //
                    if (noIsolated && AppDomainOps.IsTransparentProxy(
                            pluginWrapper))
                    {
                        continue;
                    }
#endif

                    try
                    {
                        //
                        // NOTE: Query the plugin to find out which
                        //       notification types it has elected to
                        //       receive.
                        //
                        NotifyType types = pluginWrapper.GetTypes(
                            interpreter);

                        //
                        // NOTE: Does this plugin want to receive the
                        //       notifications being sent?
                        //
                        if (!FlagOps.HasFlags(
                                types, hasTypes & NotifyType.CheckMask,
                                true))
                        {
                            continue;
                        }

                        //
                        // NOTE: Query the plugin to find out which
                        //       notification sub-types it has elected
                        //       to receive.
                        //
                        NotifyFlags flags = pluginWrapper.GetFlags(
                            interpreter);

                        //
                        // NOTE: Does this plugin want to receive the
                        //       notifications being sent?
                        //
                        if (!FlagOps.HasFlags(
                                flags, hasFlags & NotifyFlags.CheckMask,
                                true))
                        {
                            continue;
                        }

                        //
                        // NOTE: Since events can basically do anything
                        //       they want, we wrap them in a try block
                        //       to prevent exceptions from escaping.
                        //
                        interpreter.EnterNotifyLevel();

                        try
                        {
                            //
                            // NOTE: Call their notification method.  It
                            //       could do practially anything; however,
                            //       in practice it should not be modifying
                            //       the state of the passed in objects, if
                            //       any.  No guarantee is made about the
                            //       ability of plugins to affect changes
                            //       in the state of the passed in objects
                            //       -OR- to alter the course of action to
                            //       be taken after the notification has
                            //       been processed.
                            //
                            code = pluginWrapper.Notify(
                                interpreter, eventArgs, clientData,
                                arguments, ref result);
                        }
                        finally
                        {
                            interpreter.ExitNotifyLevel();
                        }
                    }
                    catch (Exception e)
                    {
                        //
                        // NOTE: Translate exceptions to a failure return.
                        //
                        result = String.Format(
                            "caught exception while firing notification: {0}",
                            e);

                        code = ReturnCode.Error;
                    }

                    //
                    // NOTE: Check for exception results specially because
                    //       we treat "Break" different from other return
                    //       codes.
                    //
                    if (code == ReturnCode.Break)
                    {
                        //
                        // NOTE: Success; however, skip processing further
                        //       events.
                        //
                        code = ReturnCode.Ok;
                        break;
                    }
                    else if (code != ReturnCode.Ok)
                    {
                        //
                        // NOTE: Some type of failure (or exception), stop
                        //       processing events.
                        //
                        break;
                    }
                }

                return code;
            }
            finally
            {
                //
                // NOTE: Remove event notification prevention flag.
                //
                interpreter.NotifyFlags &= ~NotifyFlags.NoNotify;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode CheckNotification(
            NotifyType type,         /* in */
            NotifyFlags flags,       /* in */
            object data,             /* in */
            Interpreter interpreter, /* in */
            IClientData clientData,  /* in */
            ArgumentList arguments,  /* in */
            Exception exception      /* in */
            )
        {
            Result result = null;

            return CheckNotification(
                type, flags, data, interpreter, clientData, arguments,
                exception, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode CheckNotification(
            NotifyType type,         /* in */
            NotifyFlags flags,       /* in */
            object data,             /* in */
            Interpreter interpreter, /* in */
            IClientData clientData,  /* in */
            ArgumentList arguments,  /* in */
            Exception exception,     /* in */
            ref Result result        /* in, out */
            )
        {
            if (!IsDisposedOrPending(true) &&
                !EngineFlagOps.HasNoNotify(engineFlags) &&
                CanFireNotifications())
            {
                if (CheckNotifyTypesAndFlags(type, flags))
                {
#if MONO_BUILD && (!DEBUG || !VERBOSE)
#pragma warning disable 219
#endif
                    ReturnCode eventCode; // NOTE: Flagged by the Mono C# compiler.
#if MONO_BUILD && (!DEBUG || !VERBOSE)
#pragma warning restore 219
#endif

                    Result eventResult;

                    try
                    {
                        ScriptException scriptException;

                        if (exception is ScriptException)
                            scriptException = (ScriptException)exception;
                        else if (exception != null)
                            scriptException = new ScriptException(null, exception);
                        else
                            scriptException = null;

                        IScriptEventArgs eventArgs = RuntimeOps.GetEventArgs(
                            type, flags, interpreter, new ClientData(data) /* WRAP */,
                            arguments, result, scriptException, InterruptType.None);

                        IClientData eventClientData = clientData; /* REF */

                        ArgumentList eventArguments = (arguments != null) ?
                            new ArgumentList(arguments) : null; /* COPY */

                        eventResult = Result.Copy(
                            result, ResultFlags.CopyObject); /* COPY */

                        eventCode = FireNotification(
                            eventArgs, eventClientData, eventArguments,
                            ref eventResult);
                    }
                    catch (Exception e)
                    {
                        eventResult = String.Format(
                            "caught exception while firing notifications: {0}",
                            e);

                        eventCode = ReturnCode.Error;
                    }

#if DEBUG && VERBOSE
                    if (eventCode != ReturnCode.Ok)
                        DebugOps.Complain(interpreter, eventCode, eventResult);
#endif
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY_GLOBAL
        internal static ReturnCode CheckNotifications(
            string pattern,          /* in */
            bool noCase,             /* in */
            NotifyType type,         /* in */
            NotifyFlags flags,       /* in */
            object data,             /* in */
            Interpreter interpreter, /* in */
            IClientData clientData,  /* in */
            ArgumentList arguments,  /* in */
            Exception exception      /* in */
            )
        {
            Result result = null;

            return CheckNotifications(
                pattern, noCase, type, flags, data, interpreter,
                clientData, arguments, exception, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReturnCode CheckNotifications(
            string pattern,          /* in */
            bool noCase,             /* in */
            NotifyType type,         /* in */
            NotifyFlags flags,       /* in */
            object data,             /* in */
            Interpreter interpreter, /* in */
            IClientData clientData,  /* in */
            ArgumentList arguments,  /* in */
            Exception exception,     /* in */
            ref Result result        /* in, out */
            )
        {
            InterpreterDictionary interpreters = GlobalState.GetInterpreters();

            if (interpreters != null)
            {
                bool broadcast = FlagOps.HasFlags(flags, NotifyFlags.Broadcast, true);
                bool safe = FlagOps.HasFlags(flags, NotifyFlags.Safe, true);

                ReturnCode code = ReturnCode.Ok;

                foreach (KeyValuePair<string, Interpreter> pair in interpreters)
                {
                    //
                    // NOTE: Do the pattern matching first to avoid attempting to
                    //       acquire interpreter locks without a valid reason.
                    //
                    if ((pattern == null) || StringOps.Match(
                            null, StringOps.DefaultMatchMode, pair.Key,
                            pattern, noCase))
                    {
                        Interpreter otherInterpreter = pair.Value;

                        if (otherInterpreter == null)
                            continue;

                        bool locked = false;
                        object syncRoot = otherInterpreter.InternalSyncRoot;

                        if (syncRoot == null)
                            continue;

                        try
                        {
                            locked = Monitor.TryEnter(syncRoot);

                            if (!locked)
                                continue;

                            //
                            // BUGFIX: Always skip the interpreter if it has
                            //         been disposed.
                            //
                            if (otherInterpreter.Disposed)
                                continue;

                            //
                            // BUGFIX: By default, skip this interpreter if it
                            //         belongs to another thread because we do
                            //         not want to create [thread] contexts on
                            //         this thread for it that we have no easy
                            //         way to know when to cleanup.  This limit
                            //         does not apply to broadcast notifications.
                            //
                            if (!broadcast &&
                                !otherInterpreter.IsPrimarySystemThread())
                            {
                                continue;
                            }

                            //
                            // BUGFIX: Do not send any "global" notifications
                            //         to safe interpreters.  Also, do not
                            //         notify an interpreter if we cannot
                            //         obtain the lock for the interpreter OR
                            //         the "global" notification flag is
                            //         disabled for it.  This limit does not
                            //         apply to "safe" notifications.
                            //
                            if (!safe && otherInterpreter.InternalIsSafe())
                                continue;

                            code = otherInterpreter.CheckNotification(
                                type, flags, data, interpreter, clientData,
                                arguments, exception, ref result);

                            if (code != ReturnCode.Ok)
                                break;
                        }
                        finally
                        {
                            if (locked)
                                Monitor.Exit(syncRoot);
                        }
                    }
                }

                return code;
            }
            else
            {
                result = "no interpreters available";
            }

            return ReturnCode.Error;
        }
#endif
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        #region Random Number Generation
        internal Random Random
        {
            get { return random; }
            set { random = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal RandomNumberGenerator RandomNumberGenerator
        {
            get { return randomNumberGenerator; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool AddEntropyToBytes(
            ref ByteList bytes,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool isSafe = InternalIsSafe();
                byte[] entropyBytes = isSafe ? safeEntropy : entropy;

                if (entropyBytes != null)
                {
                    if (bytes == null)
                        bytes = new ByteList();

                    bytes.AddRange(entropyBytes);
                    return true;
                }

                error = String.Format(
                    "{0}entropy not available",
                    isSafe ? "safe " : String.Empty);

                return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void AddContextToBytes(
            ref ByteList bytes
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool isSafe = InternalIsSafe();

                if (bytes == null)
                    bytes = new ByteList();

                if (!isSafe)
                {
                    bytes.Add(BitConverter.GetBytes(
                        ProcessOps.GetParentId()), 0);

                    bytes.Add(BitConverter.GetBytes(
                        ProcessOps.GetId()), 0);
                }

                bytes.Add(BitConverter.GetBytes(
                    AppDomainOps.GetCurrentId()), 0);

                if (isSafe)
                {
                    bytes.Add(BitConverter.GetBytes(
                        GlobalState.GetCurrentManagedThreadId()), 0);
                }
                else
                {
                    bytes.Add(BitConverter.GetBytes(
                        GlobalState.GetCurrentSystemThreadId()), 0);

                    bytes.Add(BitConverter.GetBytes(PrivateId), 0);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // BUGFIX: The "bytes" parameter must be "ref"; otherwise,
        //         cross-domain marshalling does not work right.
        //
        internal void GetRandomBytes(
            ref byte[] bytes
            )
        {
            RandomNumberGenerator randomNumberGenerator;
            Random random;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                randomNumberGenerator = this.randomNumberGenerator;
                random = this.random;
            }

            /* NO RESULT */
            RuntimeOps.GetRandomBytes(randomNumberGenerator, random, ref bytes);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ulong GetRandomNumber()
        {
            RandomNumberGenerator randomNumberGenerator;
            Random random;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                randomNumberGenerator = this.randomNumberGenerator;
                random = this.random;
            }

            return RuntimeOps.GetRandomNumber(randomNumberGenerator, random);
        }
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IMaybeDisposed Members
        public bool Disposed
        {
            get
            {
                // CheckDisposed(); /* EXEMPT */

                return PrivateDisposed;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool Disposing
        {
            get
            {
                // CheckDisposed(); /* EXEMPT */

                return IsPendingDispose();
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IKeyEventManager Members
#if WINFORMS
        public ReturnCode FireKeyEventHandlers(
            EventType eventType,
            object sender,
            EventArgs e,
            ref int count,
            ref Result error
            )
        {
            CheckDisposed();

            ReturnCode code = ReturnCode.Ok;

            KeyOps.ChainEventHandlers(eventType,
                sender, e, null, null, ref count,
                ref code, ref error, GetKeyEventMap(),
                StatusFormOps.GetKeyEventMap());

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode HasKeyEventMapping(
            EventType eventType,
            Keys modifiers,
            Keys keys,
            bool? useOverrides,
            ref Result error
            )
        {
            CheckDisposed();

            KeyOps.KeyEventMap keyEventMap = GetKeyEventMap(useOverrides);

            if (keyEventMap == null)
            {
                error = "key event data unavailable";
                return ReturnCode.Error;
            }

            return keyEventMap.Has(eventType, modifiers, keys, ref error) ?
                ReturnCode.Ok : ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetKeyEventMapping(
            EventType eventType,
            Keys modifiers,
            Keys keys,
            bool? useOverrides,
            ref FormEventCallback callback,
            ref Result error
            )
        {
            CheckDisposed();

            KeyOps.KeyEventMap keyEventMap = GetKeyEventMap(useOverrides);

            if (keyEventMap == null)
            {
                error = "key event data unavailable";
                return ReturnCode.Error;
            }

            return keyEventMap.Get(eventType, modifiers, keys, out callback, ref error) ?
                ReturnCode.Ok : ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddKeyEventMapping(
            EventType eventType,
            Keys modifiers,
            Keys keys,
            FormEventCallback callback,
            bool? useOverrides,
            ref Result error
            )
        {
            CheckDisposed();

            KeyOps.KeyEventMap keyEventMap = GetKeyEventMap(useOverrides);

            if (keyEventMap == null)
            {
                error = "key event data unavailable";
                return ReturnCode.Error;
            }

            return keyEventMap.Add(eventType, modifiers, keys, callback, ref error) ?
                ReturnCode.Ok : ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveKeyEventMapping(
            EventType eventType,
            Keys modifiers,
            Keys keys,
            bool? useOverrides,
            ref Result error
            )
        {
            CheckDisposed();

            KeyOps.KeyEventMap keyEventMap = GetKeyEventMap(useOverrides);

            if (keyEventMap == null)
            {
                error = "key event data unavailable";
                return ReturnCode.Error;
            }

            return keyEventMap.Remove(eventType, modifiers, keys, ref error) ?
                ReturnCode.Ok : ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal KeyOps.KeyEventMap GetKeyEventMap()
        {
            lock (syncRoot)
            {
                return keyEventMap;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal KeyOps.KeyEventMap GetKeyEventMap(
            bool? useOverrides
            )
        {
            KeyOps.KeyEventMap keyEventMap;

            if (useOverrides != null)
            {
                keyEventMap = (bool)useOverrides ?
                    GetKeyEventMap() : StatusFormOps.GetKeyEventMap();
            }
            else
            {
                keyEventMap = GetKeyEventMap();

                if (keyEventMap == null)
                    keyEventMap = StatusFormOps.GetKeyEventMap();
            }

            return keyEventMap;
        }
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region INotifyManager Members
#if NOTIFY || NOTIFY_OBJECT
        public NotifyType GlobalNotifyTypes
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return notifyTypes;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    notifyTypes = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public NotifyFlags GlobalNotifyFlags
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return notifyFlags;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    notifyFlags = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool GlobalNotify
        {
            get
            {
                CheckDisposed();

                return PrivateGlobalNotify;
            }
            set
            {
                CheckDisposed();

                Interlocked.Exchange(ref notify, value ? 1 : 0);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public NotifyType NotifyTypes
        {
            get
            {
                CheckDisposed();

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    return PrivateNotifyTypes;
                }
            }
            set
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.NotifyTypes = value;
#else
                lock (syncRoot)
                {
                    notifyTypes = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public NotifyFlags NotifyFlags
        {
            get
            {
                CheckDisposed();

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    return PrivateNotifyFlags;
                }
            }
            set
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.NotifyFlags = value;
#else
                lock (syncRoot)
                {
                    notifyFlags = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private bool PrivateGlobalNotify
        {
            get
            {
                // lock (syncRoot) /* NO-LOCK */
                {
                    return Interlocked.CompareExchange(ref notify, 0, 0) != 0;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private NotifyType PrivateNotifyTypes
        {
            get
            {
                // lock (syncRoot) /* NO-LOCK */
                {
#if THREADING
                    IEngineContext context = GetEngineContext();

                    if (context != null)
                        return notifyTypes | context.NotifyTypes;
                    else
                        return notifyTypes;
#else
                    return notifyTypes;
#endif
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private NotifyFlags PrivateNotifyFlags
        {
            get
            {
                // lock (syncRoot) /* NO-LOCK */
                {
#if THREADING
                    IEngineContext context = GetEngineContext();

                    if (context != null)
                        return notifyFlags | context.NotifyFlags;
                    else
                        return notifyFlags;
#else
                    return notifyFlags;
#endif
                }
            }
        }
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IPackageManager Members
        public ReturnCode PresentPackage(
            string name,
            Version version,
            bool exact,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPackages(ref result))
                    return ReturnCode.Error;

                IPackage package = null;

                if (GetPackage(
                        name, LookupFlags.NoVerbose,
                        ref package) != ReturnCode.Ok)
                {
                    result = String.Format(
                        "package {0} is not present",
                        FormatOps.PackageName(name, version));

                    return ReturnCode.Error;
                }

                if (package == null) /* IMPOSSIBLE? */
                {
                    result = String.Format(
                        "package {0} is invalid",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                Version loaded = package.Loaded;

                if (loaded == null)
                {
                    result = String.Format(
                        "package {0} is not present",
                        FormatOps.PackageName(name, version));

                    return ReturnCode.Error;
                }

                if (!PackageOps.VersionSatisfies(
                        loaded, version, exact))
                {
                    result = String.Format(
                        "package {0} is not present",
                        FormatOps.PackageName(name, version));

                    return ReturnCode.Error;
                }

                result = loaded;
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ProvidePackage(
            string name,
            Version version,
            ref Result result
            )
        {
            CheckDisposed();

            return PkgProvide(
                name, version, _ClientData.Empty, PackageFlags.None,
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RequirePackage(
            string name,
            Version version,
            bool exact,
            ref Result result
            )
        {
            CheckDisposed();

            return PkgRequire(
                name, version, _ClientData.Empty, PackageFlags.None,
                exact, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode WithdrawPackage(
            string name,
            Version version,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPackages(ref result))
                    return ReturnCode.Error;

                IPackage package = null;

                if (GetPackage(
                        name, LookupFlags.NoVerbose,
                        ref package) != ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't find package {0}",
                        FormatOps.PackageName(name, version));

                    return ReturnCode.Error;
                }

                if (package == null) /* IMPOSSIBLE? */
                {
                    result = String.Format(
                        "package {0} is invalid",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                Version loaded = package.Loaded;

                if (version != null)
                {
                    if (loaded != null)
                    {
                        if (PackageOps.VersionCompare(
                                loaded, version) == 0)
                        {
                            //
                            // NOTE: This version of the package is
                            //       now "withdrawn".
                            //
                            package.Loaded = null;

                            result = String.Empty;
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            //
                            // NOTE: This is an error, a different
                            //       version of this package has
                            //       been provided.
                            //
                            result = String.Format(
                                "conflicting versions withdrawn for package {0}: " +
                                "{1} then {2} ", FormatOps.DisplayName(name),
                                loaded, version);

                            return ReturnCode.Error;
                        }
                    }
                    else
                    {
                        //
                        // NOTE: Do nothing, the package has
                        //       already been unprovided.
                        //
                        result = String.Empty;
                        return ReturnCode.Ok;
                    }
                }
                else
                {
                    //
                    // NOTE: Do nothing, just return the version of the
                    //       package that has been provided.
                    //
                    if (loaded != null)
                        result = loaded;
                    else
                        result = String.Empty;

                    return ReturnCode.Ok;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private PackageContextClientData GetPackageContext()
        {
            return ContextClientData as PackageContextClientData;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HasPackagesViaContext(
            ref Result error
            )
        {
            PackageContextClientData packageContext = GetPackageContext();

            if (packageContext != null)
                return packageContext.HasPackages(ref error);

            return HasPackages(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetPackageViaContext(
            string name,
            LookupFlags lookupFlags,
            ref IPackage package
            )
        {
            PackageContextClientData packageContext = GetPackageContext();

            if (packageContext != null)
            {
                Result error = null; /* IGNORED */

                return packageContext.GetPackage(
                    name, lookupFlags, ref package, ref error);
            }

            return GetPackage(name, lookupFlags, ref package);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddPackageViaContext(
            IPackage package,
            IClientData clientData,
            ref Result result
            )
        {
            PackageContextClientData packageContext = GetPackageContext();

            if (packageContext != null)
            {
                return packageContext.AddPackage(
                    package, clientData, ref result);
            }

            return AddPackage(package, clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if APPDOMAINS || ISOLATED_INTERPRETERS || ISOLATED_PLUGINS
        internal bool HasProbePlugins()
        {
            return FlagOps.HasFlags(createFlags, CreateFlags.ProbePlugins, true);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool HasPendingPackageIndexes()
        {
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.PendingPackageIndexes, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void SetPendingPackageIndexes(
            bool pending
            )
        {
            if (pending)
                interpreterStateFlags |= InterpreterStateFlags.PendingPackageIndexes;
            else
                interpreterStateFlags &= ~InterpreterStateFlags.PendingPackageIndexes;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal PackageIndexDictionary CopyPackageIndexes()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (packageIndexes != null)
                    return new PackageIndexDictionary(packageIndexes);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For AutoPathTraceCallback / [package] use only.
        //
        internal PackageIndexDictionary PackageIndexes
        {
            set { lock (syncRoot) { packageIndexes = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ResetPkgIndexes(
            bool strict,     /* in */
            ref Result error /* out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                Result localError = null;

                if (HasPackageIndexes(ref localError))
                {
                    packageIndexes.Clear();
                }
                else if (strict)
                {
                    error = localError;
                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PkgSourceFileName(
            ref string fileName, /* out */
            ref Result error     /* out */
            )
        {
            string localFileName = null;

            if (ScriptOps.GetLocation(
                    this, true, false, ref localFileName,
                    ref error) != ReturnCode.Ok)
            {
                return ReturnCode.Error;
            }

            fileName = PathOps.GetUnixPath(localFileName);
            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode PkgIndexes(
            string pattern,
            bool noCase,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPackageIndexes(ref result))
                    return ReturnCode.Error;

                result = packageIndexes.ToString(pattern, noCase);
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode PkgNames(
            string pattern,
            bool noCase,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPackages(ref result))
                    return ReturnCode.Error;

                result = packages.ToString(pattern, noCase);
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode PkgLoaded(
            string pattern,
            bool noCase,
            bool verbose,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPackages(ref result))
                    return ReturnCode.Error;

                StringList list = new StringList();

                foreach (KeyValuePair<string, _Wrappers.Package> pair in packages)
                {
                    IPackage package = pair.Value;

                    if (package == null)
                        continue;

                    Version loaded = package.Loaded;

                    if (loaded == null)
                        continue;

                    if (verbose)
                    {
                        VersionStringDictionary ifNeeded = package.IfNeeded;

                        list.Add(StringList.MakeList(
                            "name", pair.Key, "loaded", loaded, "flags",
                            package.Flags, "ifNeeded", (ifNeeded != null) ?
                                ifNeeded.Count : Count.Invalid));
                    }
                    else
                    {
                        list.Add(pair.Key);
                    }
                }

                result = list.ToString(pattern, noCase);
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PkgForget(
            string name,
            IClientData clientData
            )
        {
            Result result = null;

            return PkgForget(name, clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode PkgForget(
            string name,
            IClientData clientData,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPackages(ref result)) /* CONSISTENCY */
                    return ReturnCode.Error;

                if (DoesPackageExist(name) != ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't find package {0}",
                        FormatOps.PackageName(name, null));
                }

                if (RemovePackage(
                        name, clientData, ref result) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode PkgForget(
            StringList names,
            IClientData clientData,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPackages(ref result)) /* CONSISTENCY */
                    return ReturnCode.Error;

                if (names == null)
                {
                    result = "invalid package list";
                    return ReturnCode.Error;
                }

                foreach (string name in names)
                {
                    /* IGNORED */
                    PkgForget(name, clientData);
                }

                result = String.Empty;
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode PkgIfNeeded(
            string name,
            Version version,
            string text,
            IClientData clientData,
            PackageFlags flags,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPackagesViaContext(ref result)) /* CONSISTENCY */
                    return ReturnCode.Error;

                if (version == null)
                {
                    result = "invalid package version";
                    return ReturnCode.Error;
                }

                IPackage package; /* REUSED */
                string indexFileName; /* REUSED */

                if (text != null)
                {
                    ReturnCode code;

                    package = null;

                    if (GetPackageViaContext(
                            name, LookupFlags.NoVerbose,
                            ref package) != ReturnCode.Ok)
                    {
                        indexFileName = null;

                        if (PkgSourceFileName(
                                ref indexFileName,
                                ref result) != ReturnCode.Ok)
                        {
                            return ReturnCode.Error;
                        }

                        package = PackageOps.NewCore(
                            name, null, null, clientData,
                            indexFileName, null, flags,
                            null, null);

                        code = AddPackageViaContext(
                            package, clientData, ref result);
                    }
                    else if (FlagOps.HasFlags(
                            flags, PackageFlags.FailExisting, true))
                    {
                        result = String.Format(
                            "package {0} is already known",
                            FormatOps.WrapOrNull(name));

                        return ReturnCode.Error;
                    }
                    else if (FlagOps.HasFlags(
                            flags, PackageFlags.KeepExisting, true))
                    {
                        result = String.Empty;
                        return ReturnCode.Ok;
                    }
                    else if (package == null) /* IMPOSSIBLE? */
                    {
                        result = String.Format(
                            "package {0} is invalid",
                            FormatOps.WrapOrNull(name));

                        return ReturnCode.Error;
                    }
                    else
                    {
                        //
                        // HACK: Package is already present in the
                        //       collection.  Update the package
                        //       index file name to reflect the
                        //       current file being evaluated.
                        //
                        indexFileName = null;

                        if (PkgSourceFileName(
                                ref indexFileName,
                                ref result) != ReturnCode.Ok)
                        {
                            return ReturnCode.Error;
                        }

                        package.IndexFileName = indexFileName;
                        code = ReturnCode.Ok;
                    }

                    //
                    // NOTE: Make sure the package was -OR- that it
                    //       did not need to be.
                    //
                    if (code != ReturnCode.Ok)
                        return ReturnCode.Error;

                    if (package == null) /* IMPOSSIBLE? */
                    {
                        result = String.Format(
                            "package {0} is invalid",
                            FormatOps.WrapOrNull(name));

                        return ReturnCode.Error;
                    }

                    VersionStringDictionary ifNeeded = package.IfNeeded;

                    if (ifNeeded != null)
                    {
                        ifNeeded[version] = text;
                        result = String.Empty;

                        return ReturnCode.Ok;
                    }
                    else
                    {
                        result = String.Format(
                            "package {0} ifneeded scripts not available",
                            FormatOps.WrapOrNull(name));

                        return ReturnCode.Error;
                    }
                }
                else
                {
                    package = null;

                    if (GetPackageViaContext(
                            name, LookupFlags.NoVerbose,
                            ref package) == ReturnCode.Ok)
                    {
                        if (package == null) /* IMPOSSIBLE? */
                        {
                            result = String.Format(
                                "package {0} is invalid",
                                FormatOps.WrapOrNull(name));

                            return ReturnCode.Error;
                        }

                        VersionStringDictionary ifNeeded = package.IfNeeded;

                        if (ifNeeded != null)
                        {
                            string localText;

                            if (ifNeeded.TryGetValue(
                                    version, out localText))
                            {
                                result = localText;
                            }
                            else
                            {
                                result = String.Empty;
                            }

                            return ReturnCode.Ok;
                        }
                        else
                        {
                            result = String.Format(
                                "package {0} ifneeded scripts not available",
                                FormatOps.WrapOrNull(name));

                            return ReturnCode.Error;
                        }
                    }
                    else
                    {
                        //
                        // NOTE: There is no package.  This is not an error,
                        //       per se, according to native Tcl.
                        //
                        result = String.Empty;
                        return ReturnCode.Ok;
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode PkgVersions(
            string name,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPackages(ref result)) /* CONSISTENCY */
                    return ReturnCode.Error;

                IPackage package = null;

                if (GetPackage(
                        name, LookupFlags.NoVerbose,
                        ref package) != ReturnCode.Ok)
                {
                    //
                    // NOTE: There is no package.  This is not an error,
                    //       per se, according to native Tcl.
                    //
                    result = String.Empty;
                    return ReturnCode.Ok;
                }

                if (package == null) /* IMPOSSIBLE? */
                {
                    result = String.Format(
                        "package {0} is invalid",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                VersionStringDictionary ifNeeded = package.IfNeeded;

                if (ifNeeded != null)
                    result = ifNeeded.ToString();
                else
                    result = String.Empty;

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode PkgProvide(
            string name,
            Version version,
            IClientData clientData,
            PackageFlags flags,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPackages(ref result)) /* CONSISTENCY */
                    return ReturnCode.Error;

                string provideFileName; /* REUSED */
                IPackage package = null;

                if (GetPackage(
                        name, LookupFlags.NoVerbose,
                        ref package) == ReturnCode.Ok)
                {
                    if (package == null) /* IMPOSSIBLE? */
                    {
                        result = String.Format(
                            "package {0} is invalid",
                            FormatOps.WrapOrNull(name));

                        return ReturnCode.Error;
                    }

                    Version loaded = package.Loaded;

                    if (version != null)
                    {
                        if (loaded == null)
                        {
                            provideFileName = null;

                            if (PkgSourceFileName(
                                    ref provideFileName,
                                    ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }

                            //
                            // NOTE: This version of the package is
                            //       now "provided".
                            //
                            package.ProvideFileName = provideFileName;
                            package.Loaded = version;

                            //
                            // NOTE: Update the package flags with the
                            //       ones provided by the caller, if
                            //       any, unless we are forbidden from
                            //       doing so.
                            //
                            if (!FlagOps.HasFlags(
                                    flags, PackageFlags.NoUpdate, true))
                            {
                                package.Flags |= flags;
                            }

                            result = String.Empty;
                            return ReturnCode.Ok;
                        }
                        else if (PackageOps.VersionCompare(
                                loaded, version) != 0)
                        {
                            //
                            // NOTE: This is an error, a different
                            //       version of this package has
                            //       already been provided.
                            //
                            result = String.Format(
                                "conflicting versions provided for package {0}: " +
                                "{1} then {2} ", FormatOps.WrapOrNull(name),
                                FormatOps.WrapOrNull(loaded),
                                FormatOps.WrapOrNull(version));
                        }
                        else
                        {
                            //
                            // NOTE: Do nothing, the identical
                            //       version has already been
                            //       provided.
                            //
                            result = String.Empty;
                            return ReturnCode.Ok;
                        }
                    }
                    else
                    {
                        //
                        // NOTE: Do nothing, just return the
                        //       version of the package that
                        //       has been provided.
                        //
                        if (loaded != null)
                            result = loaded;
                        else
                            result = String.Empty;

                        return ReturnCode.Ok;
                    }
                }
                else if (version != null)
                {
                    provideFileName = null;

                    if (PkgSourceFileName(
                            ref provideFileName,
                            ref result) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }

                    //
                    // NOTE: We have never seen this package
                    //       before.  Create a new package
                    //       and mark it as loaded.
                    //
                    if (AddPackage(PackageOps.NewCore(
                            name, null, null, clientData,
                            null, provideFileName, flags,
                            version, null), clientData,
                            ref result) == ReturnCode.Ok)
                    {
                        result = String.Empty;
                        return ReturnCode.Ok;
                    }
                }
                else
                {
                    result = "invalid package version";
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode PkgRequire(
            string name,
            Version version,
            IClientData clientData,
            PackageFlags flags,
            bool exact,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasPackages(ref result))
                    return ReturnCode.Error;

                IPackage package = null;

                if (GetPackage(
                        name, LookupFlags.NoVerbose,
                        ref package) != ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't find package {0}",
                        FormatOps.PackageName(name, version));

                    return ReturnCode.Error;
                }

                if (package == null) /* IMPOSSIBLE? */
                {
                    result = String.Format(
                        "package {0} is invalid",
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                Version loaded = package.Loaded;

                if (loaded != null)
                {
                    result = loaded;
                    return ReturnCode.Ok;
                }

                //
                // NOTE: Attempt to load the package using the provided
                //       script.
                //
                try
                {
                    Version best = null;

                    if (package.Select(
                            PackagePreference.Default, ref best,
                            ref result) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }

                    if (package.Load(
                            this, best, ref result) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }
                }
                catch (Exception e)
                {
                    result = String.Format(
                        "caught exception while loading package: {0}",
                        e);

                    return ReturnCode.Error;
                }

                loaded = package.Loaded; /* REFRESH */

                if (loaded == null)
                {
                    result = String.Format(
                        "attempt to provide package {0} failed: " +
                        "no version of package {1} provided",
                        FormatOps.PackageName(name, version),
                        FormatOps.WrapOrNull(name));

                    return ReturnCode.Error;
                }

                if ((version != null) &&
                    !PackageOps.VersionSatisfies(loaded, version, exact))
                {
                    result = String.Format(
                        "attempt to provide package {0} failed: " +
                        "package {1} provided instead",
                        FormatOps.PackageName(name, version),
                        FormatOps.PackageName(name, loaded));

                    return ReturnCode.Error;
                }

                result = loaded;
                return ReturnCode.Ok;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IPluginManager Members
        public string PluginBaseDirectory
        {
            get { CheckDisposed(); lock (syncRoot) { return pluginBaseDirectory; } }
            set { CheckDisposed(); lock (syncRoot) { pluginBaseDirectory = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public IPlugin FindPlugin( // COMPAT: Eagle beta.
            AppDomain appDomain,
            MatchMode mode,
            string pattern,
            Version version,
            byte[] publicKeyToken,
            bool noCase,
            ref Result error
            )
        {
            CheckDisposed();

            return InternalFindPlugin(
                appDomain, mode, pattern, version, publicKeyToken,
                LookupFlags.Default, noCase, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public IPlugin FindPlugin(
            AppDomain appDomain,
            MatchMode mode,
            string pattern,
            Version version,
            byte[] publicKeyToken,
            LookupFlags lookupFlags,
            bool noCase,
            ref Result error
            )
        {
            CheckDisposed();

            return InternalFindPlugin(
                appDomain, mode, pattern, version, publicKeyToken,
                lookupFlags, noCase, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int AddPluginArguments(
            string name,
            string value
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                int count = 0;

                if (!IsModifiable(true))
                    return count;

                if (String.IsNullOrEmpty(name))
                    return count;

                if ((pluginArguments != null) &&
                    !pluginArguments.ContainsKey(name)) /* EXEMPT */
                {
                    pluginArguments.Add(name, value);
                    count++;
                }

                return count;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int RemovePluginArguments(
            string name
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                int count = 0;

                if (!IsModifiable(false))
                    return count;

                if (String.IsNullOrEmpty(name))
                    return count;

                if (pluginArguments != null)
                {
                    StringList keys = new StringList(pluginArguments.Keys);

                    foreach (string key in keys)
                    {
                        if (StringOps.Match(
                                this, MatchMode.Glob, name, key, false) &&
                            pluginArguments.Remove(key))
                        {
                            count++;
                        }
                    }
                }

                return count;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode LoadPlugin(
            byte[] assemblyBytes,
            byte[] symbolBytes,
#if CAS_POLICY
            Evidence evidence,
#endif
            string typeName,
            IClientData clientData,
            PluginFlags flags,
            ref IPlugin plugin,
            ref Result result
            )
        {
            CheckDisposed();

            return LoadPlugin(null, assemblyBytes, symbolBytes,
#if CAS_POLICY
                evidence,
#endif
                typeName, clientData, flags, ref plugin, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        [Obsolete()]
        public ReturnCode LoadPlugin( /* NOT USED */
            AssemblyName assemblyName,
#if CAS_POLICY
            Evidence evidence,
#endif
            string typeName,
            IClientData clientData,
            PluginFlags flags,
            ref IPlugin plugin,
            ref Result result
            )
        {
            CheckDisposed();

            return LoadPlugin(null, assemblyName,
#if CAS_POLICY
                evidence,
#endif
                typeName, clientData, flags, ref plugin, ref result
            );
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode LoadPlugin(
            string fileName,
#if CAS_POLICY
            Evidence evidence,
            byte[] hashValue,
            AssemblyHashAlgorithm hashAlgorithm,
#endif
            string typeName,
            IClientData clientData,
            PluginFlags flags,
            ref IPlugin plugin,
            ref Result result
            )
        {
            CheckDisposed();

            return LoadPlugin(null, fileName,
#if CAS_POLICY
                evidence, hashValue, hashAlgorithm,
#endif
                typeName, clientData, flags, ref plugin, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode UnloadPlugin(
            IPlugin plugin,
            IClientData clientData,
            PluginFlags flags,
            ref Result result
            )
        {
            CheckDisposed();

            if (plugin == null)
            {
                result = "invalid plugin";
                return ReturnCode.Error;
            }

            ReturnCode code;

#if ISOLATED_PLUGINS
            bool isolated = AppDomainOps.IsIsolated(plugin);
            AppDomain appDomain = isolated ? plugin.AppDomain : null;
#endif

            if (!FlagOps.HasFlags(flags, PluginFlags.SkipTerminate, true))
            {
                GlobalState.PushActiveInterpreter(this);

                try
                {
#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.Plugin, NotifyFlags.PreUnload,
                        new ObjectPair(plugin, flags), this,
                        clientData, null, null, ref result);
#endif

                    code = TerminatePlugin(plugin, clientData, ref result);

                    if (code == ReturnCode.Ok)
                    {
#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Plugin, NotifyFlags.Unload,
                            new ObjectPair(plugin, flags), this,
                            clientData, null, null, ref result);
#endif
                    }
                }
                catch (Exception e)
                {
                    result = String.Format(
                        "caught exception while unloading plugin: {0}",
                        e);

                    code = ReturnCode.Error;
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }
            else
            {
                code = ReturnCode.Ok;
            }

#if ISOLATED_PLUGINS
            //
            // NOTE: This cannot be done completely without full AppDomain
            //       isolation of loaded plugin Assemblies.  At that point,
            //       we can simply call AppDomain.Unload to unload the plugin.
            //
            if ((code == ReturnCode.Ok) && isolated)
            {
                UnloadAppDomainForPlugin(
                    plugin, clientData, null, appDomain);
            }
#endif

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode UnloadPlugin(
            long token,
            IClientData clientData,
            PluginFlags flags, /* NOT USED */
            ref Result result
            )
        {
            CheckDisposed();

            ReturnCode code;
#if ISOLATED_PLUGINS
            IPlugin plugin = null;

            code = GetPlugin(token, LookupFlags.Unload, ref plugin, ref result);

            if (code == ReturnCode.Ok)
#endif
            {
#if ISOLATED_PLUGINS
                bool isolated = AppDomainOps.IsIsolated(plugin);
                AppDomain appDomain = isolated ? plugin.AppDomain : null;
#endif

                code = RemovePlugin(token, clientData, ref result);

#if ISOLATED_PLUGINS
                //
                // NOTE: This cannot be done completely without full AppDomain
                //       isolation of loaded plugin Assemblies.  At that point,
                //       we can simply call AppDomain.Unload to unload the plugin.
                //
                if ((code == ReturnCode.Ok) && isolated)
                {
                    UnloadAppDomainForPlugin(
                        plugin, clientData, null, appDomain);
                }
#endif
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode UnloadPlugin(
            string name,
            IClientData clientData,
            PluginFlags flags, /* NOT USED */
            ref Result result
            )
        {
            CheckDisposed();

            ReturnCode code;
#if ISOLATED_PLUGINS
            IPlugin plugin = null;

            code = GetPlugin(name, LookupFlags.Unload, ref plugin, ref result);

            if (code == ReturnCode.Ok)
#endif
            {
#if ISOLATED_PLUGINS
                bool isolated = AppDomainOps.IsIsolated(plugin);
                AppDomain appDomain = isolated ? plugin.AppDomain : null;
#endif

                code = RemovePlugin(name, clientData, ref result);

#if ISOLATED_PLUGINS
                //
                // NOTE: This cannot be done completely without full AppDomain
                //       isolation of loaded plugin Assemblies.  At that point,
                //       we can simply call AppDomain.Unload to unload the plugin.
                //
                if ((code == ReturnCode.Ok) && isolated)
                {
                    UnloadAppDomainForPlugin(
                        plugin, clientData, null, appDomain);
                }
#endif
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddCommands(
            IPlugin plugin,
            IClientData clientData,
            CommandFlags flags,
            ref Result error
            )
        {
            CheckDisposed();

            int count = 0;

            return AddCommands(new AddEntityClientData(null, this),
                plugin, clientData, flags, null, false, ref count,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveCommands(
            IPlugin plugin,
            IClientData clientData,
            CommandFlags flags,
            ref Result error
            )
        {
            CheckDisposed();

            if (plugin != null)
            {
                LongList localTokens = plugin.CommandTokens;

                if (localTokens != null)
                    localTokens = (LongList)localTokens.Clone();

                if (localTokens != null)
                {
                    ReturnCode code;
                    Result localResult; /* REUSED */

                    foreach (long token in localTokens)
                    {
                        if (DoesCommandExist(token) == ReturnCode.Ok)
                        {
                            localResult = null;

                            code = RemoveCommand(
                                token, clientData, ref localResult);

                            if (code != ReturnCode.Ok)
                            {
                                error = localResult;
                                return code;
                            }
                        }
                        else if (DoesHiddenCommandExist(token) == ReturnCode.Ok)
                        {
                            localResult = null;

                            code = RemoveHiddenCommand(
                                token, clientData, ref localResult);

                            if (code != ReturnCode.Ok)
                            {
                                error = localResult;
                                return code;
                            }
                        }
                        else
                        {
                            //
                            // NOTE: We must actually ignore "failures" here because,
                            //       in theory, the command could have been removed
                            //       using the [rename] script command or some other
                            //       mechanism.
                            //
                        }
                    }
                }

                return ReturnCode.Ok;
            }
            else
            {
                error = "invalid plugin";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveFunctions(
            IPlugin plugin,
            IClientData clientData,
            FunctionFlags flags,
            ref Result error
            )
        {
            CheckDisposed();

            if (plugin != null)
            {
                LongList localTokens = plugin.FunctionTokens;

                if (localTokens != null)
                    localTokens = (LongList)localTokens.Clone();

                if (localTokens != null)
                {
                    ReturnCode code;
                    Result localResult; /* REUSED */

                    foreach (long token in localTokens)
                    {
                        if (DoesFunctionExist(token) == ReturnCode.Ok)
                        {
                            localResult = null;

                            code = RemoveFunction(
                                token, clientData, ref localResult);

                            if (code != ReturnCode.Ok)
                            {
                                error = localResult;
                                return code;
                            }
                        }
                        else
                        {
                            //
                            // NOTE: We must actually ignore "failures" here because,
                            //       in theory, the function could have been removed
                            //       using some other mechanism.
                            //
                        }
                    }
                }

                return ReturnCode.Ok;
            }
            else
            {
                error = "invalid plugin";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddPolicies(
            IPlugin plugin,         /* in */
            IClientData clientData, /* in: OPTIONAL */
            ref Result error        /* out */
            )
        {
            CheckDisposed();

            if (plugin == null)
            {
                error = "invalid plugin";
                return ReturnCode.Error;
            }

            AppDomain appDomain = plugin.AppDomain;

            if (appDomain == null)
            {
                error = "plugin has invalid application domain";
                return ReturnCode.Error;
            }

            PolicyDataList policies = plugin.Policies;

            if (policies == null)
            {
                error = "plugin has invalid policy data list";
                return ReturnCode.Error;
            }

            //
            // NOTE: Are we merging policies from this plugin?
            //
            PluginFlags pluginFlags = plugin.Flags;

            bool ignoreExisting = FlagOps.HasFlags(
                pluginFlags, PluginFlags.MergePolicies, true);

            bool replaceExisting = FlagOps.HasFlags(
                pluginFlags, PluginFlags.OverwritePolicies, true);

#if ISOLATED_PLUGINS
            //
            // NOTE: Is this plugin supposed to be loaded into an
            //       isolated application domain?
            //
            bool isolated = AppDomainOps.IsIsolated(plugin);
#endif

            //
            // NOTE: Process each policy in no particular order
            //       (actually, the type and method name of the
            //       policy, which currently equates to the same
            //       thing).
            //
            foreach (IPolicyData policyData in policies)
            {
                //
                // NOTE: Just skip any invalid policy data.
                //
                if (policyData == null)
                    continue;

                //
                // NOTE: Query the method flags associated with this
                //       policy method.
                //
                MethodFlags dataMethodFlags = policyData.MethodFlags;

                //
                // NOTE: Check if this policy is supposed to be added
                //       added to the interpreter.
                //
                bool noAdd = FlagOps.HasFlags(
                    dataMethodFlags, MethodFlags.NoAdd, true);

                //
                // NOTE: If we are supposed to skip adding this policy
                //       altogether, then proceed no further.
                //
                if (noAdd)
                    continue;

                //
                // NOTE: Grab the policy name and make sure it is valid.
                //       For now, we just ignore invalid policy names
                //       (i.e. we skip adding the policy).
                //
                string policyName = policyData.Name;

                if (policyName == null)
                    continue;

                if (DoesPolicyExist(policyName) == ReturnCode.Ok)
                {
                    if (replaceExisting)
                    {
                        ReturnCode removeCode;
                        Result removeResult = null;

                        removeCode = RemovePolicy(
                            policyName, clientData,
                            ref removeResult);

                        if (removeCode != ReturnCode.Ok)
                        {
                            error = removeResult;
                            return removeCode;
                        }
                    }
                    else if (ignoreExisting)
                    {
                        continue;
                    }
                }

                //
                // NOTE: The type name to create is hard-coded because
                //       we currently do not support arbitrary classes
                //       here.
                //
                string typeName = typeof(Eagle._Policies.Core).FullName;

                //
                // NOTE: Setup the argument array for policy constructor.
                //       The policy MUST expose a constructor that accepts
                //       this argument type.  It is free to expose other
                //       constructors; however, they will not be used by
                //       the script engine.
                //
                object[] args = { new PolicyData(
                    policyData.Name, policyData.Group,
                    policyData.Description, clientData,
                    policyData.TypeName, policyData.MethodName,
                    policyData.BindingFlags, dataMethodFlags,
                    policyData.PolicyFlags, policyData.Plugin,
                    EntityOps.GetToken(policyData))
                };

                //
                // NOTE: Attempt to create an instance of the policy in
                //       the application domain for the plugin.
                //
                bool success = false;
                IPolicy policy = null;

                try
                {
                    BindingFlags bindingFlags = createInstanceBindingFlags;

#if ISOLATED_PLUGINS
                    if (isolated)
                    {
                        AssemblyName assemblyName = GlobalState.GetAssemblyName();

                        if (assemblyName == null)
                        {
                            //
                            // HACK: Error message is not quite correct;
                            //       however, it's close enough for now.
                            //
                            error = "plugin has invalid assembly name";
                            return ReturnCode.Error;
                        }

                        policy = appDomain.CreateInstanceAndUnwrap(
                            assemblyName.ToString(), typeName, false,
                            bindingFlags, null, args, null, null,
                            null) as IPolicy;
                    }
                    else
#endif
                    {
                        Assembly assembly = GlobalState.GetAssembly();

                        if (assembly == null)
                        {
                            //
                            // HACK: Error message is not quite correct;
                            //       however, it's close enough for now.
                            //
                            error = "plugin has invalid assembly";
                            return ReturnCode.Error;
                        }

                        policy = assembly.CreateInstance(
                            typeName, false, bindingFlags, null,
                            args, null, null) as IPolicy;
                    }

                    if (policy == null)
                    {
                        error = String.Format(
                            "could not create policy {0}",
                            FormatOps.WrapOrNull(typeName));

                        return ReturnCode.Error;
                    }

                    //
                    // NOTE: Policies must have an ObjectId attribute.
                    //       Attempt to assign the ObjectId attribute
                    //       to the Id property now.
                    //
                    /* IGNORED */
                    EntityOps.MaybeSetupId(policy);

                    //
                    // NOTE: Next, make sure the actual delegate is setup.
                    //
                    Result localResult; /* REUSED */

                    localResult = null;

                    if (policy.Setup(ref localResult) != ReturnCode.Ok)
                    {
                        error = localResult;
                        return ReturnCode.Error;
                    }

                    //
                    // NOTE: Add the policy to the interpreter.
                    //
                    long token = 0;

                    localResult = null;

                    if (AddPolicy(
                            policy, clientData, ref token,
                            ref localResult) != ReturnCode.Ok)
                    {
                        error = localResult;
                        return ReturnCode.Error;
                    }

                    EntityOps.SetToken(policyData, token); /* EXEMPT */

                    success = true;
                }
                finally
                {
                    if (!success && (policy != null))
                    {
                        IDisposable disposable = policy as IDisposable;

                        if (disposable != null)
                        {
                            disposable.Dispose();
                            disposable = null;
                        }

                        policy = null;
                    }
                }
            }

#if ISOLATED_PLUGINS
            //
            // NOTE: Update the policy data list for isolated plugins.
            //
            if (isolated)
                plugin.Policies = policies;
#endif

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemovePolicies(
            IPlugin plugin,
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            if (plugin != null)
            {
                LongList localTokens = (LongList)plugin.PolicyTokens;

                if (localTokens != null)
                    localTokens = (LongList)localTokens.Clone();

                if (localTokens != null)
                {
                    ReturnCode code;
                    Result localResult; /* REUSED */

                    foreach (long token in localTokens)
                    {
                        if (DoesPolicyExist(token) == ReturnCode.Ok)
                        {
                            localResult = null;

                            code = RemovePolicy(
                                token, clientData, ref localResult);

                            if (code != ReturnCode.Ok)
                            {
                                error = localResult;
                                return code;
                            }
                        }
                        else
                        {
                            //
                            // NOTE: We should actually ignore "failures" here because,
                            //       in theory, the policy could have been removed using
                            //       some other mechanism.
                            //
                        }
                    }
                }

                return ReturnCode.Ok;
            }
            else
            {
                error = "invalid plugin";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveTraces(
            IPlugin plugin,
            IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            if (plugin != null)
            {
                LongList localTokens = (LongList)plugin.TraceTokens;

                if (localTokens != null)
                    localTokens = (LongList)localTokens.Clone();

                if (localTokens != null)
                {
                    ReturnCode code;
                    Result localResult; /* REUSED */

                    foreach (long token in localTokens)
                    {
                        if (DoesTraceExist(token) == ReturnCode.Ok)
                        {
                            localResult = null;

                            code = RemoveTrace(
                                token, clientData, ref localResult);

                            if (code != ReturnCode.Ok)
                            {
                                error = localResult;
                                return code;
                            }
                        }
                        else
                        {
                            //
                            // NOTE: We should actually ignore "failures" here because,
                            //       in theory, the trace could have been removed using
                            //       some other mechanism.
                            //
                        }
                    }
                }

                return ReturnCode.Ok;
            }
            else
            {
                error = "invalid plugin";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RestoreCorePlugin(
            bool strict,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // HACK: The core plugin has no
                //       dynamically added policies.
                //
                return RestorePlugin(
                    NewCorePlugin, true, false, true,
                    strict, ref corePluginToken,
                    ref result);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY && NOTIFY_ARGUMENTS
        public ReturnCode RestoreMonitorPlugin(
            bool strict,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // HACK: The monitor plugin has no
                //       dynamically added policies.
                //
                return RestorePlugin(
                    NewMonitorPlugin, true, true, true,
                    strict, ref monitorPluginToken,
                    ref result);
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal long InternalCorePluginToken
        {
            set { corePluginToken = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY || NOTIFY_OBJECT
        internal long InternalObjectPluginToken
        {
            set { objectPluginToken = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TEST
        internal long InternalScriptNotifyPluginToken
        {
            set { scriptNotifyPluginToken = value; }
        }
#endif
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY && NOTIFY_ARGUMENTS
        internal long InternalMonitorPluginToken
        {
            set { monitorPluginToken = value; }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TEST_PLUGIN || DEBUG
        internal long InternalTestPluginToken
        {
            set { testPluginToken = value; }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IPlugin InternalFindPlugin(
            AppDomain appDomain,
            MatchMode mode,
            string pattern,
            Version version,
            byte[] publicKeyToken,
            LookupFlags lookupFlags,
            bool noCase,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!PrivateHasPlugins(ref error))
                    return null;

                foreach (KeyValuePair<string, _Wrappers.Plugin> pair in plugins)
                {
                    IPlugin plugin = pair.Value;

                    if (plugin == null)
                        continue;

                    if (appDomain != null)
                    {
                        AppDomain pluginAppDomain = plugin.AppDomain;

                        if ((pluginAppDomain != null) &&
                            !AppDomainOps.IsSame(pluginAppDomain, appDomain))
                        {
                            continue;
                        }
                    }

                    AssemblyName assemblyName;

#if ISOLATED_PLUGINS
                    if (AppDomainOps.IsIsolated(plugin))
                    {
                        assemblyName = plugin.AssemblyName;
                    }
                    else
#endif
                    {
                        Assembly assembly = plugin.Assembly;

                        if (assembly == null)
                            continue;

                        assemblyName = assembly.GetName();
                    }

                    if (assemblyName == null)
                        continue;

                    if ((pattern != null) && !StringOps.Match(
                            this, mode, assemblyName.Name, pattern, noCase))
                    {
                        continue;
                    }

                    if ((version != null) &&
                        (PackageOps.VersionCompare(assemblyName.Version,
                            version) != 0))
                    {
                        continue;
                    }

                    if ((publicKeyToken != null) &&
                        !ArrayOps.Equals(
                            assemblyName.GetPublicKeyToken(), publicKeyToken))
                    {
                        continue;
                    }

                    if (!RuntimeOps.CheckPluginVersusLookupFlags(
                            plugin, lookupFlags))
                    {
                        continue;
                    }

                    return plugin;
                }
            }

            error = String.Format(
                "cannot find plugin matching {0} {1} - {2} version {3} " +
                "with public key token {4} in application domain {5} " +
                "and lookup flags {6}", noCase ? "case-insensitive" :
                "case-sensitive", FormatOps.WrapOrNull(mode),
                FormatOps.WrapOrNull(pattern), FormatOps.WrapOrNull(
                version), ArrayOps.ToHexadecimalString(publicKeyToken),
                FormatOps.DisplayAppDomain(appDomain), FormatOps.WrapOrNull(
                lookupFlags));

            return null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void SetupAddEntityClientData(
            AddEntityClientData addEntityClientData
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                SetupAddEntityClientData(
                    addEntityClientData, createFlags, interpreterFlags);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void SetupAddEntityClientData(
            AddEntityClientData addEntityClientData,
            CreateFlags createFlags,
            InterpreterFlags interpreterFlags
            )
        {
            if (addEntityClientData == null)
                return;

            //
            // NOTE: Is this interpreter marked as "safe"?
            //
            addEntityClientData.CreateSafe = PrivateIsSafe(
                createFlags);

            //
            // NOTE: Are we supposed to hide unsafe commands?
            //
            addEntityClientData.HideUnsafe = PrivateIsHideUnsafe(
                createFlags);

            //
            // NOTE: Is this interpreter marked as "standard"?
            //
            addEntityClientData.CreateStandard = PrivateIsStandard(
                createFlags);

            //
            // NOTE: Are we supposed to hide non-standard commands?
            //
            addEntityClientData.HideNonStandard = PrivateIsHideNonStandard(
                createFlags);

            //
            // NOTE: Grab the string comparison type to use for this
            //       (and other?) operators.
            //
            addEntityClientData.OperatorComparisonType =
                StringOps.GetComparisonType(
                    interpreterFlags, false);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddCommands(
            AddEntityClientData addEntityClientData, /* in */
            IPlugin plugin,                          /* in */
            IClientData clientData,                  /* in */
            CommandFlags commandFlags,               /* in */
            string pattern,                          /* in */
            bool noCase,                             /* in */
            ref int count,                           /* in, out */
            ref Result error                         /* out */
            )
        {
            if (plugin == null)
            {
                error = "invalid plugin";
                return ReturnCode.Error;
            }

            AppDomain appDomain = plugin.AppDomain;

            if (appDomain == null)
            {
                error = "plugin has invalid application domain";
                return ReturnCode.Error;
            }

            CommandDataList commands = plugin.Commands;

            if (commands == null)
            {
                error = "plugin has invalid command data list";
                return ReturnCode.Error;
            }

            //
            // NOTE: Are we replacing and/or merging commands from this
            //       plugin or adding commands in command restore mode?
            //
            PluginFlags pluginFlags = plugin.Flags;

            bool replaceExisting = FlagOps.HasFlags(
                commandFlags, CommandFlags.Replace, true);

            if (!replaceExisting && FlagOps.HasFlags(
                    pluginFlags, PluginFlags.OverwriteCommands, true))
            {
                replaceExisting = true;
            }

            bool ignoreExisting = FlagOps.HasFlags(
                commandFlags, CommandFlags.Restore, true);

            if (!ignoreExisting && FlagOps.HasFlags(
                    pluginFlags, PluginFlags.MergeCommands, true))
            {
                ignoreExisting = true;
            }

#if ISOLATED_PLUGINS
            //
            // NOTE: Is this plugin supposed to be loaded into an
            //       isolated application domain?
            //
            bool isolated = AppDomainOps.IsIsolated(plugin);
#endif

            bool createSafe = addEntityClientData.CreateSafe;
            bool hideUnsafe = addEntityClientData.HideUnsafe;
            bool createStandard = addEntityClientData.CreateStandard;
            bool hideNonStandard = addEntityClientData.HideNonStandard;

            //
            // NOTE: Process each command in no particular order
            //       (actually, the type of the command, which
            //       currently equates to the same thing).
            //
            foreach (ICommandData commandData in commands)
            {
                //
                // NOTE: Just skip any invalid command data.
                //
                if (commandData == null)
                    continue;

                //
                // NOTE: Query the command flags associated with this
                //       type.
                //
                CommandFlags dataCommandFlags = commandData.Flags;

                //
                // NOTE: Check if this command is supposed to be added
                //       to the interpreter.
                //
                bool noAdd = FlagOps.HasFlags(
                    dataCommandFlags, CommandFlags.NoAdd, true);

                //
                // NOTE: If we are supposed to skip adding this command
                //       altogether, then proceed no further.
                //
                if (noAdd)
                    continue;

                //
                // NOTE: Check if this command has been marked as "safe"
                //       or "unsafe" by its author.
                //
                bool safe = EntityOps.IsSafe(dataCommandFlags);

                //
                // NOTE: If the interpreter is "safe", make sure we only
                //       add commands that are marked as "safe" and NOT
                //       marked as "unsafe" unless we are merely hiding
                //       commands not considered to be "safe".  In that
                //       case, we add all commands, hidden them as
                //       necessary.
                //
                if (!safe && createSafe && !hideUnsafe)
                    continue;

                //
                // NOTE: Check if this command is part of the official
                //       "Tcl Standard" (i.e. largely (or completely)
                //       compatible with an identically named command
                //       from native Tcl 8.4, 8.5, and/or 8.6).
                //
                bool standard = FlagOps.HasFlags(
                    dataCommandFlags, CommandFlags.Standard, true);

                //
                // NOTE: If the interpreter is "standard", make sure we
                //       only add commands that are marked as "standard"
                //       and NOT marked as "non-standard" unless we are
                //       merely hiding commands not considered to be
                //       "standard".  In that case, we add all commands,
                //       hidden them as necessary.
                //
                if (!standard && createStandard && !hideNonStandard)
                    continue;

                //
                // NOTE: Is the command named "Default" or "Core"?  If
                //       so, we need to skip over it because they are
                //       used as the base implementation for other
                //       commands.
                //
                string typeName = commandData.TypeName;

                if (RuntimeOps.IsReallyNonCommandName(typeName))
                    continue;

                //
                // NOTE: Grab the command name and make sure it is valid.
                //       For now, we just ignore invalid command names
                //       (i.e. we skip adding the command).
                //
                string commandName = commandData.Name;

                if (commandName == null)
                    continue;

                //
                // NOTE: At this point, permit the caller to only
                //       add commands matching the specified name
                //       pattern; if the name pattern is null, all
                //       candidate commands that reach this point
                //       may be added (i.e. subject to subsequent
                //       restrictions in the code below).
                //
                if ((pattern != null) && !StringOps.Match(
                        this, MatchMode.Glob, commandName, pattern,
                        noCase))
                {
                    continue;
                }

                //
                // NOTE: Always try to add the command unless we
                //       are in "restoration" mode, in that case
                //       only try to add the command if it does
                //       not already exist.
                //
                if (DoesAnyCommandExist(commandName) == ReturnCode.Ok)
                {
                    if (replaceExisting)
                    {
                        ReturnCode removeCode;
                        Result removeResult = null;

                        removeCode = RemoveCommand(
                            commandName, clientData,
                            ref removeResult);

                        if (removeCode != ReturnCode.Ok)
                        {
                            error = removeResult;
                            return removeCode;
                        }
                    }
                    else if (ignoreExisting)
                    {
                        continue;
                    }
                }

                //
                // NOTE: Start with command flags provided by our
                //       caller and mask off all non-instance flags.
                //
                CommandFlags newCommandFlags =
                    commandFlags & ~CommandFlags.NonInstanceMask;

                if ((!safe && hideUnsafe) ||
                    (!standard && hideNonStandard))
                {
                    //
                    // NOTE: If this command is not considered "safe"
                    //       -OR- "standard" and our caller instructed
                    //       us to hide such commands, do so now.
                    //
                    newCommandFlags |= CommandFlags.Hidden;
                }

#if ISOLATED_PLUGINS
                //
                // NOTE: If the plugin has been loaded into an isolated
                //       AppDomain, the command should be marked isolated
                //       as well.
                //
                if (isolated)
                    newCommandFlags |= CommandFlags.Isolated;
#endif

                //
                // NOTE: Setup the argument array for command constructor.
                //       The command MUST expose a constructor that accepts
                //       this argument type.  It is free to expose other
                //       constructors; however, they will not be used by
                //       the script engine.
                //
                object[] args = { new CommandData(
                    commandName, commandData.Group, commandData.Description,
                    commandData.ClientData, commandData.TypeName,
                    newCommandFlags, commandData.Plugin, EntityOps.GetToken(
                    commandData))
                };

                //
                // NOTE: Attempt to create an instance of the command in
                //       the application domain for the plugin.
                //
                bool success = false;
                ICommand command = null;

                try
                {
                    BindingFlags bindingFlags = createInstanceBindingFlags;

#if ISOLATED_PLUGINS
                    if (isolated)
                    {
                        AssemblyName assemblyName = plugin.AssemblyName;

                        if (assemblyName == null)
                        {
                            error = "plugin has invalid assembly name";
                            return ReturnCode.Error;
                        }

                        command = appDomain.CreateInstanceAndUnwrap(
                            assemblyName.ToString(), typeName, false,
                            bindingFlags, null, args, null, null,
                            null) as ICommand;
                    }
                    else
#endif
                    {
                        Assembly assembly = plugin.Assembly;

                        if (assembly == null)
                        {
                            error = "plugin has invalid assembly";
                            return ReturnCode.Error;
                        }

                        command = assembly.CreateInstance(
                            typeName, false, bindingFlags, null,
                            args, null, null) as ICommand;
                    }

                    if (command == null)
                    {
                        error = String.Format(
                            "could not create command {0}",
                            FormatOps.WrapOrNull(typeName));

                        return ReturnCode.Error;
                    }

                    //
                    // NOTE: Commands must have an ObjectId attribute.
                    //       Attempt to assign the ObjectId attribute
                    //       to the Id property now.
                    //
                    /* IGNORED */
                    EntityOps.MaybeSetupId(command);

                    //
                    // NOTE: Add the command to the interpreter.
                    //
                    long token = 0;
                    Result localResult = null;

                    if (AddCommand(
                            command, clientData, ref token,
                            ref localResult) != ReturnCode.Ok)
                    {
                        error = localResult;
                        return ReturnCode.Error;
                    }

                    EntityOps.SetToken(commandData, token); /* EXEMPT */

                    success = true;
                    count++;
                }
                catch(Exception e)
                {
                    error = e;
                    return ReturnCode.Error;
                }
                finally
                {
                    if (!success && (command != null))
                    {
                        ReturnCode terminateCode;
                        Result terminateResult = null;

                        terminateCode = TerminateCommand(
                            command, clientData, ref terminateResult);

                        if (terminateCode != ReturnCode.Ok)
                        {
                            DebugOps.Complain(
                                this, terminateCode, terminateResult);
                        }
                    }
                }
            }

#if ISOLATED_PLUGINS
            //
            // NOTE: Update the command data list for isolated plugins.
            //
            if (isolated)
                plugin.Commands = commands;
#endif

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Plugin Data Preview Methods
#if APPDOMAINS || ISOLATED_INTERPRETERS || ISOLATED_PLUGINS
        internal static object GetReflectionHelper(
            string fileName,                      /* in */
            StringList resourcePatterns,          /* in */
            PluginFlags pluginFlags,              /* in */
            PluginLoaderFlags pluginLoaderFlags,  /* in */
#if !NET_STANDARD_20
            ref CrossAppDomainDelegate @delegate, /* out */
#else
            ref GenericCallback @delegate,        /* out */
#endif
            ref Result error                      /* out */
            )
        {
            if (FlagOps.HasFlags(pluginFlags, PluginFlags.Verbose, true))
                pluginLoaderFlags |= PluginLoaderFlags.Verbose;

            PluginLoadHelper loadHelper = PluginLoadHelper.Create(
                fileName, null, resourcePatterns,
#if CAS_POLICY
                null,
#if !MONO && !MONO_HACKS
                null, AssemblyHashAlgorithm.None,
#endif
#endif
                pluginLoaderFlags);

            if (loadHelper != null)
            {
                @delegate = loadHelper.ReflectionNoCasLoad1;
                return loadHelper;
            }
            else
            {
                error = "cannot create plugin load helper";
                return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static object GetReflectionHelper(
            byte[] assemblyBytes,                 /* in */
            StringList resourcePatterns,          /* in */
            PluginFlags pluginFlags,              /* in */
            PluginLoaderFlags pluginLoaderFlags,  /* in */
#if !NET_STANDARD_20
            ref CrossAppDomainDelegate @delegate, /* out */
#else
            ref GenericCallback @delegate,        /* out */
#endif
            ref Result error                      /* out */
            )
        {
            if (FlagOps.HasFlags(pluginFlags, PluginFlags.Verbose, true))
                pluginLoaderFlags |= PluginLoaderFlags.Verbose;

            PluginLoadHelper loadHelper = PluginLoadHelper.Create(
                assemblyBytes, null, null, resourcePatterns,
#if CAS_POLICY
                null,
#if !MONO && !MONO_HACKS
                null, AssemblyHashAlgorithm.None,
#endif
#endif
                pluginLoaderFlags);

            if (loadHelper != null)
            {
                @delegate = loadHelper.ReflectionNoCasLoad2;
                return loadHelper;
            }
            else
            {
                error = "cannot create plugin load helper";
                return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static IPluginData ExtractPluginData(
            object helper,   /* in, always PluginLoadHelper (late bound) */
            ref Result error /* out */
            )
        {
            PluginLoadHelper loadHelper = helper as PluginLoadHelper;

            if (loadHelper == null)
            {
                error = "invalid plugin load helper";
                return null;
            }

            PluginPropertyHelper propertyHelper = loadHelper.PropertyHelper;

            if (propertyHelper == null)
            {
                error = "invalid plugin property helper";
                return null;
            }

            return new PluginData(
                null, null, null, null, propertyHelper.PluginFlags, null,
                propertyHelper.Uri, propertyHelper.UpdateUri, null, null,
                propertyHelper.AssemblyName, propertyHelper.DateTime,
                propertyHelper.FileName, propertyHelper.TypeName, null,
                null, null, null, null, null, null, null, 0);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static ReturnCode ExtractResourceData(
            object helper,                          /* in, always PluginLoadHelper (late bound) */
            ref PluginResourceDictionary resources, /* out */
            ref Result error                        /* out */
            )
        {
            PluginLoadHelper loadHelper = helper as PluginLoadHelper;

            if (loadHelper == null)
            {
                error = "invalid plugin load helper";
                return ReturnCode.Error;
            }

            PluginPropertyHelper propertyHelper = loadHelper.PropertyHelper;

            if (propertyHelper == null)
            {
                error = "invalid plugin property helper";
                return ReturnCode.Error;
            }

            resources = propertyHelper.Resources;
            return ReturnCode.Ok;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode LoadPlugin(
            IRuleSet ruleSet,
            byte[] assemblyBytes,
            byte[] symbolBytes,
#if CAS_POLICY
            Evidence evidence,
#endif
            string typeName,
            IClientData clientData,
            PluginFlags flags,
            ref IPlugin plugin,
            ref Result result
            )
        {
            ReturnCode code = ReturnCode.Ok;

            if (assemblyBytes != null)
            {
                PolicyDecision decision = PolicyDecision.None;
                Result policyResult = null;

                code = CheckPluginPolicies(
                    PolicyFlags.EngineBeforePlugin, null, typeName, null,
                    assemblyBytes, clientData, ref decision, ref policyResult);

                if (!PolicyOps.IsSuccess(code, decision))
                {
                    if (policyResult != null)
                        result = policyResult;
                    else
                        result = "plugin bytes cannot be loaded, denied by policy";

                    return ReturnCode.Error;
                }

                if (!FlagOps.HasFlags(flags, PluginFlags.Reserved2, true) &&
                    !IsPrimarySystemThread())
                {
                    result = "plugin bytes cannot be loaded, wrong thread";
                    return ReturnCode.Error;
                }

                if (FlagOps.HasFlags(flags, PluginFlags.VerifiedOnly, true) &&
                    (FlagOps.HasFlags(flags, PluginFlags.SkipVerified, true) ||
                    !RuntimeOps.IsStrongNameVerified(assemblyBytes, true)))
                {
                    result = "plugin bytes are not strong name signed or cannot be verified";
                    return ReturnCode.Error;
                }

                if (FlagOps.HasFlags(flags, PluginFlags.TrustedOnly, true) &&
                    (FlagOps.HasFlags(flags, PluginFlags.SkipTrusted, true) ||
                    !RuntimeOps.IsFileTrusted(assemblyBytes)))
                {
                    result = "plugin bytes are not Authenticode signed or cannot be trusted";
                    return ReturnCode.Error;
                }

                string friendlyName = FormatOps.AppDomainFriendlyName(
                    (string)null, typeName);

                bool verbose = FlagOps.HasFlags(flags, PluginFlags.Verbose, true);

#if ISOLATED_PLUGINS && SHELL
                bool disallowUpdateCheck = false;
#endif

#if ISOLATED_PLUGINS
                bool isolated = FlagOps.HasFlags(flags, PluginFlags.Isolated, true);

                if (!isolated
#if SHELL
                        || ShouldAllowUpdateCheck(flags, ref disallowUpdateCheck)
#endif
                    )
                {
                    //
                    // BUGFIX: *HACK* The preview feature is useless if we cannot
                    //         create the correct AppDomain paths; therefore, make
                    //         sure the AppDomain base directory is the parent of
                    //         the directory that contains the core library assembly.
                    //
                    if (!FlagOps.HasFlags(flags, PluginFlags.NoPreview, true) &&
                        GlobalState.VerifyAppDomainBaseDirectory(this, friendlyName))
                    {
                        //
                        // HACK: This is very expensive; it creates an entirely new
                        //       application domain in order to pre-load the target
                        //       plugin assembly and grab the flags associated with
                        //       its primary plugin without having to actually load
                        //       a runnable copy of the plugin assembly (i.e. it is
                        //       loaded for reflection use only).
                        //
                        PluginFlags previewFlags = flags;
                        IPluginData previewPluginData = null;
                        Uri previewUpdateUri = null;

                        if (RuntimeOps.PreviewPluginFlagsAndUpdateUri(
                                this, assemblyBytes, typeName, ref previewFlags,
                                ref previewPluginData, ref previewUpdateUri,
                                ref result) != ReturnCode.Ok)
                        {
                            return ReturnCode.Error;
                        }

                        TraceOps.DebugTrace(String.Format(
                            "LoadPlugin: preview, assemblyBytes = {0}, " +
                            "flags = {1}, previewFlags = {2}, updateUri = {3}",
                            FormatOps.HashBytes(assemblyBytes),
                            FormatOps.WrapOrNull(flags),
                            FormatOps.WrapOrNull(previewFlags),
                            FormatOps.WrapOrNull(previewUpdateUri)),
                            typeof(Interpreter).Name,
                            TracePriority.RemotingDebug2);

#if SHELL
                        //
                        // BUGFIX: If a security plugin is loading from within the
                        //         security support subsystem in ScriptOps, always
                        //         skip the update checks.
                        //
                        if ((ShouldAllowUpdateCheck(flags, ref disallowUpdateCheck) ||
                            ShouldAllowUpdateCheck(previewFlags, ref disallowUpdateCheck)) &&
                            (SecurityLevels == 0))
                        {
                            IUpdateData updateData = new UpdateData(
                                previewPluginData, ActionType.DownloadAndExtractUpdate,
                                _Shared.ReleaseType.Plugin, _Shared.UpdateType.Plugin,
                                false, true, false, false);

                            if (ShellOps.HaveRequiredUpdateData(updateData))
                            {
                                ReturnCode updateCode;
                                int updateErrorLine = 0; /* NOT USED */
                                Result updateResult = null;

                                updateCode = ShellOps.CheckForUpdate(
                                    this, updateData, false, ref updateErrorLine,
                                    ref updateResult);

                                if (updateCode == ReturnCode.Ok)
                                {
                                    flags |= PluginFlags.UpdateCheck;
                                }
                                else
                                {
                                    result = updateResult;
                                    return ReturnCode.Error;
                                }
                            }
                        }
#endif

                        bool disallowIsolatedOnly = false;

                        if (!isolated &&
                            (ShouldAllowIsolatedOnly(flags, ref disallowIsolatedOnly) ||
                            ShouldAllowIsolatedOnly(previewFlags, ref disallowIsolatedOnly)))
                        {
                            flags |= PluginFlags.Isolated;
                            isolated = true;
                        }
                    }
                }

                bool noIsolated = FlagOps.HasFlags(flags, PluginFlags.NoIsolated, true);

                if (noIsolated)
                {
                    flags &= ~PluginFlags.Isolated;
                    isolated = false;
                }
#endif

                AppDomain appDomain = null;

#if ISOLATED_PLUGINS
                try
#endif
                {
                    code = AppDomainOps.GetOrCreate(
                        this,
                        friendlyName,
                        null, null,
#if CAS_POLICY
                        evidence,
#endif
                        clientData,
#if ISOLATED_PLUGINS
                        isolated,
#else
                        false,
#endif
                        true,
#if ISOLATED_PLUGINS
                        FlagOps.HasFlags(flags, PluginFlags.VerifyCoreAssembly, true),
                        !FlagOps.HasFlags(flags, PluginFlags.NoUseEntryAssembly, true),
                        FlagOps.HasFlags(flags, PluginFlags.OptionalEntryAssembly, true),
#else
                        false, false, false,
#endif
                        ref appDomain, ref result);

                    if (code == ReturnCode.Ok)
                    {
#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Plugin, NotifyFlags.PreLoad,
                            new ObjectList(appDomain, assemblyBytes, symbolBytes,
                                typeName, flags, plugin), this,
                            clientData, null, null, ref result);
#endif

#if ISOLATED_PLUGINS
                        AssemblyName assemblyName = null;
                        Uri uri = null;
                        Uri updateUri = null;
#endif
                        Assembly assembly = null;
#if ISOLATED_PLUGINS
                        DateTime? dateTime = null;
#endif

                        try
                        {
                            PluginLoadHelper loadHelper = PluginLoadHelper.Create(
                                assemblyBytes, symbolBytes, typeName, null,
#if CAS_POLICY
#if ISOLATED_PLUGINS
                                isolated ? null : evidence,
#else
                                evidence,
#endif
#endif
                                PluginLoaderFlags.Load | (verbose ?
                                    PluginLoaderFlags.Verbose : PluginLoaderFlags.None));

#if CAS_POLICY
                            AppDomainOps.DoCallBack(appDomain, loadHelper.CasLoad3);
#else
                            AppDomainOps.DoCallBack(appDomain, loadHelper.NoCasLoad2);
#endif

#if ISOLATED_PLUGINS
                            if (isolated)
                            {
                                //
                                // NOTE: Get the plugin property helper for the plugin being
                                //       loaded from the plugin load helper.
                                //
                                PluginPropertyHelper propertyHelper = loadHelper.PropertyHelper;

                                if (propertyHelper != null)
                                {
                                    //
                                    // NOTE: Grab the name of the resolved and loaded assembly
                                    //       for the plugin being loaded from the plugin property
                                    //       helper.
                                    //
                                    assemblyName = propertyHelper.AssemblyName;

                                    //
                                    // NOTE: Grab the date/time for the plugin from the plugin
                                    //       property helper.
                                    //
                                    dateTime = propertyHelper.DateTime;

                                    //
                                    // NOTE: Grab the full name of the type for this plugin from
                                    //       the plugin property helper.  This is needed to
                                    //       determine exactly which class we need to create for
                                    //       the plugin being loaded in case a plugin assembly
                                    //       contains multiple plugins.
                                    //
                                    typeName = propertyHelper.TypeName;

                                    //
                                    // NOTE: Grab the URI for the plugin being loaded from the
                                    //       plugin property helper.  This is needed to pass to
                                    //       the constructor of the plugin type.
                                    //
                                    uri = propertyHelper.Uri;

                                    //
                                    // NOTE: Grab the update URI for the plugin being loaded from
                                    //       the plugin property helper.  This is needed to pass
                                    //       to the constructor of the plugin type.
                                    //
                                    updateUri = propertyHelper.UpdateUri;

                                    //
                                    // NOTE: Grab the extra plugin flags from the plugin property
                                    //       helper and combine them with the ones specified by
                                    //       the caller.
                                    //
                                    flags |= propertyHelper.PluginFlags;
                                }
                                else
                                {
                                    //
                                    // NOTE: We require the plugin property helper to be available
                                    //       and cannot continue to load the plugin without it.
                                    //
                                    result = "invalid plugin property helper";
                                    code = ReturnCode.Error;
                                }
                            }
                            else
#endif
                            {
                                //
                                // NOTE: Grab the loaded assembly directly from the plugin load
                                //       helper.  This is only legal (i.e. it will only work) when
                                //       we load the plugin assembly into the current application
                                //       domain.
                                //
                                assembly = loadHelper.Assembly;
                            }
                        }
                        catch (Exception e)
                        {
                            result = String.Format(
                                "caught exception while loading plugin: {0}",
                                e);

                            code = ReturnCode.Error;
                        }

                        if ((code == ReturnCode.Ok) &&
#if ISOLATED_PLUGINS
                            !isolated &&
#endif
                            String.IsNullOrEmpty(typeName))
                        {
                            //
                            // NOTE: Introspect the assembly for types that implement the IPlugin
                            //       interface and simply default to loading the first one marked
                            //       as 'Primary' that we find.
                            //
                            code = RuntimeOps.FindPrimaryPlugin(
                                assembly, verbose, ref typeName, ref result);
                        }

                        if (code == ReturnCode.Ok)
                        {
#if ISOLATED_PLUGINS
                            if (isolated)
                            {
                                code = CreatePlugin(this, ruleSet,
                                    appDomain, assemblyName, dateTime, null,
                                    typeName, uri, updateUri, clientData,
                                    flags, false, ref plugin, ref result);
                            }
                            else
#endif
                            {
                                code = CreatePlugin(this, ruleSet,
                                    appDomain, assembly, null, typeName,
                                    clientData, flags, ref plugin,
                                    ref result);
                            }

#if NOTIFY
                            if (code == ReturnCode.Ok)
                            {
                                /* IGNORED */
                                CheckNotification(
                                    NotifyType.Plugin, NotifyFlags.Load,
                                    new ObjectList(appDomain, assemblyBytes, symbolBytes,
                                        typeName, flags, plugin), this,
                                    clientData, null, null, ref result);
                            }
#endif
                        }
                    }
                }
#if ISOLATED_PLUGINS
                finally
                {
                    if ((code != ReturnCode.Ok) && isolated && (appDomain != null))
                    {
                        UnloadAppDomainForPlugin(
                            plugin, clientData, friendlyName, appDomain);
                    }
                }
#endif
            }
            else
            {
                result = "invalid assembly bytes";
                code = ReturnCode.Error;
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        [Obsolete()]
        internal ReturnCode LoadPlugin( /* NOT USED */
            IRuleSet ruleSet,
            AssemblyName assemblyName,
#if CAS_POLICY
            Evidence evidence,
#endif
            string typeName,
            IClientData clientData,
            PluginFlags flags,
            ref IPlugin plugin,
            ref Result result
            )
        {
            ReturnCode code = ReturnCode.Ok;

            if (assemblyName != null)
            {
                PolicyDecision decision = PolicyDecision.None;
                Result policyResult = null;

                code = CheckPluginPolicies(
                    PolicyFlags.EngineBeforePlugin, assemblyName, typeName, null,
                    null, clientData, ref decision, ref policyResult);

                if (!PolicyOps.IsSuccess(code, decision))
                {
                    if (policyResult != null)
                        result = policyResult;
                    else
                        result = "plugin assembly name cannot be loaded, denied by policy";

                    return ReturnCode.Error;
                }

                if (!FlagOps.HasFlags(flags, PluginFlags.Reserved2, true) &&
                    !IsPrimarySystemThread())
                {
                    result = "plugin assembly name cannot be loaded, wrong thread";
                    return ReturnCode.Error;
                }

#if ISOLATED_PLUGINS
                bool isolated = FlagOps.HasFlags(flags, PluginFlags.Isolated, true);
                bool noIsolated = FlagOps.HasFlags(flags, PluginFlags.NoIsolated, true);

                if (noIsolated)
                {
                    flags &= ~PluginFlags.Isolated;
                    isolated = false;
                }
#endif

                string friendlyName = FormatOps.AppDomainFriendlyName(
                    assemblyName, typeName);

                AppDomain appDomain = null;

#if ISOLATED_PLUGINS
                try
#endif
                {
                    code = AppDomainOps.GetOrCreate(
                        this,
                        friendlyName,
                        null, null,
#if CAS_POLICY
                        evidence,
#endif
                        clientData,
#if ISOLATED_PLUGINS
                        isolated,
#else
                        false,
#endif
                        true,
#if ISOLATED_PLUGINS
                        FlagOps.HasFlags(flags, PluginFlags.VerifyCoreAssembly, true),
                        !FlagOps.HasFlags(flags, PluginFlags.NoUseEntryAssembly, true),
                        FlagOps.HasFlags(flags, PluginFlags.OptionalEntryAssembly, true),
#else
                        false, false, false,
#endif
                        ref appDomain, ref result);

                    if (code == ReturnCode.Ok)
                    {
#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Plugin, NotifyFlags.PreLoad,
                            new ObjectList(appDomain, assemblyName, typeName, flags, plugin), this,
                            clientData, null, null, ref result);
#endif

                        Assembly assembly = null;
                        string fileName = null;

                        try
                        {
                            //
                            // BUGBUG: This will not work when using isolated AppDomains
                            //         (which is mostly fine because we never load plugins
                            //         via this method overload anyhow).
                            //
                            // NOTE: To expand upon the above, this is due to the limitations
                            //       documented in MSDN for this overload of the Load method,
                            //       which state that the target assembly will be loaded into
                            //       both application domains when the AppDomain used here is
                            //       different from the current application domain.
                            //
                            assembly = appDomain.Load(
                                assemblyName
#if CAS_POLICY
                                , evidence
#endif
                            );

                            fileName = assembly.Location;
                        }
                        catch (Exception e)
                        {
                            result = String.Format(
                                "caught exception while loading plugin: {0}",
                                e);

                            code = ReturnCode.Error;
                        }

                        if (code == ReturnCode.Ok)
                        {
                            code = CreatePlugin(this, ruleSet,
                                appDomain, assembly, fileName, typeName,
                                clientData, flags, ref plugin, ref result);
                        }

#if NOTIFY
                        if (code == ReturnCode.Ok)
                        {
                            /* IGNORED */
                            CheckNotification(
                                NotifyType.Plugin, NotifyFlags.Load,
                                new ObjectList(appDomain, fileName, typeName, flags, plugin), this,
                                clientData, null, null, ref result);
                        }
#endif
                    }
                }
#if ISOLATED_PLUGINS
                finally
                {
                    if ((code != ReturnCode.Ok) && isolated && (appDomain != null))
                    {
                        UnloadAppDomainForPlugin(
                            plugin, clientData, friendlyName, appDomain);
                    }
                }
#endif
            }
            else
            {
                result = "invalid assembly name";
                code = ReturnCode.Error;
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode LoadPlugin(
            IRuleSet ruleSet,
            string fileName,
#if CAS_POLICY
            Evidence evidence,
            byte[] hashValue,
            AssemblyHashAlgorithm hashAlgorithm,
#endif
            string typeName,
            IClientData clientData,
            PluginFlags flags,
            ref IPlugin plugin,
            ref Result result
            )
        {
            ReturnCode code = ReturnCode.Ok;

            if (!String.IsNullOrEmpty(fileName) && File.Exists(fileName))
            {
                PolicyDecision decision = PolicyDecision.None;
                Result policyResult = null;

                code = CheckPluginPolicies(
                    PolicyFlags.EngineBeforePlugin, null, typeName, fileName,
                    null, clientData, ref decision, ref policyResult);

                if (!PolicyOps.IsSuccess(code, decision))
                {
                    if (policyResult != null)
                        result = policyResult;
                    else
                        result = "plugin file cannot be loaded, denied by policy";

                    return ReturnCode.Error;
                }

                if (!FlagOps.HasFlags(flags, PluginFlags.Reserved2, true) &&
                    !IsPrimarySystemThread())
                {
                    result = "plugin file cannot be loaded, wrong thread";
                    return ReturnCode.Error;
                }

                if (FlagOps.HasFlags(flags, PluginFlags.VerifiedOnly, true) &&
                    (FlagOps.HasFlags(flags, PluginFlags.SkipVerified, true) ||
                    !RuntimeOps.IsStrongNameVerified(fileName, true)))
                {
                    result = "plugin file is not strong name signed or cannot be verified";
                    return ReturnCode.Error;
                }

                if (FlagOps.HasFlags(flags, PluginFlags.TrustedOnly, true) &&
                    (FlagOps.HasFlags(flags, PluginFlags.SkipTrusted, true) ||
                    !RuntimeOps.IsFileTrusted(fileName, IntPtr.Zero)))
                {
                    result = "plugin file is not Authenticode signed or cannot be trusted";
                    return ReturnCode.Error;
                }

                string friendlyName = FormatOps.AppDomainFriendlyName(
                    fileName, typeName);

                bool verbose = FlagOps.HasFlags(flags, PluginFlags.Verbose, true);

#if ISOLATED_PLUGINS && SHELL
                bool disallowUpdateCheck = false;
#endif

#if ISOLATED_PLUGINS
                bool isolated = FlagOps.HasFlags(flags, PluginFlags.Isolated, true);

                if (!isolated
#if SHELL
                        || ShouldAllowUpdateCheck(flags, ref disallowUpdateCheck)
#endif
                    )
                {
                    //
                    // BUGFIX: *HACK* The preview feature is useless if we cannot
                    //         create the correct AppDomain paths; therefore, make
                    //         sure the AppDomain base directory is the parent of
                    //         the directory that contains the core library assembly.
                    //
                    if (!FlagOps.HasFlags(flags, PluginFlags.NoPreview, true) &&
                        GlobalState.VerifyAppDomainBaseDirectory(this, friendlyName))
                    {
                        //
                        // HACK: This is very expensive; it creates an entirely new
                        //       application domain in order to pre-load the target
                        //       plugin assembly and grab the flags associated with
                        //       its primary plugin without having to actually load
                        //       a runnable copy of the plugin assembly (i.e. it is
                        //       loaded for reflection use only).
                        //
                        PluginFlags previewFlags = flags;
                        IPluginData previewPluginData = null;
                        Uri previewUpdateUri = null;

                        if (RuntimeOps.PreviewPluginFlagsAndUpdateUri(
                                this, fileName, typeName, ref previewFlags,
                                ref previewPluginData, ref previewUpdateUri,
                                ref result) != ReturnCode.Ok)
                        {
                            return ReturnCode.Error;
                        }

                        TraceOps.DebugTrace(String.Format(
                            "LoadPlugin: preview, fileName = {0}, " +
                            "flags = {1}, previewFlags = {2}, updateUri = {3}",
                            FormatOps.WrapOrNull(fileName),
                            FormatOps.WrapOrNull(flags),
                            FormatOps.WrapOrNull(previewFlags),
                            FormatOps.WrapOrNull(previewUpdateUri)),
                            typeof(Interpreter).Name,
                            TracePriority.RemotingDebug2);

#if SHELL
                        //
                        // BUGFIX: If a security plugin is loading from within the
                        //         security support subsystem in ScriptOps, always
                        //         skip the update checks.
                        //
                        if ((ShouldAllowUpdateCheck(flags, ref disallowUpdateCheck) ||
                            ShouldAllowUpdateCheck(previewFlags, ref disallowUpdateCheck)) &&
                            (SecurityLevels == 0))
                        {
                            IUpdateData updateData = new UpdateData(
                                previewPluginData, ActionType.DownloadAndExtractUpdate,
                                _Shared.ReleaseType.Plugin, _Shared.UpdateType.Plugin,
                                false, true, false, false);

                            if (ShellOps.HaveRequiredUpdateData(updateData))
                            {
                                ReturnCode updateCode;
                                int updateErrorLine = 0; /* NOT USED */
                                Result updateResult = null;

                                updateCode = ShellOps.CheckForUpdate(
                                    this, updateData, false, ref updateErrorLine,
                                    ref updateResult);

                                if (updateCode == ReturnCode.Ok)
                                {
                                    flags |= PluginFlags.UpdateCheck;
                                }
                                else
                                {
                                    result = updateResult;
                                    return ReturnCode.Error;
                                }
                            }
                        }
#endif

                        bool disallowIsolatedOnly = false;

                        if (!isolated &&
                            (ShouldAllowIsolatedOnly(flags, ref disallowIsolatedOnly) ||
                            ShouldAllowIsolatedOnly(previewFlags, ref disallowIsolatedOnly)))
                        {
                            flags |= PluginFlags.Isolated;
                            isolated = true;
                        }
                    }
                }

                bool noIsolated = FlagOps.HasFlags(flags, PluginFlags.NoIsolated, true);

                if (noIsolated)
                {
                    flags &= ~PluginFlags.Isolated;
                    isolated = false;
                }
#endif

                AppDomain appDomain = null;

#if ISOLATED_PLUGINS
                try
#endif
                {
                    code = AppDomainOps.GetOrCreate(
                        this,
                        friendlyName,
                        null, Path.GetDirectoryName(fileName),
#if CAS_POLICY
                        evidence,
#endif
                        clientData,
#if ISOLATED_PLUGINS
                        isolated,
#else
                        false,
#endif
                        true,
#if ISOLATED_PLUGINS
                        FlagOps.HasFlags(flags, PluginFlags.VerifyCoreAssembly, true),
                        !FlagOps.HasFlags(flags, PluginFlags.NoUseEntryAssembly, true),
                        FlagOps.HasFlags(flags, PluginFlags.OptionalEntryAssembly, true),
#else
                        false, false, false,
#endif
                        ref appDomain, ref result);

                    if (code == ReturnCode.Ok)
                    {
#if NOTIFY
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Plugin, NotifyFlags.PreLoad,
                            new ObjectList(appDomain, fileName, typeName, flags, plugin), this,
                            clientData, null, null, ref result);
#endif

#if ISOLATED_PLUGINS
                        AssemblyName assemblyName = null;
                        Uri uri = null;
                        Uri updateUri = null;
#endif
                        Assembly assembly = null;
#if ISOLATED_PLUGINS
                        DateTime? dateTime = null;
#endif

                        try
                        {
                            PluginLoadHelper loadHelper = PluginLoadHelper.Create(
                                fileName, typeName, null,
#if CAS_POLICY
#if ISOLATED_PLUGINS
                                isolated ? null : evidence,
#else
                                evidence,
#endif
#if !MONO && !MONO_HACKS
                                hashValue, hashAlgorithm,
#endif
#endif
                                PluginLoaderFlags.Load | (verbose ?
                                    PluginLoaderFlags.Verbose : PluginLoaderFlags.None));

#if CAS_POLICY
#if !MONO && !MONO_HACKS
                            if (!CommonOps.Runtime.IsMono())
                                AppDomainOps.DoCallBack(appDomain, loadHelper.CasLoad4);
                            else
#endif
                                AppDomainOps.DoCallBack(appDomain, loadHelper.CasLoad2);
#else
                                AppDomainOps.DoCallBack(appDomain, loadHelper.NoCasLoad1);
#endif

#if ISOLATED_PLUGINS
                            if (isolated)
                            {
                                //
                                // NOTE: Get the plugin property helper for the plugin being
                                //       loaded from the plugin load helper.
                                //
                                PluginPropertyHelper propertyHelper = loadHelper.PropertyHelper;

                                if (propertyHelper != null)
                                {
                                    //
                                    // NOTE: Grab the name of the resolved and loaded assembly
                                    //       for the plugin being loaded from the plugin property
                                    //       helper.
                                    //
                                    assemblyName = propertyHelper.AssemblyName;

                                    //
                                    // NOTE: Grab the date/time for the plugin from the plugin
                                    //       property helper.
                                    //
                                    dateTime = propertyHelper.DateTime;

                                    //
                                    // NOTE: Grab the full name of the type for this plugin from
                                    //       the plugin property helper.  This is needed to
                                    //       determine exactly which class we need to create for
                                    //       the plugin being loaded in case a plugin assembly
                                    //       contains multiple plugins.
                                    //
                                    typeName = propertyHelper.TypeName;

                                    //
                                    // NOTE: Grab the URI for the plugin being loaded from the
                                    //       plugin property helper.  This is needed to pass to
                                    //       the constructor of the plugin type.
                                    //
                                    uri = propertyHelper.Uri;

                                    //
                                    // NOTE: Grab the update URI for the plugin being loaded from
                                    //       the plugin property helper.  This is needed to pass
                                    //       to the constructor of the plugin type.
                                    //
                                    updateUri = propertyHelper.UpdateUri;

                                    //
                                    // NOTE: Grab the extra plugin flags from the plugin property
                                    //       helper and combine them with the ones specified by
                                    //       the caller.
                                    //
                                    flags |= propertyHelper.PluginFlags;
                                }
                                else
                                {
                                    //
                                    // NOTE: We require the plugin property helper to be available
                                    //       and cannot continue to load the plugin without it.
                                    //
                                    result = "invalid plugin property helper";
                                    code = ReturnCode.Error;
                                }
                            }
                            else
#endif
                            {
                                //
                                // NOTE: Grab the loaded assembly directly from the plugin load
                                //       helper.  This is only legal (i.e. it will only work) when
                                //       we load the plugin assembly into the current application
                                //       domain.
                                //
                                assembly = loadHelper.Assembly;
                            }
                        }
                        catch (Exception e)
                        {
                            result = String.Format(
                                "caught exception while loading plugin: {0}",
                                e);

                            code = ReturnCode.Error;
                        }

                        if ((code == ReturnCode.Ok) &&
#if ISOLATED_PLUGINS
                            !isolated &&
#endif
                            String.IsNullOrEmpty(typeName))
                        {
                            //
                            // NOTE: Introspect the assembly for types that implement the IPlugin
                            //       interface and simply default to loading the first one marked
                            //       as 'Primary' that we find.
                            //
                            code = RuntimeOps.FindPrimaryPlugin(
                                assembly, verbose, ref typeName, ref result);
                        }

                        if (code == ReturnCode.Ok)
                        {
#if ISOLATED_PLUGINS
                            if (isolated)
                            {
                                code = CreatePlugin(this, ruleSet,
                                    appDomain, assemblyName, dateTime, fileName,
                                    typeName, uri, updateUri, clientData, flags,
                                    false, ref plugin, ref result);
                            }
                            else
#endif
                            {
                                code = CreatePlugin(this, ruleSet,
                                    appDomain, assembly, fileName, typeName,
                                    clientData, flags, ref plugin, ref result);
                            }

#if NOTIFY
                            if (code == ReturnCode.Ok)
                            {
                                /* IGNORED */
                                CheckNotification(
                                    NotifyType.Plugin, NotifyFlags.Load,
                                    new ObjectList(appDomain, fileName, typeName, flags, plugin), this,
                                    clientData, null, null, ref result);
                            }
#endif
                        }
                    }
                }
#if ISOLATED_PLUGINS
                finally
                {
                    if ((code != ReturnCode.Ok) && isolated && (appDomain != null))
                    {
                        UnloadAppDomainForPlugin(
                            plugin, clientData, friendlyName, appDomain);
                    }
                }
#endif
            }
            else
            {
                result = "invalid assembly file name";
                code = ReturnCode.Error;
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if ISOLATED_PLUGINS
#if SHELL
        private static bool ShouldAllowUpdateCheck(
            PluginFlags flags, /* in */
            ref bool disallow  /* in, out */
            )
        {
            if (disallow)
                return false;

            if (FlagOps.HasFlags(flags, PluginFlags.NoUpdateCheck, true))
            {
                disallow = true;
                return false;
            }

            return FlagOps.HasFlags(flags, PluginFlags.UpdateCheck, true);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool ShouldAllowIsolatedOnly(
            PluginFlags flags, /* in */
            ref bool disallow  /* in, out */
            )
        {
            if (disallow)
                return false;

            if (FlagOps.HasFlags(flags, PluginFlags.NoIsolatedOnly, true))
            {
                disallow = true;
                return false;
            }

            return FlagOps.HasFlags(flags, PluginFlags.IsolatedOnly, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReturnCode CreatePlugin(
            Interpreter interpreter,   /* in: OPTIONAL */
            IRuleSet ruleSet,          /* in */
            AppDomain appDomain,       /* in */
            AssemblyName assemblyName, /* in */
            DateTime? dateTime,        /* in: OPTIONAL */
            string fileName,           /* in: OPTIONAL */
            string typeName,           /* in */
            Uri uri,                   /* in */
            Uri updateUri,             /* in: OPTIONAL */
            IClientData clientData,    /* in: OPTIONAL */
            PluginFlags flags,         /* in */
            bool loadFrom,             /* in */
            ref IPlugin plugin,        /* out */
            ref Result error           /* out */
            )
        {
            if (appDomain == null)
            {
                error = "invalid application domain";
                return ReturnCode.Error;
            }

            if (assemblyName == null)
            {
                error = "invalid assembly name";
                return ReturnCode.Error;
            }

            if (typeName == null)
            {
                error = "invalid type name";
                return ReturnCode.Error;
            }

            if (uri == null)
            {
                error = "invalid uri";
                return ReturnCode.Error;
            }

            try
            {
                //
                // NOTE: Setup the arguments for plugin constructor.
                //       Unfortunately, constructors cannot be part
                //       of an interface; however, we require all
                //       plugins to expose a constructor with argument
                //       types compatible with the values we supply
                //       here.  If a plugin does not comply with this
                //       requirement then it cannot be loaded by the
                //       plugin loader and will not be available for
                //       use by scripts.
                //
                // WARNING: Please do not change this because it will
                //          prevent any plugins from loading that have
                //          not been updated to use the new argument
                //          list.
                //
                object[] args = {
                    CreatePluginData(
                        null, null, assemblyName, dateTime, fileName,
                        typeName, uri, updateUri, clientData, flags
                    )
                };

                BindingFlags bindingFlags = (interpreter != null) ?
                    interpreter.CreateInstanceBindingFlags :
                    ObjectOps.GetBindingFlags(
                        MetaBindingFlags.PublicCreateInstance, true);

                bool success = false;
                IPlugin localPlugin = null;

                try
                {
                    //
                    // NOTE: Attempt to create an instance of the plugin.
                    //       If this throws an exception then the plugin
                    //       probably does not have a constructor matching
                    //       the arguments we are attempting to supply;
                    //       therefore, it is not in compliance with the
                    //       plugin loader interface and cannot be loaded.
                    //       Another common cause of failures here is that
                    //       the plugin has a different version of the core
                    //       Eagle runtime library specified in its manifest
                    //       than the one currently running.
                    //
                    if (loadFrom)
                    {
                        localPlugin = appDomain.CreateInstanceFromAndUnwrap(
                            assemblyName.ToString(), typeName, false,
                            bindingFlags, null, args, null, null,
                            null) as IPlugin;
                    }
                    else
                    {
                        localPlugin = appDomain.CreateInstanceAndUnwrap(
                            assemblyName.ToString(), typeName, false,
                            bindingFlags, null, args, null, null,
                            null) as IPlugin;
                    }

                    if (localPlugin == null)
                    {
                        error = String.Format(
                            "could not create plugin {0}",
                            FormatOps.WrapOrNull(typeName));

                        return ReturnCode.Error;
                    }

                    //
                    // NOTE: Plugins must have an ObjectId attribute.
                    //       Attempt to assign the ObjectId attribute
                    //       to the Id property now.
                    //
                    /* IGNORED */
                    EntityOps.MaybeSetupId(localPlugin);

                    //
                    // NOTE: We need the plugin to have a valid assembly
                    //       within it so that the command and policy
                    //       loaders will be able to use it.
                    //
                    PluginCreateHelper createHelper =
                        PluginCreateHelper.Create(ruleSet,
                            localPlugin, assemblyName,
                            flags);

                    AppDomainOps.DoCallBack(
                        appDomain, createHelper.Setup);

                    plugin = localPlugin;
                    success = true;

#if !DEBUG
                    ThreadOps.QueueUserWorkItem(new WaitCallback(
                        interpreter.ResetLicensedPlugins));
#endif

                    return ReturnCode.Ok;
                }
                finally
                {
                    if (!success &&
                        (localPlugin != null) && (interpreter != null))
                    {
                        ReturnCode terminateCode;
                        Result terminateResult = null;

                        terminateCode = interpreter.TerminatePlugin(
                            localPlugin, clientData, ref terminateResult);

                        if (terminateCode != ReturnCode.Ok)
                        {
                            DebugOps.Complain(interpreter,
                                terminateCode, terminateResult);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                error = e;
                return ReturnCode.Error;
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static IPluginData CreatePluginData(
            AppDomain appDomain,       /* in: OPTIONAL */
            Assembly assembly,         /* in: OPTIONAL */
            AssemblyName assemblyName, /* in */
            DateTime? dateTime,        /* in: OPTIONAL */
            string fileName,           /* in: OPTIONAL */
            string typeName,           /* in */
            Uri uri,                   /* in: OPTIONAL */
            Uri updateUri,             /* in: OPTIONAL */
            IClientData clientData,    /* in: OPTIONAL */
            PluginFlags flags          /* in */
            )
        {
            if (assemblyName == null)
                return null;

            return new PluginData(
                FormatOps.PluginName(assemblyName.FullName, typeName),
                null, null, clientData, flags, assemblyName.Version, uri,
                updateUri, appDomain, assembly, assemblyName, dateTime,
                fileName, typeName, null, null, null, null, null, null,
                null, null, 0
            );
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReturnCode CreatePlugin(
            Interpreter interpreter, /* in: OPTIONAL */
            IRuleSet ruleSet,        /* in */
            AppDomain appDomain,     /* in */
            Assembly assembly,       /* in */
            string fileName,         /* in: OPTIONAL */
            string typeName,         /* in */
            IClientData clientData,  /* in: OPTIONAL */
            PluginFlags flags,       /* in */
            ref IPlugin plugin,      /* out */
            ref Result error         /* out */
            )
        {
            if (appDomain == null)
            {
                error = "invalid application domain";
                return ReturnCode.Error;
            }

            if (assembly == null)
            {
                error = "invalid assembly";
                return ReturnCode.Error;
            }

            if (typeName == null)
            {
                error = "invalid type name";
                return ReturnCode.Error;
            }

            try
            {
                AssemblyName assemblyName = assembly.GetName();

                if (assemblyName == null)
                {
                    error = "invalid assembly name";
                    return ReturnCode.Error;
                }

                Type type = assembly.GetType(typeName, true, false);

                if (type == null)
                {
                    error = String.Format(
                        "plugin type {0} not found",
                        FormatOps.WrapOrNull(typeName));

                    return ReturnCode.Error;
                }

                //
                // NOTE: Get plugin flags related to the assembly
                //       itself and combine them with the ones we
                //       already have.
                //
                flags |= RuntimeOps.GetAssemblyPluginFlags(
                    assembly, RuntimeOps.GetSkipCheckPluginFlags());

                //
                // NOTE: Check if the plugin assembly contains a an
                //       AssemblyUri attribute.
                //
                Uri uri = _Shared.AttributeOps.GetAssemblyUri(assembly);

                //
                // NOTE: If the plugin assembly does NOT contain an
                //       AssemblyUri attribute, use the location.
                //
                if (uri == null)
                    uri = new Uri(assembly.Location); /* throw */

                //
                // NOTE: Check if the plugin assembly contains a an
                //       AssemblyUri attribute used for updates.
                //
                Uri updateUri =
                    _Shared.AttributeOps.GetAssemblyUpdateBaseUri(
                        assembly);

                //
                // NOTE: Attempt to grab the DateTime for this plugin
                //       assembly.
                //
                DateTime dateTime =
                    _Shared.AttributeOps.GetAssemblyDateTime(
                        assembly);

                //
                // NOTE: Setup the arguments for plugin constructor.
                //       Unfortunately, constructors cannot be part
                //       of an interface; however, we require all
                //       plugins to expose a constructor with argument
                //       types compatible with the values we supply
                //       here.  If a plugin does not comply with this
                //       requirement then it cannot be loaded by the
                //       plugin loader and will not be available for
                //       use by scripts.
                //
                // WARNING: Please do not change this because it will
                //          prevent any plugins from loading that have
                //          not been updated to use the new argument
                //          list.
                //
                object[] args = {
                    CreatePluginData(
                        appDomain, assembly, assemblyName, dateTime,
                        fileName, typeName, uri, updateUri, clientData,
                        flags
                    )
                };

                BindingFlags bindingFlags = (interpreter != null) ?
                    interpreter.CreateInstanceBindingFlags :
                    ObjectOps.GetBindingFlags(
                        MetaBindingFlags.PublicCreateInstance, true);

                bool success = false;
                IPlugin localPlugin = null;

                try
                {
                    //
                    // NOTE: Attempt to create an instance of the plugin.
                    //       If this throws an exception then the plugin
                    //       probably does not have a constructor matching
                    //       the arguments we are attempting to supply;
                    //       therefore, it is not in compliance with the
                    //       plugin loader interface and cannot be loaded.
                    //       Another common cause of failures here is that
                    //       the plugin has a different version of the core
                    //       Eagle runtime library specified in its manifest
                    //       than the one currently running.
                    //
                    localPlugin = assembly.CreateInstance(
                        type.FullName, false, bindingFlags, null,
                        args, null, null) as IPlugin;

                    if (localPlugin == null)
                    {
                        error = String.Format(
                            "could not create plugin {0}",
                            FormatOps.WrapOrNull(type.FullName));

                        return ReturnCode.Error;
                    }

                    //
                    // NOTE: Plugins must have an ObjectId attribute.
                    //       Attempt to assign the ObjectId attribute
                    //       to the Id property now.
                    //
                    /* IGNORED */
                    EntityOps.MaybeSetupId(localPlugin);

                    if (RuntimeOps.PopulatePluginEntities(
                            interpreter, localPlugin, null,
                            ruleSet, flags, null, false, false,
                            false, ref error) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }

                    plugin = localPlugin;
                    success = true;

#if !DEBUG
                    ThreadOps.QueueUserWorkItem(new WaitCallback(
                        interpreter.ResetLicensedPlugins));
#endif

                    return ReturnCode.Ok;
                }
                finally
                {
                    if (!success &&
                        (localPlugin != null) && (interpreter != null))
                    {
                        ReturnCode terminateCode;
                        Result terminateResult = null;

                        terminateCode = interpreter.TerminatePlugin(
                            localPlugin, clientData, ref terminateResult);

                        if (terminateCode != ReturnCode.Ok)
                        {
                            DebugOps.Complain(interpreter,
                                terminateCode, terminateResult);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                error = e;
                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetPluginCommands( /* POLICY HELPER METHOD */
            IPluginData pluginData,
            ref List<ICommand> commands,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (pluginData != null)
                {
                    if (HasCommands(ref error))
                    {
                        CommandDataList pluginCommands = pluginData.Commands;

                        if (pluginCommands != null)
                        {
                            List<ICommand> localCommands = new List<ICommand>();

                            foreach (ICommandData commandData in pluginCommands)
                            {
                                long token = EntityOps.GetToken(commandData);

                                if (token == 0)
                                    continue;

                                ICommand command = null;
                                ResultList errors = null;
                                Result localError = null;

                                if (GetCommand(token,
                                        LookupFlags.Default, ref command,
                                        ref localError) == ReturnCode.Ok)
                                {
                                    localCommands.Add(command);
                                    continue;
                                }

                                if (localError != null)
                                {
                                    if (errors == null)
                                        errors = new ResultList();

                                    errors.Add(localError);
                                }

                                localError = null;

                                if (GetHiddenCommand(token,
                                        LookupFlags.Default, ref command,
                                        ref localError) == ReturnCode.Ok)
                                {
                                    localCommands.Add(command);
                                    continue;
                                }

                                if (localError != null)
                                {
                                    if (errors == null)
                                        errors = new ResultList();

                                    errors.Add(localError);
                                }

                                error = errors;
                                return ReturnCode.Error;
                            }

                            if (commands == null)
                                commands = new List<ICommand>(localCommands);
                            else
                                commands.AddRange(localCommands);

                            return ReturnCode.Ok;
                        }
                        else
                        {
                            error = "plugin data has invalid command data list";
                        }
                    }
                }
                else
                {
                    error = "invalid plugin data";
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IPlugin GetCorePlugin()
        {
            Result error = null;

            return GetCorePlugin(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IPlugin GetCorePlugin(
            ref Result error
            )
        {
            if (corePluginToken != 0)
            {
                IPlugin plugin = null;

                if (GetPlugin(corePluginToken, LookupFlags.Default,
                        ref plugin, ref error) == ReturnCode.Ok)
                {
                    return plugin;
                }
            }
            else
            {
                error = "invalid core plugin token";
            }

            return null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IPlugin NewCorePlugin()
        {
            string typeName = typeof(_Plugins.Core).FullName;

            IPlugin plugin = new _Plugins.Core(
                new PluginData(FormatOps.PluginName(
                    GlobalState.GetAssemblyFullName(),
                    typeName), null, null,
                _ClientData.Empty, PluginFlags.None,
                GlobalState.GetAssemblyVersion(),
                GlobalState.GetAssemblyUri(), null,
                appDomain, GlobalState.GetAssembly(),
                GlobalState.GetAssemblyName(),
                GlobalState.GetAssemblyDateTime(),
                GlobalState.GetAssemblyLocation(),
                typeName, null, null, null, null,
                null, null, resourceManager, null,
                corePluginToken));

            /* IGNORED */
            GlobalState.PopulateAssemblyPluginFlags(
                this, plugin, false);

            return plugin;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY || NOTIFY_OBJECT
        private IPlugin GetObjectPlugin()
        {
            Result error = null;

            return GetObjectPlugin(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IPlugin GetObjectPlugin(
            ref Result error
            )
        {
            if (objectPluginToken != 0)
            {
                IPlugin plugin = null;

                if (GetPlugin(objectPluginToken, LookupFlags.Default,
                        ref plugin, ref error) == ReturnCode.Ok)
                {
                    return plugin;
                }
            }
            else
            {
                error = "invalid object plugin token";
            }

            return null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TEST
        private IPlugin GetScriptNotifyPlugin()
        {
            Result error = null;

            return GetScriptNotifyPlugin(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IPlugin GetScriptNotifyPlugin(
            ref Result error
            )
        {
            if (scriptNotifyPluginToken != 0)
            {
                IPlugin plugin = null;

                if (GetPlugin(scriptNotifyPluginToken, LookupFlags.Default,
                        ref plugin, ref error) == ReturnCode.Ok)
                {
                    return plugin;
                }
            }
            else
            {
                error = "invalid script notify plugin token";
            }

            return null;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IPlugin NewObjectPlugin()
        {
            string typeName = typeof(_Plugins.Object).FullName;

            IPlugin plugin = new _Plugins.Object(
                new PluginData(FormatOps.PluginName(
                    GlobalState.GetAssemblyFullName(),
                    typeName), null, null,
                _ClientData.Empty, PluginFlags.None,
                GlobalState.GetAssemblyVersion(),
                GlobalState.GetAssemblyUri(), null,
                appDomain, GlobalState.GetAssembly(),
                GlobalState.GetAssemblyName(),
                GlobalState.GetAssemblyDateTime(),
                GlobalState.GetAssemblyLocation(),
                typeName, null, null, null, null,
                null, null, resourceManager, null,
                objectPluginToken));

            /* IGNORED */
            GlobalState.PopulateAssemblyPluginFlags(
                this, plugin, false);

            return plugin;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TEST
        private IPlugin NewScriptNotifyPlugin(
            string text,
            NotifyType notifyTypes,
            NotifyFlags notifyFlags,
            EngineFlags engineFlags
            )
        {
            string typeName = typeof(_Tests.Default.ScriptNotifyPlugin).FullName;

            IPlugin plugin = new _Tests.Default.ScriptNotifyPlugin(
                new PluginData(FormatOps.PluginName(
                    GlobalState.GetAssemblyFullName(),
                    typeName), null, null,
                _ClientData.Empty, PluginFlags.None,
                GlobalState.GetAssemblyVersion(),
                GlobalState.GetAssemblyUri(), null,
                appDomain, GlobalState.GetAssembly(),
                GlobalState.GetAssemblyName(),
                GlobalState.GetAssemblyDateTime(),
                GlobalState.GetAssemblyLocation(),
                typeName, null, null, null, null,
                null, null, resourceManager, null,
                scriptNotifyPluginToken), text,
                notifyTypes, notifyFlags,
                engineFlags);

            /* IGNORED */
            GlobalState.PopulateAssemblyPluginFlags(
                this, plugin, false);

            return plugin;
        }
#endif
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY && NOTIFY_ARGUMENTS
        private IPlugin GetMonitorPlugin()
        {
            Result error = null;

            return GetMonitorPlugin(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IPlugin GetMonitorPlugin(
            ref Result error
            )
        {
            if (monitorPluginToken != 0)
            {
                IPlugin plugin = null;

                if (GetPlugin(monitorPluginToken, LookupFlags.Default,
                        ref plugin, ref error) == ReturnCode.Ok)
                {
                    return plugin;
                }
            }
            else
            {
                error = "invalid trace plugin token";
            }

            return null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IPlugin NewMonitorPlugin()
        {
            string typeName = typeof(_Plugins.Monitor).FullName;

            IPlugin plugin = new _Plugins.Monitor(
                new PluginData(FormatOps.PluginName(
                    GlobalState.GetAssemblyFullName(),
                    typeName), null, null,
                _ClientData.Empty, PluginFlags.None,
                GlobalState.GetAssemblyVersion(),
                GlobalState.GetAssemblyUri(), null,
                appDomain, GlobalState.GetAssembly(),
                GlobalState.GetAssemblyName(),
                GlobalState.GetAssemblyDateTime(),
                GlobalState.GetAssemblyLocation(),
                typeName, null, null, null, null,
                null, null, resourceManager, null,
                monitorPluginToken));

            /* IGNORED */
            GlobalState.PopulateAssemblyPluginFlags(
                this, plugin, false);

            return plugin;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TEST_PLUGIN || DEBUG
        private IPlugin GetTestPlugin()
        {
            Result error = null;

            return GetTestPlugin(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IPlugin GetTestPlugin(
            ref Result error
            )
        {
            if (testPluginToken != 0)
            {
                IPlugin plugin = null;

                if (GetPlugin(testPluginToken, LookupFlags.Default,
                        ref plugin, ref error) == ReturnCode.Ok)
                {
                    return plugin;
                }
            }
            else
            {
                error = "invalid test plugin token";
            }

            return null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IPlugin NewTestPlugin()
        {
            string typeName = typeof(_Plugins.Test).FullName;

            IPlugin plugin = new _Plugins.Test(
                new PluginData(FormatOps.PluginName(
                    GlobalState.GetAssemblyFullName(),
                    typeName), null, null,
                _ClientData.Empty, PluginFlags.None,
                GlobalState.GetAssemblyVersion(),
                GlobalState.GetAssemblyUri(), null,
                appDomain, GlobalState.GetAssembly(),
                GlobalState.GetAssemblyName(),
                GlobalState.GetAssemblyDateTime(),
                GlobalState.GetAssemblyLocation(),
                typeName, null, null, null, null,
                null, null, resourceManager, null,
                testPluginToken));

            /* IGNORED */
            GlobalState.PopulateAssemblyPluginFlags(
                this, plugin, false);

            return plugin;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TEST || TEST_PLUGIN || DEBUG
        //
        // WARNING: Do not use.  This is for external (TEST) use only.
        //
        private IPluginData NewTestPluginData(
            string typeName
            )
        {
            IPluginData pluginData = new PluginData(
                FormatOps.PluginName(
                    GlobalState.GetAssemblyFullName(),
                    typeName), null, null,
                _ClientData.Empty, PluginFlags.None,
                GlobalState.GetAssemblyVersion(),
                GlobalState.GetAssemblyUri(), null,
                appDomain, GlobalState.GetAssembly(),
                GlobalState.GetAssemblyName(),
                GlobalState.GetAssemblyDateTime(),
                GlobalState.GetAssemblyLocation(),
                typeName, null, null, null, null,
                null, null, resourceManager, null, 0);

            /* IGNORED */
            GlobalState.PopulateAssemblyPluginFlags(
                this, pluginData, false);

            return pluginData;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if !DEBUG
        private void ResetLicensedPlugins(
            object state /* in: NOT USED */
            )
        {
            IPluginData pluginData; /* REUSED */
            Result error; /* REUSED */

            ///////////////////////////////////////////////////////////////////////////////////////////

            lock (syncRoot) /* TRANSACTIONAL */
            {
                pluginData = GetCorePlugin();
                error = null;

                if (RuntimeOps.IsLicensed(
                        this, pluginData, ref error))
                {
                    EntityOps.SetLicensed(pluginData, true);
                }
                else
                {
                    EntityOps.SetLicensed(pluginData, false);

                    TraceOps.DebugTrace(String.Format(
                        "ResetLicensedPlugins: " +
                        "core plugin error = {0}",
                        FormatOps.WrapOrNull(error)),
                        typeof(Interpreter).Name,
                        TracePriority.PluginError2);
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY || NOTIFY_OBJECT
            lock (syncRoot) /* TRANSACTIONAL */
            {
                pluginData = GetObjectPlugin();
                error = null;

                if (RuntimeOps.IsLicensed(
                        this, pluginData, ref error))
                {
                    EntityOps.SetLicensed(pluginData, true);
                }
                else
                {
                    EntityOps.SetLicensed(pluginData, false);

                    TraceOps.DebugTrace(String.Format(
                        "ResetLicensedPlugins: " +
                        "object plugin error = {0}",
                        FormatOps.WrapOrNull(error)),
                        typeof(Interpreter).Name,
                        TracePriority.PluginError2);
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

#if TEST
            lock (syncRoot) /* TRANSACTIONAL */
            {
                pluginData = GetScriptNotifyPlugin();
                error = null;

                if (RuntimeOps.IsLicensed(
                        this, pluginData, ref error))
                {
                    EntityOps.SetLicensed(pluginData, true);
                }
                else
                {
                    EntityOps.SetLicensed(pluginData, false);

                    TraceOps.DebugTrace(String.Format(
                        "ResetLicensedPlugins: " +
                        "script notify plugin error = {0}",
                        FormatOps.WrapOrNull(error)),
                        typeof(Interpreter).Name,
                        TracePriority.PluginError2);
                }
            }
#endif
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY && NOTIFY_ARGUMENTS
            lock (syncRoot) /* TRANSACTIONAL */
            {
                pluginData = GetMonitorPlugin();
                error = null;

                if (RuntimeOps.IsLicensed(
                        this, pluginData, ref error))
                {
                    EntityOps.SetLicensed(pluginData, true);
                }
                else
                {
                    EntityOps.SetLicensed(pluginData, false);

                    TraceOps.DebugTrace(String.Format(
                        "ResetLicensedPlugins: " +
                        "monitor plugin error = {0}",
                        FormatOps.WrapOrNull(error)),
                        typeof(Interpreter).Name,
                        TracePriority.PluginError2);
                }
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if TEST_PLUGIN || DEBUG
            lock (syncRoot) /* TRANSACTIONAL */
            {
                pluginData = GetTestPlugin();
                error = null;

                if (RuntimeOps.IsLicensed(
                        this, pluginData, ref error))
                {
                    EntityOps.SetLicensed(pluginData, true);
                }
                else
                {
                    EntityOps.SetLicensed(pluginData, false);

                    TraceOps.DebugTrace(String.Format(
                        "ResetLicensedPlugins: " +
                        "test plugin error = {0}",
                        FormatOps.WrapOrNull(error)),
                        typeof(Interpreter).Name,
                        TracePriority.PluginError2);
                }
            }
#endif
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Assumes the interpreter lock is held.
        //
        private ReturnCode SetupPlugin(
            NewStaticPluginCallback callback, /* in */
            TypeList types,                   /* in */
            IRuleSet ruleSet,                 /* in */
            CommandFlags? commandFlags,       /* in */
            bool useBuiltIn,                  /* in */
            bool noCommands,                  /* in */
            bool noPolicies,                  /* in */
            ref long token,                   /* out */
            ref string name,                  /* out */
            ref PluginFlags flags,            /* out */
            ref Result error                  /* out */
            )
        {
            ReturnCode code;

            if (callback != null)
            {
                IPlugin plugin = callback();

                if (plugin != null)
                {
                    Result localResult = null;

                    code = RuntimeOps.PopulatePluginEntities(
                        this, plugin, types, ruleSet, pluginFlags,
                        commandFlags, useBuiltIn, noCommands,
                        noPolicies, ref localResult);

                    if (code == ReturnCode.Ok)
                    {
                        long localToken = 0;

                        code = AddPlugin(
                            plugin, null, ref localToken,
                            ref localResult);

                        if (code == ReturnCode.Ok)
                        {
                            token = localToken;
                            name = plugin.Name;
                            flags = plugin.Flags;
                        }
                        else
                        {
                            error = localResult;
                        }
                    }
                    else
                    {
                        error = localResult;
                    }
                }
                else
                {
                    error = String.Format(
                        "new plugin callback {0} failed",
                        FormatOps.WrapOrNull(
                            FormatOps.DelegateName(callback)));

                    code = ReturnCode.Error;
                }
            }
            else
            {
                error = "invalid new plugin callback";
                code = ReturnCode.Error;
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static bool ShouldUseBuiltIns(
            IdentifierKind kind
            )
        {
            switch (kind)
            {
                case IdentifierKind.Command:
                    {
                        return useBuiltInCommands;
                    }
                case IdentifierKind.Function:
                    {
                        return useBuiltInFunctions;
                    }
                case IdentifierKind.Operator:
                    {
                        return useBuiltInOperators;
                    }
                default:
                    {
                        return false;
                    }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Assumes the interpreter lock is held.
        //
        private ReturnCode SetupPlugins(
            IRuleSet ruleSet,           /* in */
            TypeList types,             /* in */
            CreateFlags createFlags,    /* in */
            CommandFlags? commandFlags, /* in */
            bool force,                 /* in */
            bool useBuiltIn,            /* in */
            bool noCommands,            /* in */
            ref Result error            /* out */
            )
        {
            if (!FlagOps.HasFlags(createFlags, CreateFlags.NoPlugins, true))
            {
                string pluginName; /* REUSED */
                PluginFlags pluginFlags; /* REUSED */
                bool nativeCode; /* REUSED */
                bool system; /* REUSED */

                if (!FlagOps.HasFlags(
                        createFlags, CreateFlags.NoCorePlugin, true))
                {
                    if (force || (corePluginToken == 0))
                    {
                        //
                        // HACK: The core plugin has no dynamically added policies.
                        //
                        pluginName = null;
                        pluginFlags = PluginFlags.None;

                        if (SetupPlugin(
                                NewCorePlugin, types, ruleSet,
                                commandFlags, useBuiltIn, noCommands, true,
                                ref corePluginToken,
                                ref pluginName, ref pluginFlags,
                                ref error) == ReturnCode.Ok)
                        {
                            nativeCode = FlagOps.HasFlags(
                                pluginFlags, PluginFlags.NativeCode, true);

                            system = FlagOps.HasFlags(
                                pluginFlags, PluginFlags.System, true);

                            TraceOps.DebugTrace(String.Format(
                                "SetupPlugins: prepared/added {0} {1} core plugin {2}",
                                nativeCode ? "native" : "managed", system ? "system" : "user",
                                FormatOps.WrapOrNull(pluginName)), typeof(Interpreter).Name,
                                TracePriority.StartupDebug);
                        }
                        else
                        {
                            return ReturnCode.Error;
                        }
                    }
                }

                ///////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY || NOTIFY_OBJECT
                if (!FlagOps.HasFlags(
                        createFlags, CreateFlags.NoObjectPlugin, true))
                {
                    if (force || (objectPluginToken == 0))
                    {
                        //
                        // HACK: The object plugin has no dynamically added policies.
                        //
                        pluginName = null;
                        pluginFlags = PluginFlags.None;

                        if (SetupPlugin(
                                NewObjectPlugin, types, ruleSet,
                                commandFlags, false, true, true,
                                ref objectPluginToken,
                                ref pluginName, ref pluginFlags,
                                ref error) == ReturnCode.Ok)
                        {
                            nativeCode = FlagOps.HasFlags(
                                pluginFlags, PluginFlags.NativeCode, true);

                            system = FlagOps.HasFlags(
                                pluginFlags, PluginFlags.System, true);

                            TraceOps.DebugTrace(String.Format(
                                "SetupPlugins: prepared/added {0} {1} object plugin {2}",
                                nativeCode ? "native" : "managed", system ? "system" : "user",
                                FormatOps.WrapOrNull(pluginName)), typeof(Interpreter).Name,
                                TracePriority.StartupDebug);
                        }
                        else
                        {
                            return ReturnCode.Error;
                        }
                    }
                }
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY && NOTIFY_ARGUMENTS
                if (!FlagOps.HasFlags(
                        createFlags, CreateFlags.NoMonitorPlugin, true))
                {
                    if (force || (monitorPluginToken == 0))
                    {
                        //
                        // HACK: The monitor plugin has no dynamically added policies.
                        //
                        pluginName = null;
                        pluginFlags = PluginFlags.None;

                        if (SetupPlugin(
                                NewMonitorPlugin, types, ruleSet,
                                commandFlags, false, true, true,
                                ref monitorPluginToken,
                                ref pluginName, ref pluginFlags,
                                ref error) == ReturnCode.Ok)
                        {
                            nativeCode = FlagOps.HasFlags(
                                pluginFlags, PluginFlags.NativeCode, true);

                            system = FlagOps.HasFlags(
                                pluginFlags, PluginFlags.System, true);

                            TraceOps.DebugTrace(String.Format(
                                "SetupPlugins: prepared/added {0} {1} trace plugin {2}",
                                nativeCode ? "native" : "managed", system ? "system" : "user",
                                FormatOps.WrapOrNull(pluginName)), typeof(Interpreter).Name,
                                TracePriority.StartupDebug);
                        }
                        else
                        {
                            return ReturnCode.Error;
                        }
                    }
                }
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

#if TEST_PLUGIN || DEBUG
                if (!FlagOps.HasFlags(
                        createFlags, CreateFlags.NoTestPlugin, true))
                {
                    if (force || (testPluginToken == 0))
                    {
                        //
                        // HACK: The test plugin has no dynamically added policies.
                        //
                        pluginName = null;
                        pluginFlags = PluginFlags.None;

                        if (SetupPlugin(
                                NewTestPlugin, types, ruleSet,
                                commandFlags, false, true, true,
                                ref testPluginToken,
                                ref pluginName, ref pluginFlags,
                                ref error) == ReturnCode.Ok)
                        {
                            nativeCode = FlagOps.HasFlags(
                                pluginFlags, PluginFlags.NativeCode, true);

                            system = FlagOps.HasFlags(
                                pluginFlags, PluginFlags.System, true);

                            TraceOps.DebugTrace(String.Format(
                                "SetupPlugins: prepared/added {0} {1} test plugin {2}",
                                nativeCode ? "native" : "managed", system ? "system" : "user",
                                FormatOps.WrapOrNull(pluginName)), typeof(Interpreter).Name,
                                TracePriority.StartupDebug);
                        }
                        else
                        {
                            return ReturnCode.Error;
                        }
                    }
                }
#endif
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Assumes the interpreter lock is held.
        //
        private ReturnCode RestorePlugin(
            NewStaticPluginCallback callback, /* in */
            bool useBuiltIn,                  /* in */
            bool noCommands,                  /* in */
            bool noPolicies,                  /* in */
            bool strict,                      /* in */
            ref long token,                   /* in, out */
            ref Result result                 /* out */
            )
        {
            long localToken = token;

            if (localToken != 0)
            {
                IPlugin plugin = null;
                Result localError = null;

                if ((GetPlugin(localToken,
                        LookupFlags.Default, ref plugin,
                        ref localError) == ReturnCode.Ok) &&
                    (AddCommands(
                        plugin, null, CommandFlags.Restore,
                        ref localError) == ReturnCode.Ok) &&
                    (MoveExposedAndHiddenCommands(
                        EntityOps.GetFlagsNoThrow(plugin),
                        ref localError) == ReturnCode.Ok) &&
                    (!strict || (SetupFunctions(
                        createFlags, pluginFlags, useBuiltIn,
                        ref localError) == ReturnCode.Ok)))
                {
                    result = String.Empty;
                    return ReturnCode.Ok;
                }
                else
                {
                    result = localError;
                }
            }
            else if (callback != null)
            {
                IPlugin plugin = callback();

                if (plugin != null)
                {
                    Result localResult = null;

                    if ((RuntimeOps.PopulatePluginEntities(
                            this, plugin, null, ruleSet, pluginFlags,
                            null, useBuiltIn, noCommands, noPolicies,
                            ref localResult) == ReturnCode.Ok) &&
                        (AddPlugin(plugin, null, ref localToken,
                            ref localResult) == ReturnCode.Ok) &&
                        (!strict || (SetupFunctions(
                            createFlags, pluginFlags, useBuiltIn,
                            ref localResult) == ReturnCode.Ok)))
                    {
                        token = localToken;
                        result = String.Empty;

                        return ReturnCode.Ok;
                    }
                    else
                    {
                        result = localResult;
                    }
                }
                else
                {
                    result = String.Format(
                        "new plugin callback {0} failed",
                        FormatOps.WrapOrNull(
                            FormatOps.DelegateName(callback)));
                }
            }
            else
            {
                result = "invalid new plugin callback";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Isolated Plugin Support
#if ISOLATED_PLUGINS
        private void UnloadAppDomainForPlugin(
            IPluginData pluginData,
            IClientData clientData,
            string friendlyName,
            AppDomain appDomain
            )
        {
            string pluginName = EntityOps.GetNameNoThrow(pluginData);
            string appDomainName = FormatOps.DisplayAppDomain(appDomain);

            TraceOps.DebugTrace(String.Format(
                "UnloadAppDomainForPlugin: interpreter = {0}, " +
                "pluginData = {1}, clientData = {2}, appDomainName = {3}",
                FormatOps.InterpreterNoThrow(this),
                FormatOps.WrapOrNull(pluginName),
                FormatOps.WrapOrNull(clientData), appDomainName),
                typeof(Interpreter).Name, TracePriority.CleanupDebug);

            AppDomainOps.UnloadOrComplain(
                this, friendlyName, appDomain, clientData);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region PluginPropertyHelper Class (MarshalByRefObject)
#if SERIALIZATION
        [Serializable()]
#endif
        [ObjectId("0a332e4c-1619-45ce-b624-14099e37cb7a")]
        private sealed class PluginPropertyHelper
#if ISOLATED_INTERPRETERS || ISOLATED_PLUGINS
            : ScriptMarshalByRefObject
#endif
        {
            #region Private Data
            private AssemblyName assemblyName;
            private DateTime? dateTime;
            private string fileName;
            private string typeName;
            private Uri uri;
            private Uri updateUri;
            private PluginFlags assemblyPluginFlags;
            private PluginFlags typePluginFlags;

#if APPDOMAINS || ISOLATED_INTERPRETERS || ISOLATED_PLUGINS
            private PluginResourceDictionary resources;
#endif
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Private Constructors
            private PluginPropertyHelper()
            {
                // do nothing.
            }
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Static "Factory" Methods
            public static PluginPropertyHelper Create()
            {
                return new PluginPropertyHelper();
            }
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Public Properties
            public AssemblyName AssemblyName
            {
                get { return assemblyName; }
                set { assemblyName = value; }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public DateTime? DateTime
            {
                get { return dateTime; }
                set { dateTime = value; }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public string FileName
            {
                get { return fileName; }
                set { fileName = value; }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public string TypeName
            {
                get { return typeName; }
                set { typeName = value; }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public Uri Uri
            {
                get { return uri; }
                set { uri = value; }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public Uri UpdateUri
            {
                get { return updateUri; }
                set { updateUri = value; }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public PluginFlags AssemblyPluginFlags
            {
                get { return assemblyPluginFlags; }
                set { assemblyPluginFlags = value; }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public PluginFlags TypePluginFlags
            {
                get { return typePluginFlags; }
                set { typePluginFlags = value; }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public PluginFlags PluginFlags
            {
                get { return assemblyPluginFlags | typePluginFlags; }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

#if APPDOMAINS || ISOLATED_INTERPRETERS || ISOLATED_PLUGINS
            public PluginResourceDictionary Resources
            {
                get { return resources; }
                set { resources = value; }
            }
#endif
            #endregion
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region PluginCreateHelper Class (Serializable)
#if SERIALIZATION
        [Serializable()]
#endif
        [ObjectId("44989f7c-828c-4170-8655-404ee607460e")]
        private sealed class PluginCreateHelper
        {
            #region Private Constants
            private const string InvalidPluginError = "invalid plugin";
            private const string InvalidAssemblyNameError = "invalid assembly name";
            private const string PluginAppDomainAlreadySetError = "plugin application domain already set";
            private const string PluginAssemblyAlreadySetError = "plugin assembly name already set";
            private const string CouldNotPopulatePluginEntitiesError = "could not populate plugin entities";
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Private Data
            private IRuleSet ruleSet; /* in */
            private IPlugin plugin; /* in */
            private AssemblyName assemblyName; /* in */
            private PluginFlags pluginFlags; /* in */
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Private Constructors
            private PluginCreateHelper(
                IRuleSet ruleSet,
                IPlugin plugin,
                AssemblyName assemblyName,
                PluginFlags pluginFlags
                )
            {
                this.ruleSet = ruleSet;
                this.plugin = plugin;
                this.assemblyName = assemblyName;
                this.pluginFlags = pluginFlags;
            }
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Static "Factory" Methods
            public static PluginCreateHelper Create(
                IRuleSet ruleSet,
                IPlugin plugin,
                AssemblyName assemblyName,
                PluginFlags pluginFlags
                )
            {
                return new PluginCreateHelper(ruleSet, plugin, assemblyName, pluginFlags);
            }
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Private Methods
            private void SetupAppDomainAndAssembly()
            {
                if (plugin == null)
                    throw new InvalidOperationException(InvalidPluginError);

                if (assemblyName == null)
                    throw new InvalidOperationException(InvalidAssemblyNameError);

                AppDomain appDomain = plugin.AppDomain;

                if (appDomain != null)
                    throw new InvalidOperationException(PluginAppDomainAlreadySetError);

                Assembly assembly = plugin.Assembly;

                if (assembly != null)
                    throw new InvalidOperationException(PluginAssemblyAlreadySetError);

                appDomain = AppDomainOps.GetCurrent();

                plugin.AppDomain = appDomain;

                assembly = AssemblyOps.FindInAppDomain(appDomain, assemblyName);

                plugin.Assembly = assembly;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            private void SetupEntities()
            {
                ReturnCode code;
                Result error = null;

                code = RuntimeOps.PopulatePluginEntities(
                    null, plugin, null, ruleSet, pluginFlags,
                    null, false, false, false, ref error);

                if (code != ReturnCode.Ok)
                {
                    throw new TypeLoadException(
                        CouldNotPopulatePluginEntitiesError,
                        new ScriptException(code, error));
                }
            }
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Public Methods
            public void Setup()
            {
                //
                // NOTE: Set the application domain and assembly for this
                //       plugin now because this could not be done from
                //       the primary application domain.
                //
                SetupAppDomainAndAssembly();

                //
                // NOTE: Get the command and policy type metadata for this
                //       plugin now because this cannot be done from the
                //       primary application domain.
                //
                SetupEntities();
            }
            #endregion
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region PluginLoadHelper Class (Serializable)
#if SERIALIZATION
        [Serializable()]
#endif
        [ObjectId("532f533d-6b21-45d8-8139-54c7a4be4dbd")]
        private sealed class PluginLoadHelper
        {
            #region Private Constants
            private const string AppDomainNotAvailableError = "application domain not available";
            private const string AssemblyNotLoadedError = "assembly not loaded";
            private const string AssemblyAlreadyLoadedError = "assembly already loaded";
            private const string AssemblyNameAlreadySetError = "assembly name already set";
            private const string TypeNotSetError = "type not set";
            private const string TypeAlreadySetError = "type already set";
            private const string PrimaryPluginTypeNotFoundError = "primary plugin type not found";
            private const string UriAlreadySetError = "uri already set";
            private const string UpdateUriAlreadySetError = "update uri already set";
            private const string ResourceStreamNotAvailable = "resource stream not available";
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Private Data
#if SERIALIZATION
            [NonSerialized()]
#endif
            private AppDomain appDomain;

            private bool viaBytes;

            private byte[] assemblyBytes; /* in */
            private byte[] symbolBytes; /* in */

            private string fileName; /* in */
            private string typeName; /* in, out */

#if CAS_POLICY
#if SERIALIZATION
            [NonSerialized()]
#endif
            private Evidence evidence; /* in */

#if !MONO && !MONO_HACKS
            private byte[] hashValue; /* in */
            private AssemblyHashAlgorithm hashAlgorithm; /* in */
#endif
#endif

            private PluginPropertyHelper propertyHelper; /* in, out */
            private PluginLoaderFlags pluginLoaderFlags; /* in */

            private StringList resourcePatterns; /* in */

#if SERIALIZATION
            [NonSerialized()]
#endif
            private Assembly assembly; /* out */

#if SERIALIZATION
            [NonSerialized()]
#endif
            private Type type; /* out */

            private AssemblyName assemblyName; /* out */
            private DateTime? dateTime; /* out */
            private Uri uri; /* out */
            private Uri updateUri; /* out */
            private PluginFlags assemblyPluginFlags; /* out */
            private PluginFlags typePluginFlags; /* out */

#if APPDOMAINS || ISOLATED_INTERPRETERS || ISOLATED_PLUGINS
            private PluginResourceDictionary resources; /* out */
#endif
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Private Constructors
            private PluginLoadHelper(
                byte[] assemblyBytes,                /* in */
                byte[] symbolBytes,                  /* in */
                string fileName,                     /* in */
                string typeName,                     /* in */
                StringList resourcePatterns,         /* in */
#if CAS_POLICY
                Evidence evidence,                   /* in */
#if !MONO && !MONO_HACKS
                byte[] hashValue,                    /* in */
                AssemblyHashAlgorithm hashAlgorithm, /* in */
#endif
#endif
                PluginPropertyHelper propertyHelper, /* in */
                PluginLoaderFlags pluginLoaderFlags  /* in */
                )
            {
                this.assemblyBytes = assemblyBytes;
                this.symbolBytes = symbolBytes;

                this.fileName = fileName;
                this.typeName = typeName;
                this.resourcePatterns = resourcePatterns;

#if CAS_POLICY
                this.evidence = evidence;

#if !MONO && !MONO_HACKS
                this.hashValue = hashValue;
                this.hashAlgorithm = hashAlgorithm;
#endif
#endif

                this.propertyHelper = propertyHelper;
                this.pluginLoaderFlags = pluginLoaderFlags;
            }
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Static "Factory" Methods
            public static PluginLoadHelper Create(
                byte[] assemblyBytes,               /* in */
                byte[] symbolBytes,                 /* in */
                string typeName,                    /* in */
                StringList resourcePatterns,        /* in */
#if CAS_POLICY
                Evidence evidence,                  /* in */
#endif
                PluginLoaderFlags pluginLoaderFlags /* in */
                )
            {
                return new PluginLoadHelper(
                    assemblyBytes, symbolBytes, null, typeName,
                    resourcePatterns,
#if CAS_POLICY
                    evidence,
#if !MONO && !MONO_HACKS
                    null, AssemblyHashAlgorithm.None,
#endif
#endif
                    PluginPropertyHelper.Create(), pluginLoaderFlags);
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public static PluginLoadHelper Create(
                string fileName,                     /* in */
                string typeName,                     /* in */
                StringList resourcePatterns,         /* in */

#if CAS_POLICY
                Evidence evidence,                   /* in */
#if !MONO && !MONO_HACKS
                byte[] hashValue,                    /* in */
                AssemblyHashAlgorithm hashAlgorithm, /* in */
#endif
#endif
                PluginLoaderFlags pluginLoaderFlags  /* in */
                )
            {
                return new PluginLoadHelper(
                    null, null, fileName, typeName,
                    resourcePatterns,
#if CAS_POLICY
                    evidence,
#if !MONO && !MONO_HACKS
                    hashValue, hashAlgorithm,
#endif
#endif
                    PluginPropertyHelper.Create(), pluginLoaderFlags);
            }
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Private Event Handlers
#if ISOLATED_PLUGINS
            private Assembly AssemblyResolve(
                object sender,        /* in */
                ResolveEventArgs args /* in */
                )
            {
                if (args == null)
                    return null;

                //
                // NOTE: This event handler does not attempt to resolve an
                //       assembly that already has a context (i.e. the Load
                //       or LoadFrom contexts that are used when loading via
                //       an AssemblyName or file name, respectively).
                //
                if ((assemblyBytes == null) || (fileName != null))
                    return null;

                //
                // TODO: Are these the right string comparisons to use here?
                //
                if ((assemblyName != null) && SharedStringOps.SystemEquals(
                        args.Name, assemblyName.FullName))
                {
                    return assembly;
                }

                return null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            private Assembly ReflectionOnlyAssemblyResolve(
                object sender,        /* in */
                ResolveEventArgs args /* in */
                )
            {
                if (args == null)
                    return null;

                //
                // TODO: Are these the right string comparisons to use here?
                //
                if (SharedStringOps.SystemEquals(
                        args.Name, GlobalState.GetAssemblyFullName()))
                {
                    return Assembly.ReflectionOnlyLoadFrom(
                        GlobalState.GetAssemblyLocation());
                }

                if ((assemblyName != null) && SharedStringOps.SystemEquals(
                        args.Name, assemblyName.FullName))
                {
                    return assembly;
                }

                //
                // NOTE: Fallback to simply (re-)loading any assembly that is
                //       requested into the reflection-only context, including
                //       things like "System", et al.
                //
                return Assembly.ReflectionOnlyLoad(args.Name);
            }
#endif
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Private Methods
            private byte[] GetResourceBytes(
                string resourceName /* in */
                )
            {
                if (assembly == null)
                    throw new InvalidOperationException(AssemblyNotLoadedError);

                using (Stream stream = assembly.GetManifestResourceStream(resourceName)) /* throw */
                {
                    if (stream == null)
                        throw new InvalidOperationException(ResourceStreamNotAvailable);

                    using (BinaryReader binaryReader = new BinaryReader(stream))
                    {
                        return binaryReader.ReadBytes((int)stream.Length); /* throw */
                    }
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            private void SetupAppDomain()
            {
                if (appDomain == null)
                {
                    //
                    // NOTE: Use the current application domain.  This is correct
                    //       because this method should only ever called when the
                    //       correct application domain is on the call stack.
                    //
                    appDomain = AppDomainOps.GetCurrent();

                    ///////////////////////////////////////////////////////////////////////////////////

#if ISOLATED_PLUGINS
                    if (appDomain != null)
                    {
                        //
                        // NOTE: Setup our assembly resolution event handler so that
                        //       it can deal with resolving an assemblies loaded via
                        //       a byte array (i.e. which has no context).
                        //
                        appDomain.AssemblyResolve += new ResolveEventHandler(
                            AssemblyResolve);

                        appDomain.ReflectionOnlyAssemblyResolve += new ResolveEventHandler(
                            ReflectionOnlyAssemblyResolve);
                    }
#endif
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            private void Setup() /* throw */
            {
                SetupAppDomain();

                if (FlagOps.HasFlags(
                        pluginLoaderFlags, PluginLoaderFlags.Verbose, true))
                {
                    DebugOps.DumpAppDomain(appDomain);
                }

                SetupAssemblyName(); /* throw */
                SetupDateTime(); /* throw */

                if (FlagOps.HasFlags(
                        pluginLoaderFlags, PluginLoaderFlags.Type, true))
                {
                    SetupTypeName(); /* throw */
                }

                SetupUri(); /* throw */
                SetupUpdateUri(); /* throw */
                SetupAssemblyPluginFlags(); /* throw */

                if (FlagOps.HasFlags(
                        pluginLoaderFlags, PluginLoaderFlags.Type, true))
                {
                    SetupTypePluginFlags(); /* throw */
                }

#if APPDOMAINS || ISOLATED_INTERPRETERS || ISOLATED_PLUGINS
                if (FlagOps.HasFlags(
                        pluginLoaderFlags, PluginLoaderFlags.Resources, true))
                {
                    SetupResources(); /* throw */
                }
#endif

                //
                // NOTE: If the property helper was provided, use it to send our
                //       output data back to the other application domain.
                //
                if (propertyHelper != null)
                {
                    propertyHelper.AssemblyName = assemblyName;
                    propertyHelper.DateTime = dateTime;
                    propertyHelper.FileName = fileName;
                    propertyHelper.TypeName = typeName;
                    propertyHelper.Uri = uri;
                    propertyHelper.UpdateUri = updateUri;
                    propertyHelper.AssemblyPluginFlags = assemblyPluginFlags;
                    propertyHelper.TypePluginFlags = typePluginFlags;

#if APPDOMAINS || ISOLATED_INTERPRETERS || ISOLATED_PLUGINS
                    propertyHelper.Resources = resources;
#endif
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            private void SetupAssemblyName()
            {
                if (assembly == null)
                    throw new InvalidOperationException(AssemblyNotLoadedError);

                if (assemblyName != null)
                    throw new InvalidOperationException(AssemblyNameAlreadySetError);

                //
                // NOTE: Get the full name of the assembly and store it for
                //       later use by the plugin loader.
                //
                assemblyName = assembly.GetName();
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            private void SetupDateTime()
            {
                if (assembly == null)
                    throw new InvalidOperationException(AssemblyNotLoadedError);

                //
                // NOTE: Get the DateTime of the assembly and store it for later
                //       use by the plugin loader.
                //
                if (assembly.ReflectionOnly)
                {
                    if (fileName != null)
                    {
                        DateTime localDateTime = DateTime.MinValue;

                        if (FileOps.GetPeFileDateTime(
                                fileName, ref localDateTime))
                        {
                            dateTime = localDateTime;
                        }
                        else
                        {
                            dateTime = DateTime.MinValue;
                        }
                    }
                    else
                    {
                        dateTime = DateTime.MinValue;
                    }
                }
                else
                {
                    dateTime = _Shared.AttributeOps.GetAssemblyDateTime(
                        assembly);
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            private void SetupAssemblyPluginFlags()
            {
                if (assembly == null)
                    throw new InvalidOperationException(AssemblyNotLoadedError);

                PluginFlags pluginFlags = RuntimeOps.GetSkipCheckPluginFlags();

                if (viaBytes)
                {
                    assemblyPluginFlags |= RuntimeOps.GetAssemblyPluginFlags(
                        assembly, assemblyBytes, pluginFlags);
                }
                else
                {
                    assemblyPluginFlags |= RuntimeOps.GetAssemblyPluginFlags(
                        assembly, pluginFlags);
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            private void SetupTypePluginFlags()
            {
                if (assembly == null)
                    throw new InvalidOperationException(AssemblyNotLoadedError);

                if (type == null)
                    throw new InvalidOperationException(TypeNotSetError);

                if (assembly.ReflectionOnly)
                    typePluginFlags = AttributeOps.GetReflectionOnlyPluginFlags(type);
                else
                    typePluginFlags = AttributeOps.GetPluginFlags(type);
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            private void SetupTypeName()
            {
                if (assembly == null)
                    throw new InvalidOperationException(AssemblyNotLoadedError);

                if (type != null)
                    throw new InvalidOperationException(TypeAlreadySetError);

                //
                // NOTE: Do they want a specific plugin type or simply the
                //       default one?
                //
                if (!String.IsNullOrEmpty(typeName))
                {
                    type = assembly.GetType(typeName, true, false); /* throw */

                    //
                    // NOTE: Did we find the type?  For now, this should already be
                    //       true because the above code should throw an exception
                    //       if the type is not found.
                    //
                    if (type != null)
                        typeName = type.FullName;
                }
                else
                {
                    ReturnCode code;
                    Result error = null;

                    code = RuntimeOps.FindPrimaryPlugin(
                        assembly, FlagOps.HasFlags(pluginLoaderFlags,
                        PluginLoaderFlags.Verbose, true), ref typeName,
                        ref error);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Attempt to get the type from the assembly now.
                        //
                        type = assembly.GetType(typeName, true, false); /* throw */
                    }
                    else
                    {
                        throw new TypeLoadException(
                            PrimaryPluginTypeNotFoundError,
                            new ScriptException(code, error));
                    }
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            private void SetupUri()
            {
                if (assembly == null)
                    throw new InvalidOperationException(AssemblyNotLoadedError);

                if (uri != null)
                    throw new InvalidOperationException(UriAlreadySetError);

                //
                // NOTE: Check if the plugin assembly contains a an AssemblyUri
                //       attribute.
                //
                if (assembly.ReflectionOnly)
                    uri = AttributeOps.GetReflectionOnlyAssemblyUri(assembly);
                else
                    uri = _Shared.AttributeOps.GetAssemblyUri(assembly);

                //
                // NOTE: If the plugin assembly does NOT contain an AssemblyUri
                //       attribute, use its location.
                //
                if (uri == null)
                {
                    string location = assembly.Location;

                    if (!String.IsNullOrEmpty(location))
                        uri = new Uri(location); /* throw */
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            private void SetupUpdateUri()
            {
                if (assembly == null)
                    throw new InvalidOperationException(AssemblyNotLoadedError);

                if (updateUri != null)
                    throw new InvalidOperationException(UpdateUriAlreadySetError);

                //
                // NOTE: Check if the plugin assembly contains a an AssemblyUri
                //       attribute.
                //
                if (assembly.ReflectionOnly)
                {
                    updateUri = AttributeOps.GetReflectionOnlyAssemblyUpdateBaseUri(
                        assembly);
                }
                else
                {
                    updateUri = _Shared.AttributeOps.GetAssemblyUpdateBaseUri(
                        assembly);
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

#if APPDOMAINS || ISOLATED_INTERPRETERS || ISOLATED_PLUGINS
            private void SetupResources()
            {
                if (assembly == null)
                    throw new InvalidOperationException(AssemblyNotLoadedError);

                string[] resourceNames = assembly.GetManifestResourceNames(); /* throw */

                if (resourceNames != null)
                {
                    bool ignoreEmpty = FlagOps.HasFlags(
                        pluginLoaderFlags, PluginLoaderFlags.IgnoreEmpty,
                        true);

                    foreach (string resourceName in resourceNames)
                    {
                        if ((resourcePatterns != null) &&
                            !StringOps.MatchAnyOrAll(
                                null, MatchMode.Glob, resourceName,
                                resourcePatterns, false, false))
                        {
                            continue;
                        }

                        byte[] bytes = GetResourceBytes(resourceName);

                        if (ignoreEmpty &&
                            ((bytes == null) || (bytes.Length == 0)))
                        {
                            continue;
                        }

                        if (resources == null)
                            resources = new PluginResourceDictionary();

                        resources[resourceName] = bytes;
                    }
                }
            }
#endif
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Public Properties
            public AppDomain AppDomain
            {
                get { SetupAppDomain(); return appDomain; }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public Assembly Assembly
            {
                get { return assembly; }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public PluginPropertyHelper PropertyHelper
            {
                get { return propertyHelper; }
            }
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Public Methods
#if !CAS_POLICY
            public void NoCasLoad1()
            {
                if (assembly != null)
                    throw new InvalidOperationException(AssemblyAlreadyLoadedError);

                //
                // NOTE: Load the assembly into this AppDomain now.
                //
                assembly = Assembly.LoadFrom(fileName); /* throw */

                //
                // NOTE: This assembly was NOT loaded via an array of bytes.
                //
                viaBytes = false;

                //
                // NOTE: Perform the post-load setup steps?
                //
                if (FlagOps.HasFlags(
                        pluginLoaderFlags, PluginLoaderFlags.Setup, true))
                {
                    Setup(); /* throw */
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public void NoCasLoad2()
            {
                if (assembly != null)
                    throw new InvalidOperationException(AssemblyAlreadyLoadedError);

                SetupAppDomain();

                if (appDomain == null)
                    throw new InvalidOperationException(AppDomainNotAvailableError);

                //
                // NOTE: Load the raw assembly into this AppDomain now.
                //
                assembly = appDomain.Load(assemblyBytes, symbolBytes);

                //
                // NOTE: This assembly was loaded via an array of bytes.
                //
                viaBytes = true;

                //
                // NOTE: Perform the post-load setup steps?
                //
                if (FlagOps.HasFlags(
                        pluginLoaderFlags, PluginLoaderFlags.Setup, true))
                {
                    Setup(); /* throw */
                }
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if CAS_POLICY
            public void CasLoad2()
            {
                if (assembly != null)
                    throw new InvalidOperationException(AssemblyAlreadyLoadedError);

                //
                // NOTE: Load the assembly into this AppDomain using the
                //       provided evidence now.
                //
                assembly = Assembly.LoadFrom(fileName, evidence); /* throw */

                //
                // NOTE: This assembly was NOT loaded via an array of bytes.
                //
                viaBytes = false;

                //
                // NOTE: Perform the post-load setup steps?
                //
                if (FlagOps.HasFlags(
                        pluginLoaderFlags, PluginLoaderFlags.Setup, true))
                {
                    Setup(); /* throw */
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public void CasLoad3()
            {
                if (assembly != null)
                    throw new InvalidOperationException(AssemblyAlreadyLoadedError);

                SetupAppDomain();

                if (appDomain == null)
                    throw new InvalidOperationException(AppDomainNotAvailableError);

                //
                // NOTE: Load the raw assembly into this AppDomain using the
                //       provided evidence now.
                //
                assembly = appDomain.Load(
                    assemblyBytes, symbolBytes, evidence); /* throw */

                //
                // NOTE: This assembly was loaded via an array of bytes.
                //
                viaBytes = true;

                //
                // NOTE: Perform the post-load setup steps?
                //
                if (FlagOps.HasFlags(
                        pluginLoaderFlags, PluginLoaderFlags.Setup, true))
                {
                    Setup(); /* throw */
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

#if !MONO && !MONO_HACKS
            public void CasLoad4()
            {
                if (assembly != null)
                    throw new InvalidOperationException(AssemblyAlreadyLoadedError);

                //
                // NOTE: Load the assembly into this AppDomain using the
                //       provided evidence and hash parameters now.
                //
                assembly = Assembly.LoadFrom(
                    fileName, evidence, hashValue, hashAlgorithm); /* throw */

                //
                // NOTE: This assembly was NOT loaded via an array of bytes.
                //
                viaBytes = false;

                //
                // NOTE: Perform the post-load setup steps?
                //
                if (FlagOps.HasFlags(
                        pluginLoaderFlags, PluginLoaderFlags.Setup, true))
                {
                    Setup(); /* throw */
                }
            }
#endif
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            public void ReflectionNoCasLoad1()
            {
                if (assembly != null)
                    throw new InvalidOperationException(AssemblyAlreadyLoadedError);

                //
                // NOTE: Load the assembly into this AppDomain now (for use by
                //       reflection only).
                //
                assembly = Assembly.ReflectionOnlyLoadFrom(fileName); /* throw */

                //
                // NOTE: This assembly was NOT loaded via an array of bytes.
                //
                viaBytes = false;

                //
                // NOTE: Perform the post-load setup steps?
                //
                if (FlagOps.HasFlags(
                        pluginLoaderFlags, PluginLoaderFlags.Setup, true))
                {
                    Setup(); /* throw */
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            public void ReflectionNoCasLoad2()
            {
                if (assembly != null)
                    throw new InvalidOperationException(AssemblyAlreadyLoadedError);

                //
                // NOTE: Load the raw assembly into this AppDomain now (for use
                //       by reflection only).
                //
                assembly = Assembly.ReflectionOnlyLoad(assemblyBytes); /* throw */

                //
                // NOTE: This assembly was loaded via an array of bytes.
                //
                viaBytes = true;

                //
                // NOTE: Perform the post-load setup steps?
                //
                if (FlagOps.HasFlags(
                        pluginLoaderFlags, PluginLoaderFlags.Setup, true))
                {
                    Setup(); /* throw */
                }
            }
            #endregion
        }
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IPropertyManager Members
        public object ApplicationObject
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return applicationObject;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    applicationObject = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public object PolicyObject
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return policyObject;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    policyObject = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public object ResolverObject
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return resolverObject;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    resolverObject = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public object UserObject
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return userObject;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    userObject = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ClientDataDictionary RuntimeOptions
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return runtimeOptions;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    //
                    // NOTE: *SPECIAL* The current runtime options cannot be reset
                    //       when the interpreter is flagged as immutable.
                    //
                    if (!IsModifiable(false))
                        return;

                    VariableFlags flags = VariableFlags.ViaProperty;

                    //
                    // NOTE: Do not create the variable if we have been prohibited
                    //       from doing so.
                    //
                    if (InternalIsSafe() || PrivateIsNoVariables())
                        flags |= VariableFlags.NoCreate;

                    ClientDataDictionary oldRuntimeOptions;

                    SaveRuntimeOptions(out oldRuntimeOptions);
                    runtimeOptions = value;

                    //
                    // NOTE: Update script-level informational variable.  This
                    //       variable is NOT allowed in "safe" interpreters.
                    //
                    SetLibraryVariableValue2(
                        flags, Vars.Platform.Name, Vars.Platform.RuntimeOptions,
                        runtimeOptions.ToString());

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.RuntimeOption, NotifyFlags.Replaced,
                        new ObjectPair(oldRuntimeOptions, runtimeOptions),
                        this, null, null, null);
#endif
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool HasRuntimeOption(
            string name
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (String.IsNullOrEmpty(name))
                    return false;

                return (runtimeOptions != null) &&
                    runtimeOptions.ContainsKey(name); /* EXEMPT */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool ClearRuntimeOptions()
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false))
                    return false;

                if (runtimeOptions != null)
                {
                    VariableFlags flags = VariableFlags.ViaProperty;

                    //
                    // NOTE: Do not create the variable if we have been prohibited
                    //       from doing so.
                    //
                    if (InternalIsSafe() || PrivateIsNoVariables())
                        flags |= VariableFlags.NoCreate;

                    //
                    // NOTE: Update script-level informational variable.  This
                    //       variable is NOT allowed in "safe" interpreters.
                    //
                    ClientDataDictionary oldRuntimeOptions;

                    SaveRuntimeOptions(out oldRuntimeOptions);
                    runtimeOptions.Clear();

                    /* IGNORED */
                    SetLibraryVariableValue2(flags, Vars.Platform.Name,
                        Vars.Platform.RuntimeOptions,
                        runtimeOptions.ToString());

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.RuntimeOption, NotifyFlags.Cleared,
                        new ObjectPair(oldRuntimeOptions, runtimeOptions),
                        this, null, null, null);
#endif

                    return true;
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool AddRuntimeOption(
            string name
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true))
                    return false;

                if (String.IsNullOrEmpty(name))
                    return false;

                if ((runtimeOptions != null) &&
                    !runtimeOptions.ContainsKey(name)) /* EXEMPT */
                {
                    VariableFlags flags = VariableFlags.ViaProperty;

                    //
                    // NOTE: Do not create the variable if we have been prohibited
                    //       from doing so.
                    //
                    if (InternalIsSafe() || PrivateIsNoVariables())
                        flags |= VariableFlags.NoCreate;

                    //
                    // NOTE: Update script-level informational variable.  This
                    //       variable is NOT allowed in "safe" interpreters.
                    //
                    runtimeOptions.Add(name, null);

                    /* IGNORED */
                    SetLibraryVariableValue2(flags, Vars.Platform.Name,
                        Vars.Platform.RuntimeOptions,
                        runtimeOptions.ToString());

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.RuntimeOption, NotifyFlags.Added,
                        new ObjectPair(runtimeOptions, name), this,
                        null, null, null);
#endif

                    return true;
                }
                else
                {
                    return false;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool RemoveRuntimeOption(
            string name
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false))
                    return false;

                if (String.IsNullOrEmpty(name))
                    return false;

                if ((runtimeOptions != null) &&
                    runtimeOptions.ContainsKey(name)) /* EXEMPT */
                {
                    VariableFlags flags = VariableFlags.ViaProperty;

                    //
                    // NOTE: Do not create the variable if we have been prohibited
                    //       from doing so.
                    //
                    if (InternalIsSafe() || PrivateIsNoVariables())
                        flags |= VariableFlags.NoCreate;

                    //
                    // NOTE: Update script-level informational variable.  This
                    //       variable is NOT allowed in "safe" interpreters.
                    //
                    bool result = runtimeOptions.Remove(name);

                    /* IGNORED */
                    SetLibraryVariableValue2(flags, Vars.Platform.Name,
                        Vars.Platform.RuntimeOptions,
                        runtimeOptions.ToString());

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.RuntimeOption, NotifyFlags.Removed,
                        new ObjectPair(runtimeOptions, name), this,
                        null, null, null);
#endif

                    return result; /* NOTE: Must be true. */
                }
                else
                {
                    return false;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool ChangeRuntimeOption(
            string name
            )
        {
            CheckDisposed();

            if (String.IsNullOrEmpty(name))
                return false;

            char @operator = name[0];

            switch (@operator)
            {
                case Characters.PlusSign:
                    {
                        if (name.Length > 1)
                            return AddRuntimeOption(name.Substring(1));

                        break;
                    }
                case Characters.MinusSign:
                    {
                        if (name.Length > 1)
                            return RemoveRuntimeOption(name.Substring(1));

                        break;
                    }
                case Characters.EqualSign:
                    {
                        if (name.Length > 1)
                        {
                            return ClearRuntimeOptions() &&
                                AddRuntimeOption(name.Substring(1));
                        }

                        break;
                    }
                default:
                    {
                        if (Parser.IsIdentifier(@operator))
                            return AddRuntimeOption(name);

                        break;
                    }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal bool ThrowOnFeatureNotSupported
        {
            get
            {
                lock (syncRoot)
                {
                    return throwOnFeatureNotSupported;
                }
            }
            set
            {
                lock (syncRoot)
                {
                    throwOnFeatureNotSupported = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool GetRuntimeOption(
            string name,
            ref IClientData value
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (String.IsNullOrEmpty(name))
                    return false;

                return (runtimeOptions != null) &&
                    runtimeOptions.TryGetValue(name, out value);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool SetRuntimeOption(
            string name,
            IClientData value
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false))
                    return false;

                if (String.IsNullOrEmpty(name))
                    return false;

                if (runtimeOptions != null)
                {
                    VariableFlags flags = VariableFlags.ViaProperty;

                    //
                    // NOTE: Do not create the variable if we have been prohibited
                    //       from doing so.
                    //
                    if (InternalIsSafe() || PrivateIsNoVariables())
                        flags |= VariableFlags.NoCreate;

                    //
                    // NOTE: Update script-level informational variable.  This
                    //       variable is NOT allowed in "safe" interpreters.
                    //
                    runtimeOptions[name] = value;

                    /* IGNORED */
                    SetLibraryVariableValue2(flags, Vars.Platform.Name,
                        Vars.Platform.RuntimeOptions,
                        runtimeOptions.ToString());

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.RuntimeOption, NotifyFlags.Updated,
                        new ObjectTriplet(runtimeOptions, name, value),
                        this, null, null, null);
#endif

                    return true;
                }
                else
                {
                    return false;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void SaveRuntimeOptions(
            out ClientDataDictionary savedRuntimeOptions
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                savedRuntimeOptions = (runtimeOptions != null) ?
                    new ClientDataDictionary(runtimeOptions) : null;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IResolveManager Members
        #region Variable Frame Resolution (WARNING: EXPERIMENTAL)
        public ReturnCode GetVariableFrameViaResolvers(
            LookupFlags lookupFlags,         /* in */
            ref ICallFrame frame,            /* in, out */
            ref string varName,              /* in, out */
            ref VariableFlags variableFlags, /* in, out */
            ref Result error                 /* out */
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasResolvers(ref  error))
                {
                    ResultList errors = null;

                    foreach (IResolve resolve in resolvers)
                    {
                        if (resolve != null)
                        {
                            Result localError = null;

                            try
                            {
                                ReturnCode code = resolve.GetVariableFrame(
                                    ref frame, ref varName, ref variableFlags,
                                    ref localError);

                                if (code == ReturnCode.Ok)
                                {
                                    //
                                    // NOTE: Success, return the entity that this
                                    //       resolver found.
                                    //
                                    return ReturnCode.Ok;
                                }
                                else if (code == ReturnCode.Return)
                                {
                                    //
                                    // NOTE: Failure, return the error that this
                                    //       resolver returned verbatim.
                                    //
                                    error = localError;

                                    return ReturnCode.Error;
                                }
                                else if (code == ReturnCode.Break)
                                {
                                    //
                                    // NOTE: Failure, skip all other resolvers
                                    //       for this entity and return all the
                                    //       previously collected errors.
                                    //
                                    break;
                                }
                                else if (code == ReturnCode.Continue)
                                {
                                    //
                                    // NOTE: Failure, keep trying; however, do
                                    //       not add the error message from this
                                    //       resolver.
                                    //
                                    continue;
                                }
                            }
                            catch (Exception e)
                            {
                                if (FlagOps.HasFlags(
                                        lookupFlags, LookupFlags.Verbose, true))
                                {
                                    localError = e;
                                }
                            }

                            if (localError != null)
                            {
                                if (errors == null)
                                    errors = new ResultList();

                                errors.Add(localError);
                            }
                        }
                    }

                    if (errors != null)
                        error = errors;
                    else
                        error = "no resolvers defined";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal ReturnCode GetVariableFrameViaResolvers(
            LookupFlags lookupFlags, /* in */
            ref ICallFrame frame,    /* in, out */
            ref Result error         /* out */
            )
        {
            string varName = null;
            VariableFlags variableFlags = VariableFlags.None;

            return GetVariableFrameViaResolvers(
                lookupFlags, ref frame, ref varName, ref variableFlags,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetVariableFrameViaResolvers(
            LookupFlags lookupFlags, /* in */
            ref ICallFrame frame,    /* in, out */
            ref string varName,      /* in, out */
            ref Result error         /* out */
            )
        {
            VariableFlags variableFlags = VariableFlags.None;

            return GetVariableFrameViaResolvers(
                lookupFlags, ref frame, ref varName, ref variableFlags,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetVariableFrameViaResolvers(
            LookupFlags lookupFlags,
            ref ICallFrame frame
            )
        {
            string varName = null;
            VariableFlags variableFlags = VariableFlags.None;
            Result error = null;

            return GetVariableFrameViaResolvers(
                lookupFlags, ref frame, ref varName, ref variableFlags,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetVariableFrameViaResolvers(
            LookupFlags lookupFlags,
            ref ICallFrame frame,
            ref VariableFlags variableFlags,
            ref Result error
            )
        {
            string varName = null;

            return GetVariableFrameViaResolvers(
                lookupFlags, ref frame, ref varName, ref variableFlags,
                ref error);
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Namespace Management (WARNING: EXPERIMENTAL)
        //
        // WARNING: *EXPERIMENTAL* This API may change until the
        //          resolver subsystem is completed.
        //
        public ReturnCode GetGlobalNamespace(
            LookupFlags lookupFlags, /* NOTE: NOT USED. */
            ref INamespace @namespace,
            ref Result result /* NOTE: NOT USED, cannot currently fail. */
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                @namespace = globalNamespace;
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: *EXPERIMENTAL* This API may change until the
        //          resolver subsystem is completed.
        //
        public ReturnCode GetCurrentNamespaceViaResolvers(
            ICallFrame frame,
            LookupFlags lookupFlags,
            ref INamespace @namespace,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasResolvers(ref  error))
                {
                    ResultList errors = null;

                    foreach (IResolve resolve in resolvers)
                    {
                        if (resolve != null)
                        {
                            Result localError = null;

                            try
                            {
                                ReturnCode code = resolve.GetCurrentNamespace(
                                    frame, ref @namespace, ref localError);

                                if (code == ReturnCode.Ok)
                                {
                                    //
                                    // NOTE: Success, return the entity that this
                                    //       resolver found.
                                    //
                                    return ReturnCode.Ok;
                                }
                                else if (code == ReturnCode.Return)
                                {
                                    //
                                    // NOTE: Failure, return the error that this
                                    //       resolver returned verbatim.
                                    //
                                    error = localError;

                                    return ReturnCode.Error;
                                }
                                else if (code == ReturnCode.Break)
                                {
                                    //
                                    // NOTE: Failure, skip all other resolvers
                                    //       for this entity and return all the
                                    //       previously collected errors.
                                    //
                                    break;
                                }
                                else if (code == ReturnCode.Continue)
                                {
                                    //
                                    // NOTE: Failure, keep trying; however, do
                                    //       not add the error message from this
                                    //       resolver.
                                    //
                                    continue;
                                }
                            }
                            catch (Exception e)
                            {
                                if (FlagOps.HasFlags(
                                        lookupFlags, LookupFlags.Verbose, true))
                                {
                                    localError = e;
                                }
                            }

                            if (localError != null)
                            {
                                if (errors == null)
                                    errors = new ResultList();

                                errors.Add(localError);
                            }
                        }
                    }

                    if (errors != null)
                        error = errors;
                    else
                        error = "no resolvers defined";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal bool IsGlobalNamespace(
            INamespace @namespace
            )
        {
            return Object.ReferenceEquals(
                @namespace, globalNamespace);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetCurrentNamespaceViaResolvers(
            ICallFrame frame,
            LookupFlags lookupFlags,
            ref INamespace @namespace
            )
        {
            Result result = null;

            return GetCurrentNamespaceViaResolvers(
                frame, lookupFlags, ref @namespace, ref result);
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Call Frame Management (WARNING: EXPERIMENTAL)
        //
        // WARNING: *EXPERIMENTAL* This API may change until the
        //          resolver subsystem is completed.
        //
        public bool? HasCallFrameFlags( /* EXPERIMENTAL */
            ICallFrame frame,        /* in */
            CallFrameFlags hasFlags, /* in */
            bool all                 /* in */
            )
        {
            CheckDisposed();

#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                frame = MaybeGetCurrentCallFrame(frame);

                if (frame == null)
                    return null;

                return FlagOps.HasFlags(frame.Flags, hasFlags, all);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: *EXPERIMENTAL* This API may change until the
        //          resolver subsystem is completed.
        //
        public ReturnCode GetCallFrame( /* EXPERIMENTAL */
            bool absolute,              /* in */
            int level,                  /* in */
            CallFrameFlags hasFlags,    /* in */
            CallFrameFlags notHasFlags, /* in */
            bool hasAll,                /* in */
            bool notHasAll,             /* in */
            ref ICallFrame frame,       /* in, out */
            ref Result error            /* out */
            )
        {
            CheckDisposed();

#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                ICallFrame currentFrame =
                    (frame != null) ? frame : CurrentFrame;

                return CallFrameOps.GetOrFind(
                    CallStack, GlobalFrame /* EXEMPT */, CurrentGlobalFrame,
                    currentFrame, absolute, false, level, hasFlags,
                    notHasFlags, hasAll, notHasAll, ref frame, ref error);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private ICallFrame MaybeGetCurrentCallFrame(
            ICallFrame frame
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                if (frame != null)
                    return frame;

                return CallFrameOps.FollowNext(CurrentFrame);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal FrameResult GetCallFrame(
            string text,
            ref ICallFrame otherFrame,
            ref Result error
            )
        {
            //
            // BUGBUG: Why not use the NoVariables (Tracking) flag here?
            //
            return Value.GetCallFrame(
                text, LevelFlags.All, CallStack, GlobalFrame /* EXEMPT */,
                CurrentGlobalFrame, CurrentFrame, CallFrameFlags.Variables,
                CallFrameFlags.Invisible | CallFrameFlags.NoVariables,
                false, false, Value.GetCallFrameValueFlags(false),
                InternalCultureInfo, ref otherFrame, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal FrameResult GetCallFrame(
            string text,
            ref bool mark,
            ref bool absolute,
            ref bool super,
            ref int level,
            ref ICallFrame currentFrame,
            ref ICallFrame otherFrame,
            ref Result error
            )
        {
            //
            // BUGBUG: Why not use the NoVariables (Tracking) flag here?
            //
            currentFrame = CurrentFrame;

            return Value.GetCallFrame(
                text, LevelFlags.All, CallStack, GlobalFrame /* EXEMPT */,
                CurrentGlobalFrame, currentFrame, CallFrameFlags.Variables,
                CallFrameFlags.Invisible | CallFrameFlags.NoVariables,
                false, false, Value.GetCallFrameValueFlags(false),
                InternalCultureInfo, ref mark, ref absolute, ref super,
                ref level, ref otherFrame, ref error);
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Command & Variable Resolution (WARNING: EXPERIMENTAL)
        //
        // WARNING: The name of this method differs from the internal
        //          methods named "GetResolveEngineFlags" by omitting
        //          the second "r", which is very subtle.
        //
        public EngineFlags GetResolverEngineFlags(
            bool exact
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                return GetResolveEngineFlagsNoLock(exact);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: *EXPERIMENTAL* This API may change until the
        //          resolver subsystem is completed.
        //
        public ReturnCode GetIExecuteViaResolvers( /* EXPERIMENTAL */
            ICallFrame frame,
            EngineFlags engineFlags,
            string name,
            ArgumentList arguments,
            LookupFlags lookupFlags,
            ref bool ambiguous,
            ref long token,
            ref IExecute execute,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasResolvers(ref error))
                {
                    ResultList errors = null;

                    foreach (IResolve resolve in resolvers)
                    {
                        if (resolve != null)
                        {
                            Result localError = null;

                            try
                            {
                                ReturnCode code = resolve.GetIExecute(frame,
                                    engineFlags, name, arguments, lookupFlags,
                                    ref ambiguous, ref token, ref execute,
                                    ref localError);

                                if (code == ReturnCode.Ok)
                                {
                                    //
                                    // NOTE: Success, return the entity that this
                                    //       resolver found.
                                    //
                                    return ReturnCode.Ok;
                                }
                                else if (code == ReturnCode.Return)
                                {
                                    //
                                    // NOTE: Failure, return the error that this
                                    //       resolver returned verbatim.
                                    //
                                    error = localError;

                                    return ReturnCode.Error;
                                }
                                else if (code == ReturnCode.Break)
                                {
                                    //
                                    // NOTE: Failure, skip all other resolvers
                                    //       for this entity and return all the
                                    //       previously collected errors.
                                    //
                                    break;
                                }
                                else if (code == ReturnCode.Continue)
                                {
                                    //
                                    // NOTE: Failure, keep trying; however, do
                                    //       not add the error message from this
                                    //       resolver.
                                    //
                                    continue;
                                }
                            }
                            catch (Exception e)
                            {
                                if (FlagOps.HasFlags(
                                        lookupFlags, LookupFlags.Verbose, true))
                                {
                                    localError = e;
                                }
                            }

                            if (localError != null)
                            {
                                if (errors == null)
                                    errors = new ResultList();

                                errors.Add(localError);
                            }
                        }
                    }

                    if (errors != null)
                        error = errors;
                    else
                        error = "no resolvers defined";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: *EXPERIMENTAL* This API may change until the
        //          resolver subsystem is completed.
        //
        public ReturnCode GetVariableViaResolvers( /* EXPERIMENTAL */
            ICallFrame frame,
            string varName,
            string varIndex,
            ref VariableFlags flags,
            ref IVariable variable,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasResolvers(ref error))
                {
                    bool resolveNull = FlagOps.HasFlags(
                        flags, VariableFlags.ResolveNull, true);

                    bool noUsable = FlagOps.HasFlags(
                        flags, VariableFlags.NoUsable, true);

                    ResultList errors = null;

                    foreach (IResolve resolve in resolvers)
                    {
                        if (resolve != null)
                        {
                            Result localError; /* REUSED */

                            try
                            {
                                ReturnCode code;
                                IVariable localVariable = null;

                                localError = null;

                                code = resolve.GetVariable(
                                    frame, varName, varIndex, ref flags,
                                    ref localVariable, ref localError);

                                if (code == ReturnCode.Ok)
                                {
                                    //
                                    // NOTE: Success, return the entity that this
                                    //       resolver found.  If that entity is
                                    //       now null and that is disallowed via
                                    //       the flags, fail.
                                    //
                                    if (!resolveNull && (localVariable == null))
                                    {
                                        error = String.Format(
                                            "can't resolve {0}: variable is invalid",
                                            FormatOps.ErrorVariableName(varName, varIndex));

                                        return ReturnCode.Error;
                                    }

                                    if (!noUsable && (localVariable != null))
                                    {
                                        localError = null;

                                        if (!localVariable.IsUsable(ref localError))
                                        {
                                            error = String.Format(
                                                "can't resolve {0}: {1}",
                                                FormatOps.ErrorVariableName(varName, varIndex),
                                                FormatOps.DisplayString(localError));

                                            return ReturnCode.Error;
                                        }
                                    }

                                    variable = localVariable;
                                    return ReturnCode.Ok;
                                }
                                else if (code == ReturnCode.Return)
                                {
                                    //
                                    // NOTE: Failure, return the error that this
                                    //       resolver returned verbatim.
                                    //
                                    error = localError;

                                    return ReturnCode.Error;
                                }
                                else if (code == ReturnCode.Break)
                                {
                                    //
                                    // NOTE: Failure, skip all other resolvers
                                    //       for this entity and return all the
                                    //       previously collected errors.
                                    //
                                    break;
                                }
                                else if (code == ReturnCode.Continue)
                                {
                                    //
                                    // NOTE: Failure, keep trying; however, do
                                    //       not add the error message from this
                                    //       resolver.
                                    //
                                    continue;
                                }
                            }
                            catch (Exception e)
                            {
                                localError = e;
                            }

                            if (localError != null)
                            {
                                if (errors == null)
                                    errors = new ResultList();

                                errors.Add(localError);
                            }
                        }
                    }

                    if (errors != null)
                        error = errors;
                    else
                        error = "no resolvers defined";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal EngineFlags GetResolveEngineFlagsNoLock(
            bool exact
            )
        {
            return GetResolveEngineFlags(engineFlags, exact);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static EngineFlags GetResolveEngineFlags(
            EngineFlags engineFlags,
            bool exact
            )
        {
            return Engine.GetResolveFlags(engineFlags, exact);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static EngineFlags GetMatchAnyEngineFlags(
            EngineFlags engineFlags,
            bool exact
            )
        {
            EngineFlags result = engineFlags;

            if (exact)
            {
                if (EngineFlagOps.HasMatchHidden(result))
                    result |= EngineFlags.GetHidden;
            }
            else
            {
                if (EngineFlagOps.HasGetHidden(result))
                    result |= EngineFlags.MatchHidden;
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool MaybeUnwrapIExecute(
            LookupFlags lookupFlags, /* in */
            IExecute executeWrapper, /* in */
            ref IExecute execute     /* out */
            )
        {
            Result error = null;

            return MaybeUnwrapIExecute(
                lookupFlags, executeWrapper, ref execute, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool MaybeUnwrapIExecute(
            LookupFlags lookupFlags, /* in */
            IExecute executeWrapper, /* in */
            ref IExecute execute,    /* out */
            ref Result error         /* out */
            )
        {
            if (FlagOps.HasFlags(lookupFlags, LookupFlags.Wrapper, true))
            {
                //
                // NOTE: The caller, PrivateMatchAnyIExecute, must make sure
                //       the "executeWrapper" parameter is in fact a wrapper.
                //
                execute = executeWrapper;
            }
            else
            {
                IWrapper wrapper = executeWrapper as IWrapper;

                if (wrapper != null)
                    execute = wrapper.Object as IExecute;
                else
                    execute = null;
            }

            //
            // NOTE: At this point, either the IExecute must be valid -OR-
            //       the Validate lookup flag must be unset; otherwise, this
            //       method has failed (i.e. thus emulating the behavior of
            //       the associated PrivateGet* methods).
            //
            if ((execute == null) &&
                FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true))
            {
                error = "invalid execute";
                return false;
            }

            return true;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if EXECUTE_CACHE
        private bool TryGetIExecuteFromCache(
            string name,
            LookupFlags lookupFlags,
            bool useHidden,
            ref IExecute execute
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                IExecute localExecute = null;

                if (useHidden)
                {
                    if (hiddenExecuteCache != null)
                    {
                        if (hiddenExecuteCache.TryGet(name,
                                FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true),
                                ref localExecute))
                        {
                            if (MaybeUnwrapIExecute(
                                    lookupFlags, localExecute, ref localExecute))
                            {
#if CACHE_STATISTICS
                                hiddenExecuteCache.IncrementCacheCount(CacheCountType.Hit);
#endif

                                execute = localExecute;
                                return true;
                            }
#if CACHE_STATISTICS
                            else
                            {
                                hiddenExecuteCache.IncrementCacheCount(CacheCountType.Miss);
                            }
#endif
                        }
#if CACHE_STATISTICS
                        else
                        {
                            hiddenExecuteCache.IncrementCacheCount(CacheCountType.Miss);
                        }
#endif
                    }
                }
                else
                {
                    if (executeCache != null)
                    {
                        if (executeCache.TryGet(name,
                                FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true),
                                ref localExecute))
                        {
                            if (MaybeUnwrapIExecute(
                                    lookupFlags, localExecute, ref localExecute))
                            {
#if CACHE_STATISTICS
                                executeCache.IncrementCacheCount(CacheCountType.Hit);
#endif

                                execute = localExecute;
                                return true;
                            }
#if CACHE_STATISTICS
                            else
                            {
                                executeCache.IncrementCacheCount(CacheCountType.Miss);
                            }
#endif
                        }
#if CACHE_STATISTICS
                        else
                        {
                            executeCache.IncrementCacheCount(CacheCountType.Miss);
                        }
#endif
                    }
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool AddOrUpdateIExecuteToCache(
            string name,
            IExecute execute,
            bool useHidden,
            bool invalidate
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (useHidden)
                {
                    if (hiddenExecuteCache != null)
                    {
                        return hiddenExecuteCache.AddOrUpdate(
                            name, execute, invalidate);
                    }
                }
                else
                {
                    if (executeCache != null)
                    {
                        return executeCache.AddOrUpdate(
                            name, execute, invalidate);
                    }
                }

                return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool RenameIExecuteInCache(
            string oldName,
            string newName,
            IExecute execute,
            bool useHidden,
            bool invalidate
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (useHidden)
                {
                    if (hiddenExecuteCache != null)
                    {
                        return hiddenExecuteCache.Rename(
                            oldName, newName, execute, invalidate);
                    }
                }
                else
                {
                    if (executeCache != null)
                    {
                        return executeCache.Rename(
                            oldName, newName, execute, invalidate);
                    }
                }

                return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool RemoveIExecuteFromCache(
            string name,
            bool useHidden,
            bool invalidate
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (useHidden)
                {
                    if (hiddenExecuteCache != null)
                    {
                        return hiddenExecuteCache.Remove(
                            name, invalidate);
                    }
                }
                else
                {
                    if (executeCache != null)
                    {
                        return executeCache.Remove(
                            name, invalidate);
                    }
                }

                return false;
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetAnyIExecute(
            ICallFrame frame, /* NOT USED */
            EngineFlags engineFlags,
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IExecute execute,
            ref Result error
            )
        {
            string newName = ScriptOps.MakeCommandName(name);

#if EXECUTE_CACHE
            bool noCache = EngineFlagOps.HasNoCache(engineFlags);
#endif

            bool useHidden = EngineFlagOps.HasUseHidden(engineFlags);
            IExecute localExecute; /* REUSED */

#if EXECUTE_CACHE
            localExecute = null;

            if (!noCache &&
                TryGetIExecuteFromCache(newName, lookupFlags, useHidden, ref localExecute))
            {
                execute = localExecute;
                return ReturnCode.Ok;
            }
#endif

            localExecute = null;

            if (EngineFlagOps.HasUseIExecutes(engineFlags) &&
                 ((useHidden && (GetHiddenIExecute(
                    newName, lookupFlags, ref localExecute) == ReturnCode.Ok)) ||
                 (!useHidden && (GetIExecute(
                    newName, lookupFlags, ref localExecute) == ReturnCode.Ok))))
            {
#if EXECUTE_CACHE
                if (!noCache)
                    AddOrUpdateIExecuteToCache(newName, localExecute, useHidden, false);
#endif

                execute = localExecute;
                return ReturnCode.Ok;
            }
            else
            {
                IProcedure localProcedure = null;

                if (EngineFlagOps.HasUseProcedures(engineFlags) &&
                    ((useHidden && (GetHiddenProcedure(
                        newName, lookupFlags, ref localProcedure) == ReturnCode.Ok)) ||
                    (!useHidden && (GetProcedure(
                        newName, lookupFlags, ref localProcedure) == ReturnCode.Ok))))
                {
#if EXECUTE_CACHE
                    if (!noCache)
                        AddOrUpdateIExecuteToCache(newName, localProcedure, useHidden, false);
#endif

                    execute = localProcedure;
                    return ReturnCode.Ok;
                }
                else
                {
                    ICommand localCommand = null;

                    if (EngineFlagOps.HasUseCommands(engineFlags) &&
                        ((useHidden && (GetHiddenCommand(
                            newName, lookupFlags, ref localCommand) == ReturnCode.Ok)) ||
                        (!useHidden && (GetCommand(
                            newName, lookupFlags, ref localCommand) == ReturnCode.Ok))))
                    {
#if EXECUTE_CACHE
                        if (!noCache)
                            AddOrUpdateIExecuteToCache(newName, localCommand, useHidden, false);
#endif

                        execute = localCommand;
                        return ReturnCode.Ok;
                    }
                    else
                    {
                        error = FlagOps.HasFlags(
                            lookupFlags, LookupFlags.Verbose, true) ?
                            String.Format(
                                "invalid {0}command name {1}",
                                useHidden ? "hidden " : String.Empty,
                                FormatOps.DisplayName(name)) :
                            "invalid command name";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateMatchAnyIExecute(
            ICallFrame frame, /* NOT USED */
            EngineFlags engineFlags,
            string name,
            LookupFlags lookupFlags,
            ref bool ambiguous,
            ref long token,
            ref IExecute execute,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // NOTE: *WARNING* Empty command/procedure names are allowed,
                //       please do not change this to "!String.IsNullOrEmpty".
                //
                if (name != null)
                {
                    string newName = ScriptOps.MakeCommandPattern(name);

#if EXECUTE_CACHE
                    bool noCache = EngineFlagOps.HasNoCache(engineFlags);
#endif

                    bool useHidden = EngineFlagOps.HasUseHidden(engineFlags);

#if EXECUTE_CACHE
                    if (!noCache &&
                        TryGetIExecuteFromCache(newName, lookupFlags, useHidden, ref execute))
                    {
                        return ReturnCode.Ok;
                    }
#endif

                    string exactName = null;
                    ExecuteDictionary matches = new ExecuteDictionary();

                    if (exactName == null)
                    {
                        if (EngineFlagOps.HasUseIExecutes(engineFlags))
                        {
                            ExecuteWrapperDictionary localExecutes = useHidden ?
                                hiddenExecutes : executes;

                            if ((localExecutes != null) && (localExecutes.Count > 0))
                            {
                                _Wrappers._Execute localExecute;

                                if (localExecutes.TryGetValue(newName, out localExecute))
                                {
                                    //
                                    // NOTE: Exact execute match.
                                    //
                                    exactName = newName;

                                    //
                                    // NOTE: Store the exact execute match in the results
                                    //       dictionary.
                                    //
                                    matches.Add(newName, localExecute);
                                }
                                else
                                {
                                    foreach (KeyValuePair<string, _Wrappers._Execute> pair in localExecutes)
                                    {
                                        if (SharedStringOps.SystemEquals(pair.Key, 0, newName, 0, newName.Length))
                                        {
                                            //
                                            // NOTE: Was the key valid (this should always succeed).
                                            //
                                            if (pair.Key != null)
                                            {
                                                //
                                                // NOTE: It was a match; however, was it an exact match?
                                                //
                                                if (pair.Key.Length == newName.Length)
                                                    //
                                                    // NOTE: Preserve match, it may differ in case.
                                                    //
                                                    exactName = pair.Key;

                                                //
                                                // NOTE: Was it an exact match or did we match at least one
                                                //       character in a partial match?
                                                //
                                                if ((pair.Key.Length == newName.Length) || (newName.Length > 0))
                                                    //
                                                    // NOTE: Store the exact or partial match in the results
                                                    //       dictionary.
                                                    //
                                                    matches.Add(pair.Key, pair.Value);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    bool matchHidden = EngineFlagOps.HasMatchHidden(engineFlags);

                    if (exactName == null)
                    {
                        if (EngineFlagOps.HasUseProcedures(engineFlags))
                        {
                            ProcedureWrapperDictionary localProcedures = useHidden ?
                                hiddenProcedures : procedures;

                            if ((localProcedures != null) && (localProcedures.Count > 0))
                            {
                                _Wrappers.Procedure localProcedure;

                                if (localProcedures.TryGetValue(newName, out localProcedure) &&
                                    (matchHidden || !EntityOps.IsHidden(localProcedure)))
                                {
                                    //
                                    // NOTE: Exact procedure match.
                                    //
                                    exactName = newName;

                                    //
                                    // NOTE: Store the exact procedure match in the results
                                    //       dictionary.
                                    //
                                    matches.Add(newName, localProcedure);
                                }
                                else
                                {
                                    foreach (KeyValuePair<string, _Wrappers.Procedure> pair in localProcedures)
                                    {
                                        if (SharedStringOps.SystemEquals(pair.Key, 0, newName, 0, newName.Length))
                                        {
                                            //
                                            // NOTE: Is the procedure visible or are we allowed to
                                            //       find hidden procedures?
                                            //
                                            if (matchHidden || !EntityOps.IsHidden(pair.Value))
                                            {
                                                //
                                                // NOTE: Was the key valid (this should always succeed).
                                                //
                                                if (pair.Key != null)
                                                {
                                                    //
                                                    // NOTE: It was a match; however, was it an exact match?
                                                    //
                                                    if (pair.Key.Length == newName.Length)
                                                        //
                                                        // NOTE: Preserve match, it may differ in case.
                                                        //
                                                        exactName = pair.Key;

                                                    //
                                                    // NOTE: Was it an exact match or did we match at least one
                                                    //       character in a partial match?
                                                    //
                                                    if ((pair.Key.Length == newName.Length) || (newName.Length > 0))
                                                        //
                                                        // NOTE: Store the exact or partial match in the results
                                                        //       dictionary.
                                                        //
                                                        matches.Add(pair.Key, pair.Value);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (exactName == null)
                    {
                        if (EngineFlagOps.HasUseCommands(engineFlags))
                        {
                            CommandWrapperDictionary localCommands = useHidden ?
                                hiddenCommands : commands;

                            if ((localCommands != null) && (localCommands.Count > 0))
                            {
                                _Wrappers.Command localCommand;

                                if (localCommands.TryGetValue(newName, out localCommand) &&
                                    (matchHidden || !EntityOps.IsHidden(localCommand)))
                                {
                                    //
                                    // NOTE: Exact command match.
                                    //
                                    exactName = newName;

                                    //
                                    // NOTE: Store the exact command match in the results
                                    //       dictionary.
                                    //
                                    matches.Add(newName, localCommand);
                                }
                                else
                                {
                                    foreach (KeyValuePair<string, _Wrappers.Command> pair in localCommands)
                                    {
                                        if (SharedStringOps.SystemEquals(pair.Key, 0, newName, 0, newName.Length))
                                        {
                                            //
                                            // NOTE: Is the command visible or are we allowed to
                                            //       find hidden command?
                                            //
                                            if (matchHidden || !EntityOps.IsHidden(pair.Value))
                                            {
                                                //
                                                // NOTE: Was the key valid (this should always succeed).
                                                //
                                                if (pair.Key != null)
                                                {
                                                    //
                                                    // NOTE: It was a match; however, was it an exact match?
                                                    //
                                                    if (pair.Key.Length == newName.Length)
                                                        //
                                                        // NOTE: Preserve match, it may differ in case.
                                                        //
                                                        exactName = pair.Key;

                                                    //
                                                    // NOTE: Was it an exact match or did we match at least one
                                                    //       character in a partial match?
                                                    //
                                                    if ((pair.Key.Length == newName.Length) || (newName.Length > 0))
                                                        //
                                                        // NOTE: Store the exact or partial match in the results
                                                        //       dictionary.
                                                        //
                                                        matches.Add(pair.Key, pair.Value);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    //
                    // NOTE: If there was an exact match, just use it.
                    //
                    // BUGFIX: We need to make 100% sure that we get the wrapper here
                    //         because that is what we want to store in the execute
                    //         cache.  Otherwise, the cache cannot satisfy requests
                    //         for the wrapper later (i.e. based on the lookup flags
                    //         for each call).
                    //
                    LookupFlags localLookupFlags = lookupFlags | LookupFlags.Wrapper;

                    if (exactName != null)
                    {
                        //
                        // NOTE: Exact match, return the matching command or
                        //       procedure.
                        //
                        IExecute match = matches[exactName];

                        if (match is _Wrappers._Execute)
                        {
                            long localToken = 0;
                            IExecute localExecute = null;

                            if ((useHidden && PrivateGetHiddenIExecute(
                                    exactName, localLookupFlags, ref localToken,
                                    ref localExecute, ref error) == ReturnCode.Ok) ||
                                (!useHidden && PrivateGetIExecute(
                                    exactName, localLookupFlags, ref localToken,
                                    ref localExecute, ref error) == ReturnCode.Ok))
                            {
#if EXECUTE_CACHE
                                if (!noCache)
                                    AddOrUpdateIExecuteToCache(exactName, localExecute, useHidden, false);
#endif

                                if (MaybeUnwrapIExecute(
                                        lookupFlags, localExecute, ref localExecute, ref error))
                                {
#if NOTIFY
                                    /* IGNORED */
                                    CheckNotification(
                                        NotifyType.Resolver | (useHidden ? NotifyType.HiddenIExecute : NotifyType.IExecute),
                                        NotifyFlags.Matched | (useHidden ? NotifyFlags.Hidden : NotifyFlags.None),
                                        new ObjectList(engineFlags, name, exactName, localExecute, localToken), this, null, null, null,
                                        ref error);
#endif

                                    token = localToken;
                                    execute = localExecute;

                                    return ReturnCode.Ok;
                                }
                            }
                        }
                        else if (match is _Wrappers.Procedure)
                        {
                            long localToken = 0;
                            IProcedure localProcedure = null;
                            IExecute localExecute = null;

                            if ((useHidden && PrivateGetHiddenProcedure(
                                    exactName, localLookupFlags, ref localToken,
                                    ref localProcedure, ref error) == ReturnCode.Ok) ||
                                (!useHidden && PrivateGetProcedure(
                                    exactName, localLookupFlags, ref localToken,
                                    ref localProcedure, ref error) == ReturnCode.Ok))
                            {
#if EXECUTE_CACHE
                                if (!noCache)
                                    AddOrUpdateIExecuteToCache(exactName, localProcedure, useHidden, false);
#endif

                                if (MaybeUnwrapIExecute(
                                        lookupFlags, localProcedure, ref localExecute, ref error))
                                {
#if NOTIFY
                                    /* IGNORED */
                                    CheckNotification(
                                        NotifyType.Resolver | (useHidden ? NotifyType.HiddenProcedure : NotifyType.Procedure),
                                        NotifyFlags.Matched | (useHidden ? NotifyFlags.Hidden : NotifyFlags.None),
                                        new ObjectList(engineFlags, name, exactName, localProcedure, localToken), this, null, null, null,
                                        ref error);
#endif

                                    token = localToken;
                                    execute = localExecute;

                                    return ReturnCode.Ok;
                                }
                            }
                        }
                        else if (match is _Wrappers.Command)
                        {
                            long localToken = 0;
                            ICommand localCommand = null;
                            IExecute localExecute = null;

                            if ((useHidden && PrivateGetHiddenCommand(
                                    exactName, localLookupFlags, ref localToken,
                                    ref localCommand, ref error) == ReturnCode.Ok) ||
                                (!useHidden && PrivateGetCommand(
                                    exactName, localLookupFlags, ref localToken,
                                    ref localCommand, ref error) == ReturnCode.Ok))
                            {
#if EXECUTE_CACHE
                                if (!noCache)
                                    AddOrUpdateIExecuteToCache(exactName, localCommand, useHidden, false);
#endif

                                if (MaybeUnwrapIExecute(
                                        lookupFlags, localCommand, ref localExecute, ref error))
                                {
#if NOTIFY
                                    /* IGNORED */
                                    CheckNotification(
                                        NotifyType.Resolver | (useHidden ? NotifyType.HiddenCommand : NotifyType.Command),
                                        NotifyFlags.Matched | (useHidden ? NotifyFlags.Hidden : NotifyFlags.None),
                                        new ObjectList(engineFlags, name, exactName, localCommand, localToken), this, null, null, null,
                                        ref error);
#endif

                                    token = localToken;
                                    execute = localExecute;

                                    return ReturnCode.Ok;
                                }
                            }
                        }
                        else
                        {
                            error = FlagOps.HasFlags(
                                lookupFlags, LookupFlags.Verbose, true) ?
                                String.Format(
                                    "object {0} is not an execute, procedure, or command wrapper",
                                    FormatOps.WrapOrNull(exactName)) :
                                "object is not an execute, procedure, or command wrapper";
                        }
                    }
                    else if (matches.Count == 1)
                    {
                        string key = new StringList(matches.Keys)[0];

                        //
                        // NOTE: Normal case, exactly one command matched.
                        //
                        if (matches[key] is _Wrappers._Execute)
                        {
                            long localToken = 0;
                            IExecute localExecute = null;

                            if ((useHidden && (PrivateGetHiddenIExecute(
                                    key, localLookupFlags, ref localToken,
                                    ref localExecute, ref error) == ReturnCode.Ok)) ||
                                (!useHidden && (PrivateGetIExecute(
                                    key, localLookupFlags, ref localToken,
                                    ref localExecute, ref error) == ReturnCode.Ok)))
                            {
#if EXECUTE_CACHE
                                if (!noCache)
                                    AddOrUpdateIExecuteToCache(key, localExecute, useHidden, false);
#endif

                                if (MaybeUnwrapIExecute(
                                        lookupFlags, localExecute, ref localExecute, ref error))
                                {
#if NOTIFY
                                    /* IGNORED */
                                    CheckNotification(
                                        NotifyType.Resolver | (useHidden ? NotifyType.HiddenIExecute : NotifyType.IExecute),
                                        NotifyFlags.Matched | (useHidden ? NotifyFlags.Hidden : NotifyFlags.None),
                                        new ObjectList(engineFlags, name, key, localExecute, localToken), this, null, null, null,
                                        ref error);
#endif

                                    token = localToken;
                                    execute = localExecute;

                                    return ReturnCode.Ok;
                                }
                            }
                        }
                        else if (matches[key] is _Wrappers.Procedure)
                        {
                            long localToken = 0;
                            IProcedure localProcedure = null;
                            IExecute localExecute = null;

                            if ((useHidden && (PrivateGetHiddenProcedure(
                                    key, localLookupFlags, ref localToken,
                                    ref localProcedure, ref error) == ReturnCode.Ok)) ||
                                (!useHidden && (PrivateGetProcedure(
                                    key, localLookupFlags, ref localToken,
                                    ref localProcedure, ref error) == ReturnCode.Ok)))
                            {
#if EXECUTE_CACHE
                                if (!noCache)
                                    AddOrUpdateIExecuteToCache(key, localProcedure, useHidden, false);
#endif

                                if (MaybeUnwrapIExecute(
                                        lookupFlags, localProcedure, ref localExecute, ref error))
                                {
#if NOTIFY
                                    /* IGNORED */
                                    CheckNotification(
                                        NotifyType.Resolver | (useHidden ? NotifyType.HiddenProcedure : NotifyType.Procedure),
                                        NotifyFlags.Matched | (useHidden ? NotifyFlags.Hidden : NotifyFlags.None),
                                        new ObjectList(engineFlags, name, key, localProcedure, localToken), this, null, null, null,
                                        ref error);
#endif

                                    token = localToken;
                                    execute = localExecute;

                                    return ReturnCode.Ok;
                                }
                            }
                        }
                        else if (matches[key] is _Wrappers.Command)
                        {
                            long localToken = 0;
                            ICommand localCommand = null;
                            IExecute localExecute = null;

                            if ((useHidden && (PrivateGetHiddenCommand(
                                    key, localLookupFlags, ref localToken,
                                    ref localCommand, ref error) == ReturnCode.Ok)) ||
                                (!useHidden && (PrivateGetCommand(
                                    key, localLookupFlags, ref localToken,
                                    ref localCommand, ref error) == ReturnCode.Ok)))
                            {
#if EXECUTE_CACHE
                                if (!noCache)
                                    AddOrUpdateIExecuteToCache(key, localCommand, useHidden, false);
#endif

                                if (MaybeUnwrapIExecute(
                                        lookupFlags, localCommand, ref localExecute, ref error))
                                {
#if NOTIFY
                                    /* IGNORED */
                                    CheckNotification(
                                        NotifyType.Resolver | (useHidden ? NotifyType.HiddenCommand : NotifyType.Command),
                                        NotifyFlags.Matched | (useHidden ? NotifyFlags.Hidden : NotifyFlags.None),
                                        new ObjectList(engineFlags, name, key, localCommand, localToken), this, null, null, null,
                                        ref error);
#endif

                                    token = localToken;
                                    execute = localExecute;

                                    return ReturnCode.Ok;
                                }
                            }
                        }
                        else
                        {
                            error = FlagOps.HasFlags(
                                lookupFlags, LookupFlags.Verbose, true) ?
                                String.Format(
                                    "object {0} is not an execute, procedure, or command wrapper",
                                    FormatOps.WrapOrNull(key)) :
                                "object is not an execute, procedure, or command wrapper";
                        }
                    }
                    else if (matches.Count > 1)
                    {
                        error = FlagOps.HasFlags(
                            lookupFlags, LookupFlags.Verbose, true) ?
                            ScriptOps.BadValue(
                                "ambiguous", useHidden ?
                                "hidden command" : "command", name, matches.Keys,
                                null, null) :
                            (Result)"ambiguous command";

                        ambiguous = true;
                    }
                    else
                    {
                        error = FlagOps.HasFlags(
                            lookupFlags, LookupFlags.Verbose, true) ?
                            String.Format(
                                "invalid {0}command name {1}",
                                useHidden ? "hidden " : String.Empty,
                                FormatOps.WrapOrNull(name)) :
                            "invalid command name";
                    }
                }
                else
                {
                    error = "invalid command name";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetAnyIExecute(
            ICallFrame frame,
            EngineFlags engineFlags,
            string name,
            LookupFlags lookupFlags,
            ref IExecute execute,
            ref Result error
            )
        {
            long token = 0;

            return GetAnyIExecute(
                frame, engineFlags, name, lookupFlags, ref token,
                ref execute, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetAnyIExecute(
            ICallFrame frame,
            EngineFlags engineFlags,
            string name,
            LookupFlags lookupFlags,
            ref long token,
            ref IExecute execute,
            ref Result error
            ) /* USED BY CORE RESOLVER */
        {
            /* CheckDisposed(); */

            //
            // NOTE: When searching for [non-hidden] commands, fallback to
            //       searching the hidden commands also to give the policies,
            //       if any, a chance to allow or deny their execution;
            //       however, only do this if the appropriate flag (i.e. the
            //       MatchHidden flag) is set.
            //
            Result localError = null;

            if (PrivateGetAnyIExecute(
                    frame, engineFlags, name, lookupFlags, ref token,
                    ref execute, ref localError) == ReturnCode.Ok)
            {
                return ReturnCode.Ok;
            }
            else if (RuntimeOps.ShouldResolveHidden(engineFlags, false))
            {
                Result localError2 = null; /* VALUE NOT USED */

                if (PrivateGetAnyIExecute(
                        frame, engineFlags | EngineFlags.UseHidden,
                        name, lookupFlags, ref token, ref execute,
                        ref localError2) == ReturnCode.Ok)
                {
                    return ReturnCode.Ok;
                }
            }

            error = localError;
            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode MatchAnyIExecute(
            ICallFrame frame,
            EngineFlags engineFlags,
            string name,
            LookupFlags lookupFlags,
            ref IExecute execute,
            ref Result error
            ) /* USED BY UNIVERSAL OPTION PARSER */
        {
            /* CheckDisposed(); */

            bool ambiguous = false;
            long token = 0;

            return MatchAnyIExecute(
                frame, engineFlags, name, lookupFlags, ref ambiguous,
                ref token, ref execute, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode MatchAnyIExecute(
            ICallFrame frame,
            EngineFlags engineFlags,
            string name,
            LookupFlags lookupFlags,
            ref bool ambiguous,
            ref long token,
            ref IExecute execute,
            ref Result error
            ) /* USED BY CORE RESOLVER */
        {
            /* CheckDisposed(); */

            //
            // BUGFIX: Always try for an exact match first.  This produces the
            //         correct behavior when a single name prefix is an exact
            //         match for a hidden command and is also a prefix match
            //         for a different, visible command.  Currently, this is
            //         hard-coded behavior that cannot be disabled at runtime.
            //
            Result localError = null;

            if (GetAnyIExecute(frame,
                    GetMatchAnyEngineFlags(engineFlags, true),
                    name, lookupFlags, ref token, ref execute,
                    ref localError) == ReturnCode.Ok)
            {
                return ReturnCode.Ok;
            }

            //
            // NOTE: When searching for [non-hidden] commands, fallback to
            //       searching the hidden commands also to give the policies,
            //       if any, a chance to allow or deny their execution;
            //       however, only do this if the appropriate flag (i.e. the
            //       MatchHidden flag) is set.
            //
            if (PrivateMatchAnyIExecute(
                        frame, GetMatchAnyEngineFlags(engineFlags, false),
                        name, lookupFlags, ref ambiguous, ref token,
                        ref execute, ref localError) == ReturnCode.Ok)
            {
                return ReturnCode.Ok;
            }
            else if (RuntimeOps.ShouldResolveHidden(engineFlags, false))
            {
                Result localError2 = null; /* VALUE NOT USED */

                if (PrivateMatchAnyIExecute(
                        frame, GetMatchAnyEngineFlags(engineFlags, false) |
                        EngineFlags.UseHidden, name, lookupFlags,
                        ref ambiguous, ref token, ref execute,
                        ref localError2) == ReturnCode.Ok)
                {
                    return ReturnCode.Ok;
                }
            }

            error = localError;
            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ListAnyIExecute(
            string pattern,
            bool noCase,
            bool hidden,
            bool strict,
            ref ObjectDictionary dictionary,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                ResultList errors = null;
                ObjectDictionary localDictionary = null;
                Result localError = null;

                ///////////////////////////////////////////////////////////////////////////////////////

                if (HasCommands(ref localError))
                {
                    if (commands.ToDictionary(
                            pattern, noCase, ref localDictionary,
                            ref localError) != ReturnCode.Ok)
                    {
                        if (errors == null)
                            errors = new ResultList();

                        errors.Add(localError);
                    }
                }
                else if (strict)
                {
                    if (errors == null)
                        errors = new ResultList();

                    errors.Add(localError);
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                if (HasProcedures(ref localError))
                {
                    if (procedures.ToDictionary(
                            pattern, noCase, ref localDictionary,
                            ref localError) != ReturnCode.Ok)
                    {
                        if (errors == null)
                            errors = new ResultList();

                        errors.Add(localError);
                    }
                }
                else if (strict)
                {
                    if (errors == null)
                        errors = new ResultList();

                    errors.Add(localError);
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                if (HasIExecutes(ref localError))
                {
                    if (executes.ToDictionary(
                            pattern, noCase, ref localDictionary,
                            ref localError) != ReturnCode.Ok)
                    {
                        if (errors == null)
                            errors = new ResultList();

                        errors.Add(localError);
                    }
                }
                else if (strict)
                {
                    if (errors == null)
                        errors = new ResultList();

                    errors.Add(localError);
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                if (hidden)
                {
                    if (HasHiddenCommands(ref localError))
                    {
                        if (hiddenCommands.ToDictionary(
                                pattern, noCase, ref localDictionary,
                                ref localError) != ReturnCode.Ok)
                        {
                            if (errors == null)
                                errors = new ResultList();

                            errors.Add(localError);
                        }
                    }
                    else if (strict)
                    {
                        if (errors == null)
                            errors = new ResultList();

                        errors.Add(localError);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////

                    if (HasHiddenProcedures(ref localError))
                    {
                        if (hiddenProcedures.ToDictionary(
                                pattern, noCase, ref localDictionary,
                                ref localError) != ReturnCode.Ok)
                        {
                            if (errors == null)
                                errors = new ResultList();

                            errors.Add(localError);
                        }
                    }
                    else if (strict)
                    {
                        if (errors == null)
                            errors = new ResultList();

                        errors.Add(localError);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////

                    if (HasHiddenIExecutes(ref localError))
                    {
                        if (hiddenExecutes.ToDictionary(
                                pattern, noCase, ref localDictionary,
                                ref localError) != ReturnCode.Ok)
                        {
                            if (errors == null)
                                errors = new ResultList();

                            errors.Add(localError);
                        }
                    }
                    else if (strict)
                    {
                        if (errors == null)
                            errors = new ResultList();

                        errors.Add(localError);
                    }
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                if (errors != null)
                {
                    error = errors;
                    return ReturnCode.Error;
                }

                dictionary = localDictionary;
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetIExecuteViaResolvers(
            EngineFlags engineFlags,
            string name,
            ArgumentList arguments,
            LookupFlags lookupFlags,
            ref IExecute execute
            )
        {
            return GetIExecuteViaResolvers(
                null, engineFlags, name, arguments, lookupFlags, ref execute);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetIExecuteViaResolvers(
            ICallFrame frame,
            EngineFlags engineFlags,
            string name,
            ArgumentList arguments,
            LookupFlags lookupFlags,
            ref IExecute execute
            )
        {
            Result error = null;

            return GetIExecuteViaResolvers(
                frame, engineFlags, name, arguments, lookupFlags, ref execute,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetIExecuteViaResolvers(
            EngineFlags engineFlags,
            string name,
            ArgumentList arguments,
            LookupFlags lookupFlags,
            ref IExecute execute,
            ref Result error
            )
        {
            return GetIExecuteViaResolvers(
                null, engineFlags, name, arguments, lookupFlags, ref execute,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetIExecuteViaResolvers(
            ICallFrame frame,
            EngineFlags engineFlags,
            string name,
            ArgumentList arguments,
            LookupFlags lookupFlags,
            ref IExecute execute,
            ref Result error
            )
        {
            bool ambiguous = false;

            return GetIExecuteViaResolvers(
                frame, engineFlags, name, arguments, lookupFlags, ref ambiguous,
                ref execute, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetIExecuteViaResolvers(
            EngineFlags engineFlags,
            string name,
            ArgumentList arguments,
            LookupFlags lookupFlags,
            ref bool ambiguous,
            ref IExecute execute,
            ref Result error
            )
        {
            return GetIExecuteViaResolvers(
                null, engineFlags, name, arguments, lookupFlags, ref ambiguous,
                ref execute, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetIExecuteViaResolvers(
            ICallFrame frame,
            EngineFlags engineFlags,
            string name,
            ArgumentList arguments,
            LookupFlags lookupFlags,
            ref bool ambiguous,
            ref IExecute execute,
            ref Result error
            )
        {
            long token = 0;

            return GetIExecuteViaResolvers(
                frame, engineFlags, name, arguments, lookupFlags, ref ambiguous,
                ref token, ref execute, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetProcedureViaResolvers(
            string name,
            LookupFlags lookupFlags,
            ref IProcedure procedure,
            ref Result error
            )
        {
            IExecute execute = null;

            if (GetIExecuteViaResolvers(
                    GetResolveEngineFlagsNoLock(true),
                    name, null, lookupFlags,
                    ref execute, ref error) == ReturnCode.Ok)
            {

            retry:

                if (execute is IProcedure)
                {
                    procedure = (IProcedure)execute;
                    return ReturnCode.Ok;
                }
                else if (execute is IWrapper)
                {
                    IWrapper wrapper = (IWrapper)execute;
                    execute = wrapper.Object as IExecute;
                    goto retry;
                }
                else if (execute is IAlias)
                {
                    IAlias alias = (IAlias)execute;
                    string targetName = null;

                    if (GetAliasArguments(
                            alias, null, ref targetName,
                            ref error) == ReturnCode.Ok)
                    {
                        IExecute aliasTarget = null;

                        if (GetAliasTarget(alias,
                                targetName, null, lookupFlags,
                                true, ref aliasTarget,
                                ref error) == ReturnCode.Ok)
                        {
                            execute = aliasTarget;
                            goto retry;
                        }
                        else
                        {
                            return ReturnCode.Error;
                        }
                    }
                    else
                    {
                        return ReturnCode.Error;
                    }
                }
            }
            else
            {
                return ReturnCode.Error;
            }

            error = FlagOps.HasFlags(
                lookupFlags, LookupFlags.Verbose, true) ?
                String.Format(
                    "invalid procedure name {0}",
                    FormatOps.DisplayName(name)) :
                "invalid procedure name";

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by the ScriptOps.LinkVariable method only.
        //
        internal ReturnCode GetVariableViaResolversWithSplit(
            ICallFrame frame,
            string name,
            ref IVariable variable
            )
        {
            VariableFlags flags = VariableFlags.NoUsable;
            Result error = null;

            return GetVariableViaResolversWithSplit(
                frame, name, null, ref flags, ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetVariableViaResolversWithSplit(
            string name,
            ref VariableFlags variableFlags,
            ref IVariable variable
            )
        {
            Result error = null;

            return GetVariableViaResolversWithSplit(
                name, ref variableFlags, ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetVariableViaResolversWithSplit(
            string name,
            ref VariableFlags variableFlags,
            ref IVariable variable,
            ref Result error
            )
        {
            return GetVariableViaResolversWithSplit(
                null, name, null, ref variableFlags, ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetVariableViaResolversWithSplit(
            ICallFrame frame,
            string name,
            ref VariableFlags variableFlags,
            ref IVariable variable,
            ref Result error
            )
        {
            return GetVariableViaResolversWithSplit(
                frame, name, null, ref variableFlags, ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetVariableViaResolversWithSplit(
            ICallFrame frame,
            string name,
            string index,
            ref VariableFlags variableFlags,
            ref IVariable variable,
            ref Result error
            )
        {
            string varName = null;
            string varIndex = null;

            return GetVariableViaResolversWithSplit(
                frame, name, index, ref varName, ref varIndex, ref variableFlags,
                ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetVariableViaResolversWithSplit(
            ICallFrame frame,
            string name,
            string index,
            ref string varName,
            ref string varIndex,
            ref VariableFlags variableFlags,
            ref IVariable variable,
            ref Result error
            )
        {
            //
            // NOTE: Reset the error related flags because we have not
            //       actually searched for the variable yet.
            //
            variableFlags &= ~VariableFlags.ErrorMask;

            //
            // BUGFIX: Prevent any custom resolvers from returning a null
            //         variable along with a successful return code.
            //
            variableFlags &= ~VariableFlags.ResolveNull;

            //
            // BUGFIX: Block all attempts to use an array element reference
            //         in the variable name if an explicit array element
            //         index has been explicitly specified by the caller.
            //
            if (index != null)
                variableFlags |= VariableFlags.NoElement;

            //
            // NOTE: Perform a split of the name (which may refer to an array
            //       element) into the base variable name and the array index,
            //       if any.
            //
            if (ScriptOps.SplitVariableName(
                    this, variableFlags, name, ref varName,
                    ref varIndex, ref error) == ReturnCode.Ok)
            {
                //
                // NOTE: The caller may need to know if the variable name
                //       refers to an array element.
                //
                if (varIndex != null)
                    variableFlags |= VariableFlags.WasElement;

                return GetVariableViaResolvers(
                    frame, varName, varIndex, ref variableFlags,
                    ref variable, ref error);
            }

            return ReturnCode.Error;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Resolver Management (WARNING: EXPERIMENTAL)
        public bool HasResolvers(ref Result error)
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool result = (resolvers != null);

                if (!result)
                    error = "resolvers not available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ResetResolvers(
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(false, ref error))
                    return ReturnCode.Error;

                if (!HasResolvers(ref error))
                    return ReturnCode.Error;

                InternalResetResolvers(ref error);
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetResolver(
            Priority priority,
            ref IResolve resolve,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasResolvers(ref error))
                    return ReturnCode.Error;

                if (priority == Priority.Lowest)
                    priority = (Priority)resolvers.Count - 1;
                else if (priority == Priority.None)
                    priority = Priority.Highest;

                if (((int)priority < 0) ||
                    ((int)priority > resolvers.Count))
                {
                    error = "invalid priority";
                    return ReturnCode.Error;
                }

                resolve = resolvers[(int)priority];
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddResolver(
            IResolve resolve,
            IClientData clientData,
            Priority priority,
            ref Result result
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!IsModifiable(true, ref result))
                    return ReturnCode.Error;

                if (resolve == null)
                {
                    result = "invalid resolve";
                    return ReturnCode.Error;
                }

                if (!HasResolvers(ref result))
                    return ReturnCode.Error;

                long token;

                if (priority == Priority.Lowest)
                {
                    resolvers.Add(resolve);
                    token = resolvers.Count - 1;
                }
                else
                {
                    if (priority == Priority.None)
                        priority = Priority.Highest;

                    if (((int)priority < 0) ||
                        ((int)priority > resolvers.Count))
                    {
                        result = "invalid priority";
                        return ReturnCode.Error;
                    }

                    resolvers.Insert((int)priority, resolve);
                    token = (long)priority;
                }

                token = EntityOps.NextTokenIdNoThrow(resolve, token);
                EntityOps.SetToken(resolve, token);

#if NOTIFY
                /* IGNORED */
                CheckNotification(
                    NotifyType.Resolve, NotifyFlags.Added,
                    new ObjectPair(resolve, priority), this,
                    clientData, null, null, ref result);
#endif

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private bool HasResolvers()
        {
            Result error = null;

            return HasResolvers(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void InternalResetResolvers(
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasResolvers())
                {
                    DisposeResolvers();

                    IResolve resolve = RuntimeOps.NewResolver(
                        this, CurrentGlobalFrame, globalNamespace,
                        createFlags);

                    resolvers.Clear();
                    resolvers.Add(resolve);

                    EntityOps.SetToken(
                        resolve, (long)Priority.Highest); /* EXEMPT */

#if NOTIFY
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.Resolve, NotifyFlags.Reset,
                        null, this, null, null, null, ref error);
#endif
                }
            }
        }
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IResourceManager Members
        public string GetString(
            string name
            )
        {
            CheckDisposed();

            return GetString(null, name);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string GetString(
            IPlugin plugin,
            string name
            )
        {
            CheckDisposed();

            //
            // NOTE: Use the culture configured for this interpreter.
            //
            return GetString(plugin, name, cultureInfo);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string GetString(
            IPlugin plugin,
            string name,
            ref Result error
            )
        {
            CheckDisposed();

            //
            // NOTE: Use the culture configured for this interpreter.
            //
            return GetString(plugin, name, cultureInfo, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string GetString(
            IPlugin plugin,
            string name,
            CultureInfo cultureInfo
            )
        {
            CheckDisposed();

            Result error = null;

            return GetString(plugin, name, cultureInfo, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public string GetString(
            IPlugin plugin,
            string name,
            CultureInfo cultureInfo,
            ref Result error
            )
        {
            CheckDisposed();

            return RuntimeOps.GetString(
                plugin, resourceManager, name, cultureInfo, ref error);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IScriptManager Members
        public string LibraryPath
        {
            get { CheckDisposed(); lock (syncRoot) { return libraryPath; } }
            set { CheckDisposed(); lock (syncRoot) { libraryPath = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public StringList AutoPathList
        {
            get { CheckDisposed(); lock (syncRoot) { return autoPathList; } }
            set { CheckDisposed(); lock (syncRoot) { autoPathList = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode PreInitialize(
            bool force,      /* in */
            ref Result error /* out */
            )
        {
            CheckDisposed();

            return PrivatePreInitialize(force, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode Initialize(
            bool force,      /* in */
            ref Result error /* out */
            )
        {
            CheckDisposed();

            return PrivateInitialize(force, false, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL
        public ReturnCode InitializeShell(
            bool force,      /* in */
            ref Result error /* out */
            )
        {
            CheckDisposed();

            return PrivateInitializeShell(force, false, ref error);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetScript(
            string name,
            ref ScriptFlags scriptFlags,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            return PrivateGetScript(
                name, ref scriptFlags, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private ReturnCode PrivatePreInitialize(
            bool force,
            ref Result error
            )
        {
            ReturnCode code = ReturnCode.Ok;
            bool wasInitialized;
            bool didInitialize = false;

            lock (syncRoot)
            {
                wasInitialized = preInitialized;
            }

            if (force || !wasInitialized)
            {
                #region Phase 0: Pre-Initialization Script (Optional)
                string text;

                lock (syncRoot)
                {
                    text = preInitializeText;
                }

                if (text != null)
                {
                    Result localResult = null;

                    code = EvaluateScript(text, ref localResult); /* EXEMPT */

                    if (code == ReturnCode.Ok)
                        didInitialize = true;
                    else
                        error = localResult;
                }
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Phase 1: Set Library Pre-Initialized Flag
                //
                // NOTE: Has everything succeeded?
                //
                if (code == ReturnCode.Ok)
                {
                    lock (syncRoot) /* TRANSACTIONAL */
                    {
                        if (!preInitialized)
                            preInitialized = true;
                    }

#if NOTIFY && NOTIFY_GLOBAL
                    if (this.PrivateGlobalNotify)
                    {
                        /* IGNORED */
                        CheckNotifications(
                            null, false, NotifyType.Interpreter |
                            NotifyType.Library, NotifyFlags.PreInitialized,
                            new ObjectTriplet(force, text, didInitialize),
                            this, null, null, null, ref error);
                    }
#endif
                }
                #endregion
            }

            TraceOps.DebugTrace(String.Format(
                "PrivatePreInitialize: interpreter = {0}, force = {1}, " +
                "wasInitialized = {2}, didInitialize = {3}, code = {4}, " +
                "error = {5}",
                FormatOps.InterpreterNoThrow(this),
                force, wasInitialized, didInitialize, code,
                FormatOps.WrapOrNull(true, true, error)),
                typeof(Interpreter).Name, TracePriority.StartupDebug);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsInitializeDirect()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                return FlagOps.HasFlags(
                    initializeFlags, InitializeFlags.Direct, true);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string GetScript(
            string name,
            ref ScriptFlags scriptFlags,
            ref IClientData clientData
            )
        {
            Result result = null;

            if (PrivateGetScript(
                    name, ref scriptFlags, ref clientData,
                    ref result) != ReturnCode.Ok)
            {
                result = null; /* NOTE: Discard error message. */
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetScript(
            string name,
            ref ScriptFlags scriptFlags,
            ref Result result
            )
        {
            IClientData clientData = null;

            return PrivateGetScript(
                name, ref scriptFlags, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateGetScript(
            string name,
            ref ScriptFlags scriptFlags,
            ref IClientData clientData,
            ref Result result
            )
        {
            IFileSystemHost fileSystemHost = InternalHost;
            bool direct = IsInitializeDirect();

            if (FlagOps.HasFlags(
                    scriptFlags, ScriptFlags.Library, true))
            {
                return ScriptOps.GetLibrary(
                    this, fileSystemHost, name, direct,
                    ref scriptFlags, ref clientData,
                    ref result);
            }
            else
            {
                return HostOps.GetScript(
                    this, fileSystemHost, name, direct,
                    ref scriptFlags, ref clientData,
                    ref result);
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ISecurityManager Members
        public StringList TrustedPaths
        {
            get { CheckDisposed(); return InternalTrustedPaths; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public UriDictionary<object> TrustedUris
        {
            get { CheckDisposed(); return InternalTrustedUris; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ObjectDictionary TrustedTypes
        {
            get { CheckDisposed(); return InternalTrustedTypes; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public PolicyDecision CommandDecision
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return commandDecision;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    commandDecision = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public PolicyDecision ScriptDecision
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return scriptDecision;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    scriptDecision = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public PolicyDecision FileDecision
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return fileDecision;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    fileDecision = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public PolicyDecision StreamDecision
        {
            get
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    return streamDecision;
                }
            }
            set
            {
                CheckDisposed();

                lock (syncRoot)
                {
                    streamDecision = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsRestricted()
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                return InternalIsSafe() || InternalIsAnySdk();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsSecuritySdk()
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                return PrivateIsSecuritySdk();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsLicenseSdk()
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                return PrivateIsLicenseSdk();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsAnySdk()
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                return InternalIsAnySdk();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsSdk(
            SdkType sdkType,
            bool all
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                return InternalIsSdk(sdkType, all);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsSafe()
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                return InternalIsSafe();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode MakeSafe(
            MakeFlags makeFlags,
            bool safe,
            ref Result error
            )
        {
            CheckDisposed();

            return InternalMakeSafe(makeFlags, safe, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode MarkTrusted(
            ref Result error /* NOT USED */
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                InternalMarkTrusted();
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode MarkSafe(
            ref Result error /* NOT USED */
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                InternalMarkSafe();
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode LockAndMarkTrusted(ref Result error)
        {
            CheckDisposed();

            if (syncRoot == null)
            {
                error = "invalid interpreter synchronization object";
                return ReturnCode.Error;
            }

            if (!Monitor.TryEnter(syncRoot)) /* EXEMPT */
            {
                error = "could not obtain interpreter lock";
                return ReturnCode.Error;
            }

            if (!InternalIsSafe())
            {
                error = "interpreter is already marked as trusted";
                Monitor.Exit(syncRoot); /* EXEMPT */
                return ReturnCode.Error;
            }

            /* LOCK HELD */
            InternalMarkTrusted();

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode MarkSafeAndUnlock(ref Result error)
        {
            CheckDisposed();

            if (syncRoot == null)
            {
                error = "invalid interpreter synchronization object";
                return ReturnCode.Error;
            }

            if (!Monitor.TryEnter(syncRoot)) /* EXEMPT */
            {
                error = "could not obtain interpreter lock";
                return ReturnCode.Error;
            }

            if (InternalIsSafe())
            {
                error = "interpreter is already marked as safe";
                Monitor.Exit(syncRoot); /* EXEMPT */
                return ReturnCode.Error;
            }

            /* LOCK HELD */
            InternalMarkSafe();
            Monitor.Exit(syncRoot); /* EXEMPT */
            Monitor.Exit(syncRoot); /* EXEMPT */
            /* LOCK NOT HELD */

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool SetSecurityWasEnabled(
            bool? enabled
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                InterpreterStateFlags flags = InterpreterStateFlags.SecurityWasEnabled;
                bool result = FlagOps.HasFlags(interpreterStateFlags, flags, true);

                if (enabled != null)
                {
                    if ((bool)enabled)
                    {
                        interpreterStateFlags |= flags;
                        result = !result;
                    }
                    else
                    {
                        interpreterStateFlags &= ~flags;
                    }
                }

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsStandard()
        {
            CheckDisposed();

            return InternalIsStandard();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode MakeStandard(
            MakeFlags makeFlags,
            bool standard,
            ref Result error
            )
        {
            CheckDisposed();

            return PrivateMakeStandard(makeFlags, standard, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal bool InternalPreSetup
        {
            get { return preSetup; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateSetup /* NOT USED */
        {
            get { return setup; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalInitialized
        {
            get { return initialized; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateInitialized
        {
            get { return initialized; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string InternalInitializedPath
        {
            get { return initializedPath; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL
        //
        // WARNING: This cannot be named simply "InitializeShell"
        //          because that conflicts with the method of the
        //          same name.
        //
        private bool ShouldInitializeShell
        {
            get
            {
                return FlagOps.HasFlags(interpreterStateFlags,
                    InterpreterStateFlags.InitializeShell, true);
            }
            set
            {
                if (value)
                    interpreterStateFlags |= InterpreterStateFlags.InitializeShell;
                else
                    interpreterStateFlags &= ~InterpreterStateFlags.InitializeShell;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateInitializedShell /* NOT USED */
        {
            get { return initializedShell; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string InternalInitializedShellPath
        {
            get { return initializedShellPath; }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal StringList InternalTrustedPaths
        {
            get { return trustedPaths; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal UriDictionary<object> InternalTrustedUris
        {
            get { return trustedUris; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ObjectDictionary InternalTrustedTypes
        {
            get { return trustedTypes; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool HasZeroString(
            MakeFlags makeFlags
            )
        {
#if !MONO && NATIVE && WINDOWS
            return FlagOps.HasFlags(
                makeFlags, MakeFlags.ZeroString, true);
#else
            return false;
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateIsSecuritySdk()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            return PrivateIsSecuritySdk(createFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateIsLicenseSdk()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            return PrivateIsLicenseSdk(createFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalIsAnySdk()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            return PrivateIsAnySdk(createFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalIsSdk(
            SdkType sdkType,
            bool all
            )
        {
            //
            // NOTE: Assumes lock is already held.
            //
            return PrivateIsSdk(sdkType, createFlags, all);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalIsSafe()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            return PrivateIsSafe(createFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalIsSafeOrSdk()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            return PrivateIsSafeOrSdk(createFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalIsSafeWithFlags(
            InterpreterFlags hasFlags,
            bool all
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                return InternalIsSafe() &&
                    /* EXEMPT */
                    FlagOps.HasFlags(interpreterFlags, hasFlags, all);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void InternalMarkTrusted()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            createFlags &= ~CreateFlags.Safe;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void InternalMarkSafe()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            createFlags |= CreateFlags.Safe;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateIsHideUnsafe()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            return PrivateIsHideUnsafe(createFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalIsStandard()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            return PrivateIsStandard(createFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateIsHideNonStandard()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            return PrivateIsHideNonStandard(createFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool PrivateIsSecuritySdk(
            CreateFlags createFlags
            )
        {
            return FlagOps.HasFlags(
                createFlags, CreateFlags.SecuritySdk, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool PrivateIsLicenseSdk(
            CreateFlags createFlags
            )
        {
            return FlagOps.HasFlags(
                createFlags, CreateFlags.LicenseSdk, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool PrivateIsAnySdk(
            CreateFlags createFlags
            )
        {
            return FlagOps.HasFlags(
                createFlags, CreateFlags.SdkMask, false);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool PrivateIsSdk(
            SdkType sdkType,
            CreateFlags createFlags,
            bool all
            )
        {
            CreateFlags hasCreateFlags = CreateFlags.None;

            if (FlagOps.HasFlags(sdkType, SdkType.Security, true))
                hasCreateFlags |= CreateFlags.SecuritySdk;

            if (FlagOps.HasFlags(sdkType, SdkType.License, true))
                hasCreateFlags |= CreateFlags.LicenseSdk;

            return FlagOps.HasFlags(createFlags, hasCreateFlags, all);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool PrivateIsSafe(
            CreateFlags createFlags
            )
        {
            return FlagOps.HasFlags(
                createFlags, CreateFlags.Safe, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool PrivateIsSafeOrSdk(
            CreateFlags createFlags
            )
        {
            return FlagOps.HasFlags(
                createFlags, CreateFlags.SafeOrSdkMask, false);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool PrivateIsHideUnsafe(
            CreateFlags createFlags
            )
        {
            return FlagOps.HasFlags(
                createFlags, CreateFlags.HideUnsafe, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool PrivateIsStandard(
            CreateFlags createFlags
            )
        {
            return FlagOps.HasFlags(
                createFlags, CreateFlags.Standard, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool PrivateIsHideNonStandard(
            CreateFlags createFlags
            )
        {
            return FlagOps.HasFlags(
                createFlags, CreateFlags.HideNonStandard, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void PrivateMarkSafeAndHideUnsafe()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            createFlags |= CreateFlags.SafeAndHideUnsafe;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void PrivateUnmarkSafeAndHideUnsafe()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            createFlags &= ~CreateFlags.SafeAndHideUnsafe;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void PrivateMarkStandardAndHideNonStandard()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            createFlags |= CreateFlags.StandardAndHideNonStandard;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void PrivateUnmarkStandardAndHideNonStandard()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            createFlags &= ~CreateFlags.StandardAndHideNonStandard;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MakeVariableSafe(
            string name,
            IVariable variable,
            bool reset,
            bool zero
            )
        {
            if (variable == null)
                return;

            VariableFlags flags = variable.Flags;

            if ((!FlagOps.HasFlags(flags, VariableFlags.Safe, true) ||
                FlagOps.HasFlags(flags, VariableFlags.Unsafe, true)) &&
                !ScriptOps.IsSafeVariableName(name))
            {
                //
                // NOTE: Mark this "unsafe" variable for removal.
                //
                if (reset && (variable is Variable))
                    ((Variable)variable).ResetValue(this, zero);

                EntityOps.SetUndefined(variable, true);
            }
            else if (SharedStringOps.SystemEquals(name, TclVars.Platform.Name))
            {
                //
                // NOTE: Prepare to remove the "unsafe" array elements
                //       from the "tcl_platform" array.
                //
                ElementDictionary arrayValue = variable.ArrayValue;

                if (arrayValue != null)
                {
                    //
                    // NOTE: This must be done in two phases because
                    //       we cannot modify the dictionary while we
                    //       enumerate it.
                    //
                    StringList keys = new StringList();

                    foreach (KeyValuePair<string, object> pair2 in arrayValue)
                        if (!ScriptOps.IsSafeTclPlatformElementName(pair2.Key))
                            keys.Add(pair2.Key);

                    //
                    // NOTE: Purge the "unsafe" array elements.
                    //
                    foreach (string key in keys)
                    {
                        if (reset)
                        {
                            /* IGNORED */
                            arrayValue.ResetValue(this, key, zero);
                        }
                        else
                        {
                            /* IGNORED */
                            arrayValue.Remove(key);
                        }
                    }
                }
            }
            else if (SharedStringOps.SystemEquals(name, Vars.Platform.Name))
            {
                //
                // NOTE: Prepare to remove the "unsafe" array elements
                //       from the "eagle_platform" array.
                //
                ElementDictionary arrayValue = variable.ArrayValue;

                if (arrayValue != null)
                {
                    //
                    // NOTE: This must be done in two phases because
                    //       we cannot modify the dictionary while we
                    //       enumerate it.
                    //
                    StringList keys = new StringList();

                    foreach (KeyValuePair<string, object> pair2 in arrayValue)
                        if (!ScriptOps.IsSafeEaglePlatformElementName(pair2.Key))
                            keys.Add(pair2.Key);

                    //
                    // NOTE: Purge the "unsafe" array elements.
                    //
                    foreach (string key in keys)
                    {
                        if (reset)
                        {
                            /* IGNORED */
                            arrayValue.ResetValue(this, key, zero);
                        }
                        else
                        {
                            /* IGNORED */
                            arrayValue.Remove(key);
                        }
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode InternalMakeSafe(
            MakeFlags makeFlags,
            bool safe,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (FlagOps.HasFlags(makeFlags, MakeFlags.IncludeCommands, true))
                {
                    CommandWrapperDictionary localCommands = safe ? commands : hiddenCommands;

                    if (localCommands != null)
                    {
                        foreach (KeyValuePair<string, _Wrappers.Command> pair in localCommands)
                        {
                            ICommand command = pair.Value;

                            if (command == null)
                                continue;

                            CommandFlags flags = command.Flags;

                            if (!FlagOps.HasFlags(flags, CommandFlags.Safe, true) ||
                                FlagOps.HasFlags(flags, CommandFlags.Unsafe, true))
                            {
                                if (safe)
                                    flags |= CommandFlags.Hidden;
                                else
                                    flags &= ~CommandFlags.Hidden;

                                command.Flags = flags;
                            }
                        }
                    }
                }

                if (FlagOps.HasFlags(makeFlags, MakeFlags.IncludeProcedures, true))
                {
                    ProcedureWrapperDictionary localProcedures = safe ? procedures : hiddenProcedures;

                    if (localProcedures != null)
                    {
                        foreach (KeyValuePair<string, _Wrappers.Procedure> pair in localProcedures)
                        {
                            IProcedure procedure = pair.Value;

                            if (procedure == null)
                                continue;

                            ProcedureFlags flags = procedure.Flags;

                            if (!FlagOps.HasFlags(flags, ProcedureFlags.Safe, true) ||
                                FlagOps.HasFlags(flags, ProcedureFlags.Unsafe, true))
                            {
                                if (safe)
                                    flags |= ProcedureFlags.Hidden;
                                else
                                    flags &= ~ProcedureFlags.Hidden;

                                procedure.Flags = flags;
                            }
                        }
                    }
                }

                if ((functions != null) &&
                    FlagOps.HasFlags(makeFlags, MakeFlags.IncludeFunctions, true))
                {
                    foreach (KeyValuePair<string, _Wrappers.Function> pair in functions)
                    {
                        IFunction function = pair.Value;

                        if (function == null)
                            continue;

                        FunctionFlags flags = function.Flags;

                        if (!FlagOps.HasFlags(flags, FunctionFlags.Safe, true) ||
                            FlagOps.HasFlags(flags, FunctionFlags.Unsafe, true))
                        {
                            if (safe)
                                flags |= FunctionFlags.DisabledAndHidden;
                            else
                                flags &= ~FunctionFlags.DisabledAndHidden;

                            function.Flags = flags;
                        }
                    }
                }

                //
                // NOTE: Move all the newly hidden and exposed commands to
                //       their proper internal collections.
                //
                if (MoveExposedAndHiddenCommands(
                        PluginFlags.None, ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }

                //
                // BUGBUG: Removal of the "unsafe" variables and array
                //         elements from the global call frame is
                //         currently a one-way street, just like in Tcl.
                //         We make no attempt to restore the deleted
                //         variables if/when the interpreter is made
                //         "unsafe" again.
                //
                if (safe &&
                    FlagOps.HasFlags(makeFlags, MakeFlags.IncludeVariables, true))
                {
                    if (UnsetGlobalScopeCallFrame(false, ref error) == ReturnCode.Ok)
                    {
                        ICallFrame variableFrame = CurrentGlobalFrame;

                        if (variableFrame != null)
                        {
                            VariableDictionary variables = variableFrame.Variables;

                            if (variables != null)
                            {
                                bool reset = FlagOps.HasFlags(
                                    makeFlags, MakeFlags.ResetValue, true);

                                bool zero = HasZeroString() && HasZeroString(makeFlags);

                                foreach (KeyValuePair<string, IVariable> pair in variables)
                                    MakeVariableSafe(pair.Key, pair.Value, reset, zero);

                                //
                                // NOTE: Purge all the undefined (i.e. deleted)
                                //       variables from the [global] call frame.
                                //
                                /* IGNORED */
                                CallFrameOps.Cleanup(
                                    variableFrame, variableFrame, false);
                            }
                        }
                    }
                    else
                    {
                        return ReturnCode.Error;
                    }
                }

                if (safe)
                    PrivateMarkSafeAndHideUnsafe();
                else
                    PrivateUnmarkSafeAndHideUnsafe();
            }

            //
            // NOTE: *WARNING* Please do not move this inside of the lock
            //       statement.
            //
            if (safe &&
                FlagOps.HasFlags(makeFlags, MakeFlags.IncludeLibrary, true))
            {
                //
                // NOTE: Finally, attempt to evaluate the safe interpreter
                //       initialization script (i.e. "safe.eagle").
                //
                bool direct = IsInitializeDirect();

                ScriptFlags scriptFlags = ScriptOps.GetFlags(
                    this, ScriptFlags.CoreLibraryRequiredFile,
                    false, false);

                IClientData clientData = _ClientData.Empty;

                ReturnCode code = EvaluateScript(
                    this, FileName.Safe, true, direct, ref scriptFlags,
                    ref clientData, ref error);

                if (code != ReturnCode.Ok)
                    return code;
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateMakeStandard(
            MakeFlags makeFlags,
            bool standard,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (FlagOps.HasFlags(makeFlags, MakeFlags.IncludeCommands, true))
                {
                    CommandWrapperDictionary localCommands = standard ? commands : hiddenCommands;

                    if (localCommands != null)
                    {
                        foreach (KeyValuePair<string, _Wrappers.Command> pair in localCommands)
                        {
                            ICommand command = pair.Value;

                            if (command == null)
                                continue;

                            CommandFlags flags = command.Flags;

                            if (!FlagOps.HasFlags(flags, CommandFlags.Standard, true) ||
                                FlagOps.HasFlags(flags, CommandFlags.NonStandard, true))
                            {
                                if (standard)
                                    flags |= CommandFlags.Hidden;
                                else
                                    flags &= ~CommandFlags.Hidden;

                                command.Flags = flags;
                            }
                        }
                    }
                }

                if ((functions != null) &&
                    FlagOps.HasFlags(makeFlags, MakeFlags.IncludeFunctions, true))
                {
                    foreach (KeyValuePair<string, _Wrappers.Function> pair in functions)
                    {
                        IFunction function = pair.Value;

                        if (function == null)
                            continue;

                        FunctionFlags flags = function.Flags;

                        if (!FlagOps.HasFlags(flags, FunctionFlags.Standard, true) ||
                            FlagOps.HasFlags(flags, FunctionFlags.NonStandard, true))
                        {
                            if (standard)
                                flags |= FunctionFlags.DisabledAndHidden;
                            else
                                flags &= ~FunctionFlags.DisabledAndHidden;

                            function.Flags = flags;
                        }
                    }
                }

                if ((operators != null) &&
                    FlagOps.HasFlags(makeFlags, MakeFlags.IncludeOperators, true))
                {
                    foreach (KeyValuePair<string, _Wrappers.Operator> pair in operators)
                    {
                        IOperator @operator = pair.Value;

                        if (@operator == null)
                            continue;

                        OperatorFlags flags = @operator.Flags;

                        if (!FlagOps.HasFlags(flags, OperatorFlags.Standard, true) ||
                            FlagOps.HasFlags(flags, OperatorFlags.NonStandard, true))
                        {
                            if (standard)
                                flags |= OperatorFlags.DisabledAndHidden;
                            else
                                flags &= ~OperatorFlags.DisabledAndHidden;

                            @operator.Flags = flags;
                        }
                    }
                }

                //
                // NOTE: Move all the newly hidden and exposed commands to
                //       their proper internal collections.
                //
                if (MoveExposedAndHiddenCommands(
                        PluginFlags.None, ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }

                if (standard)
                    PrivateMarkStandardAndHideNonStandard();
                else
                    PrivateUnmarkStandardAndHideNonStandard();
            }

            return ReturnCode.Ok;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IShellManager Members
#if SHELL
        public PreviewArgumentCallback PreviewArgumentCallback
        {
            get
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.PreviewArgumentCallback;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return previewArgumentCallback;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.PreviewArgumentCallback = value;
#else
                lock (syncRoot)
                {
                    previewArgumentCallback = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public UnknownArgumentCallback UnknownArgumentCallback
        {
            get
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.UnknownArgumentCallback;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return unknownArgumentCallback;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.UnknownArgumentCallback = value;
#else
                lock (syncRoot)
                {
                    unknownArgumentCallback = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public EvaluateScriptCallback EvaluateScriptCallback
        {
            get
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.EvaluateScriptCallback;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return evaluateScriptCallback;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.EvaluateScriptCallback = value;
#else
                lock (syncRoot)
                {
                    evaluateScriptCallback = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public EvaluateFileCallback EvaluateFileCallback
        {
            get
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.EvaluateFileCallback;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return evaluateFileCallback;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.EvaluateFileCallback = value;
#else
                lock (syncRoot)
                {
                    evaluateFileCallback = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public EvaluateEncodedFileCallback EvaluateEncodedFileCallback
        {
            get
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.EvaluateEncodedFileCallback;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return evaluateEncodedFileCallback;
                }
#endif
            }
            set
            {
                CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.EvaluateEncodedFileCallback = value;
#else
                lock (syncRoot)
                {
                    evaluateEncodedFileCallback = value;
                }
#endif
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IStatusManager Members
#if WINFORMS
        public ReturnCode CheckStatus(
            IClientData clientData, /* in: NOT USED */
            int? timeout,           /* in */
            ref Result error        /* out */
            )
        {
            CheckDisposed();

            int localTimeout;

            if (timeout != null)
                localTimeout = (int)timeout;
            else
                localTimeout = GetMinimumSleepTime(SleepType.Heartbeat) * 2;

            return StatusFormOps.CheckThread(this, localTimeout, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode StartStatus(
            IClientData clientData, /* in: OPTIONAL */
            int? timeout,           /* in */
            ref Result error        /* out */
            )
        {
            CheckDisposed();

            bool? canClose;
            bool? topMost;
            bool? allowHotKeys;

            StatusFormOps.GetStartFlags(
                clientData, out canClose, out topMost, out allowHotKeys);

            int localTimeout;

            if (timeout != null)
            {
                localTimeout = (int)timeout;
            }
            else
            {
                localTimeout = GetMinimumSleepTime(SleepType.Heartbeat) * 10;

                if (CommonOps.Runtime.IsMono())
                    localTimeout *= 2;
            }

            return StatusFormOps.StartThread(
                this, localTimeout, canClose, topMost, allowHotKeys, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode StopStatus(
            IClientData clientData, /* in: NOT USED */
            int? timeout,           /* in */
            ref Result error        /* out */
            )
        {
            CheckDisposed();

            return StatusFormOps.StopThread(
                this, GetStatusSynchronous(false, true), ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ClearStatus(
            IClientData clientData, /* in: OPTIONAL */
            int? timeout,           /* in */
            ref Result error        /* out */
            )
        {
            CheckDisposed();

            if (MaybeInvokeStatusCallback(
                    clientData, null, true, ref error))
            {
                return ReturnCode.Ok;
            }

            return StatusFormOps.Clear(
                this, !GetStatusSynchronous(false, false),
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ReportStatus(
            IClientData clientData, /* in: OPTIONAL */
            string text,            /* in */
            int? timeout,           /* in */
            ref Result error        /* out */
            )
        {
            CheckDisposed();

            if (MaybeInvokeStatusCallback(
                    clientData, text, false, ref error))
            {
                return ReturnCode.Ok;
            }

            return StatusFormOps.Report(
                this, text, !GetStatusSynchronous(false, false),
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private bool GetStatusSynchronous(
            bool dispose,
            bool stop
            )
        {
            if (!dispose && stop &&
                !PlatformOps.IsWindowsOperatingSystem())
            {
                return true; /* HACK: Wait for stop on Mono with X11. */
            }

            return statusSynchronous;
        }
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ISynchronize Members
        public object SyncRoot
        {
            //
            // TODO: Rethink this strategy.  Should calls for the interpreter
            //       lock from inside the interpreter methods be able to throw
            //       an exception?  If so, why?  If not, why not?
            //
            get { CheckDisposed(); return syncRoot; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public void TryLock(
            ref bool locked
            )
        {
            CheckDisposed();

            InternalSoftTryLock(ref locked);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public void TryLock(
            int timeout,
            ref bool locked
            )
        {
            CheckDisposed();

            InternalTryLock(timeout, ref locked);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public void ExitLock(
            ref bool locked
            )
        {
            if (RuntimeOps.ShouldCheckDisposedOnExitLock(locked)) /* EXEMPT */
                CheckDisposed();

            InternalExitLock(ref locked);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal object InternalSyncRoot
        {
            get { return syncRoot; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void InternalLock(
            ref bool locked
            )
        {
            if (syncRoot == null)
                return;

            Monitor.Enter(syncRoot);
            locked = true;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void InternalSoftTryLock(
            ref bool locked
            )
        {
            if (syncRoot == null)
                return;

            locked = Monitor.TryEnter(syncRoot);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void InternalHardTryLock(
            ref bool locked
            )
        {
            InternalTryLock(ThreadOps.GetTimeout(
                this, null, TimeoutType.Lock), ref locked);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void InternalTryLock(
            int timeout,
            ref bool locked
            )
        {
            if (syncRoot == null)
                return;

            locked = Monitor.TryEnter(syncRoot, timeout);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void InternalExitLock(
            ref bool locked
            )
        {
            if (syncRoot == null)
                return;

            if (locked)
            {
                Monitor.Exit(syncRoot);
                locked = false;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ITclEntityManager Members
#if NATIVE && TCL
        #region Tcl Interpreter Support
        public bool HasTclInterpreters(ref Result error)
        {
            CheckDisposed();

            return InternalHasTclInterpreters(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesTclInterpreterExist(string name)
        {
            CheckDisposed();

            IntPtr interp = IntPtr.Zero;
            Result error = null;

            return GetTclInterpreter(name, LookupFlags.Exists, ref interp, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetTclInterpreter(
            string name,
            LookupFlags lookupFlags,
            ref IntPtr interp,
            ref Result error
            )
        {
            CheckDisposed();

            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (InternalHasTclInterpreters(ref error))
                {
                    //
                    // NOTE: *WARNING* Empty Tcl interpreter names are allowed,
                    //       please do not change this to "!String.IsNullOrEmpty".
                    //
                    if (name != null)
                    {
                        if (tclInterps.TryGetValue(name, out interp) &&
                            ((interp != IntPtr.Zero) ||
                            !FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true)))
                        {
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            error = FlagOps.HasFlags(
                                lookupFlags, LookupFlags.Verbose, true) ?
                                String.Format(
                                    "invalid Tcl interpreter {0}",
                                    FormatOps.WrapOrNull(name)) :
                                "invalid Tcl interpreter";
                        }
                    }
                    else
                    {
                        error = "invalid Tcl interpreter name";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode CreateTclInterpreter(
            bool initialize,
            bool memory,
            bool safe,
            ref Result result
            )
        {
            CheckDisposed();

            if (!IsModifiable(true, ref result))
                return ReturnCode.Error;

            if (IsTclReadOnly(ref result))
                return ReturnCode.Error;

            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (InternalHasTclInterpreters(ref result))
                {
                    GlobalState.PushActiveInterpreter(this);

                    try
                    {
                        IntPtr interp = IntPtr.Zero;

                        if (TclWrapper.CreateInterpreter(tclApi, initialize, memory, safe,
                                ref interp, ref result) == ReturnCode.Ok)
                        {
                            string name = FormatOps.Id(
                                safe ? tclSafeInterpPrefix : tclInterpPrefix, null, NextId());

                            tclInterps.Add(name, interp);
                            result = name;

#if NOTIFY && NOTIFY_TCL
                            /* IGNORED */
                            CheckNotification(
                                NotifyType.Tcl | NotifyType.Interpreter, NotifyFlags.Added,
                                //
                                // BUGBUG: In order to use this class for notification
                                //         parameters, it really should probably be
                                //         made public.
                                //
                                new ObjectList(initialize, safe, name, interp), this,
                                null, null, null, ref result);
#endif

                            return ReturnCode.Ok;
                        }
                    }
                    finally
                    {
                        /* IGNORED */
                        GlobalState.PopActiveInterpreter();
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DeleteTclInterpreter(
            string name,
            ref Result result
            )
        {
            CheckDisposed();

            if (!IsModifiable(false, ref result))
                return ReturnCode.Error;

            if (IsTclReadOnly(ref result))
                return ReturnCode.Error;

            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (InternalHasTclInterpreters(ref result))
                {
                    GlobalState.PushActiveInterpreter(this);

                    try
                    {
                        IntPtr interp = IntPtr.Zero;

                        if (GetTclInterpreter(
                                name, LookupFlags.Default, ref interp, ref result) == ReturnCode.Ok)
                        {
                            if (
#if NATIVE_PACKAGE
                                !NativePackage.ShouldDeleteTclInterpreter(name, interp) ||
#endif
                                TclWrapper.DeleteInterpreter(
                                    tclApi, false, ref interp, ref result) == ReturnCode.Ok)
                            {
                                tclInterps.Remove(name);
                                result = String.Empty;

#if NOTIFY && NOTIFY_TCL
                                /* IGNORED */
                                CheckNotification(
                                    NotifyType.Tcl | NotifyType.Interpreter, NotifyFlags.Removed,
                                    new ObjectPair(name, interp), this,
                                    null, null, null, ref result);
#endif

                                return ReturnCode.Ok;
                            }
                        }
                    }
                    finally
                    {
                        /* IGNORED */
                        GlobalState.PopActiveInterpreter();
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal bool InternalHasTclInterpreters()
        {
            Result error = null;

            return InternalHasTclInterpreters(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalHasTclInterpreters(
            ref Result error
            )
        {
            lock (tclSyncRoot)
            {
                bool result = (tclInterps != null);

                if (!result)
                    error = "no Tcl interpreters available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetTclInterpreter(
            string name,
            LookupFlags lookupFlags,
            ref IntPtr interp
            )
        {
            Result error = null;

            return GetTclInterpreter(name, lookupFlags, ref interp, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetTclParentInterpreter(
            LookupFlags lookupFlags,
            ref string name,
            ref IntPtr interp,
            ref Result error
            )
        {
            /* CheckDisposed(); */

            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (InternalHasTclInterpreters(ref error))
                {
                    //
                    // HACK: Use the convention that we always prefix the
                    //       parent Tcl interpreter with a specially formatted
                    //       name in order to find it (we cannot simply use the
                    //       Tcl interpreter at index zero because the Tcl
                    //       interpreters are maintained in a dictionary).
                    //
                    string pattern = FormatOps.Id(tclParentInterpPrefix, null,
                        Characters.Asterisk.ToString());

                    //
                    // NOTE: Search all the Tcl interpreters in this interpreter
                    //       for the parent Tcl interp stopping as soon as we
                    //       find a valid one (there should only be one valid
                    //       parent Tcl interpreter per interpreter at any given
                    //       time).
                    //
                    string key = null;
                    IntPtr value = IntPtr.Zero;

                    foreach (KeyValuePair<string, IntPtr> pair in tclInterps)
                    {
                        //
                        // NOTE: Hard-coded match mode is OK here.
                        //
                        if (StringOps.Match(
                                this, MatchMode.Glob, pair.Key, pattern, false) &&
                            (pair.Value != IntPtr.Zero))
                        {
                            key = pair.Key;
                            value = pair.Value;
                            break;
                        }
                    }

                    //
                    // NOTE: Did we find the handle for the parent Tcl
                    //       interpreter?
                    //
                    if (key != null)
                    {
                        name = key;
                        interp = value;

                        return ReturnCode.Ok;
                    }
                    else
                    {
                        error = "Tcl parent interpreter is not available";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Used by the Execute method of the _Commands.Tcl class to help
        //       implement the [tcl primary] sub-command.
        //
        internal ReturnCode GetAnyTclParentInterpreter(
            LookupFlags lookupFlags,
            ref string name,
            ref IntPtr interp,
            ref Result error
            )
        {
            ResultList errors = null;
            Result localError = null;

            if (GetTclParentInterpreter(
                    lookupFlags, ref name, ref interp,
                    ref localError) == ReturnCode.Ok)
            {
                return ReturnCode.Ok;
            }
            else
            {
                if (errors == null)
                    errors = new ResultList();

                errors.Add(localError);
            }

#if NATIVE_PACKAGE
            localError = null;

            if (NativePackage.GetParentTclInterpreter(
                    this, ref name, ref interp,
                    ref localError) == ReturnCode.Ok)
            {
                return ReturnCode.Ok;
            }
            else
            {
                if (errors == null)
                    errors = new ResultList();

                errors.Add(localError);
            }
#endif

            error = errors;
            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the TclApi class only.
        //
        internal bool HasTclInterpreter(
            string pattern,
            IntPtr interp
            )
        {
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (tclInterps == null)
                    return false;

                foreach (KeyValuePair<string, IntPtr> pair in tclInterps) /* O(N) */
                {
                    //
                    // NOTE: Hard-coded match mode is OK here.
                    //
                    if ((pattern != null) && !StringOps.Match(
                            this, MatchMode.Glob, pair.Key, pattern, false))
                    {
                        continue;
                    }

                    //
                    // NOTE: Does this Tcl interpreter match the one specified
                    //       by the caller?  If so, stop now.
                    //
                    if (pair.Value == interp)
                        return true;
                }

                //
                // NOTE: No matching Tcl interpreter was found.
                //
                return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the TclApi class only.
        //
        internal void AddTclInterpreter(
            string interpName,
            IntPtr interp
            )
        {
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (tclInterps == null)
                    return;

                tclInterps.Add(interpName, interp); /* O(1) */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the TclApi class only.
        //
        internal int RemoveTclInterpreter(
            IntPtr interp
            )
        {
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (tclInterps == null)
                    return 0;

                return tclInterps.RemoveAll(interp, 0); /* O(N) */
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Tcl Thread Support
#if TCL_THREADS
        public bool HasTclThreads(ref Result error)
        {
            CheckDisposed();

            lock (tclSyncRoot)
            {
                bool result = (tclThreads != null);

                if (!result)
                    error = "no Tcl threads available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesTclThreadExist(string name)
        {
            CheckDisposed();

            TclThread thread = null;
            Result error = null;

            return GetTclThread(name, LookupFlags.Exists, ref thread, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TCL_WRAPPER
        public
#else
        internal
#endif
        ReturnCode GetTclThread(
            string name,
            LookupFlags lookupFlags,
            ref TclThread thread,
            ref Result error
            )
        {
#if TCL_WRAPPER
            CheckDisposed();
#endif

            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (HasTclThreads(ref error))
                {
                    //
                    // NOTE: *WARNING* Empty Tcl thread names are allowed,
                    //       please do not change this to "!String.IsNullOrEmpty".
                    //
                    if (name != null)
                    {
                        if (tclThreads.TryGetValue(name, out thread) &&
                            ((thread != null) ||
                            !FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true)))
                        {
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            error = FlagOps.HasFlags(
                                lookupFlags, LookupFlags.Verbose, true) ?
                                String.Format(
                                    "invalid Tcl thread {0}",
                                    FormatOps.WrapOrNull(name)) :
                                "invalid Tcl thread";
                        }
                    }
                    else
                    {
                        error = "invalid Tcl thread name";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode CreateTclThread(
            ResultCallback callback,
            IClientData clientData,
            int timeout,
            bool generic,
            bool debug,
            bool wait,
            ref Result result
            )
        {
            CheckDisposed();

            if (!IsModifiable(true, ref result))
                return ReturnCode.Error;

            if (IsTclReadOnly(ref result))
                return ReturnCode.Error;

            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (HasTclThreads(ref result))
                {
                    GlobalState.PushActiveInterpreter(this);

                    try
                    {
                        string name = FormatOps.Id(tclThreadPrefix, null,
                            GlobalState.NextThreadId(this, true));

                        TclThread thread = TclThread.Create(
                            this, callback, clientData, timeout, name, generic,
                            debug, ref result);

                        if (thread != null)
                        {
                            tclThreads.Add(name, thread);
                            result = name;

#if NOTIFY && NOTIFY_TCL
                            /* IGNORED */
                            CheckNotification(
                                NotifyType.Tcl | NotifyType.Thread, NotifyFlags.Added,
                                new ObjectPair(name, thread), this,
                                null, null, null, ref result);
#endif

                            //
                            // HACK: Always wait for the thread to fully start by
                            //       using the default join timeout instead of the
                            //       timeout value specified by the caller.
                            //
                            if (wait)
                                thread.WaitForStart(ThreadOps.DefaultJoinTimeout);

                            return ReturnCode.Ok;
                        }
                    }
                    finally
                    {
                        /* IGNORED */
                        GlobalState.PopActiveInterpreter();
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DeleteTclThread(
            string name,
            bool strict,
            ref Result result
            )
        {
            CheckDisposed();

            TclThread thread = null;

            if (!IsModifiable(false, ref result))
                return ReturnCode.Error;

            if (IsTclReadOnly(ref result))
                return ReturnCode.Error;

            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (HasTclThreads(ref result))
                {
                    if ((GetTclThread(
                            name, LookupFlags.Default, ref thread,
                            ref result) == ReturnCode.Ok) &&
                        (thread == null))
                    {
                        result = "invalid Tcl thread";
                    }
                }
            }

            //
            // NOTE: If we managed to find the thread above then attempt
            //       to shut it down now.  We do this without holding a
            //       lock on the interpreter to avoid a deadlock with the
            //       other thread when it attempts to use the Tcl API
            //       object associated with this interpreter.
            //
            if (thread != null)
            {
                GlobalState.PushActiveInterpreter(this);

                try
                {
                    ITclApi tclApi;

                    lock (tclSyncRoot)
                    {
                        tclApi = this.tclApi;
                    }

                    if (thread.Shutdown(
                            tclApi, GetTclBridges(thread.Interp, null, null),
                            true, false, strict, ref result) == ReturnCode.Ok)
                    {
                        thread.Dispose(); /* throw */

                        lock (tclSyncRoot)
                        {
                            tclThreads.Remove(name);
                        }

                        result = String.Empty;

#if NOTIFY && NOTIFY_TCL
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Tcl | NotifyType.Thread, NotifyFlags.Removed,
                            new ObjectPair(name, thread), this,
                            null, null, null, ref result);
#endif

                        return ReturnCode.Ok;
                    }
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal string TclThreadsToString(
            string pattern,
            bool noCase
            )
        {
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (tclThreads != null)
                    return tclThreads.ToString(pattern, noCase);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool HasTclThreads()
        {
            Result error = null;
            return HasTclThreads(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetTclThread(
            string name,
            LookupFlags lookupFlags,
            ref TclThread thread
            )
        {
            Result error = null;

            return GetTclThread(name, lookupFlags, ref thread, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: The returned Tcl interpreter may only be used in conjunction with the Tcl
        //          C API on the thread that it was created on.  This restriction is NOT
        //          enforced by this function as we are merely returning the pointer to it.
        //
        private ReturnCode GetTclInterpreterOrThread(
            string name,
            LookupFlags lookupFlags,
            ref IntPtr interp,
            ref Result error
            )
        {
            bool fromThread = false;

            return GetTclInterpreterOrThread(
                name, lookupFlags, ref interp, ref fromThread, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetTclInterpreterOrThread(
            string name,
            LookupFlags lookupFlags,
            ref IntPtr interp,
            ref bool fromThread,
            ref Result error
            )
        {
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (InternalHasTclInterpreters(ref error))
                {
                    //
                    // NOTE: *WARNING* Empty Tcl interpreter and thread names are allowed,
                    //       please do not change this to "!String.IsNullOrEmpty".
                    //
                    if (name != null)
                    {
                        if (tclInterps.TryGetValue(name, out interp) &&
                            ((interp != IntPtr.Zero) ||
                            !FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true)))
                        {
                            fromThread = false;
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            if (HasTclThreads(ref error))
                            {
                                TclThread thread;

                                if (tclThreads.TryGetValue(name, out thread) &&
                                    ((thread != null) ||
                                    !FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true)))
                                {
                                    interp = (thread != null) ?
                                        thread.Interp : IntPtr.Zero;

                                    fromThread = true;
                                    return ReturnCode.Ok;
                                }
                                else
                                {
                                    error = FlagOps.HasFlags(
                                        lookupFlags, LookupFlags.Verbose, true) ?
                                        String.Format(
                                            "invalid Tcl interpreter or thread {0}",
                                            FormatOps.WrapOrNull(name)) :
                                        "invalid Tcl interpreter or thread";
                                }
                            }
                        }
                    }
                    else
                    {
                        error = "invalid Tcl interpreter or thread name";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetTclInterpreters(
            string pattern,
            LookupFlags lookupFlags,
            bool noCase,
            bool strict,
            ref IntPtrDictionary interps,
            ref Result error
            )
        {
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                Result localError = null;

                if (InternalHasTclInterpreters(ref localError))
                {
                    if (interps == null)
                        interps = new IntPtrDictionary();

                    foreach (KeyValuePair<string, IntPtr> pair in tclInterps)
                    {
                        if ((pattern == null) ||
                            StringOps.Match(
                                this, MatchMode.Glob, pair.Key, pattern, noCase))
                        {
                            interps.Add(pair.Key, pair.Value);
                        }
                    }

                    return ReturnCode.Ok;
                }
                else if (strict)
                {
                    error = localError;
                    return ReturnCode.Error;
                }
                else
                {
                    return ReturnCode.Ok;
                }
            }
        }
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Tcl Command Support
        public bool HasTclBridges(ref Result error)
        {
            CheckDisposed();

            return InternalHasTclBridges(ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesTclBridgeExist(string name)
        {
            CheckDisposed();

            TclBridge tclBridge = null;
            Result error = null;

            return GetTclBridge(name, LookupFlags.Exists, ref tclBridge, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddTclBridge(
            IExecute execute,
            string interpName,
            string commandName,
            IClientData clientData,
            bool forceDelete,
            bool noComplain,
            ref Result result
            )
        {
            CheckDisposed();

            if (!IsModifiable(true, ref result))
                return ReturnCode.Error;

            if (IsTclReadOnly(ref result))
                return ReturnCode.Error;

            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (execute == null)
                {
                    result = "invalid execute";
                    return ReturnCode.Error;
                }

                if (!InternalHasTclInterpreters(ref result))
                    return ReturnCode.Error;

                if (!InternalHasTclBridges(ref result))
                    return ReturnCode.Error;

                IntPtr interp = IntPtr.Zero;

                //
                // NOTE: *THREADING* Get the Tcl interpreter even if it is in an isolated thread.
                //       If the Tcl interpreter is from an isolated thread then this method may
                //       only be called from that thread.
                //
                bool fromThread = false;

#if TCL_THREADS
                if (GetTclInterpreterOrThread(
                        interpName, LookupFlags.Default, ref interp,
                        ref fromThread, ref result) != ReturnCode.Ok)
#else
                if (GetTclInterpreter(
                        interpName, LookupFlags.Default, ref interp,
                        ref result) != ReturnCode.Ok)
#endif
                {
                    return ReturnCode.Error;
                }

                string bridgeName =
                    FormatOps.TclBridgeName(interpName, commandName);

                if (bridgeName == null)
                {
                    result = "invalid bridge name";
                    return ReturnCode.Error;
                }

                if (DoesTclBridgeExist(bridgeName) == ReturnCode.Ok)
                {
                    result = String.Format(
                        "can't add {0}: command already exists in Tcl interpreter {1}",
                        FormatOps.WrapOrNull(commandName),
                        FormatOps.WrapOrNull(interpName));

                    return ReturnCode.Error;
                }

                GlobalState.PushActiveInterpreter(this);

                try
                {
                    TclBridge tclBridge = TclBridge.Create(this, execute,
                        (clientData != null) ? clientData : ObjectOps.GetClientData(execute),
                        interp, commandName, fromThread, forceDelete, noComplain, ref result);

                    if (tclBridge == null)
                        return ReturnCode.Error;

                    tclBridges.Add(bridgeName, tclBridge);

#if NOTIFY && NOTIFY_TCL
                    /* IGNORED */
                    CheckNotification(
                        NotifyType.Tcl | NotifyType.Command, NotifyFlags.Added,
                        //
                        // BUGBUG: In order to use this class for notification
                        //         parameters, it really should probably be
                        //         made public.
                        //
                        new ObjectList(execute, interpName, commandName, bridgeName,
                            forceDelete, tclBridge), this,
                        clientData, null, null, ref result);
#endif

                    result = bridgeName;
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode AddStandardTclBridge(
            string interpName,
            string commandName,
            IClientData clientData,
            bool forceDelete,
            bool noComplain,
            ref Result result
            )
        {
            CheckDisposed();

            if (!IsModifiable(true, ref result))
                return ReturnCode.Error;

            if (IsTclReadOnly(ref result))
                return ReturnCode.Error;

            //
            // NOTE: Lookup and fetch a reference to the Eagle [eval]
            //       command, if available.
            //
            ICommand command = null;

            if (GetCommand(
                    typeof(_Commands.Eval), LookupFlags.Default,
                    ref command, ref result) == ReturnCode.Ok)
            {
                //
                // NOTE: Create a "bridge" between the Eagle [eval] command
                //       and the native Tcl [eagle] command.  This allows a
                //       native Tcl script to execute Eagle commands.
                //
                if (commandName == null)
                    commandName = GlobalState.GetPackageNameNoCase();

                if (!String.IsNullOrEmpty(commandName))
                {
                    return AddTclBridge(
                        command, interpName, commandName, null,
                        forceDelete, noComplain, ref result);
                }

                result = "invalid command name";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RemoveTclBridge(
            string interpName,
            string commandName,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            if (!IsModifiable(false, ref result))
                return ReturnCode.Error;

            if (IsTclReadOnly(ref result))
                return ReturnCode.Error;

            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (InternalHasTclBridges(ref result))
                {
                    string bridgeName =
                        FormatOps.TclBridgeName(interpName, commandName);

                    TclBridge tclBridge = null;

                    if (GetTclBridge(
                            bridgeName, LookupFlags.Remove, ref tclBridge,
                            ref result) == ReturnCode.Ok)
                    {
                        GlobalState.PushActiveInterpreter(this);

                        try
                        {
                            if (tclBridge != null)
                            {
                                tclBridge.Dispose(); /* throw */
                                tclBridge = null;
                            }

                            tclBridges.Remove(bridgeName);

#if NOTIFY && NOTIFY_TCL
                            /* IGNORED */
                            CheckNotification(
                                NotifyType.Tcl | NotifyType.Command, NotifyFlags.Removed,
                                //
                                // BUGBUG: In order to use this class for notification
                                //         parameters, it really should probably be
                                //         made public.
                                //
                                new ObjectList(interpName, commandName, bridgeName, tclBridge), this,
                                clientData, null, null, ref result);
#endif

                            result = String.Empty;
                            return ReturnCode.Ok;
                        }
                        catch (Exception e)
                        {
                            result = String.Format(
                                "caught exception while disposing Tcl bridge: {0}",
                                e);

                            return ReturnCode.Error;
                        }
                        finally
                        {
                            /* IGNORED */
                            GlobalState.PopActiveInterpreter();
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal bool InternalHasTclBridges(
            ref Result error
            )
        {
            lock (tclSyncRoot)
            {
                bool result = (tclBridges != null);

                if (!result)
                    error = "no Tcl bridges available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string TclBridgesToString(
            string pattern,
            bool noCase
            )
        {
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (tclBridges != null)
                    return tclBridges.ToString(pattern, noCase);
                else
                    return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal TclBridgeDictionary CopyTclBridges()
        {
            lock (tclSyncRoot)
            {
                return new TclBridgeDictionary(tclBridges);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void AddTclBridge(
            string name,
            TclBridge tclBridge
            )
        {
            if (name != null)
            {
                lock (tclSyncRoot) /* TRANSACTIONAL */
                {
                    if (tclBridges != null)
                        tclBridges.Add(name, tclBridge);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int RemoveTclBridges(
            TclBridge tclBridge
            )
        {
            int result = 0;

            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (tclBridges != null)
                {
                    StringList keys = new StringList();

                    //
                    // NOTE: Cleanup, PASS #1, collect the list of keys we need to remove
                    //       from the TclBridges collection in the containing interpreter.
                    //
                    foreach (KeyValuePair<string, TclBridge> pair in tclBridges)
                        if (Object.ReferenceEquals(pair.Value, tclBridge))
                            keys.Add(pair.Key);

                    //
                    // NOTE: Cleanup, PASS #2, remove all the TclBridge objects we found
                    //       from PASS #1 (above).  Please note that since all of these
                    //       are assumed to refer to the same TclBridge object, dispose is
                    //       called [exactly once] after the TclBridge collection cleanup
                    //       has been completed.
                    //
                    foreach (string key in keys)
                        if (tclBridges.Remove(key))
                            result++;
                }
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetTclBridge(
            string name,
            LookupFlags lookupFlags,
            ref TclBridge tclBridge
            )
        {
            Result error = null;

            return GetTclBridge(name, lookupFlags, ref tclBridge, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetTclBridge(
            string name,
            LookupFlags lookupFlags,
            ref TclBridge tclBridge,
            ref Result error
            )
        {
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (InternalHasTclBridges(ref error))
                {
                    //
                    // NOTE: *WARNING* Empty Tcl command names are allowed,
                    //       please do not change this to "!String.IsNullOrEmpty".
                    //
                    if (name != null)
                    {
                        if (tclBridges.TryGetValue(name, out tclBridge) &&
                            ((tclBridge != null) ||
                            !FlagOps.HasFlags(lookupFlags, LookupFlags.Validate, true)))
                        {
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            error = FlagOps.HasFlags(
                                lookupFlags, LookupFlags.Verbose, true) ?
                                String.Format(
                                    "invalid Tcl command {0}",
                                    FormatOps.WrapOrNull(name)) :
                                "invalid Tcl command";
                        }
                    }
                    else
                    {
                        error = "invalid Tcl command name";
                    }
                }
            }

            return ReturnCode.Error;
        }
        #endregion
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ITclManager Members
#if NATIVE && TCL
        #region Tcl Synchronization Support
        public object TclSyncRoot
        {
            //
            // TODO: Rethink this strategy.  Should calls for the interpreter
            //       lock from inside the interpreter methods be able to throw
            //       an exception?  If so, why?  If not, why not?
            //
            get { CheckDisposed(); return tclSyncRoot; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal object InternalTclSyncRoot
        {
            get { return tclSyncRoot; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void PrivateSoftTclTryLock(
             ref bool locked
             )
        {
            if (tclSyncRoot == null)
                return;

            locked = Monitor.TryEnter(tclSyncRoot);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void PrivateTclExitLock(
            ref bool locked
            )
        {
            if (tclSyncRoot == null)
                return;

            if (locked)
            {
                Monitor.Exit(tclSyncRoot);
                locked = false;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Tcl Read-Only Support
        public bool TclReadOnly
        {
            get
            {
                CheckDisposed();

                lock (tclSyncRoot)
                {
                    return PrivateTclReadOnly;
                }
            }
            set
            {
                CheckDisposed();

                lock (tclSyncRoot)
                {
                    PrivateTclReadOnly = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        private bool PrivateTclReadOnly
        {
            get { /* NO-LOCK */ return tclReadOnly; }
            set { /* NO-LOCK */ tclReadOnly = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsTclReadOnly(
            ref Result error
            )
        {
            lock (tclSyncRoot)
            {
                if (tclReadOnly)
                {
                    error = "Tcl subsystem is read-only";
                    return true;
                }

                return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void MakeTclReadOnly(
            bool readOnly
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (readOnly)
                    createFlags |= CreateFlags.TclReadOnly;
                else
                    createFlags &= ~CreateFlags.TclReadOnly;
            }

            lock (tclSyncRoot)
            {
                tclReadOnly = readOnly;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Tcl Loader Support
        public bool HasTcl(ref Result error)
        {
            CheckDisposed();

            lock (tclSyncRoot)
            {
                bool result = (tclApi != null);

                if (!result)
                    error = "no Tcl available";

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsTclThread()
        {
            CheckDisposed();

            return IsTclThread(GlobalState.GetCurrentNativeThreadId());
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetTclPatchLevel(
            ref Version patchLevel,
            ref Result error
            )
        {
            CheckDisposed();

            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (tclApi != null)
                {
                    TclBuild build = tclApi.Build;

                    if (build != null)
                    {
                        patchLevel = build.PatchLevel;
                        return ReturnCode.Ok;
                    }
                    else
                    {
                        error = "invalid Tcl build object";
                    }
                }
                else
                {
                    error = "invalid Tcl API object";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode LoadTcl(
            FindFlags findFlags,
            LoadFlags loadFlags,
            IEnumerable<string> paths,
            string text,
            Version minimumRequired,
            Version maximumRequired,
            Version unknown,
            IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            if (!IsModifiable(true, ref result))
                return ReturnCode.Error;

            if (IsTclReadOnly(ref result))
                return ReturnCode.Error;

            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (InternalHasTclInterpreters(ref result))
                {
                    if (IsTclThread())
                    {
                        GlobalState.PushActiveInterpreter(this);

                        try
                        {
#if NOTIFY && NOTIFY_TCL
                            /* IGNORED */
                            CheckNotification(
                                NotifyType.Tcl, NotifyFlags.PreLoad,
                                //
                                // BUGBUG: In order to use this class for notification
                                //         parameters, it really should probably be
                                //         made public.
                                //
                                new ObjectList(findFlags, loadFlags, paths, minimumRequired,
                                    maximumRequired, unknown), this, null, null, null,
                                    ref result);
#endif

                            IntPtr interp = IntPtr.Zero;

                            if (TclWrapper.Load(
                                    this, findFlags, loadFlags, null, paths,
                                    text, minimumRequired, maximumRequired,
                                    unknown, clientData, ref tclApi,
                                    ref interp, ref result) == ReturnCode.Ok)
                            {
                                string name = FormatOps.Id(
                                    tclParentInterpPrefix, null, NextId());

                                //
                                // NOTE: Even though the parent Tcl interpreter is not really intended
                                //       for general purpose scripting use, add it anyhow so that we
                                //       can keep track of it and delete it later.  This Tcl interpreter
                                //       is always considered to be "fully trusted" and has the full set
                                //       of Tcl commands available to it.
                                //
                                tclInterps.Add(name, interp);
                                result = name;

#if NOTIFY && NOTIFY_TCL
                                /* IGNORED */
                                CheckNotification(
                                    NotifyType.Tcl, NotifyFlags.Load,
                                    //
                                    // BUGBUG: In order to use this class for notification
                                    //         parameters, it really should probably be
                                    //         made public.
                                    //
                                    new ObjectList(findFlags, loadFlags, paths, minimumRequired,
                                        maximumRequired, unknown), this, null, null, null,
                                        ref result);
#endif

                                return ReturnCode.Ok;
                            }
                        }
                        finally
                        {
                            /* IGNORED */
                            GlobalState.PopActiveInterpreter();
                        }
                    }
                    else
                    {
                        result = "cannot load Tcl, wrong thread";
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode UnloadTcl(
            UnloadFlags unloadFlags, /* in */
            ref Result error         /* out */
            )
        {
            CheckDisposed();

            if (!IsModifiable(false, ref error))
                return ReturnCode.Error;

            if (IsTclReadOnly(ref error))
                return ReturnCode.Error;

            //
            // BUGFIX: Holding this lock while disposing of isolated Tcl
            //         threads can very easily result in a deadlock.
            //
            // lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (IsTclThread())
                {
                    GlobalState.PushActiveInterpreter(this);

                    try
                    {
#if NOTIFY && NOTIFY_TCL
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Tcl, NotifyFlags.PreUnload,
                            unloadFlags, this,
                            null, null, null, ref error);
#endif

                        //
                        // NOTE: First, attempt to cleanup and/or dispose
                        //       any Tcl related objects.
                        //
                        if (DisposeTcl(false, false, false, ref error) == ReturnCode.Ok)
                        {
                            //
                            // NOTE: Since the Tcl parent interpreter should
                            //       already be deleted now, just [implicitly]
                            //       pass an invalid Tcl interpreter handle to
                            //       Unload here, which will cause it to skip
                            //       attempting to delete the Tcl parent
                            //       interpreter.  After this call it may no
                            //       longer be safe to use the Tcl API because
                            //       we may be holding the last reference to it
                            //       and this call will then cause it to be
                            //       completely unloaded from memory.
                            //
                            if (TclWrapper.Unload(this, unloadFlags, ref tclApi,
                                    ref error) == ReturnCode.Ok)
                            {
#if NOTIFY && NOTIFY_TCL
                                /* IGNORED */
                                CheckNotification(
                                    NotifyType.Tcl, NotifyFlags.Unload,
                                    unloadFlags, this,
                                    null, null, null, ref error);
#endif

                                return ReturnCode.Ok;
                            }
                        }
                    }
                    finally
                    {
                        /* IGNORED */
                        GlobalState.PopActiveInterpreter();
                    }
                }
                else
                {
                    error = "cannot unload Tcl, wrong thread";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TCL_WRAPPER
        public ITclApi TclApi
        {
            get
            {
                CheckDisposed();

                lock (tclSyncRoot)
                {
                    return tclApi;
                }
            }
            set
            {
                CheckDisposed();

                lock (tclSyncRoot)
                {
                    tclApi = value;
                }
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal long GetTclThreadId()
        {
            //
            // HACK: In order to avoid any potential deadlocks
            //       here, avoid grabbing the interpreter lock.
            //
            return Interlocked.CompareExchange(ref nativeThreadId, 0, 0);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsTclThread(long threadId)
        {
            return (threadId == GetTclThreadId());
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ITclApi InternalTclApi
        {
            get { return tclApi; }
            set { tclApi = value; }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Tcl Interpreter Support
        public ReturnCode IsTclInterpreterCanceled(
            string name,
            ref Result error
            )
        {
            CheckDisposed();

            return IsTclInterpreterCanceled(
                name, TclWrapper.GetCanceledFlags(false, true),
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode IsTclInterpreterCanceled(
            string name,
            Tcl_CanceledFlags flags,
            ref Result error
            )
        {
            CheckDisposed();

            IntPtr interp = IntPtr.Zero;

            if (GetTclInterpreter(
                    name, LookupFlags.Default, ref interp,
                    ref error) == ReturnCode.Ok)
            {
                return TclWrapper.Canceled(
                    tclApi, interp, flags, ref error);
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsTclInterpreterReady(
            string name,
            bool deleted,
            ref Result error
            )
        {
            CheckDisposed();

            IntPtr interp = IntPtr.Zero;

            if (GetTclInterpreter(
                    name, LookupFlags.Default, ref interp,
                    ref error) == ReturnCode.Ok)
            {
                return TclWrapper.IsReady(
                    tclApi, interp, deleted, ref error);
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsTclInterpreterActive(
            string name
            )
        {
            CheckDisposed();

            IntPtr interp = IntPtr.Zero;

            if (GetTclInterpreter(
                    name, LookupFlags.NoVerbose,
                    ref interp) == ReturnCode.Ok)
            {
                return TclWrapper.GetInterpActive(tclApi, interp);
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int GetTclInterpreterErrorLine(
            string name
            )
        {
            CheckDisposed();

            IntPtr interp = IntPtr.Zero;

            if (GetTclInterpreter(
                    name, LookupFlags.NoVerbose,
                    ref interp) == ReturnCode.Ok)
            {
                return TclWrapper.GetErrorLine(tclApi, interp);
            }

            return 0;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal bool IsTclInterpreterReady(
            string name
            )
        {
            Result error = null;

            return IsTclInterpreterReady(name, true, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool FindTclInterpreterThreadId(
            IntPtr interp,
            ref long threadId
            )
        {
            IntPtrList interps = null;
#if TCL_THREADS
            TclThreadList threads = null;
#endif

            //
            // BUGBUG: This is likely to be a serious performance bottleneck
            //         since this method must be called for every Tcl API
            //         function call that involves a Tcl interpreter or a Tcl
            //         object.
            //
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                //
                // NOTE: Get the list of Tcl interps from the
                //       interpreter.
                //
                if (InternalHasTclInterpreters())
                    interps = new IntPtrList(tclInterps.Values);

#if TCL_THREADS
                //
                // NOTE: Get the list of Tcl threads from the
                //       interpreter.
                //
                if (HasTclThreads())
                    threads = new TclThreadList(tclThreads.Values);
#endif
            }

            //
            // NOTE: First, check the Tcl interps that belong to the
            //       primary thread for this interpreter.
            //
            if (interps != null)
            {
                foreach (IntPtr localInterp in interps)
                {
                    if (localInterp == interp)
                    {
                        //
                        // NOTE: Return the primary native thread Id.
                        //
                        threadId = GetTclThreadId();

                        //
                        // NOTE: Success, we found the Tcl interpreter.
                        //
                        return true;
                    }
                }
            }

#if TCL_THREADS
            //
            // NOTE: Next, check the Tcl threads that belong to this
            //       interpreter.  Each one of these threads has an
            //       isolated Tcl interpreter.
            //
            if (threads != null)
            {
                foreach (TclThread thread in threads)
                {
                    if ((thread != null) && (thread.Interp == interp))
                    {
                        //
                        // NOTE: Return the specified thread Id for this Tcl
                        //       interpreter.
                        //
                        threadId = thread.ThreadId;

                        //
                        // NOTE: Success, we found the Tcl interpreter.
                        //
                        return true;
                    }
                }
            }
#endif

#if TCL_WRAPPER
            // lock (syncRoot) /* TRANSACTIONAL */ /* NOTE: Avoid deadlock? */
            {
                //
                // NOTE: In "Tcl wrapper" mode, we assume that any Tcl
                //       interpreter we cannot otherwise locate was
                //       created on the main thread of the Eagle
                //       interpreter.
                //
                if (FlagOps.HasFlags(createFlags, CreateFlags.TclWrapper, true))
                {
                    //
                    // NOTE: Return the primary thread Id.
                    //
                    threadId = this.threadId;

                    return true;
                }
            }
#endif

            //
            // NOTE: Failure, we did not find the Tcl interpreter.
            //
            return false;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Tcl Thread Event Support
#if TCL_THREADS
        public ReturnCode QueueTclThreadEvent(
            string threadName,
            EventType type,
            EventFlags flags,
            object data,
            bool synchronous,
            ref Result result
            )
        {
            CheckDisposed();

            int errorLine = 0;

            return QueueTclThreadEvent(
                threadName, type, flags, data, synchronous, ref result, ref errorLine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode QueueTclThreadEvent(
            string threadName,
            EventType type,
            EventFlags flags,
            object data,
            bool synchronous,
            ref Result result,
            ref int errorLine
            )
        {
            CheckDisposed();

            TclThread thread = null;

            if (GetTclThread(threadName, LookupFlags.Default, ref thread, ref result) == ReturnCode.Ok)
            {
                if (thread != null)
                {
                    if (thread.QueueEvent(type, flags, data, synchronous,
                            ref result, ref errorLine) == ReturnCode.Ok)
                    {
#if NOTIFY && NOTIFY_TCL
                        /* IGNORED */
                        CheckNotification(
                            NotifyType.Tcl | NotifyType.Thread | NotifyType.Event, NotifyFlags.Queued,
                            new ObjectList(threadName, thread, type, flags, data, synchronous),
                            this, null, null, null, ref result);
#endif

                        return ReturnCode.Ok;
                    }
                }
                else
                {
                    result = "invalid Tcl thread";
                }
            }

            return ReturnCode.Error;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Tcl Thread Miscellaneous Support
#if !TCL_THREADS
        internal bool IsPrimaryTclThread(
            ref long threadId /* in, out */
            )
        {
            //
            // NOTE: Is the thread Id provided by the caller the same as the
            //       primary one for this interpreter?
            //
            bool result = (threadId == this.threadId);

            //
            // NOTE: Now that we know the result, overwrite the thread Id
            //       provided by the caller with the primary one for this
            //       interpreter, if necessary (for their use).
            //
            if (!result) /* NOTE: Skip if already the same. */
                threadId = this.threadId;

            //
            // NOTE: Done, return the result.
            //
            return result;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Tcl Script Support
        public ReturnCode CancelTclEvaluate(
            string interpName,
            Result result,
            ref Result error
            )
        {
            CheckDisposed();

            return CancelTclEvaluate(interpName, result,
                TclWrapper.GetCancelEvaluateFlags(true),
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode CancelTclEvaluate(
            string interpName,
            Result result,
            Tcl_EvalFlags flags,
            ref Result error
            )
        {
            CheckDisposed();

            IClientData clientData = null;

            return CancelTclEvaluate(
                interpName, result, flags, ref clientData, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode CancelTclEvaluate(
            string interpName,
            Result result,
            Tcl_EvalFlags flags,
            ref IClientData clientData,
            ref Result error
            )
        {
            CheckDisposed();

            IntPtr interp = IntPtr.Zero;

            ReturnCode code = GetTclInterpreter(
                interpName, LookupFlags.Default, ref interp, ref result);

            if (code == ReturnCode.Ok)
            {
                code = TclWrapper.CancelEvaluate(
                    tclApi, interp, result, flags, ref clientData, ref error);
            }

#if NOTIFY && NOTIFY_TCL
            /* IGNORED */
            CheckNotification(
                NotifyType.Tcl | NotifyType.Script, NotifyFlags.Canceled,
                new ObjectTriplet(flags, result, code), this,
                null, null, null, ref error);
#endif

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclExpression(
            string interpName,
            string text,
            ref Result result
            )
        {
            CheckDisposed();

            return EvaluateTclExpression(interpName, text, TclExceptions, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclExpression(
            string interpName,
            string text,
            bool exceptions,
            ref Result result
            )
        {
            CheckDisposed();

            IClientData clientData = null;

            return EvaluateTclExpression(interpName, text, exceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclExpression(
            string interpName,
            string text,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            return EvaluateTclExpression(
                interpName, text, TclExceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclExpression(
            string interpName,
            string text,
            bool exceptions,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            IntPtr interp = IntPtr.Zero;

            ReturnCode code = GetTclInterpreter(
                interpName, LookupFlags.Default, ref interp, ref result);

            if (code == ReturnCode.Ok)
            {
                string name = StringList.MakeList("tcl expr", interpName);

                ICallFrame frame = NewTrackingCallFrame(name,
                    CallFrameFlags.Expression | CallFrameFlags.Tcl);

                PushAutomaticCallFrame(frame);

                code = TclWrapper.EvaluateExpression(
                    tclApi, interp, text, exceptions, ref clientData, ref result);

                if (code == ReturnCode.Error)
                {
                    Result errorInfo = null;

                    if (TclWrapper.GetVariable(tclApi, interp, Tcl_VarFlags.TCL_GLOBAL_ONLY,
                            TclVars.Core.ErrorInfo, ref errorInfo, ref errorInfo) == ReturnCode.Ok)
                    {
                        Engine.AddErrorInformation(this, null,
                            String.Format("{0}{1}", HasErrorInProgress()
                                ? Environment.NewLine : String.Empty, errorInfo));
                    }

                    Engine.AddErrorInformation(this, result,
                        String.Format("{0}    (\"tcl expr\" body line {1})",
                            Environment.NewLine, TclWrapper.GetErrorLine(tclApi, interp)));
                }

#if NOTIFY && NOTIFY_TCL
                /* IGNORED */
                CheckNotification(
                    NotifyType.Tcl | NotifyType.Expression, NotifyFlags.Evaluated,
                    new ObjectTriplet(interpName, text, code), this,
                    null, null, null, ref result);
#endif

                //
                // NOTE: Pop the original call frame that we pushed above and
                //       any intervening scope call frames that may be leftover
                //       (i.e. they were not explicitly closed).
                //
                /* IGNORED */
                PopScopeCallFramesAndOneMore();
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool TclExceptions
        {
            get
            {
                CheckDisposed();

                lock (tclSyncRoot) /* TRANSACTIONAL */
                {
                    return (tclApi != null) ? tclApi.Exceptions : false;
                }
            }
            set
            {
                CheckDisposed();

                lock (tclSyncRoot) /* TRANSACTIONAL */
                {
                    if (tclApi != null) tclApi.Exceptions = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclScript(
            string interpName,
            string text,
            ref Result result
            )
        {
            CheckDisposed();

            return EvaluateTclScript(
                interpName, text, TclExceptions, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclScript(
            string interpName,
            string text,
            bool exceptions,
            ref Result result
            )
        {
            CheckDisposed();

            return EvaluateTclScript(interpName, text, Tcl_EvalFlags.TCL_EVAL_NONE,
                exceptions, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclScript(
            string interpName,
            string text,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            return EvaluateTclScript(
                interpName, text, TclExceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclScript(
            string interpName,
            string text,
            bool exceptions,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            return EvaluateTclScript(interpName, text, Tcl_EvalFlags.TCL_EVAL_NONE,
                exceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclScript(
            string interpName,
            string text,
            Tcl_EvalFlags flags,
            ref Result result
            )
        {
            CheckDisposed();

            return EvaluateTclScript(
                interpName, text, flags, TclExceptions, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclScript(
            string interpName,
            string text,
            Tcl_EvalFlags flags,
            bool exceptions,
            ref Result result
            )
        {
            CheckDisposed();

            IClientData clientData = null;

            return EvaluateTclScript(interpName, text, flags, exceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclScript(
            string interpName,
            string text,
            Tcl_EvalFlags flags,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            return EvaluateTclScript(
                interpName, text, flags, TclExceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclScript(
            string interpName,
            string text,
            Tcl_EvalFlags flags,
            bool exceptions,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            IntPtr interp = IntPtr.Zero;

            ReturnCode code = GetTclInterpreter(
                interpName, LookupFlags.Default, ref interp, ref result);

            if (code == ReturnCode.Ok)
            {
                string name = StringList.MakeList("tcl eval", interpName);

                ICallFrame frame = NewTrackingCallFrame(name,
                    CallFrameFlags.Evaluate | CallFrameFlags.Tcl);

                PushAutomaticCallFrame(frame);

                code = TclWrapper.EvaluateScript(
                    tclApi, interp, text, flags, exceptions, ref clientData, ref result);

                if (code == ReturnCode.Error)
                {
                    Result errorInfo = null;

                    if (TclWrapper.GetVariable(tclApi, interp, Tcl_VarFlags.TCL_GLOBAL_ONLY,
                            TclVars.Core.ErrorInfo, ref errorInfo, ref errorInfo) == ReturnCode.Ok)
                    {
                        Engine.AddErrorInformation(this, null,
                            String.Format("{0}{1}", HasErrorInProgress()
                                ? Environment.NewLine : String.Empty, errorInfo));
                    }

                    Engine.AddErrorInformation(this, result,
                        String.Format("{0}    (\"tcl eval\" body line {1})",
                            Environment.NewLine, TclWrapper.GetErrorLine(tclApi, interp)));
                }

#if NOTIFY && NOTIFY_TCL
                /* IGNORED */
                CheckNotification(
                    NotifyType.Tcl | NotifyType.Script, NotifyFlags.Evaluated,
                    new ObjectTriplet(interpName, text, flags), this,
                    null, null, null, ref result);
#endif

                //
                // NOTE: Pop the original call frame that we pushed above and
                //       any intervening scope call frames that may be leftover
                //       (i.e. they were not explicitly closed).
                //
                /* IGNORED */
                PopScopeCallFramesAndOneMore();
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclFile(
            string interpName,
            string fileName,
            ref Result result
            )
        {
            CheckDisposed();

            return EvaluateTclFile(
                interpName, fileName, TclExceptions, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclFile(
            string interpName,
            string fileName,
            bool exceptions,
            ref Result result
            )
        {
            CheckDisposed();

            IClientData clientData = null;

            return EvaluateTclFile(interpName, fileName, exceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclFile(
            string interpName,
            string fileName,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            return EvaluateTclFile(
                interpName, fileName, TclExceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode EvaluateTclFile(
            string interpName,
            string fileName,
            bool exceptions,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            IntPtr interp = IntPtr.Zero;

            ReturnCode code = GetTclInterpreter(
                interpName, LookupFlags.Default, ref interp, ref result);

            if (code == ReturnCode.Ok)
            {
                string name = StringList.MakeList("tcl source", interpName, fileName);

                ICallFrame frame = NewTrackingCallFrame(name,
                    CallFrameFlags.Source | CallFrameFlags.Tcl);

                PushAutomaticCallFrame(frame);

                code = TclWrapper.EvaluateFile(
                    tclApi, interp, fileName, exceptions, ref clientData, ref result);

#if NOTIFY && NOTIFY_TCL
                /* IGNORED */
                CheckNotification(
                    NotifyType.Tcl | NotifyType.File, NotifyFlags.Evaluated,
                    new ObjectPair(interpName, fileName), this,
                    null, null, null, ref result);
#endif

                //
                // NOTE: Pop the original call frame that we pushed above and
                //       any intervening scope call frames that may be leftover
                //       (i.e. they were not explicitly closed).
                //
                /* IGNORED */
                PopScopeCallFramesAndOneMore();
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RecordAndEvaluateTclScript(
            string interpName,
            string text,
            ref Result result
            )
        {
            CheckDisposed();

            return RecordAndEvaluateTclScript(
                interpName, text, TclExceptions, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RecordAndEvaluateTclScript(
            string interpName,
            string text,
            bool exceptions,
            ref Result result
            )
        {
            CheckDisposed();

            return RecordAndEvaluateTclScript(interpName, text, Tcl_EvalFlags.TCL_EVAL_NONE,
                exceptions, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RecordAndEvaluateTclScript(
            string interpName,
            string text,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            return RecordAndEvaluateTclScript(
                interpName, text, TclExceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RecordAndEvaluateTclScript(
            string interpName,
            string text,
            bool exceptions,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            return RecordAndEvaluateTclScript(interpName, text, Tcl_EvalFlags.TCL_EVAL_NONE,
                exceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RecordAndEvaluateTclScript(
            string interpName,
            string text,
            Tcl_EvalFlags flags,
            ref Result result
            )
        {
            CheckDisposed();

            return RecordAndEvaluateTclScript(
                interpName, text, flags, TclExceptions, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RecordAndEvaluateTclScript(
            string interpName,
            string text,
            Tcl_EvalFlags flags,
            bool exceptions,
            ref Result result
            )
        {
            CheckDisposed();

            IClientData clientData = null;

            return RecordAndEvaluateTclScript(
                interpName, text, flags, exceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RecordAndEvaluateTclScript(
            string interpName,
            string text,
            Tcl_EvalFlags flags,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            return RecordAndEvaluateTclScript(
                interpName, text, flags, TclExceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode RecordAndEvaluateTclScript(
            string interpName,
            string text,
            Tcl_EvalFlags flags,
            bool exceptions,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            IntPtr interp = IntPtr.Zero;

            ReturnCode code = GetTclInterpreter(
                interpName, LookupFlags.Default, ref interp, ref result);

            if (code == ReturnCode.Ok)
            {
                string name = StringList.MakeList("tcl record", interpName);

                ICallFrame frame = NewTrackingCallFrame(name,
                    CallFrameFlags.Evaluate | CallFrameFlags.Tcl);

                PushAutomaticCallFrame(frame);

                code = TclWrapper.RecordAndEvaluateScript(
                    tclApi, interp, text, flags, exceptions, ref clientData, ref result);

                if (code == ReturnCode.Error)
                {
                    Result errorInfo = null;

                    if (TclWrapper.GetVariable(tclApi, interp, Tcl_VarFlags.TCL_GLOBAL_ONLY,
                            TclVars.Core.ErrorInfo, ref errorInfo, ref errorInfo) == ReturnCode.Ok)
                    {
                        Engine.AddErrorInformation(this, null,
                            String.Format("{0}{1}", HasErrorInProgress()
                                ? Environment.NewLine : String.Empty, errorInfo));
                    }

                    Engine.AddErrorInformation(this, result,
                        String.Format("{0}    (\"tcl record\" body line {1})",
                            Environment.NewLine, TclWrapper.GetErrorLine(tclApi, interp)));
                }

#if NOTIFY && NOTIFY_TCL
                /* IGNORED */
                CheckNotification(
                    NotifyType.Tcl | NotifyType.Script, NotifyFlags.Evaluated,
                    new ObjectTriplet(interpName, text, flags), this,
                    null, null, null, ref result);
#endif

                //
                // NOTE: Pop the original call frame that we pushed above and
                //       any intervening scope call frames that may be leftover
                //       (i.e. they were not explicitly closed).
                //
                /* IGNORED */
                PopScopeCallFramesAndOneMore();
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteTclString(
            string interpName,
            string text,
            ref Result result
            )
        {
            CheckDisposed();

            return SubstituteTclString(
                interpName, text, TclExceptions, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteTclString(
            string interpName,
            string text,
            bool exceptions,
            ref Result result
            )
        {
            CheckDisposed();

            IClientData clientData = null;

            return SubstituteTclString(interpName, text, exceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteTclString(
            string interpName,
            string text,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            return SubstituteTclString(
                interpName, text, TclExceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteTclString(
            string interpName,
            string text,
            bool exceptions,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            return SubstituteTclString(interpName, text, Tcl_SubstFlags.TCL_SUBST_ALL, exceptions,
                ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteTclString(
            string interpName,
            string text,
            Tcl_SubstFlags flags,
            ref Result result
            )
        {
            CheckDisposed();

            IClientData clientData = null;

            return SubstituteTclString(interpName, text, flags, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteTclString(
            string interpName,
            string text,
            Tcl_SubstFlags flags,
            bool exceptions,
            ref Result result
            )
        {
            CheckDisposed();

            IClientData clientData = null;

            return SubstituteTclString(interpName, text, flags, exceptions, ref clientData,
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteTclString(
            string interpName,
            string text,
            Tcl_SubstFlags flags,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            return SubstituteTclString(
                interpName, text, flags, TclExceptions, ref clientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SubstituteTclString(
            string interpName,
            string text,
            Tcl_SubstFlags flags,
            bool exceptions,
            ref IClientData clientData,
            ref Result result
            )
        {
            CheckDisposed();

            IntPtr interp = IntPtr.Zero;

            ReturnCode code = GetTclInterpreter(
                interpName, LookupFlags.Default, ref interp, ref result);

            if (code == ReturnCode.Ok)
            {
                string name = StringList.MakeList("tcl subst", interpName);

                ICallFrame frame = NewTrackingCallFrame(name,
                    CallFrameFlags.Substitute | CallFrameFlags.Tcl);

                PushAutomaticCallFrame(frame);

                code = TclWrapper.SubstituteString(
                    tclApi, interp, text, flags, exceptions, ref clientData, ref result);

                if (code == ReturnCode.Error)
                {
                    Result errorInfo = null;

                    if (TclWrapper.GetVariable(tclApi, interp, Tcl_VarFlags.TCL_GLOBAL_ONLY,
                            TclVars.Core.ErrorInfo, ref errorInfo, ref errorInfo) == ReturnCode.Ok)
                    {
                        Engine.AddErrorInformation(this, null,
                            String.Format("{0}{1}", HasErrorInProgress()
                                ? Environment.NewLine : String.Empty, errorInfo));
                    }

                    Engine.AddErrorInformation(this, result,
                        String.Format("{0}    (\"tcl subst\" body line {1})",
                            Environment.NewLine, TclWrapper.GetErrorLine(tclApi, interp)));
                }

#if NOTIFY && NOTIFY_TCL
                /* IGNORED */
                CheckNotification(
                    NotifyType.Tcl | NotifyType.String, NotifyFlags.Substituted,
                    new ObjectTriplet(interpName, text, code), this,
                    null, null, null, ref result);
#endif

                //
                // NOTE: Pop the original call frame that we pushed above and
                //       any intervening scope call frames that may be leftover
                //       (i.e. they were not explicitly closed).
                //
                /* IGNORED */
                PopScopeCallFramesAndOneMore();
            }

            return code;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Tcl Variable Support
        public ReturnCode GetTclVariableValue(
            string interpName,
            Tcl_VarFlags flags,
            string name,
            ref Result value,
            ref Result error
            )
        {
            CheckDisposed();

            IntPtr interp = IntPtr.Zero;

            ReturnCode code = GetTclInterpreter(
                interpName, LookupFlags.Default, ref interp, ref error);

            if (code == ReturnCode.Ok)
            {
                code = TclWrapper.GetVariable(
                    tclApi, interp, flags, name, ref value, ref error);

#if NOTIFY && NOTIFY_TCL
                /* IGNORED */
                CheckNotification(
                    NotifyType.Tcl | NotifyType.Variable, NotifyFlags.GetVariable,
                    new ObjectList(interpName, flags, name, value), this,
                    null, null, null, ref error);
#endif
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SetTclVariableValue(
            string interpName,
            Tcl_VarFlags flags,
            string name,
            ref Result value,
            ref Result error
            )
        {
            CheckDisposed();

            if (!IsModifiable(false, ref error))
                return ReturnCode.Error;

            if (IsTclReadOnly(ref error))
                return ReturnCode.Error;

            IntPtr interp = IntPtr.Zero;

            ReturnCode code = GetTclInterpreter(
                interpName, LookupFlags.Default, ref interp, ref error);

            if (code == ReturnCode.Ok)
            {
                code = TclWrapper.SetVariable(
                    tclApi, interp, flags, name, ref value, ref error);

#if NOTIFY && NOTIFY_TCL
                /* IGNORED */
                CheckNotification(
                    NotifyType.Tcl | NotifyType.Variable, NotifyFlags.SetVariable,
                    new ObjectList(interpName, flags, name, value), this,
                    null, null, null, ref error);
#endif
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode UnsetTclVariableValue(
            string interpName,
            Tcl_VarFlags flags,
            string name,
            ref Result error
            )
        {
            CheckDisposed();

            if (!IsModifiable(false, ref error))
                return ReturnCode.Error;

            if (IsTclReadOnly(ref error))
                return ReturnCode.Error;

            IntPtr interp = IntPtr.Zero;

            ReturnCode code = GetTclInterpreter(
                interpName, LookupFlags.Default, ref interp, ref error);

            if (code == ReturnCode.Ok)
            {
                code = TclWrapper.UnsetVariable(
                    tclApi, interp, flags, name, ref error);

#if NOTIFY && NOTIFY_TCL
                /* IGNORED */
                CheckNotification(
                    NotifyType.Tcl | NotifyType.Variable, NotifyFlags.UnsetVariable,
                    new ObjectTriplet(interpName, flags, name), this,
                    null, null, null, ref error);
#endif
            }

            return code;
        }
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ITraceManager Members
        //
        // WARNING: This method exists only to facilitate accessing the
        //          static TraceOps state from another application domain.
        //
        public TracePriority GetTracePriority()
        {
            CheckDisposed();

            return TraceOps.GetTracePriority();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This method exists only to facilitate accessing the
        //          static TraceOps state from another application domain.
        //
        // BUGBUG: For this particular method, it does not make much sense
        //         because the sole purpose of this method is to adjust its
        //         priority parameter by adding (or subtracting) a relative
        //         numeric value (i.e. go up two levels, etc).  Technically,
        //         the internal array that assists with this task is mutable
        //         state belonging to the AppDomain; therefore, this method
        //         being exposed technically makes sense.
        //
        public void AdjustTracePriority(
            ref TracePriority priority,
            int adjustment
            )
        {
            CheckDisposed();

            TraceOps.ExternalAdjustTracePriority(ref priority, adjustment);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This method exists only to facilitate accessing the
        //          static TraceOps state from another application domain.
        //
        public TracePriority GetTracePriorities()
        {
            CheckDisposed();

            return TraceOps.GetTracePriorities();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This method exists only to facilitate accessing the
        //          static TraceOps state from another application domain.
        //
        public void SetTracePriorities(
            TracePriority priorities
            )
        {
            CheckDisposed();

            TraceOps.SetTracePriorities(priorities);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This method exists only to facilitate accessing the
        //          static TraceOps state from another application domain.
        //
        public void AdjustTracePriorities(
            TracePriority priority,
            bool enabled
            )
        {
            CheckDisposed();

            TraceOps.AdjustTracePriorities(priority, enabled);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This method exists only to facilitate accessing the
        //          static TraceOps state from another application domain.
        //
        public void ResetTraceStatus(
            Interpreter interpreter,
            bool overrideEnvironment
            )
        {
            CheckDisposed();

            TraceOps.ResetStatus(interpreter, overrideEnvironment);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This method exists only to facilitate accessing the
        //          static TraceOps state from another application domain.
        //
        public TraceStateType ForceTraceEnabledOrDisabled(
            Interpreter interpreter,
            TraceStateType stateType,
            bool enabled
            )
        {
            CheckDisposed();

            return TraceOps.ForceEnabledOrDisabled(interpreter, stateType, enabled);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This method exists only to facilitate accessing the
        //          static TraceOps state from another application domain.
        //
        public ReturnCode ProcessTraceClientData(
            TraceClientData traceClientData,
            ref Result result
            )
        {
            CheckDisposed();

            return TraceOps.ProcessClientData(traceClientData, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This method exists only to facilitate accessing the
        //          static TraceOps state from another application domain.
        //
        public bool MaybeAdjustTraceLimits(
            bool? enable
            )
        {
            CheckDisposed();

            return TraceLimits.MaybeAdjustEnabled(enable);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IVariableManager Members
        #region Variable Checking
        public ReturnCode DoesVariableExist(
            VariableFlags flags,
            string name
            )
        {
            CheckDisposed();

            IVariable variable = null;

            return DoesVariableExist(flags, name, ref variable);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode DoesVariableExist(
            VariableFlags flags,
            string name,
            ref Result error
            )
        {
            CheckDisposed();

            IVariable variable = null;
            bool badRequest = false;

            return DoesVariableExist(
                flags, null, name, ref variable, ref badRequest,
                ref error);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Variable Performance
        public ReturnCode MakeVariableFast(
            string name,
            bool fast,
            ref Result error
            )
        {
            CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                VariableFlags flags = VariableFlags.NoElement;
                IVariable variable = null;

                if (GetVariableViaResolversWithSplit(
                        name, ref flags, ref variable,
                        ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }

                if (EntityOps.IsLink(variable))
                {
                    variable = EntityOps.FollowLinks(
                        variable, flags, ref error);

                    if (variable == null)
                        return ReturnCode.Error;
                }

                variable.SetFlags(VariableFlags.FastMask, fast);
                return ReturnCode.Ok;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Variable Management (Single)
        public ReturnCode AddVariable(
            VariableFlags flags,
            string name,
            TraceList traces,
            bool errorOnExist,
            ref Result error
            )
        {
            CheckDisposed();

            IVariable variable = null;

            return AddVariable2(
                flags, name, traces, errorOnExist, ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetVariableValue(
            string name,
            ref Result value,
            ref Result error
            )
        {
            CheckDisposed();

            IVariable variable = null;

            return GetVariableValue2(
                VariableFlags.None, name, null,
                ref variable, ref value, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetVariableValue(
            VariableFlags flags,
            string name,
            ref Result value,
            ref Result error
            )
        {
            CheckDisposed();

            IVariable variable = null;

            return GetVariableValue2(
                flags, name, null, ref variable,
                ref value, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ResetVariable(
            VariableFlags flags,
            string name,
            ref Result error
            )
        {
            CheckDisposed();

            return ResetVariable2(flags, null, name, null, null, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SetVariableEnumerable(
            VariableFlags flags,
            string name,
            IEnumerable collection,
            bool autoReset,
            ref Result error
            )
        {
            CheckDisposed();

            IVariable variable = null;

            return SetVariableEnumerable2(
                flags, null, name, null, collection, autoReset, ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SetVariableLink(
            VariableFlags flags,
            string name,
            MemberInfo memberInfo,
            object @object,
            ref Result error
            )
        {
            CheckDisposed();

            IVariable variable = null;

            return SetVariableLink2(
                flags, null, name, null, memberInfo, @object, ref variable,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SetVariableSystemArray(
            VariableFlags flags,
            string name,
            Array array,
            ref Result error
            )
        {
            CheckDisposed();

            IVariable variable = null;

            return SetVariableSystemArray2(
                flags, null, name, array, ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SetVariableValue(
            string name,
            string value,
            ref Result error
            )
        {
            CheckDisposed();

            IVariable variable = null;

            return SetVariableValue(
                VariableFlags.None, name, value,
                null, ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SetVariableValue(
            VariableFlags flags,
            string name,
            string value,
            TraceList traces,
            ref Result error
            )
        {
            CheckDisposed();

            IVariable variable = null;

            return SetVariableValue(
                flags, name, value, traces,
                ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode UnsetVariable(
            string name,
            ref Result error
            )
        {
            CheckDisposed();

            return UnsetVariable2(
                VariableFlags.None, name, null, null, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode UnsetVariable(
            VariableFlags flags,
            string name,
            ref Result error
            )
        {
            CheckDisposed();

            return UnsetVariable2(
                flags, name, null, null, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode WaitVariable(
            EventWaitFlags eventWaitFlags, /* in */
            VariableFlags variableFlags,   /* in */
            string name,                   /* in */
            long microseconds,             /* in */
            long? threadId,                /* in, optional */
            int limit,                     /* in */
            EventWaitHandle @event,        /* in, optional */
            ref bool changed,              /* out */
            ref Result error               /* out */
            ) /* THREAD-SAFE */
        {
            CheckDisposed();

            if (microseconds < 0)
            {
                error = "number of microseconds cannot be negative";
                return ReturnCode.Error;
            }

            ReturnCode code;

            if (EnterWait() > 0)
            {
                //
                // NOTE: *WARNING* Empty variable names are allowed, please do not change
                //       these to "!String.IsNullOrEmpty".
                //
                if (name != null)
                {
                    bool noBgError = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.NoBgError, true);

                    bool noManagerEvents = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.NoManagerEvents, true);

                    bool noCancel = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.NoCancel, true);

                    bool noGlobalCancel = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.NoGlobalCancel, true);

                    bool stopOnError = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.StopOnError, true);

                    bool errorOnEmpty = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.ErrorOnEmpty, true);

                    bool userInterface = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.UserInterface, true);

                    bool noUserInterface = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.NoUserInterface, true);

                    bool noEvents = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.NoEvents, true);

                    bool noWindows = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.NoWindows, true);

                    bool noSleep = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.NoSleep, true);

                    bool noComplain = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.NoComplain, true);

                    bool stopOnComplain = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.StopOnComplain, true);

                    bool stopOnGlobalComplain = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.StopOnGlobalComplain, true);

                    bool onlyWaiting = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.OnlyWaiting, true);

                    bool onlyExists = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.OnlyExists, true);

                    bool doOneEvent = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.DoOneEvent, true);

#if NATIVE && TCL
                    bool tclDoOneEvent = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.TclDoOneEvent, true);

                    //
                    // NOTE: The "TclWaitEvent" flag should rarely, if ever,
                    //       be used.
                    //
                    bool tclWaitEvent = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.TclWaitEvent, true);

                    bool tclAllEvents = FlagOps.HasFlags(
                        eventWaitFlags, EventWaitFlags.TclAllEvents, true);
#endif

                    //
                    // NOTE: *WARNING* Sanity check the user-interface flag here.  We MUST
                    //       pump messages if this is an STA thread.
                    //
                    if (!userInterface && ThreadOps.IsStaThread())
                    {
                        userInterface = true;

                        if (FlagOps.HasFlags(eventWaitFlags, EventWaitFlags.Trace, true))
                        {
                            //
                            // HACK: Uses the interpreter "id" field directly, to avoid
                            //       disposal exception issues.
                            //
                            TraceOps.DebugTrace(String.Format(
                                "WaitVariable: detected STA thread, user-interface " +
                                "flag forcibly enabled, interpreter = {0}, " +
                                "eventWaitFlags = {1}, variableFlags = {2}, name = {3}, " +
                                "microseconds = {4}, limit = {5}, event = {6}, " +
                                "changed = {7}, error = {8}", FormatOps.WrapOrNull(id),
                                FormatOps.WrapOrNull(eventWaitFlags),
                                FormatOps.WrapOrNull(variableFlags),
                                FormatOps.WrapOrNull(name), microseconds,
                                limit, FormatOps.WrapOrNull(@event), changed,
                                FormatOps.WrapOrNull(true, true, error)),
                                typeof(Interpreter).Name, TracePriority.EventDebug);
                        }
                    }

                    //
                    // NOTE: Setup the extra event flags for this method.  These will be
                    //       based primarily on the event wait flags passed by the caller
                    //       and will typically be "None".
                    //
                    EventFlags extraEventFlags = EventFlags.None;

                    if (noBgError)
                        extraEventFlags |= EventFlags.NoBgError;

                    //
                    // NOTE: Is the variable undefined before waiting for changes?
                    //
                    bool wasUndefined = false;

                    //
                    // NOTE: Has the existence of the variable been checked?
                    //
                    bool once = false;

                    //
                    // NOTE: NOTE: Does the variable currently exist?
                    //
                    bool exists = false;

                    //
                    // NOTE: Has the variable been added, modified, or unset since we
                    //       started waiting?
                    //
                    bool dirty = false;

                    //
                    // NOTE: What is the timeout used when waiting for an internal lock
                    //       request (e.g. to fetch the IEventManager, etc)?
                    //
                    int timeout = EventOps.GetMilliseconds(microseconds);

                    //
                    // NOTE: Create the array of event handles to wait on.  The first event
                    //       is signaled when any variable is set or unset in the interpreter.
                    //       The second event is signaled when the queue managed by the event
                    //       manager is empty.  The third [and final] event is signaled when
                    //       an event is queued to the queue managed by the event manager.
                    //
                    EventWaitHandle[] events = GetEventWaitHandles(@event, timeout, true,
                        noManagerEvents, true);

                    //
                    // NOTE: Keep track of the total number of Eagle events processed.
                    //
                    int localEventCount = 0;

#if NATIVE && TCL
                    //
                    // NOTE: Keep track of the total number of native Tcl events processed.
                    //
                    int localTclEventCount = 0;
                    int localTclSleepCount = 0;
#endif

                    //
                    // NOTE: Keep track of the iterations of main loop of this method (for
                    //       diagnostic purposes only).
                    //
                    int localWaitSpinCount = 0;

                    //
                    // NOTE: For precise timing, use the high-resolution CPU performance
                    //       counter.
                    //
                    long startCount = PerformanceOps.GetCount();

                    //
                    // BUGFIX: Make sure the slop time does not exceed the actual wait.
                    //
                    long slopMicroseconds = EventOps.GetSlopMicroseconds(microseconds);

                    //
                    // NOTE: Keep waiting for the variable until one of the following
                    //       conditions is true:
                    //
                    //       1. The interpreter is no longer ready (i.e. canceled, deleted,
                    //          halted, exited, etc).
                    //
                    //       2. The variable is created, deleted, or changed.
                    //
                    //       3. Any error is raised while processing events, fully taking
                    //          into account the "stopOnError" flag, which is handled by
                    //          the EventManager itself.
                    //
                    CheckVariableNameUndefined(
                        this, name, eventWaitFlags, variableFlags, ref wasUndefined);

                    while (((code = EventReady(
                                 this, noCancel, noGlobalCancel,
                                 ref error)) == ReturnCode.Ok) &&
                           ((microseconds == 0) || !PerformanceOps.HasElapsed(
                                 startCount, microseconds, slopMicroseconds)) &&
                           ((code = IsVariableNameSignaled(
                                 this, name, eventWaitFlags, variableFlags, onlyWaiting,
                                 onlyExists, ref wasUndefined, ref once, ref exists,
                                 ref dirty, ref error)) == ReturnCode.Ok) && !dirty)
                    {
                        //
                        // NOTE: Grab the (current) number of complaints that have been
                        //       registered for this thread and/or AppDomain.
                        //
                        long beforeComplainCount = 0;
                        long beforeGlobalComplainCount = 0;
                        long beforeComplainQuietCount = 0; /* NOT USED */
                        long beforeGlobalComplainQuietCount = 0; /* NOT USED */

                        if (stopOnComplain || stopOnGlobalComplain)
                        {
                            DebugOps.GetComplainCounts(
                                stopOnComplain, stopOnGlobalComplain,
                                ref beforeComplainCount, ref beforeGlobalComplainCount,
                                ref beforeComplainQuietCount, ref beforeGlobalComplainQuietCount);
                        }

                        //
                        // NOTE: We need a local result because we do not want to change
                        //       the caller's result based on random async events that
                        //       get processed while waiting for their variable to become
                        //       "signaled".  However, we will change the caller's result
                        //       if an error is encountered.
                        //
                        Result localResult; /* REUSED */

#if NATIVE && TCL
                        //
                        // NOTE: Does the caller also want to process native Tcl events
                        //       during this wait operation?
                        //
                        if (tclDoOneEvent)
                        {
                            //
                            // NOTE: If Tcl has been loaded into this interpreter,
                            //       attempt to process events for it now.
                            //
                            ITclApi tclApi = _Private.Tcl.TclApi.GetTclApi(this);

                            if (_Private.Tcl.TclApi.CheckModule(tclApi))
                            {
                                //
                                // NOTE: Process one (or all) Tcl events from its
                                //       queue, without waiting.
                                //
                                localResult = null;

                                code = TclWrapper.DoOneEvent(
                                    this, 0, tclWaitEvent, tclAllEvents,
                                    noComplain, ref localTclEventCount,
                                    ref localTclSleepCount, ref tclApi,
                                    ref localResult);

                                _Private.Tcl.TclApi.SetTclApi(this, tclApi);

                                //
                                // NOTE: If we encountered an error processing Tcl
                                //       events, break out of the loop and return
                                //       the error code and result to the caller.
                                //
                                if (code != ReturnCode.Ok)
                                {
                                    error = localResult;
                                    break;
                                }
                            }
                        }
#endif

                        //
                        // NOTE: Does the caller also want to process events during
                        //       this wait operation?
                        //
                        if (doOneEvent)
                        {
                            //
                            // NOTE: Attempt to process all pending events stopping
                            //       if an error is encountered.  This grabs and uses
                            //       the current wait event flags without locking.
                            //
                            EventFlags localWaitEventFlags;

                            lock (syncRoot)
                            {
                                localWaitEventFlags = waitEventFlags;
                            }

                            localResult = null;

                            code = EventOps.DoOneEvent(this,
                                localWaitEventFlags | extraEventFlags,
                                EventPriority.WaitVariable, threadId,
                                limit, stopOnError, errorOnEmpty,
                                !noUserInterface && userInterface,
                                ref localEventCount, ref localResult);

                            //
                            // NOTE: If we encountered an error processing events,
                            //       break out of the loop and return the error
                            //       code and result to the caller.
                            //
                            if (code != ReturnCode.Ok)
                            {
                                error = localResult;
                                break;
                            }
                        }

                        //
                        // NOTE: Is the caller permitting us to sleep?  If not, do
                        //       nothing; otherwise, figure out the correct method
                        //       and timeout for sleeping.
                        //
                        if (!noSleep)
                        {
                            //
                            // NOTE: Get configured sleep time for this interpreter
                            //       [or the minimum possible sleep time].
                            //
                            int sleepMilliseconds = GetMinimumSleepTime(
                                SleepType.Variable, timeout);

                            //
                            // NOTE: Here, we yield to other running threads.  This
                            //       also gives them an opportunity to cancel any
                            //       script being evaluated on this thread and/or
                            //       update the variable we are waiting for.
                            //
                            SleepWaitCallback localSleepWaitCallback;

                            lock (syncRoot)
                            {
                                localSleepWaitCallback = sleepWaitCallback;
                            }

                            if (localSleepWaitCallback != null)
                            {
                                localResult = null;

                                code = localSleepWaitCallback(
                                    this, events, sleepMilliseconds, eventWaitFlags,
                                    ref localResult);

                                if (code != ReturnCode.Ok)
                                {
                                    error = localResult;
                                    break;
                                }
                            }
                            else if (!noEvents && (events != null))
                            {
#if NATIVE && WINDOWS
                                if (!noWindows &&
                                    PlatformOps.IsWindowsOperatingSystem())
                                {
                                    localResult = null;

                                    code = WindowOps.WaitForMultipleHandles(
                                        events, sleepMilliseconds, userInterface,
                                        ref localResult);

                                    if (code != ReturnCode.Ok)
                                    {
                                        error = localResult;
                                        break;
                                    }
                                }
                                else
#endif
                                {
                                    /* IGNORED */
                                    ThreadOps.WaitAnyEvent(
                                        events, sleepMilliseconds);
                                }
                            }
                            else
                            {
                                localResult = null;

                                code = HostOps.Sleep(
                                    this, sleepMilliseconds, ref localResult);

                                if (code != ReturnCode.Ok)
                                {
                                    error = localResult;
                                    break;
                                }
                            }
                        }

                        //
                        // NOTE: Grab the (new) number of complaints that have been
                        //       registered for this thread and/or AppDomain.
                        //
                        long afterComplainCount = 0;
                        long afterGlobalComplainCount = 0;
                        long afterComplainQuietCount = 0; /* NOT USED */
                        long afterGlobalComplainQuietCount = 0; /* NOT USED */

                        if (stopOnComplain || stopOnGlobalComplain)
                        {
                            DebugOps.GetComplainCounts(
                                stopOnComplain, stopOnGlobalComplain,
                                ref afterComplainCount, ref afterGlobalComplainCount,
                                ref afterComplainQuietCount, ref afterGlobalComplainQuietCount);
                        }

                        //
                        // NOTE: If the stop-on-complain flags have been set, make sure
                        //       there have been no complaints for this iteration -OR-
                        //       stop processing events now.
                        //
                        if (stopOnComplain && (afterComplainCount > beforeComplainCount))
                        {
                            string complaint = this.Complaint; /* THREAD-SAFE */

                            error = StringList.MakeList(String.Format(
                                "count of complaints increased from {0} to {1}",
                                beforeComplainCount, afterComplainCount), complaint);

                            code = ReturnCode.Error;
                            break;
                        }

                        if (stopOnGlobalComplain &&
                                (afterGlobalComplainCount > beforeGlobalComplainCount))
                        {
                            string complaint = DebugOps.SafeGetGlobalComplaint(); /* THREAD-SAFE */

                            error = StringList.MakeList(String.Format(
                                "count of global complaints increased from {0} to {1}",
                                beforeGlobalComplainCount, afterGlobalComplainCount),
                                complaint);

                            code = ReturnCode.Error;
                            break;
                        }

                        //
                        // NOTE: Keep track of how many times we actually waited for an
                        //       event.  This does not currently distinguish between a
                        //       timeout and one of the event handles being signaled.
                        //
                        localWaitSpinCount++; /* THREAD-SAFE */
                        Interlocked.Increment(ref waitSpinCount);
                    }

#if NATIVE && TCL
                    //
                    // BUGFIX: Update the total processed Tcl event count for this
                    //         interpreter.  We do not care about the return code
                    //         here because this field is totally exempt from the
                    //         "transactional semantics" of this method.  This was
                    //         being done from within the loop above; however, it
                    //         was wrong to do it that way (i.e. because an event
                    //         could be double counted).
                    //
                    /* IGNORED */
                    Interlocked.Add(ref tclEventCount, localTclEventCount);
                    Interlocked.Add(ref tclSleepCount, localTclSleepCount);
#endif

                    //
                    // BUGFIX: Update the total processed event count for this
                    //         interpreter.  We do not care about the return code
                    //         here because this field is totally exempt from the
                    //         "transactional semantics" of this method.  This was
                    //         being done from within the loop above; however, it
                    //         was wrong to do it that way (i.e. because an event
                    //         could be double counted).
                    //
                    /* IGNORED */
                    Interlocked.Add(ref eventCount, localEventCount);

                    //
                    // NOTE: Clear the wait status bit(s) for the scalar variable
                    //       and/or array element being waited for.
                    //
                    ClearVariableNameWait(this, name, eventWaitFlags, variableFlags);

                    //
                    // NOTE: Show diagnostic information about this wait operation?
                    //
                    if (FlagOps.HasFlags(eventWaitFlags, EventWaitFlags.Trace, true))
                    {
                        //
                        // HACK: Uses the interpreter "id" field directly, to avoid disposal
                        //       exception issues.
                        //
                        TraceOps.DebugTrace(String.Format(
                            "WaitVariable: interpreter = {0}, code = {1}, " +
                            "eventWaitFlags = {2}, variableFlags = {3}, " +
                            "name = {4}, microseconds = {5}, threadId = {6}, " +
                            "limit = {7}, wasUndefined = {8}, once = {9}, " +
                            "exists = {10}, dirty = {11}, localEventCount = {12}, " +
                            "eventCount = {13}, localTclEventCount = {14}, " +
                            "localTclSleepCount = {15}, tclEventCount = {16}, " +
                            "tclSleepCount = {17}, waitCount = {18}, " +
                            "localWaitSpinCount = {19}, waitSpinCount = {20}, " +
                            "event = {21}, changed = {22}, error = {23}",
                            FormatOps.WrapOrNull(id), code,
                            FormatOps.WrapOrNull(eventWaitFlags),
                            FormatOps.WrapOrNull(variableFlags),
                            FormatOps.WrapOrNull(name),
                            microseconds,
                            FormatOps.WrapOrNull(threadId),
                            limit, wasUndefined, once, exists,
                            dirty, localEventCount, eventCount,
#if NATIVE && TCL
                            localTclEventCount,
                            localTclSleepCount,
                            tclEventCount,
                            tclSleepCount,
#else
                            0,
                            0,
                            0,
                            0,
#endif
                            waitCount, localWaitSpinCount, waitSpinCount,
                            FormatOps.WrapOrNull(@event), changed,
                            FormatOps.WrapOrNull(true, true, error)),
                            typeof(Interpreter).Name, TracePriority.EventDebug);
                    }

                    //
                    // NOTE: Upon success, let the caller know if the variable
                    //       was actually changed (i.e. set to dirty).
                    //
                    if (code == ReturnCode.Ok)
                        changed = dirty;
                }
                else
                {
                    error = "invalid variable name";
                    code = ReturnCode.Error;
                }

                /* IGNORED */
                ExitWait();
            }
            else
            {
                error = "wait subsystem locked";
                code = ReturnCode.Error;
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode LockVariable(
            EventWaitFlags eventWaitFlags, /* in */
            VariableFlags variableFlags,   /* in */
            string name,                   /* in */
            long microseconds,             /* in */
            EventWaitHandle @event,        /* in, optional */
            ref Result error               /* out */
            ) /* THREAD-SAFE */
        {
            CheckDisposed();

            return PrivateLockVariable(
                eventWaitFlags, variableFlags, name, microseconds,
                @event, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode UnlockVariable(
            VariableFlags variableFlags, /* in */
            string name,                 /* in */
            ref Result error             /* out */
            )
        {
            CheckDisposed();

            return PrivateUnlockVariable(variableFlags, name, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal StringList VariablesToList(
            VariableFlags flags, /* in */
            string pattern,      /* in */
            bool noCase          /* in */
            )
        {
            ICallFrame frame;

            return VariablesToList(flags, pattern, noCase, out frame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal StringList VariablesToList(
            VariableFlags flags, /* in */
            string pattern,      /* in */
            bool noCase,         /* in */
            out ICallFrame frame /* out */
            )
        {
            Result error = null;

            StringList list = VariablesToList(
                flags, pattern, noCase, out frame, ref error);

            if ((list == null) && (error != null))
                DebugOps.Complain(this, ReturnCode.Error, error);

            return list;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private StringList VariablesToList(
            VariableFlags flags, /* in */
            string pattern,      /* in */
            bool noCase,         /* in */
            ref Result error     /* out */
            )
        {
            ICallFrame frame;

            return VariablesToList(
                flags, pattern, noCase, out frame, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private StringList VariablesToList(
            VariableFlags flags,  /* in */
            string pattern,       /* in */
            bool noCase,          /* in */
            out ICallFrame frame, /* out */
            ref Result error      /* out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                frame = null;

                bool globalOnly = FlagOps.HasFlags(
                    flags, VariableFlags.GlobalOnly, true);

                ICallFrame variableFrame = null;
                VariableFlags frameFlags = VariableFlags.None;
                INamespace @namespace = null;
                string qualifiers = null;
                bool qualified = false;
                bool absolute = false;

                if (globalOnly)
                {
                    if (pattern != null)
                        pattern = ScriptOps.MakeVariableName(pattern);

                    variableFrame = CurrentGlobalFrame;
                }
                else
                {
                    bool useNamespaces = AreNamespacesEnabled();

                    if (useNamespaces && (pattern != null))
                    {
                        string tail = null;
                        NamespaceFlags namespaceFlags = NamespaceFlags.None;

                        if (NamespaceOps.SplitName(
                                pattern, ref qualifiers, ref tail,
                                ref namespaceFlags, ref error) != ReturnCode.Ok)
                        {
                            return null;
                        }

                        qualified = FlagOps.HasFlags(
                            namespaceFlags, NamespaceFlags.Qualified, true);

                        absolute = FlagOps.HasFlags(
                            namespaceFlags, NamespaceFlags.Absolute, true);

                        @namespace = NamespaceOps.Lookup(
                            this, qualifiers, false, false, ref error);

                        if (@namespace == null)
                            return null;

                        if (qualified || absolute)
                        {
                            if (IsGlobalNamespace(@namespace))
                            {
                                variableFrame = CurrentGlobalFrame;
                                frameFlags |= VariableFlags.GlobalOnly;
                            }
                            else
                            {
                                variableFrame = @namespace.VariableFrame;
                            }
                        }
                        else
                        {
                            variableFrame = GetVariableFrame(null, frameFlags);

                            if (GetVariableFrameViaResolvers(
                                    LookupFlags.NoVerbose, ref variableFrame,
                                    ref frameFlags, ref error) != ReturnCode.Ok)
                            {
                                return null;
                            }
                        }

                        pattern = tail;
                    }
                    else
                    {
                        if (useNamespaces &&
                            GetCurrentNamespaceViaResolvers(
                                null, LookupFlags.NoVerbose,
                                ref @namespace, ref error) != ReturnCode.Ok)
                        {
                            return null;
                        }

                        variableFrame = GetVariableFrame(null,
                            ref pattern, ref frameFlags);

                        if (GetVariableFrameViaResolvers(
                                LookupFlags.NoVerbose, ref variableFrame,
                                ref frameFlags, ref error) != ReturnCode.Ok)
                        {
                            return null;
                        }
                    }
                }

                if (variableFrame == null)
                {
                    error = "invalid call frame from resolver";
                    return null;
                }

                VariableDictionary variables = variableFrame.Variables;

                if (variables == null)
                {
                    error = "call frame does not support variables";
                    return null;
                }

                StringList list = new StringList();

                bool linksOnly = FlagOps.HasFlags(flags,
                    VariableFlags.Link, true);

                bool systemOnly = FlagOps.HasFlags(flags,
                    VariableFlags.System, true);

                bool undefinedOnly = FlagOps.HasFlags(flags,
                    VariableFlags.Undefined, true);

                bool frameGlobalOnly = FlagOps.HasFlags(frameFlags,
                    VariableFlags.GlobalOnly, true);

                foreach (KeyValuePair<string, IVariable> pair in variables)
                {
                    IVariable variable = pair.Value;

                    if (!undefinedOnly && EntityOps.IsUndefined(variable))
                        continue;

                    string varName = pair.Key;

                    if ((pattern != null) && !StringOps.Match(
                            this, StringOps.DefaultMatchMode, varName,
                            pattern, false))
                    {
                        continue;
                    }

                    ///////////////////////////////////////////////////////////

                    if (globalOnly)
                    {
                        //
                        // BUGFIX: *COMPAT* Tcl. Apparently, links to undefined
                        //         variables do show up in the list of returned
                        //         globals (upvar-8.10).
                        //
                        // BUGFIX: Actually, that is a Tcl bug, not a feature;
                        //         therefore, we will mask undefined variables
                        //         from being returned by this command.
                        //
                        if (IsGlobalCallFrame(CallFrameOps.FollowNext(
                                variable.Frame)))
                        {
                            list.Add(varName);
                        }
                    }
                    else if ((!linksOnly || EntityOps.IsLink(variable)) &&
                        (!systemOnly || EntityOps.IsSystem(variable)) &&
                        (!undefinedOnly || EntityOps.IsUndefined(variable)))
                    {
                        //
                        // NOTE: Add the local variable or variable link name
                        //       to the resulting list.
                        //
                        if ((@namespace != null) &&
                            !IsGlobalNamespace(@namespace))
                        {
                            list.Add(NamespaceOps.MakeName(qualifiers,
                                varName, qualified, qualified || absolute));
                        }
                        else
                        {
                            list.Add(frameGlobalOnly ?
                                NamespaceOps.MakeAbsoluteName(varName) :
                                varName);
                        }
                    }
                }

                frame = variableFrame;
                return list;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void MaybeAddGlobals(
            ICallFrame frame,    /* in */
            VariableFlags flags, /* in */
            string pattern,      /* in */
            bool noCase,         /* in */
            ref StringList list  /* in, out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (IsNamespaceCallFrame(frame))
                {
                    StringList localList = VariablesToList(
                        flags | VariableFlags.GlobalOnly, pattern,
                        noCase);

                    if (localList != null)
                    {
                        if (list == null)
                            list = new StringList();

                        list.AddRange(localList);
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void CreateMissingVariable(
            ICallFrame variableFrame,
            string varName,
            object varValue,
            TraceList traces,
            bool dirty,
            ref VariableFlags variableFlags,
            out IVariable localVariable
            )
        {
            //
            // NOTE: The variable does not exist in the call frame,
            //       set the "WasMissing" flag.
            //
            variableFlags |= VariableFlags.WasMissing;

            //
            // NOTE: Is the target call frame the global one?  If so,
            //       make sure the correct flag is set.
            //
            bool isGlobalCallFrame = IsGlobalCallFrame(variableFrame);

            //
            // NOTE: Create the new variable instance now.  This is
            //       very similar to how variables are created via
            //       the AddVariable2 method.
            //
            localVariable = new Variable(variableFrame, varName,
                (variableFlags & ~VariableFlags.NonAddMask) |
                CallFrameOps.GetNewVariableFlags(variableFrame) |
                GetNewVariableFlags(isGlobalCallFrame), null,
                GetTraces(traces, varName, null, varValue, null),
                variableEvent);

            //
            // NOTE: Does the newly created (dummy) variable need a
            //       value?
            //
            if (varValue != null)
            {
                //
                // HACK: If the value happens to refer to an array
                //       of elements, this new variable will become
                //       an array; otherwise, it will be a scalar.
                //
                ElementDictionary arrayValue =
                    varValue as ElementDictionary;

                if (arrayValue != null)
                {
                    localVariable.Value = null;
                    localVariable.ArrayValue = arrayValue;

                    EntityOps.SetArray(localVariable, true);
                }
                else
                {
                    localVariable.Value = varValue;
                    localVariable.ArrayValue = null;

                    EntityOps.SetArray(localVariable, false);
                }
            }

            //
            // NOTE: Does the newly created (dummy) variable need to
            //       be signaled (as dirty)?
            //
            if (dirty)
                EntityOps.SetDirty(localVariable, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetVariable(
            ICallFrame frame,
            string varName,
            string varIndex, /* NOT USED */
            TraceList traces,
            ref VariableFlags variableFlags,
            ref IVariable variable,
            ref Result error
            ) /* USED BY CORE RESOLVER ONLY */
        {
            /* CheckDisposed(); */

            //
            // NOTE: Reset all status flags because we haven't checked
            //       anything yet.
            //
            variableFlags &= ~VariableFlags.ErrorMask;

            //
            // NOTE: Make sure the supplied variable name is valid.
            //
            if (varName == null)
            {
                error = "invalid variable name";
                return ReturnCode.Error;
            }

            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // NOTE: Get applicable call frame based on provided
                //       variable name and flags.
                //
                ICallFrame variableFrame = frame;

                if (GetVariableFrameViaResolvers(
                        LookupFlags.Default, ref variableFrame,
                        ref varName, ref variableFlags,
                        ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }

                if (variableFrame == null)
                {
                    error = "invalid call frame from resolver";
                    return ReturnCode.Error;
                }

                VariableDictionary variables = variableFrame.Variables;

                if (variables == null)
                {
                    error = "call frame does not support variables";
                    return ReturnCode.Error;
                }

                if (variables.Count == 0)
                {
                    //
                    // NOTE: The variable cannot exist in the call frame
                    //       (i.e. because there are no variables in the
                    //       call frame), set the "NotFound" flag.
                    //
                    variableFlags |= VariableFlags.NotFound;

                    error = "no variables in call frame";
                    return ReturnCode.Error;
                }

                //
                // NOTE: Try to get the variable in the desired call frame.
                //
                IVariable localVariable;

                if (variables.TryGetValue(varName, out localVariable))
                {
                    //
                    // NOTE: Ok, there was physically a variable within the
                    //       call frame.  Now, make sure it is defined -AND-
                    //       matches the other variable flags specified by
                    //       the caller, if any.
                    //
                    if (ScriptOps.CheckVariableStatus(
                            varName, localVariable, ref variableFlags,
                            ref error) == ReturnCode.Ok)
                    {
                        variable = localVariable;
                        return ReturnCode.Ok;
                    }
                }
                else if (FlagOps.HasFlags(
                        variableFlags, VariableFlags.CreateMissing, true))
                {
                    //
                    // HACK: The variable does not exist in the call frame;
                    //       however, since the "CreateMissing" flag is set,
                    //       pretend like it does.  It should be noted that
                    //       the variable is not actually added to the call
                    //       frame here.  Since this flag introduces a new,
                    //       unusual, and potentially disruptive behavior,
                    //       it should generally only be used for diagnostic
                    //       and testing purposes.
                    //
                    CreateMissingVariable(
                        variableFrame, varName, missingVariableValue,
                        traces, missingVariableDirty, ref variableFlags,
                        out localVariable);

                    variable = localVariable;
                    return ReturnCode.Ok;
                }
                else
                {
                    //
                    // NOTE: The variable does not exist in the call frame,
                    //       set the "NotFound" flag.
                    //
                    variableFlags |= VariableFlags.NotFound;

                    //
                    // HACK: This is on the "hot path" for WaitVariable on
                    //       variables that do not yet exist; therefore, do
                    //       not use String.Format here.
                    //
                    // BUGBUG: Just how slow is String.Format and why?
                    //
                    // error = String.Format(
                    //     "variable {0} not found in call frame {1}",
                    //     FormatOps.ErrorVariableName(varName),
                    //     FormatOps.WrapOrNull(variableFrame));
                    //
                    error = "variable not found in call frame";
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DoesVariableExist(
            VariableFlags flags,
            string name,
            ref IVariable variable
            )
        {
            bool badRequest = false;
            Result error = null;

            return DoesVariableExist(
                flags, null, name, ref variable, ref badRequest, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DoesVariableExist(
            VariableFlags flags,
            ICallFrame frame,
            string name,
            ref bool badRequest,
            ref Result error
            )
        {
            IVariable variable = null;

            return DoesVariableExist(
                flags, frame, name, ref variable, ref badRequest, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DoesVariableExist( /* SECONDARY */
            VariableFlags flags,
            ICallFrame frame,
            string name,
            ref IVariable variable,
            ref bool badRequest,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                flags |= existVariableFlags;

                string varName = null;
                string varIndex = null;

                if (ScriptOps.SplitVariableName(
                        this, flags, name, ref varName,
                        ref varIndex, ref error) == ReturnCode.Ok)
                {
                    IVariable localVariable = null;

                    flags |= VariableFlags.NoUsable;

                    if (GetVariableViaResolversWithSplit(
                            frame, varName, ref flags, ref localVariable,
                            ref error) == ReturnCode.Ok)
                    {
                        //
                        // BUGFIX: Null and undefined variables do not "exist".
                        //
                        if (localVariable == null)
                        {
                            error = String.Format(
                                "can't verify {0}: no such variable",
                                FormatOps.ErrorVariableName(
                                    localVariable, null, varName, varIndex));

                            return ReturnCode.Error;
                        }

                        //
                        // NOTE: If the variable physically exists but is not usable
                        //       from this thread, just return failure now, with the
                        //       bad request flag set.
                        //
                        if (!localVariable.IsUsable(ref error))
                        {
                            badRequest = true;
                            return ReturnCode.Error;
                        }

                        //
                        // NOTE: For linked variables, we may be linking to an array
                        //       element.
                        //
                        string linkIndex = null;

                        if (EntityOps.IsLink(localVariable))
                        {
                            //
                            // NOTE: Get the array element index of the link, if any.
                            //
                            linkIndex = localVariable.LinkIndex;

                            //
                            // NOTE: Follow the linked variable.
                            //
                            localVariable = EntityOps.FollowLinks(
                                localVariable, flags, ref error);

                            if (localVariable == null)
                                return ReturnCode.Error;

                            //
                            // NOTE: If the variable physically exists but is not usable
                            //       from this thread, just return failure now, with the
                            //       bad request flag set.
                            //
                            if (!localVariable.IsUsable(ref error))
                            {
                                badRequest = true;
                                return ReturnCode.Error;
                            }
                        }

                        //
                        // NOTE: If they specified the NoElement flag, then make sure
                        //       the linked variable does not refer to an array element.
                        //
                        if ((linkIndex == null) ||
                            !FlagOps.HasFlags(flags, VariableFlags.NoElement, true))
                        {
                            badRequest = false; // var name searched OK and found OK.

                            //
                            // BUGFIX: Null and undefined variables do not "exist".
                            //
                            if (!EntityOps.IsUndefined(localVariable))
                            {
                                //
                                // NOTE: Are they requesting an array, directly or
                                //       indirectly (i.e. indirectly if the specified
                                //       variable name or variable link contains an
                                //       element index and they did not specify the
                                //       NoElement flag)?
                                //
                                if (FlagOps.HasFlags(flags, VariableFlags.Array, true) ||
                                    (varIndex != null) || (linkIndex != null))
                                {
                                    //
                                    // NOTE: Is the variable an array?
                                    //
                                    if (EntityOps.IsArray2(localVariable) &&
                                        ((varIndex == null) || (linkIndex == null)))
                                    {
                                        if ((varIndex != null) || (linkIndex != null))
                                        {
                                            //
                                            // NOTE: If there was no element index specified,
                                            //       use the one from the variable link.
                                            //
                                            if (varIndex == null)
                                                varIndex = linkIndex;

                                            //
                                            // HACK: Handle the global "env" array specially.
                                            //       We must do this because our global "env"
                                            //       array has no backing storage (unlike Tcl's)
                                            //       and we do not have a trace operation for
                                            //       "exists".
                                            //
                                            ElementDictionary arrayValue = localVariable.ArrayValue;

                                            if ((IsEnvironmentVariable(localVariable) &&
                                                    CommonOps.Environment.DoesVariableExist(varIndex)) ||
                                                ((arrayValue != null) && arrayValue.ContainsKey(varIndex)))
                                            {
                                                variable = localVariable;
                                                return ReturnCode.Ok;
                                            }
                                            else if ((IsTestsVariable(localVariable) &&
                                                    DoesTestsVariableExist(varIndex)) ||
                                                ((arrayValue != null) && arrayValue.ContainsKey(varIndex)))
                                            {
                                                variable = localVariable;
                                                return ReturnCode.Ok;
                                            }
                                            else if ((IsSystemArrayVariable(localVariable) &&
                                                    MarshalOps.DoesArrayElementExist(
                                                        binder, cultureInfo, localVariable, varIndex)) ||
                                                ((arrayValue != null) && arrayValue.ContainsKey(varIndex)))
                                            {
                                                variable = localVariable;
                                                return ReturnCode.Ok;
                                            }
                                            else
                                            {
                                                ThreadVariable threadVariable = null;

                                                if ((IsThreadVariable(localVariable, ref threadVariable) &&
                                                        threadVariable.DoesExist(this, varIndex)) ||
                                                    ((arrayValue != null) && arrayValue.ContainsKey(varIndex)))
                                                {
                                                    variable = localVariable;
                                                    return ReturnCode.Ok;
                                                }
                                                else
                                                {
#if DATA
                                                    DatabaseVariable databaseVariable = null;

                                                    if ((IsDatabaseVariable(localVariable, ref databaseVariable) &&
                                                            databaseVariable.DoesExist(this, varIndex)) ||
                                                        ((arrayValue != null) && arrayValue.ContainsKey(varIndex)))
                                                    {
                                                        variable = localVariable;
                                                        return ReturnCode.Ok;
                                                    }
                                                    else
#endif
                                                    {
#if NETWORK && WEB
                                                        NetworkVariable networkVariable = null;

                                                        if ((IsNetworkVariable(localVariable, ref networkVariable) &&
                                                                networkVariable.DoesExist(this, varIndex)) ||
                                                            ((arrayValue != null) && arrayValue.ContainsKey(varIndex)))
                                                        {
                                                            variable = localVariable;
                                                            return ReturnCode.Ok;
                                                        }
                                                        else
#endif
                                                        {
#if !NET_STANDARD_20 && WINDOWS
                                                            RegistryVariable registryVariable = null;

                                                            if ((IsRegistryVariable(localVariable, ref registryVariable) &&
                                                                    registryVariable.DoesExist(this, varIndex)) ||
                                                                ((arrayValue != null) && arrayValue.ContainsKey(varIndex)))
                                                            {
                                                                variable = localVariable;
                                                                return ReturnCode.Ok;
                                                            }
                                                            else
#endif
                                                            {
                                                                error = String.Format(
                                                                    "can't verify {0}: no such element in array",
                                                                    FormatOps.ErrorVariableName(
                                                                        localVariable, linkIndex, varName, varIndex));
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else
                                        {
                                            //
                                            // NOTE: The variable is an array and we did not want to
                                            //       validate any actual element.
                                            //
                                            variable = localVariable;
                                            return ReturnCode.Ok;
                                        }
                                    }
                                    else
                                    {
                                        error = String.Format(
                                            "can't verify {0}: variable isn't array",
                                            FormatOps.ErrorVariableName(
                                                localVariable, linkIndex, varName, varIndex));
                                    }
                                }
                                else if (FlagOps.HasFlags(flags, VariableFlags.NoArray, true))
                                {
                                    if (EntityOps.IsArray2(localVariable))
                                    {
                                        //
                                        // NOTE: They requested verification of a scalar variable
                                        //       and the variable is actually an array, this is
                                        //       an error.
                                        //
                                        error = String.Format(
                                            "can't verify {0}: variable is array",
                                            FormatOps.ErrorVariableName(
                                                localVariable, linkIndex, varName, varIndex));
                                    }
                                    else
                                    {
                                        //
                                        // HACK: *SPECIAL* Transparently per-thread scalar
                                        //       variables need special checking.
                                        //
                                        ThreadVariable threadVariable = null;

                                        if (IsThreadVariable(localVariable, ref threadVariable))
                                        {
                                            if (threadVariable.DoesExist(this))
                                            {
                                                variable = localVariable;
                                                return ReturnCode.Ok;
                                            }
                                            else
                                            {
                                                error = String.Format(
                                                    "can't verify {0}: no such variable",
                                                    FormatOps.ErrorVariableName(
                                                        localVariable, linkIndex, varName, varIndex));
                                            }
                                        }
                                        else
                                        {
                                            //
                                            // NOTE: They requested verification of a scalar variable
                                            //       and [correctly] did not supply an element index,
                                            //       everything is ok.
                                            //
                                            variable = localVariable;
                                            return ReturnCode.Ok;
                                        }
                                    }
                                }
                                else
                                {
                                    //
                                    // HACK: *SPECIAL* Transparently per-thread scalar
                                    //       variables need special checking.
                                    //
                                    ThreadVariable threadVariable = null;

                                    if (IsThreadVariable(localVariable, ref threadVariable))
                                    {
                                        if (threadVariable.DoesExist(this))
                                        {
                                            variable = localVariable;
                                            return ReturnCode.Ok;
                                        }
                                        else
                                        {
                                            error = String.Format(
                                                "can't verify {0}: no such variable",
                                                FormatOps.ErrorVariableName(
                                                    localVariable, linkIndex, varName, varIndex));
                                        }
                                    }
                                    else
                                    {
                                        //
                                        // NOTE: No special flags were set and they did not specify an
                                        //       element index.
                                        //
                                        variable = localVariable;
                                        return ReturnCode.Ok;
                                    }
                                }
                            }
                            else
                            {
                                error = String.Format(
                                    "can't verify {0}: no such variable",
                                    FormatOps.ErrorVariableName(
                                        localVariable, linkIndex, varName, varIndex));
                            }
                        }
                        else
                        {
                            //
                            // NOTE: Bad request, they wanted to validate that the
                            //       variable does not refer to an array element
                            //       and the linked variable does.  Indicate this
                            //       special condition to the caller.
                            //
                            badRequest = true; // var name NOT searched OK.

                            //
                            // NOTE: Provide an informative error message.
                            //
                            error = "name refers to an element in an array";
                        }
                    }
                    else
                    {
                        //
                        // NOTE: If we did not actually search for the variable
                        //       (due to the internal calls to parse the variable
                        //       name failing, etc), we do not want to pretend that
                        //       the variable was simply not found.
                        //
                        if (FlagOps.HasFlags(flags, VariableFlags.NotFound, true))
                            badRequest = false; // var name searched OK and NOT found.
                        else
                            badRequest = true; // var name NOT searched OK.
                    }
                }
                else
                {
                    //
                    // NOTE: Bad variable name could not be parsed.
                    //       Indicate this special condition to the
                    //       caller.
                    //
                    badRequest = true; // var name NOT searched OK.
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HasNoPostProcess()
        {
            /* EXEMPT */
            return FlagOps.HasFlags(interpreterFlags,
                InterpreterFlags.NoPostProcess, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PostProcessVariableValue(
            VariableFlags flags,
            string name,
            string index,
            IVariable variable,
            object oldValue,
            ref Result value,
            ref Result error
            )
        {
            //
            // NOTE: Do we need to post-process this variable value at all
            //       prior to returning it?
            //
            if (EntityOps.IsSubstituteOrEvaluate(variable))
            {
                Result result = null;

                //
                // NOTE: Do we need to post-process the variable value by
                //       processing substitutions contained within it?
                //
                if (EntityOps.IsSubstitute(variable))
                {
                    if (SubstituteString(
                            StringOps.GetStringFromObject(oldValue),
                            ref result) != ReturnCode.Ok)
                    {
                        error = result;
                        return ReturnCode.Error;
                    }

                    oldValue = result;
                }

                //
                // NOTE: Do we need to post-process the variable value by
                //       evaluating it as a script?
                //
                if (EntityOps.IsEvaluate(variable))
                {
                    if (EvaluateScript(
                            StringOps.GetStringFromObject(oldValue),
                            ref result) != ReturnCode.Ok) /* EXEMPT */
                    {
                        error = result;
                        return ReturnCode.Error;
                    }

                    oldValue = result;
                }
            }

            //
            // NOTE: If post-processing was skipped or we were
            //       successful, signal success and return.
            //
            if (!FlagOps.HasFlags(flags, VariableFlags.SkipToString, true))
            {
                value = StringOps.GetResultFromObject(oldValue);
            }
            else
            {
                value = Result.FromObject(
                    oldValue, false, false, FlagOps.HasFlags(
                    flags, VariableFlags.FallbackToString, true));
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Currently, for use by the [array] command and the
        //       FireArraySetTraces method only.
        //
        internal ReturnCode FireTraces(
            BreakpointType breakpointType,
            VariableFlags flags,
            ICallFrame frame,
            string varName,
            string varIndex,
            object newValue,
            ElementDictionary oldValues,
            ElementDictionary newValues,
            IVariable variable,
            ref Result result
            )
        {
            if (!FlagOps.HasFlags(flags, VariableFlags.NonTrace, false) &&
                !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
            {
                object oldValue = EntityOps.GetOldValue(
                    flags, variable, varIndex,
                    ScriptOps.GetDefaultValue(breakpointType));

                ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                    this, null, breakpointType, frame, variable,
                    varName, varIndex, flags, oldValue, newValue,
                    oldValues, newValues, null, NeedNewTraceInfo(
                    flags), false, !EntityOps.IsNoPostProcess(
                    variable), ReturnCode.Ok);

                return ScriptOps.FireTraces(
                    variable, breakpointType, this, traceInfo,
                    ref result);
            }
            else
            {
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by the FireCloneTraces method only.
        //
        private ReturnCode FireTraces(
            BreakpointType breakpointType,
            VariableFlags flags,
            ICallFrame frame,
            string varName,
            string varIndex,
            object oldValue,
            object newValue,
            ElementDictionary oldValues,
            ElementDictionary newValues,
            IVariable variable,
            ref Result result
            )
        {
            if (!FlagOps.HasFlags(flags, VariableFlags.NonTrace, false) &&
                !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
            {
                ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                    this, null, breakpointType, frame, variable,
                    varName, varIndex, flags, oldValue, newValue,
                    oldValues, newValues, null, NeedNewTraceInfo(
                    flags), false, !EntityOps.IsNoPostProcess(
                    variable), ReturnCode.Ok);

                return ScriptOps.FireTraces(
                    variable, breakpointType, this, traceInfo,
                    ref result);
            }
            else
            {
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by the IVariable.CopyValueFrom and
        //          IVariable.Clone methods only.
        //
        internal ReturnCode FireCloneTraces(
            BreakpointType breakpointType,
            VariableFlags flags,
            ICallFrame frame,
            string varName,
            string varIndex,
            object oldValue,
            object newValue,
            ElementDictionary oldValues,
            ElementDictionary newValues,
            IVariable variable,
            ref Result result
            )
        {
            EventWaitHandle variableEvent;

            variableEvent = TryGetVariableEvent(ref result);

            if (variableEvent == null)
                return ReturnCode.Error;

            ElementDictionary effectiveNewValues = (oldValues != null) ?
                new ElementDictionary(variableEvent, oldValues) :
                new ElementDictionary(variableEvent);

            if (newValues != null)
            {
                foreach (KeyValuePair<string, object> pair in newValues)
                    effectiveNewValues[pair.Key] = pair.Value;
            }

            return FireTraces(
                breakpointType, flags, frame, varName, varIndex,
                oldValue, newValue, oldValues, effectiveNewValues,
                variable, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode FireArraySetTraces( // NOTE: For use by [array] command only.
            BreakpointType breakpointType,
            VariableFlags flags,
            ICallFrame frame,
            string varName,
            string varIndex,
            object newValue,
            ElementDictionary oldValues,
            ElementDictionary newValues,
            IVariable variable,
            ref Result result
            )
        {
            EventWaitHandle variableEvent;

            variableEvent = TryGetVariableEvent(ref result);

            if (variableEvent == null)
                return ReturnCode.Error;

            ElementDictionary effectiveNewValues = (oldValues != null) ?
                new ElementDictionary(variableEvent, oldValues) :
                new ElementDictionary(variableEvent);

            if (newValues != null)
            {
                foreach (KeyValuePair<string, object> pair in newValues)
                    effectiveNewValues[pair.Key] = pair.Value;
            }

            return FireTraces(
                breakpointType, flags, frame, varName, varIndex, newValue,
                oldValues, effectiveNewValues, variable, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetIntegerVariableValue( /* NOTE: For [incr] use only. */
            VariableFlags flags,
            string name,
            ref long value,
            ref Result error
            )
        {
            ReturnCode code;
            Result result = null;

            code = GetVariableValue(
                flags | VariableFlags.SkipToString, name, ref result,
                ref error);

            if (code != ReturnCode.Ok)
                return code;

            if (result != null)
            {
                if (result.Value is int)
                {
                    value = (int)result.Value;
                    return ReturnCode.Ok;
                }

                if (result.Value is long)
                {
                    value = (long)result.Value;
                    return ReturnCode.Ok;
                }
            }

            code = Value.GetWideInteger2(
                (IGetValue)result, ValueFlags.AnyWideInteger,
                cultureInfo, ref value, ref error);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SetIntegerVariableValue( /* NOTE: For [incr] use only. */
            VariableFlags flags,
            string name,
            long value,
            ref Result error
            )
        {
            int intValue = ConversionOps.ToInt(value);

            if (value == intValue)
            {
                IVariable variable = null;

                return SetVariableValue2(
                    flags, null, name, null, intValue, null, ref variable,
                    ref error);
            }
            else
            {
                IVariable variable = null;

                return SetVariableValue2(
                    flags, null, name, null, value, null, ref variable,
                    ref error);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetListVariableValue( /* NOTE: For [lsearch] use only. */
            VariableFlags flags,
            string name,
            bool copy,
            bool errorOnNotFound,
            bool errorOnNotList,
            bool readOnly,
            ref StringList value
            )
        {
            IVariable variable = null;
            bool cached = false;
            Result error = null;

            return GetListVariableValue(
                flags, name, copy, errorOnNotFound, errorOnNotList,
                readOnly, ref variable, ref value, ref cached,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetListVariableValue( /* NOTE: For [lappend]/[lget]/[lset] use only. */
            VariableFlags flags,
            string name,
            bool copy,
            bool errorOnNotFound,
            bool errorOnNotList,
            bool readOnly,
            ref StringList value,
            ref Result error
            )
        {
            IVariable variable = null;
            bool cached = false;

            return GetListVariableValue(
                flags, name, copy, errorOnNotFound, errorOnNotList,
                readOnly, ref variable, ref value, ref cached,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetListVariableValue(
            VariableFlags flags,
            string name,
            bool copy,
            bool errorOnNotFound,
            bool errorOnNotList,
            bool readOnly,
            ref IVariable variable,
            ref StringList value,
            ref bool cached,
            ref Result error
            )
        {
            ReturnCode code;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                flags |= VariableFlags.SkipToString;

                string varIndex = null;
                Result localValue = null;
                Result localError = null;

                code = GetVariableValue(
                    flags, name, ref varIndex, ref variable, ref localValue,
                    ref localError);

                if (code == ReturnCode.Ok)
                {
                    object oldValue = !EntityOps.IsVirtualOrSystem(variable) ?
                        EntityOps.GetOldValue(flags, variable, varIndex, null) :
                        StringOps.GetStringFromObject(localValue);

                    if (oldValue is StringList)
                    {
                        if (copy)
                            value = new StringList((StringList)oldValue);
                        else
                            value = (StringList)oldValue;

                        cached = true;
                    }
                    else if (!errorOnNotList)
                    {
                        if (oldValue != null)
                        {
                            code = ParserOps<string>.SplitList(
                                this, StringOps.GetStringFromObject(oldValue),
                                0, Length.Invalid, readOnly, ref value, ref error);

                            if (code == ReturnCode.Ok)
                                cached = false;
                        }
                        else
                        {
                            value = new StringList();
                            cached = false;
                        }
                    }
                    else
                    {
                        error = "variable value is not a list";
                        code = ReturnCode.Error;
                    }
                }
                else if (!errorOnNotFound)
                {
                    //
                    // NOTE: The variable does not exist (or the name is
                    //       invalid, etc).  Return an empty list and let
                    //       the caller deal with it.  For [lappend], if
                    //       the name is invalid, the subsequent call to
                    //       SetVariableValue will fail, that's alright.
                    //
                    value = new StringList();
                    cached = false;

                    code = ReturnCode.Ok;
                }
                else
                {
                    error = localError;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetVariableValue(
            VariableFlags flags,
            string name,
            ref Result value
            )
        {
            IVariable variable = null;
            Result error = null;

            return GetVariableValue2(
                flags, name, null, ref variable, ref value, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetVariableValue( /* NOTE: For use by GetListVariableValue only. */
            VariableFlags flags,
            string name,
            ref string varIndex,
            ref IVariable variable,
            ref Result value,
            ref Result error
            )
        {
            string varName = null;

            if (ScriptOps.SplitVariableName(
                    this, flags, name, ref varName,
                    ref varIndex, ref error) == ReturnCode.Ok)
            {
                return GetVariableValue2(
                    flags, varName, varIndex, ref variable,
                    ref value, ref error);
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetVariableValue2(
            VariableFlags flags,
            string name,
            string index,
            ref Result value
            )
        {
            Result error = null;

            return GetVariableValue2(flags, name, index, ref value, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetVariableValue2(
            VariableFlags flags,
            string name,
            string index,
            ref Result value,
            ref Result error
            )
        {
            IVariable variable = null;

            return GetVariableValue2(
                flags, name, index, ref variable, ref value, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetVariableValue2(
            VariableFlags flags,
            ICallFrame frame,
            string name,
            string index,
            ref Result value,
            ref Result error
            )
        {
            IVariable variable = null;

            return GetVariableValue2(
                flags, frame, name, index, ref variable, ref value, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetVariableValue2(
            VariableFlags flags,
            string name,
            string index,
            ref IVariable variable,
            ref Result value,
            ref Result error
            )
        {
            return GetVariableValue2(
                flags, null, name, index, ref variable, ref value, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetVariableValue2( /* PRIMARY */
            VariableFlags flags,
            ICallFrame frame,
            string name,
            string index,
            ref IVariable variable,
            ref Result value,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                flags |= getVariableFlags;

                bool haveVariable = (variable != null);
                Result localError = null;

                if ((haveVariable ||
                    (GetVariableViaResolversWithSplit(frame, name, index, ref flags,
                        ref variable, ref localError) == ReturnCode.Ok)) &&
                    !EntityOps.IsUndefined(variable, "read", name, index,
                        ref localError))
                {
                    //
                    // COMPAT: Tcl, if the index was specified, make sure the name
                    //         itself does not contain an array element reference.
                    //
                    if (haveVariable || (index == null))
                    {
                        VariableFlags splitFlags = flags;
                        string splitIndex = null;

                        if (index != null)
                            splitFlags |= VariableFlags.NoElement;

                        if (ScriptOps.SplitVariableName(
                                this, splitFlags, name, ref name,
                                ref splitIndex, ref error) == ReturnCode.Ok)
                        {
                            if ((index == null) && (splitIndex != null))
                                index = splitIndex;
                        }
                        else
                        {
                            return ReturnCode.Error;
                        }
                    }

                    //
                    // NOTE: Make sure we have a variable.
                    //
                    if (variable == null)
                    {
                        error = String.Format(
                            "can't read {0}: variable is invalid",
                            FormatOps.ErrorVariableName(name, index));

                        return ReturnCode.Error;
                    }

                    //
                    // NOTE: For linked variables, we may be linking to an array
                    //       element.
                    //
                    string linkIndex = null;

                    //
                    // NOTE: Save original call frame for traces.
                    //
                    ICallFrame savedFrame = variable.Frame;

                    //
                    // NOTE: Is the variable really a link to another variable?
                    //
                    if (EntityOps.IsLink(variable))
                    {
                        //
                        // NOTE: Get the array element index of the link, if any.
                        //
                        linkIndex = variable.LinkIndex;

                        //
                        // NOTE: Follow the linked variable.
                        //
                        variable = EntityOps.FollowLinks(variable, flags, ref error);

                        if (variable == null)
                            return ReturnCode.Error;
                    }

                    if (!EntityOps.IsUndefined(variable))
                    {
                        if ((index != null) || (linkIndex != null))
                        {
                            if (EntityOps.IsArray2(variable) &&
                                ((index == null) || (linkIndex == null)))
                            {
                                //
                                // NOTE: If there was no element index specified, use
                                //       the one from the variable link.
                                //
                                if (index == null)
                                    index = linkIndex;

                                if (!EntityOps.IsWriteOnly(variable))
                                {
                                    ElementDictionary arrayValue = variable.ArrayValue;
                                    ITraceInfo traceInfo; /* REUSED */

                                    if (arrayValue != null)
                                    {
                                        object defaultValue;

                                        if (arrayValue.ContainsKey(index, out defaultValue) ||
                                            (defaultValue != null))
                                        {
                                            object oldValue = EntityOps.GetOldValue(
                                                flags, arrayValue, index, ScriptOps.GetDefaultValue(
                                                    BreakpointType.BeforeVariableGet, defaultValue));

                                            traceInfo = ScriptOps.NewTraceInfo(
                                                this, null, BreakpointType.BeforeVariableGet, savedFrame,
                                                variable, name, index, flags, oldValue, null, null, null,
                                                null, NeedNewTraceInfo(flags), false,
                                                !EntityOps.IsNoPostProcess(variable), ReturnCode.Ok);

#if DEBUGGER && DEBUGGER_VARIABLE
                                            if (!FlagOps.HasFlags(traceInfo.Flags,
                                                    VariableFlags.NonWatchpoint, false) &&
                                                CanHitWatchpoints(traceInfo.BreakpointType) &&
                                                !EntityOps.IsNoWatchpoint(variable) &&
                                                EntityOps.IsBreakOnGet(variable))
                                            {
                                                //
                                                // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                                //       get access for this variable.
                                                //
                                                Result localResult = null;

                                                if (CheckWatchpoints(
                                                        ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                                        traceInfo, ref localResult) != ReturnCode.Ok)
                                                {
                                                    error = localResult;
                                                    return ReturnCode.Error;
                                                }
                                            }
#endif

                                            if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                                !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                                !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                                            {
                                                try
                                                {
                                                    if (ScriptOps.FireTraces(
                                                            variable, traceInfo.BreakpointType, this, traceInfo,
                                                            ref value, ref error) != ReturnCode.Ok)
                                                    {
                                                        return ReturnCode.Error;
                                                    }
                                                }
                                                catch (Exception e)
                                                {
                                                    error = String.Format(
                                                        "caught exception while firing variable traces: {0}",
                                                        e);

                                                    return ReturnCode.Error;
                                                }
                                            }

#if NOTIFY
                                            if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                                !EntityOps.IsNoNotify(variable))
                                            {
                                                /* IGNORED */
                                                CheckNotification(
                                                    NotifyType.Variable, NotifyFlags.Trace,
                                                    new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                                    this, null, null, null, ref error);
                                            }
#endif

                                            //
                                            // NOTE: If the trace(s) did not cancel the operation, proceed.
                                            //
                                            if (!traceInfo.Cancel)
                                            {
                                                //
                                                // NOTE: Check for post-processing of the variable value.
                                                //
                                                if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonPostProcess, false) &&
                                                    traceInfo.PostProcess && !HasNoPostProcess())
                                                {
                                                    try
                                                    {
                                                        if (PostProcessVariableValue(
                                                                traceInfo.Flags, name, traceInfo.Index, variable,
                                                                traceInfo.OldValue, ref value, ref error) != ReturnCode.Ok)
                                                        {
                                                            return ReturnCode.Error;
                                                        }
                                                    }
                                                    catch (Exception e)
                                                    {
                                                        error = String.Format(
                                                            "caught exception while post-processing variable value: {0}",
                                                            e);

                                                        return ReturnCode.Error;
                                                    }
                                                }
                                                else
                                                {
                                                    if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.SkipToString, true))
                                                    {
                                                        try
                                                        {
                                                            value = StringOps.GetResultFromObject(traceInfo.OldValue);
                                                        }
                                                        catch (Exception e)
                                                        {
                                                            error = String.Format(
                                                                "caught exception while converting variable value to string: {0}",
                                                                e);

                                                            return ReturnCode.Error;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        value = Result.FromObject(
                                                            traceInfo.OldValue, false, false, FlagOps.HasFlags(
                                                            traceInfo.Flags, VariableFlags.FallbackToString, true));
                                                    }
                                                }
                                            }

                                            return traceInfo.ReturnCode;
                                        }
                                    }

                                    traceInfo = ScriptOps.NewTraceInfo(
                                        this, null, BreakpointType.BeforeVariableGet, savedFrame,
                                        variable, name, index, flags, null, null, null, null,
                                        null, NeedNewTraceInfo(flags), false,
                                        !EntityOps.IsNoPostProcess(variable), ReturnCode.Error);

#if DEBUGGER && DEBUGGER_VARIABLE
                                    if (CanHitWatchpoints(traceInfo.BreakpointType) &&
                                        EntityOps.IsBreakOnGet(variable))
                                    {
                                        //
                                        // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                        //       get access for this variable.
                                        //
                                        Result localResult = null;

                                        if (CheckWatchpoints(
                                                ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                                traceInfo, ref localResult) != ReturnCode.Ok)
                                        {
                                            error = localResult;
                                            return ReturnCode.Error;
                                        }
                                    }
#endif

                                    if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                        !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                        !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                                    {
                                        try
                                        {
                                            if (ScriptOps.FireTraces(
                                                    variable, traceInfo.BreakpointType, this, traceInfo,
                                                    ref value, ref error) != ReturnCode.Ok)
                                            {
                                                return ReturnCode.Error;
                                            }
                                        }
                                        catch (Exception e)
                                        {
                                            error = String.Format(
                                                "caught exception while firing variable traces: {0}",
                                                e);

                                            return ReturnCode.Error;
                                        }
                                    }

#if NOTIFY
                                    if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                        !EntityOps.IsNoNotify(variable))
                                    {
                                        /* IGNORED */
                                        CheckNotification(
                                            NotifyType.Variable, NotifyFlags.Trace,
                                            new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                            this, null, null, null, ref error);
                                    }
#endif

                                    //
                                    // NOTE: If the trace(s) did not cancel the operation, proceed
                                    //       with producing an appropriate error message.  Otherwise,
                                    //       if a trace callback canceled the operation with a
                                    //       successful return code (i.e. not the original error
                                    //       return code) then post-process the variable value (if
                                    //       required) and return.
                                    //
                                    if (traceInfo.Cancel)
                                    {
                                        if (traceInfo.ReturnCode == ReturnCode.Ok)
                                        {
                                            //
                                            // NOTE: Check for post-processing of the variable value.
                                            //
                                            if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonPostProcess, false) &&
                                                traceInfo.PostProcess && !HasNoPostProcess())
                                            {
                                                try
                                                {
                                                    if (PostProcessVariableValue(
                                                            traceInfo.Flags, name, traceInfo.Index, variable,
                                                            traceInfo.OldValue, ref value, ref error) != ReturnCode.Ok)
                                                    {
                                                        return ReturnCode.Error;
                                                    }
                                                }
                                                catch (Exception e)
                                                {
                                                    error = String.Format(
                                                        "caught exception while post-processing variable value: {0}",
                                                        e);

                                                    return ReturnCode.Error;
                                                }
                                            }
                                            else
                                            {
                                                if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.SkipToString, true))
                                                {
                                                    try
                                                    {
                                                        value = StringOps.GetResultFromObject(traceInfo.OldValue);
                                                    }
                                                    catch (Exception e)
                                                    {
                                                        error = String.Format(
                                                            "caught exception while converting variable value to string: {0}",
                                                            e);

                                                        return ReturnCode.Error;
                                                    }
                                                }
                                                else
                                                {
                                                    value = Result.FromObject(
                                                        traceInfo.OldValue, false, false, FlagOps.HasFlags(
                                                        traceInfo.Flags, VariableFlags.FallbackToString, true));
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (FlagOps.HasFlags(flags, VariableFlags.NoComplain, true))
                                        {
                                            value = null;
                                            return ReturnCode.Ok;
                                        }
                                        else
                                        {
                                            error = String.Format(
                                                "can't read {0}: no such element in array",
                                                FormatOps.ErrorVariableName(
                                                    variable, linkIndex, name, traceInfo.Index));
                                        }
                                    }

                                    return traceInfo.ReturnCode;
                                }
                                else
                                {
                                    error = String.Format(
                                        "can't read {0}: variable is write-only",
                                        FormatOps.ErrorVariableName(
                                            variable, linkIndex, name, index));
                                }
                            }
                            else
                            {
                                if (FlagOps.HasFlags(flags, VariableFlags.NoComplain, true))
                                {
                                    value = null;
                                    return ReturnCode.Ok;
                                }
                                else
                                {
                                    error = String.Format(
                                        "can't read {0}: variable isn't array",
                                        FormatOps.ErrorVariableName(
                                            variable, linkIndex, name, index));
                                }
                            }
                        }
                        else
                        {
                            if (!EntityOps.IsArray2(variable))
                            {
                                if (!EntityOps.IsWriteOnly(variable))
                                {
                                    object oldValue = (variable.Value != null) ?
                                        variable.Value : ScriptOps.GetDefaultValue(
                                            BreakpointType.BeforeVariableGet);

                                    ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                                        this, null, BreakpointType.BeforeVariableGet, savedFrame,
                                        variable, name, index, flags, oldValue, null, null,
                                        null, null, NeedNewTraceInfo(flags), false,
                                        !EntityOps.IsNoPostProcess(variable), ReturnCode.Ok);

#if DEBUGGER && DEBUGGER_VARIABLE
                                    if (!FlagOps.HasFlags(traceInfo.Flags,
                                            VariableFlags.NonWatchpoint, false) &&
                                        CanHitWatchpoints(traceInfo.BreakpointType) &&
                                        !EntityOps.IsNoWatchpoint(variable) &&
                                        EntityOps.IsBreakOnGet(variable))
                                    {
                                        //
                                        // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                        //       get access for this variable.
                                        //
                                        Result localResult = null;

                                        if (CheckWatchpoints(
                                                ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                                traceInfo, ref localResult) != ReturnCode.Ok)
                                        {
                                            error = localResult;
                                            return ReturnCode.Error;
                                        }
                                    }
#endif

                                    if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                        !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                        !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                                    {
                                        try
                                        {
                                            if (ScriptOps.FireTraces(
                                                    variable, traceInfo.BreakpointType, this, traceInfo,
                                                    ref value, ref error) != ReturnCode.Ok)
                                            {
                                                return ReturnCode.Error;
                                            }
                                        }
                                        catch (Exception e)
                                        {
                                            error = String.Format(
                                                "caught exception while firing variable traces: {0}",
                                                e);

                                            return ReturnCode.Error;
                                        }
                                    }

#if NOTIFY
                                    if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                        !EntityOps.IsNoNotify(variable))
                                    {
                                        /* IGNORED */
                                        CheckNotification(
                                            NotifyType.Variable, NotifyFlags.Trace,
                                            new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                            this, null, null, null, ref error);
                                    }
#endif

                                    //
                                    // NOTE: If the trace(s) did not cancel the operation, proceed.
                                    //
                                    if (!traceInfo.Cancel)
                                    {
                                        //
                                        // NOTE: Check for post-processing of the variable value.
                                        //
                                        if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonPostProcess, false) &&
                                            traceInfo.PostProcess && !HasNoPostProcess())
                                        {
                                            try
                                            {
                                                if (PostProcessVariableValue(
                                                        traceInfo.Flags, name, traceInfo.Index, variable,
                                                        traceInfo.OldValue, ref value, ref error) != ReturnCode.Ok)
                                                {
                                                    return ReturnCode.Error;
                                                }
                                            }
                                            catch (Exception e)
                                            {
                                                error = String.Format(
                                                    "caught exception while post-processing variable value: {0}",
                                                    e);

                                                return ReturnCode.Error;
                                            }
                                        }
                                        else
                                        {
                                            if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.SkipToString, true))
                                            {
                                                try
                                                {
                                                    value = StringOps.GetResultFromObject(traceInfo.OldValue);
                                                }
                                                catch (Exception e)
                                                {
                                                    error = String.Format(
                                                        "caught exception while converting variable value to string: {0}",
                                                        e);

                                                    return ReturnCode.Error;
                                                }
                                            }
                                            else
                                            {
                                                value = Result.FromObject(
                                                    traceInfo.OldValue, false, false, FlagOps.HasFlags(
                                                    traceInfo.Flags, VariableFlags.FallbackToString, true));
                                            }
                                        }
                                    }

                                    return traceInfo.ReturnCode;
                                }
                                else
                                {
                                    error = String.Format(
                                        "can't read {0}: variable is write-only",
                                        FormatOps.ErrorVariableName(name));
                                }
                            }
                            else
                            {
                                if (FlagOps.HasFlags(flags, VariableFlags.NoComplain, true))
                                {
                                    value = null;
                                    return ReturnCode.Ok;
                                }
                                else
                                {
                                    error = String.Format(
                                        "can't read {0}: variable is array",
                                        FormatOps.ErrorVariableName(name));
                                }
                            }
                        }
                    }
                    else
                    {
                        if (!EntityOps.IsWriteOnly(variable))
                        {
                            ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                                this, null, BreakpointType.BeforeVariableGet, savedFrame,
                                variable, name, index, flags, null, null, null,
                                null, null, NeedNewTraceInfo(flags), false,
                                !EntityOps.IsNoPostProcess(variable), ReturnCode.Error);

#if DEBUGGER && DEBUGGER_VARIABLE
                            if (!FlagOps.HasFlags(traceInfo.Flags,
                                    VariableFlags.NonWatchpoint, false) &&
                                CanHitWatchpoints(traceInfo.BreakpointType) &&
                                !EntityOps.IsNoWatchpoint(variable) &&
                                EntityOps.IsBreakOnGet(variable))
                            {
                                //
                                // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                //       get access for this variable.
                                //
                                Result localResult = null;

                                if (CheckWatchpoints(
                                        ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                        traceInfo, ref localResult) != ReturnCode.Ok)
                                {
                                    error = localResult;
                                    return ReturnCode.Error;
                                }
                            }
#endif

                            if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                            {
                                try
                                {
                                    if (ScriptOps.FireTraces(
                                            variable, traceInfo.BreakpointType, this, traceInfo,
                                            ref value, ref error) != ReturnCode.Ok)
                                    {
                                        return ReturnCode.Error;
                                    }
                                }
                                catch (Exception e)
                                {
                                    error = String.Format(
                                        "caught exception while firing variable traces: {0}",
                                        e);

                                    return ReturnCode.Error;
                                }
                            }

#if NOTIFY
                            if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                !EntityOps.IsNoNotify(variable))
                            {
                                /* IGNORED */
                                CheckNotification(
                                    NotifyType.Variable, NotifyFlags.Trace,
                                    new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                    this, null, null, null, ref error);
                            }
#endif

                            //
                            // NOTE: If the trace(s) did not cancel the operation, proceed
                            //       with producing an appropriate error message.  Otherwise,
                            //       if a trace callback canceled the operation with a
                            //       successful return code (i.e. not the original error
                            //       return code) then post-process the variable value (if
                            //       required) and return.
                            //
                            if (traceInfo.Cancel)
                            {
                                if (traceInfo.ReturnCode == ReturnCode.Ok)
                                {
                                    //
                                    // NOTE: Check for post-processing of the variable value.
                                    //
                                    if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonPostProcess, false) &&
                                        traceInfo.PostProcess && !HasNoPostProcess())
                                    {
                                        try
                                        {
                                            if (PostProcessVariableValue(
                                                    traceInfo.Flags, name, traceInfo.Index, variable,
                                                    traceInfo.OldValue, ref value, ref error) != ReturnCode.Ok)
                                            {
                                                return ReturnCode.Error;
                                            }
                                        }
                                        catch (Exception e)
                                        {
                                            error = String.Format(
                                                "caught exception while post-processing variable value: {0}",
                                                e);

                                            return ReturnCode.Error;
                                        }
                                    }
                                    else
                                    {
                                        if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.SkipToString, true))
                                        {
                                            try
                                            {
                                                value = StringOps.GetResultFromObject(traceInfo.OldValue);
                                            }
                                            catch (Exception e)
                                            {
                                                error = String.Format(
                                                    "caught exception while converting variable value to string: {0}",
                                                    e);

                                                return ReturnCode.Error;
                                            }
                                        }
                                        else
                                        {
                                            value = Result.FromObject(
                                                traceInfo.OldValue, false, false, FlagOps.HasFlags(
                                                traceInfo.Flags, VariableFlags.FallbackToString, true));
                                        }
                                    }
                                }
                            }
                            else
                            {
                                //
                                // BUGFIX: When the variable traces, if any, do not cancel
                                //         the operation entirely, honor the NoComplain flag.
                                //
                                if (FlagOps.HasFlags(
                                        traceInfo.Flags, VariableFlags.NoComplain, true))
                                {
                                    value = null;
                                    return ReturnCode.Ok;
                                }

                                error = String.Format(
                                    "can't read {0}: no such variable",
                                    FormatOps.ErrorVariableName(
                                        variable, linkIndex, name, traceInfo.Index));
                            }

                            return traceInfo.ReturnCode;
                        }
                        else
                        {
                            error = String.Format(
                                "can't read {0}: variable is write-only",
                                FormatOps.ErrorVariableName(name));
                        }
                    }
                }
                else
                {
                    if (FlagOps.HasFlags(flags, VariableFlags.NotFound, true))
                    {
                        if (FlagOps.HasFlags(flags, VariableFlags.NoComplain, true))
                        {
                            value = null;
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            error = String.Format(
                                "can't read {0}: no such variable",
                                FormatOps.ErrorVariableName(
                                    variable, null, name, index));
                        }
                    }
                    else
                    {
                        if (FlagOps.HasFlags(flags, VariableFlags.NoComplain, true))
                        {
                            value = null;
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            //
                            // NOTE: We did not actually search for the variable,
                            //       inform the caller as to why.
                            //
                            error = localError;
                        }
                    }
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddLibraryVariable(
            VariableFlags flags,
            string name,
            TraceList traces,
            bool errorOnExist,
            ref Result error
            )
        {
            flags |= VariableFlags.Library;
            return AddVariable(flags, name, traces, errorOnExist, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddVariable2(
            VariableFlags flags,
            string name,
            TraceList traces,
            bool errorOnExist,
            ref IVariable variable,
            ref Result error
            )
        {
            return AddVariable2(flags, null, name, traces, errorOnExist, ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddVariable2( /* PRIMARY */
            VariableFlags flags,
            ICallFrame frame,
            string name,
            TraceList traces,
            bool errorOnExist,
            ref IVariable variable,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                flags |= addVariableFlags;

                if (!readOnly || FlagOps.HasFlags(flags, VariableFlags.ReadOnlyMask, false))
                {
                    bool badRequest = false;
                    Result localError = null;

                    if (DoesVariableExist(flags, frame, name, ref badRequest, ref localError) != ReturnCode.Ok)
                    {
                        if (!badRequest)
                        {
                            ICallFrame variableFrame = frame;
                            string newName = name;

                            if (GetVariableFrameViaResolvers(
                                    LookupFlags.Default, ref variableFrame, ref newName,
                                    ref flags, ref error) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }

                            if (variableFrame == null)
                            {
                                error = "invalid call frame from resolver";
                                return ReturnCode.Error;
                            }

                            bool isGlobalCallFrame = IsGlobalCallFrame(variableFrame);

                            variable = new Variable(variableFrame, newName,
                                (flags & ~VariableFlags.NonAddMask) |
                                CallFrameOps.GetNewVariableFlags(variableFrame) |
                                GetNewVariableFlags(isGlobalCallFrame), null,
                                GetTraces(traces, newName, null, null, null),
                                variableEvent);

                            MaybeSetQualifiedName(variable);

                            if (isGlobalCallFrame)
                                EntityOps.SetGlobal(variable, true);
                            else
                                EntityOps.SetLocal(variable, true);

                            ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                                this, null, BreakpointType.BeforeVariableAdd, variableFrame,
                                variable, name, null, flags, null, null, null,
                                null, null, NeedNewTraceInfo(flags), false,
                                !EntityOps.IsNoPostProcess(variable), ReturnCode.Ok);

#if DEBUGGER && DEBUGGER_VARIABLE
                            if (!FlagOps.HasFlags(traceInfo.Flags,
                                    VariableFlags.NonWatchpoint, false) &&
                                CanHitWatchpoints(traceInfo.BreakpointType) &&
                                !EntityOps.IsNoWatchpoint(variable) &&
                                EntityOps.IsBreakOnSet(variable))
                            {
                                //
                                // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                //       set access for this variable.
                                //
                                Result localResult = null;

                                if (CheckWatchpoints(
                                        ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                        traceInfo, ref localResult) != ReturnCode.Ok)
                                {
                                    error = localResult;
                                    return ReturnCode.Error;
                                }
                            }
#endif

                            if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                            {
                                try
                                {
                                    if (ScriptOps.FireTraces(
                                            variable, traceInfo.BreakpointType, this, traceInfo,
                                            ref error) != ReturnCode.Ok)
                                    {
                                        return ReturnCode.Error;
                                    }
                                }
                                catch (Exception e)
                                {
                                    error = String.Format(
                                        "caught exception while firing variable traces: {0}",
                                        e);

                                    return ReturnCode.Error;
                                }
                            }

#if NOTIFY
                            if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                !EntityOps.IsNoNotify(variable))
                            {
                                /* IGNORED */
                                CheckNotification(
                                    NotifyType.Variable, NotifyFlags.Trace,
                                    new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                    this, null, null, null, ref error);
                            }
#endif

                            //
                            // NOTE: If the trace(s) did not cancel the operation, proceed.
                            //
                            if (!traceInfo.Cancel)
                            {
                                //
                                // BUGFIX: If the variable name exists in the call frame at
                                //         this point it is most likely a zombie (i.e.
                                //         undefined); therefore, replace it if necessary.
                                //
                                VariableDictionary variables = variableFrame.Variables;

                                if (variables == null)
                                {
                                    error = String.Format(
                                        "can't add {0}: call frame does not support variables",
                                        FormatOps.ErrorVariableName(name));

                                    return ReturnCode.Error;
                                }

                                //
                                // NOTE: If there is a variable limit, make sure that there
                                //       is still room for one more variable.  In this case,
                                //       we do not bother checking if the variable was already
                                //       present in the call frame because this is a logical
                                //       "add" operation (i.e. not a "set" operation).
                                //
                                if ((variableLimit != 0) &&
                                    (variables.Count >= variableLimit) &&
                                    (variables.GetDefinedCount() >= variableLimit))
                                {
                                    error = String.Format(
                                        "can't add {0}: variable limit exceeded",
                                        FormatOps.ErrorVariableName(name));

                                    return ReturnCode.Error;
                                }

                                //
                                // NOTE: All arrays (even virtual ones) must have a valid
                                //       dictionary for their elements.
                                //
                                if (EntityOps.IsArray2(variable))
                                {
                                    variable.Value = null;
                                    variable.ArrayValue = new ElementDictionary(variableEvent);
                                }

                                //
                                // NOTE: Add or replace variable in current call frame.
                                //
                                variables[newName] = variable;

                                //
                                // BUGFIX: Mark the variable as "dirty" AFTER the
                                //         actual modifications have been completed.
                                //
                                EntityOps.SetDirty(variable, true);
                            }

                            return traceInfo.ReturnCode;
                        }
                        else
                        {
                            error = localError;
                        }
                    }
                    else if (errorOnExist)
                    {
                        error = String.Format(
                            "can't add {0}: variable already exists",
                            FormatOps.ErrorVariableName(name));
                    }
                    else
                    {
                        //
                        // NOTE: Variable already exists (non-strict) mode.
                        //
                        return ReturnCode.Ok;
                    }
                }
                else
                {
                    error = String.Format(
                        "can't add {0}: interpreter is read-only",
                        FormatOps.ErrorVariableName(name));
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode ResetVariable2( /* PRIMARY */
            VariableFlags flags,
            ICallFrame frame,
            string name,
            string index,
            IVariable variable,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                flags |= resetVariableFlags;

                if (immutable && !FlagOps.HasFlags(flags, VariableFlags.ImmutableMask, false))
                {
                    error = String.Format(
                        "can't reset {0}: interpreter is immutable",
                        FormatOps.ErrorVariableName(name, index));

                    return ReturnCode.Error;
                }

                if (!readOnly || FlagOps.HasFlags(flags, VariableFlags.ReadOnlyMask, false))
                {
                    //
                    // BUGBUG: This may need revision; we do need some way to remove
                    //         "stale" undefined variables from the call frame even
                    //         though the only way to officially create one is via the
                    //         global or upvar commands and those get cleaned up
                    //         automatically upon procedure exit.
                    //
                    bool haveVariable = (variable != null);
                    Result localError = null;

                    if ((haveVariable ||
                        (GetVariableViaResolversWithSplit(frame, name, index, ref flags,
                            ref variable, ref localError) == ReturnCode.Ok)) &&
                        !EntityOps.IsUndefined(variable, "reset", name, index,
                            ref localError))
                    {
                        //
                        // COMPAT: Tcl, if the index was specified, make sure the name
                        //         itself does not contain an array element reference.
                        //
                        if (haveVariable || (index == null))
                        {
                            VariableFlags splitFlags = flags;
                            string splitIndex = null;

                            if (index != null)
                                splitFlags |= VariableFlags.NoElement;

                            if (ScriptOps.SplitVariableName(
                                    this, splitFlags, name, ref name,
                                    ref splitIndex, ref error) == ReturnCode.Ok)
                            {
                                if ((index == null) && (splitIndex != null))
                                    index = splitIndex;
                            }
                            else
                            {
                                return ReturnCode.Error;
                            }
                        }

                        //
                        // NOTE: Make sure we have a variable.
                        //
                        if (variable == null)
                        {
                            error = String.Format(
                                "can't reset {0}: variable is invalid",
                                FormatOps.ErrorVariableName(name, index));

                            return ReturnCode.Error;
                        }

                        //
                        // NOTE: For linked variables, we may be linking to an array
                        //       element.
                        //
                        string linkIndex = null;

                        //
                        // NOTE: Save original call frame for traces.
                        //
                        ICallFrame savedFrame = variable.Frame;

                        //
                        // NOTE: Is the variable really a link to another variable?
                        //
                        if (EntityOps.IsLink(variable))
                        {
                            //
                            // NOTE: Get the array element index of the link, if any.
                            //
                            linkIndex = variable.LinkIndex;

                            //
                            // NOTE: Follow the linked variable.
                            //
                            variable = EntityOps.FollowLinks(variable, flags, ref error);

                            if (variable == null)
                                return ReturnCode.Error;
                        }

                        if ((index != null) || (linkIndex != null))
                        {
                            if (EntityOps.IsArray2(variable) &&
                                    ((index == null) || (linkIndex == null)))
                            {
                                //
                                // NOTE: If there was no element index specified, use
                                //       the one from the variable link.
                                //
                                if (index == null)
                                    index = linkIndex;

                                if (!EntityOps.IsReadOnly(variable) && !EntityOps.IsInvariant(variable))
                                {
                                    ElementDictionary arrayValue = variable.ArrayValue;

                                    if ((arrayValue != null) && arrayValue.ContainsKey(index))
                                    {
                                        object oldValue = EntityOps.GetOldValue(
                                            flags, variable, index, ScriptOps.GetDefaultValue(
                                                BreakpointType.BeforeVariableSet));

                                        object newValue = EntityOps.GetNewValue(
                                            flags, oldValue, null);

                                        ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                                            this, null, BreakpointType.BeforeVariableReset, savedFrame,
                                            variable, name, index, flags, oldValue, newValue, null,
                                            null, null, NeedNewTraceInfo(flags), false,
                                            !EntityOps.IsNoPostProcess(variable), ReturnCode.Ok);

#if DEBUGGER && DEBUGGER_VARIABLE
                                        if (!FlagOps.HasFlags(traceInfo.Flags,
                                                VariableFlags.NonWatchpoint, false) &&
                                            CanHitWatchpoints(traceInfo.BreakpointType) &&
                                            !EntityOps.IsNoWatchpoint(variable) &&
                                            EntityOps.IsBreakOnSet(variable))
                                        {
                                            //
                                            // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                            //       set access for this variable.
                                            //
                                            Result localResult = null;

                                            if (CheckWatchpoints(
                                                    ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                                    traceInfo, ref localResult) != ReturnCode.Ok)
                                            {
                                                error = localResult;
                                                return ReturnCode.Error;
                                            }
                                        }
#endif

                                        if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                            !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                            !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                                        {
                                            try
                                            {
                                                if (ScriptOps.FireTraces(
                                                        variable, traceInfo.BreakpointType, this, traceInfo,
                                                        ref error) != ReturnCode.Ok)
                                                {
                                                    return ReturnCode.Error;
                                                }
                                            }
                                            catch (Exception e)
                                            {
                                                error = String.Format(
                                                    "caught exception while firing variable traces: {0}",
                                                    e);

                                                return ReturnCode.Error;
                                            }
                                        }

#if NOTIFY
                                        if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                            !EntityOps.IsNoNotify(variable))
                                        {
                                            /* IGNORED */
                                            CheckNotification(
                                                NotifyType.Variable, NotifyFlags.Trace,
                                                new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                                this, null, null, null, ref error);
                                        }
#endif

                                        //
                                        // NOTE: If the trace(s) did not cancel the operation, proceed.
                                        //
                                        if (!traceInfo.Cancel)
                                        {
                                            arrayValue = variable.ArrayValue; /* REFRESH */

                                            if (arrayValue != null)
                                            {
                                                arrayValue[index] = traceInfo.NewValue;

                                                //
                                                // BUGFIX: Mark the variable as "dirty" AFTER the
                                                //         actual modifications have been completed.
                                                //
                                                EntityOps.SignalDirty(variable, index);
                                            }
                                            else
                                            {
                                                error = String.Format(
                                                    "can't reset {0}: no longer an array",
                                                    FormatOps.ErrorVariableName(
                                                        variable, linkIndex, name, index));

                                                return ReturnCode.Error;
                                            }
                                        }

                                        return traceInfo.ReturnCode;
                                    }
                                    else
                                    {
                                        ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                                            this, null, BreakpointType.BeforeVariableReset, savedFrame,
                                            variable, name, index, flags, null, null, null, null,
                                            null, NeedNewTraceInfo(flags), false,
                                            !EntityOps.IsNoPostProcess(variable), ReturnCode.Error);

#if DEBUGGER && DEBUGGER_VARIABLE
                                        if (!FlagOps.HasFlags(traceInfo.Flags,
                                                VariableFlags.NonWatchpoint, false) &&
                                            CanHitWatchpoints(traceInfo.BreakpointType) &&
                                            !EntityOps.IsNoWatchpoint(variable) &&
                                            EntityOps.IsBreakOnSet(variable))
                                        {
                                            //
                                            // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                            //       unset access for this variable.
                                            //
                                            Result localResult = null;

                                            if (CheckWatchpoints(
                                                    ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                                    traceInfo, ref localResult) != ReturnCode.Ok)
                                            {
                                                error = localResult;
                                                return ReturnCode.Error;
                                            }
                                        }
#endif

                                        if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                            !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                            !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                                        {
                                            try
                                            {
                                                if (ScriptOps.FireTraces(
                                                        variable, traceInfo.BreakpointType, this, traceInfo,
                                                        ref error) != ReturnCode.Ok)
                                                {
                                                    return ReturnCode.Error;
                                                }
                                            }
                                            catch (Exception e)
                                            {
                                                error = String.Format(
                                                    "caught exception while firing variable traces: {0}",
                                                    e);

                                                return ReturnCode.Error;
                                            }
                                        }

#if NOTIFY
                                        if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                            !EntityOps.IsNoNotify(variable))
                                        {
                                            /* IGNORED */
                                            CheckNotification(
                                                NotifyType.Variable, NotifyFlags.Trace,
                                                new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                                this, null, null, null, ref error);
                                        }
#endif

                                        //
                                        // NOTE: If the trace(s) did not cancel the operation, proceed.
                                        //
                                        if (!traceInfo.Cancel)
                                        {
                                            error = String.Format(
                                                "can't reset {0}: no such element in array",
                                                FormatOps.ErrorVariableName(
                                                    variable, linkIndex, name, index));
                                        }

                                        return traceInfo.ReturnCode;
                                    }
                                }
                                else
                                {
                                    error = String.Format(
                                        "can't reset {0}: variable is read-only",
                                        FormatOps.ErrorVariableName(
                                            variable, linkIndex, name, index));
                                }
                            }
                            else
                            {
                                error = String.Format(
                                    "can't reset {0}: variable isn't array",
                                    FormatOps.ErrorVariableName(
                                        variable, linkIndex, name, index));
                            }
                        }
                        else
                        {
                            if (!EntityOps.IsReadOnly(variable) && !EntityOps.IsInvariant(variable))
                            {
                                object oldValue = EntityOps.GetOldValue(
                                    flags, variable, index, ScriptOps.GetDefaultValue(
                                        BreakpointType.BeforeVariableSet));

                                object newValue = EntityOps.GetNewValue(
                                    flags, oldValue, null);

                                ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                                    this, null, BreakpointType.BeforeVariableReset, savedFrame,
                                    variable, name, index, flags, oldValue, newValue, null,
                                    null, null, NeedNewTraceInfo(flags), false,
                                    !EntityOps.IsNoPostProcess(variable), ReturnCode.Ok);

#if DEBUGGER && DEBUGGER_VARIABLE
                                if (!FlagOps.HasFlags(traceInfo.Flags,
                                        VariableFlags.NonWatchpoint, false) &&
                                    CanHitWatchpoints(traceInfo.BreakpointType) &&
                                    !EntityOps.IsNoWatchpoint(variable) &&
                                    EntityOps.IsBreakOnSet(variable))
                                {
                                    //
                                    // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                    //       set access for this variable.
                                    //
                                    Result localResult = null;

                                    if (CheckWatchpoints(
                                            ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                            traceInfo, ref localResult) != ReturnCode.Ok)
                                    {
                                        error = localResult;
                                        return ReturnCode.Error;
                                    }
                                }
#endif

                                if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                    !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                    !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                                {
                                    try
                                    {
                                        if (ScriptOps.FireTraces(
                                                variable, traceInfo.BreakpointType, this, traceInfo,
                                                ref error) != ReturnCode.Ok)
                                        {
                                            return ReturnCode.Error;
                                        }
                                    }
                                    catch (Exception e)
                                    {
                                        error = String.Format(
                                            "caught exception while firing variable traces: {0}",
                                            e);

                                        return ReturnCode.Error;
                                    }
                                }

#if NOTIFY
                                if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                    !EntityOps.IsNoNotify(variable))
                                {
                                    /* IGNORED */
                                    CheckNotification(
                                        NotifyType.Variable, NotifyFlags.Trace,
                                        new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                        this, null, null, null, ref error);
                                }
#endif

                                //
                                // NOTE: If the trace(s) did not cancel the operation, proceed.
                                //
                                if (!traceInfo.Cancel)
                                {
                                    //
                                    // NOTE: Did the trace(s) change the variable into an array?
                                    //
                                    if (EntityOps.IsArray2(variable))
                                    {
                                        //
                                        // NOTE: Allocate space for the array name/values now.
                                        //
                                        variable.Value = null;
                                        variable.ArrayValue = new ElementDictionary(variableEvent);
                                    }
                                    //
                                    // NOTE: If the trace(s) changed the variable to be a link, we do
                                    //       not bother doing anything else to it (i.e. we assume it
                                    //       points where they want it to point).
                                    //
                                    else if (!EntityOps.IsLink(variable))
                                    {
                                        //
                                        // NOTE: Set the value to the output of the trace(s).
                                        //
                                        variable.Value = traceInfo.NewValue;
                                    }

                                    //
                                    // BUGFIX: Mark the variable as "dirty" AFTER the
                                    //         actual modifications have been completed.
                                    //
                                    EntityOps.SignalDirty(variable, null);
                                }

                                return traceInfo.ReturnCode;
                            }
                            else
                            {
                                error = String.Format(
                                    "can't reset {0}: variable is read-only",
                                    FormatOps.ErrorVariableName(
                                        variable, linkIndex, name, null));
                            }
                        }
                    }
                    else
                    {
                        if (FlagOps.HasFlags(flags, VariableFlags.NotFound, true))
                        {
                            if (FlagOps.HasFlags(flags, VariableFlags.NoComplain, true))
                            {
                                return ReturnCode.Ok;
                            }
                            else
                            {
                                error = String.Format(
                                    "can't reset {0}: no such variable",
                                    FormatOps.ErrorVariableName(
                                        variable, null, name, index));
                            }
                        }
                        else
                        {
                            if (FlagOps.HasFlags(flags, VariableFlags.NoComplain, true))
                            {
                                return ReturnCode.Ok;
                            }
                            else
                            {
                                //
                                // NOTE: We did not actually search for the variable,
                                //       inform the caller as to why.
                                //
                                error = localError;
                            }
                        }
                    }
                }
                else
                {
                    error = String.Format(
                        "can't reset {0}: interpreter is read-only",
                        FormatOps.ErrorVariableName(name, index));
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ResetExistingVariable(
            VariableFlags flags,
            string name,
            ref Result error
            )
        {
            bool badRequest = false;
            Result localError; /* REUSED */

            //
            // NOTE: Check if the variable exists; if
            //       not, do nothing.  If the name is
            //       invalid, return overall failure;
            //       otherwise, return total success.
            //
            localError = null;

            if (DoesVariableExist(
                    flags, null, name, ref badRequest,
                    ref localError) != ReturnCode.Ok)
            {
                //
                // NOTE: The variable does not exist;
                //       check if the name itself was
                //       bad.
                //
                if (badRequest)
                {
                    error = localError;
                    return ReturnCode.Error;
                }

                return ReturnCode.Ok;
            }

            //
            // NOTE: The variable already exists; try
            //       to reset its value now.  Failing
            //       that, return an overall failure.
            //
            localError = null;

            if (ResetVariable(flags, name,
                    ref localError) != ReturnCode.Ok)
            {
                error = localError;
                return ReturnCode.Error;
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetVariableEnumerable2(
            VariableFlags flags,
            ICallFrame frame,
            string name,
            string index,
            IEnumerable collection,
            bool autoReset,
            ref IVariable variable,
            ref Result error
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                IMutableAnyTriplet<IEnumerable, IEnumerator, bool> anyTriplet =
                    new MutableAnyTriplet<IEnumerable, IEnumerator, bool>(
                        true, collection, null, autoReset);

                if (SetVariableValue2(
                        flags, frame, name, index, anyTriplet,
                        enumerableVariableTraceList, ref variable,
                        ref error) == ReturnCode.Ok)
                {
                    if (HasEnumerableVariableTraceCallback(variable))
                    {
                        return ReturnCode.Ok;
                    }
                    else
                    {
                        error = String.Format(
                            "can't enumerate {0}: could not set variable trace",
                            FormatOps.ErrorVariableName(
                                variable, null, name, index));
                    }
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetVariableLink2(
            VariableFlags flags,
            ICallFrame frame,
            string name,
            string index,
            MemberInfo memberInfo,
            object @object,
            ref IVariable variable,
            ref Result error
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                IAnyPair<MemberInfo, object> anyPair =
                    new AnyPair<MemberInfo, object>(memberInfo, @object);

                if (SetVariableValue2(
                        flags, frame, name, index, anyPair,
                        linkedVariableTraceList, ref variable,
                        ref error) == ReturnCode.Ok)
                {
                    if (HasLinkedVariableTraceCallback(variable))
                    {
                        return ReturnCode.Ok;
                    }
                    else
                    {
                        error = String.Format(
                            "can't link {0}: could not set variable trace",
                            FormatOps.ErrorVariableName(
                                variable, null, name, index));
                    }
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetVariableSystemArray2(
            VariableFlags flags,
            ICallFrame frame,
            string name,
            Array array,
            ref IVariable variable,
            ref Result error
            )
        {
            // CheckDisposed();

            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // HACK: Make use of the configured "extra" variable flags
                //       for this operation.
                //
                flags |= systemArrayVariableFlags;

                //
                // NOTE: This code assumes the systemArrayTraceList field
                //       cannot be null.
                //
                TraceList traces = systemArrayTraceList;

                if (GetVariableViaResolversWithSplit(
                        frame, name, null, ref flags,
                        ref variable, ref error) == ReturnCode.Ok)
                {
                    if ((traces != null) &&
                        (variable.AddTraces(traces) == traces.Count) &&
                        HasSystemArrayTraceCallback(variable))
                    {
                        variable.SetupValue(array, false, true, true, true);
                        return ReturnCode.Ok;
                    }
                    else
                    {
                        error = String.Format(
                            "can't link {0}: could not set variable array",
                            FormatOps.ErrorVariableName(
                                variable, null, name, null));
                    }

                    return ReturnCode.Error;
                }
                else
                {
                    if (SetVariableValue2(
                            flags, frame, name, null, array, traces,
                            ref variable, ref error) == ReturnCode.Ok)
                    {
                        if (HasSystemArrayTraceCallback(variable))
                        {
                            variable.SetupValue(null, false, true, true, true);
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            error = String.Format(
                                "can't link {0}: could not set variable array",
                                FormatOps.ErrorVariableName(
                                    variable, null, name, null));
                        }
                    }

                    return ReturnCode.Error;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the PopulateOperatingSystemExtra method only.
        //
        internal ReturnCode SetOperatingSystemExtra(
            string value,
            ref Result error
            )
        {
            return SetLibraryVariableValue2(
                VariableFlags.None, TclVars.Platform.Name,
                TclVars.Platform.OsExtra, value, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetLibraryVariableValue(
            VariableFlags flags,
            string name,
            string value
            )
        {
            Result error = null;

            return SetLibraryVariableValue(flags, name, value, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetLibraryVariableValue(
            VariableFlags flags,
            string name,
            string value,
            TraceList traces
            )
        {
            Result error = null;

            return SetLibraryVariableValue(flags, name, value, traces, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SetLibraryVariableValue(
            VariableFlags flags,
            string name,
            string value,
            ref Result error
            )
        {
            return SetLibraryVariableValue(flags, name, value, (TraceList)null, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetLibraryVariableValue(
            VariableFlags flags,
            string name,
            string value,
            TraceList traces,
            ref Result error
            )
        {
            return SetLibraryVariableValue2(flags, name, null, value, traces, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetLibraryVariableValue2(
            VariableFlags flags,
            string name,
            string index,
            string value
            )
        {
            Result error = null;

            return SetLibraryVariableValue2(flags, name, index, value, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetLibraryVariableValue2(
            VariableFlags flags,
            string name,
            string index,
            string value,
            ref Result error
            )
        {
            return SetLibraryVariableValue2(flags, name, index, value, null, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetLibraryVariableValue2(
            VariableFlags flags,
            string name,
            string index,
            string value,
            TraceList traces,
            ref Result error
            )
        {
            flags |= VariableFlags.Library;
            return SetVariableValue2(flags, name, index, value, traces, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SetVariableValue(
            VariableFlags flags,
            string name,
            string value,
            TraceList traces
            )
        {
            Result error = null;

            return SetVariableValue(
                flags, name, value, traces, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SetListVariableValue(
            VariableFlags flags,
            string name,
            StringList value,
            TraceList traces,
            ref Result error
            )
        {
            IVariable variable = null;

            return SetVariableValue2(
                flags, null, name, null, value, traces, ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetVariableValue(
            VariableFlags flags,
            string name,
            string value,
            TraceList traces,
            ref IVariable variable,
            ref Result error
            )
        {
            return SetVariableValue2(
                flags, name, null, value, traces, ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SetVariableValue(
            VariableFlags flags,
            string name,
            string value,
            ref Result error
            )
        {
            return SetVariableValue2(flags, name, null, value, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SetVariableValue2(
            VariableFlags flags,
            string name,
            string index,
            string value,
            ref Result error
            )
        {
            return SetVariableValue2(flags, name, index, value, null, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SetVariableValue2(
            VariableFlags flags,
            string name,
            string index,
            string value,
            TraceList traces,
            ref Result error
            )
        {
            IVariable variable = null;

            return SetVariableValue2(
                flags, name, index, value, traces,
                ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SetVariableValue2(
            VariableFlags flags,
            ICallFrame frame,
            string name,
            string index,
            string value,
            TraceList traces,
            ref Result error
            )
        {
            IVariable variable = null;

            return SetVariableValue2(
                flags, frame, name, index, value, traces,
                ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetVariableValue2(
            VariableFlags flags,
            string name,
            string index,
            string value,
            TraceList traces,
            ref IVariable variable,
            ref Result error
            )
        {
            return SetVariableValue2(
                flags, null, name, index, value, traces,
                ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetVariableValue2(
            VariableFlags flags,
            ICallFrame frame,
            string name,
            string index,
            string value,
            TraceList traces,
            ref IVariable variable,
            ref Result error
            )
        {
            return SetVariableValue2(
                flags, frame, name, index, (object)value, traces,
                ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SetVariableValue2( /* NOTE: FOR PROCEDURE USE ONLY. */
            VariableFlags flags,
            ICallFrame frame,
            string name,
            object value,
            ref Result error
            )
        {
            IVariable variable = null;

            return SetVariableValue2(
                flags, frame, name, null, (object)value, null,
                ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SetVariableValue2( /* NOTE: FOR [append]/[catch]/[set] USE ONLY. */
            VariableFlags flags,
            string name,
            object value,
            TraceList traces,
            ref Result error
            )
        {
            IVariable variable = null;

            return SetVariableValue2(
                flags, null, name, null, (object)value, traces,
                ref variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SetVariableValue2( /* PRIMARY */
            VariableFlags flags,
            ICallFrame frame,
            string name,
            string index,
            object value,
            TraceList traces,
            ref IVariable variable,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // HACK: Make use of the configured "extra" variable flags
                //       for this operation.
                //
                flags |= setVariableFlags;

                if (!readOnly || FlagOps.HasFlags(flags, VariableFlags.ReadOnlyMask, false))
                {
                    bool haveVariable = (variable != null);
                    Result localError = null;

                    if (haveVariable ||
                        (GetVariableViaResolversWithSplit(frame, name, index, ref flags,
                            ref variable, ref localError) == ReturnCode.Ok))
                    {
                        //
                        // COMPAT: Tcl, if the index was specified, make sure the name
                        //         itself does not contain an array element reference.
                        //
                        if (haveVariable || (index == null))
                        {
                            VariableFlags splitFlags = flags;
                            string splitIndex = null;

                            if (index != null)
                                splitFlags |= VariableFlags.NoElement;

                            if (ScriptOps.SplitVariableName(
                                    this, splitFlags, name, ref name,
                                    ref splitIndex, ref error) == ReturnCode.Ok)
                            {
                                if ((index == null) && (splitIndex != null))
                                    index = splitIndex;
                            }
                            else
                            {
                                return ReturnCode.Error;
                            }
                        }

                        //
                        // NOTE: Make sure we have a variable.
                        //
                        if (variable == null)
                        {
                            error = String.Format(
                                "can't set {0}: variable is invalid",
                                FormatOps.ErrorVariableName(name, index));

                            return ReturnCode.Error;
                        }

                        //
                        // NOTE: For linked variables, we may be linking to an array
                        //       element.
                        //
                        string linkIndex = null;

                        //
                        // NOTE: Save original call frame for traces.
                        //
                        ICallFrame savedFrame = variable.Frame;

                        //
                        // NOTE: For linked variables, save a reference to the original
                        //       variable link itself.
                        //
                        IVariable savedVariable = null;

                        //
                        // NOTE: Is the variable really a link to another variable?
                        //
                        // BUGFIX: Also, does the variable at the end of the link exist
                        //         in a defined call frame?
                        //
                        Result linkError = null; /* REUSED */

                        if (EntityOps.HasValidLink(
                                variable, false, ref linkError))
                        {
                            //
                            // NOTE: Get the array element index
                            //       of the link, if any.
                            //
                            linkIndex = variable.LinkIndex;

                            //
                            // NOTE: Save the link itself because
                            //       we may need to mark it as
                            //       undefined (below).
                            //
                            savedVariable = variable;

                            //
                            // NOTE: Follow the linked variable.
                            //
                            linkError = null;

                            variable = EntityOps.FollowLinks(
                                variable, flags, ref linkError);

                            if (variable == null)
                            {
                                error = linkError;
                                return ReturnCode.Error;
                            }
                        }
                        else if (linkError != null)
                        {
                            error = linkError;
                            return ReturnCode.Error;
                        }

                        //
                        // NOTE: Either a direct index or a link index is required.
                        //
                        if ((index != null) || (linkIndex != null))
                        {
                            //
                            // BUGFIX: (PART 1) If the variable was previously undefined, we
                            //         cannot validate it as an array variable.
                            //
                            // BUGFIX: If the variable is a link at this point the call frame
                            //         for the variable at the link destination is invalid;
                            //         therefore, allow the variable to be re-used as an array.
                            //
                            bool wasUndefined = EntityOps.IsUndefined(variable);

                            if ((wasUndefined || EntityOps.IsLink(variable) ||
                                    EntityOps.IsArray2(variable)) &&
                                ((index == null) || (linkIndex == null)))
                            {
                                //
                                // NOTE: If there was no element index specified, use
                                //       the one from the variable link.
                                //
                                if (index == null)
                                    index = linkIndex;

                                if (wasUndefined ||
                                    (!EntityOps.IsReadOnly(variable) && !EntityOps.IsInvariant(variable)))
                                {
                                    object oldValue = EntityOps.GetOldValue(
                                        flags, variable, index, ScriptOps.GetDefaultValue(
                                            BreakpointType.BeforeVariableSet));

                                    object newValue = EntityOps.GetNewValue(
                                        flags, oldValue, value);

                                    ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                                        this, null, BreakpointType.BeforeVariableSet, savedFrame,
                                        variable, name, index, flags, oldValue, newValue, null,
                                        null, null, NeedNewTraceInfo(flags), false,
                                        !EntityOps.IsNoPostProcess(variable), ReturnCode.Ok);

                                    bool wasArray = EntityOps.IsArray(traceInfo);

                                    //
                                    // BUGFIX: If the variable was undefined, make sure it now has the
                                    //         right traces, both local and global.  Prior to this fix,
                                    //         running the test "debug-5.1" (in file "writebox.eagle")
                                    //         after test file "upvar-tcl.eagle" resulted in a failure.
                                    //         This was caused by a recycling of the "x" variable, which
                                    //         removed all of its traces.  Later, when the value was set
                                    //         to a freshly created opaque object handle, the reference
                                    //         count was not incremented due to the lack of traces (e.g.
                                    //         ObjectTraceCallback handle trace), which caused it to be
                                    //         removed during subsequent FixupByRefArguments processing.
                                    //
                                    if (wasUndefined)
                                    {
                                        variable.Traces = GetTraces(
                                            traces, name, index, newValue, wasArray);
                                    }

                                    bool redidCallbacks = false;

                                redoCallbacks:

#if DEBUGGER && DEBUGGER_VARIABLE
                                    if (!FlagOps.HasFlags(traceInfo.Flags,
                                            VariableFlags.NonWatchpoint, false) &&
                                        CanHitWatchpoints(traceInfo.BreakpointType) &&
                                        !EntityOps.IsNoWatchpoint(variable) &&
                                        EntityOps.IsBreakOnSet(variable))
                                    {
                                        //
                                        // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                        //       set access for this variable.
                                        //
                                        Result localResult = null;

                                        if (CheckWatchpoints(
                                                ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                                traceInfo, ref localResult) != ReturnCode.Ok)
                                        {
                                            error = localResult;
                                            return ReturnCode.Error;
                                        }
                                    }
#endif

                                    if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                        !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                        !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                                    {
                                        try
                                        {
                                            if (ScriptOps.FireTraces(
                                                    variable, traceInfo.BreakpointType, this, traceInfo,
                                                    ref error) != ReturnCode.Ok)
                                            {
                                                return ReturnCode.Error;
                                            }
                                        }
                                        catch (Exception e)
                                        {
                                            error = String.Format(
                                                "caught exception while firing variable traces: {0}",
                                                e);

                                            return ReturnCode.Error;
                                        }
                                    }

#if NOTIFY
                                    if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                        !EntityOps.IsNoNotify(variable))
                                    {
                                        /* IGNORED */
                                        CheckNotification(
                                            NotifyType.Variable, NotifyFlags.Trace,
                                            new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                            this, null, null, null, ref error);
                                    }
#endif

                                    if (!redidCallbacks && !wasArray && EntityOps.IsArray(traceInfo))
                                    {
                                        redidCallbacks = true;

                                        variable.Traces = GetTraces(traces,
                                            traceInfo.Name, traceInfo.Index, traceInfo.NewValue,
                                            true);

                                        goto redoCallbacks;
                                    }

                                    //
                                    // NOTE: If the trace(s) did not cancel the operation, proceed.
                                    //
                                    if (!traceInfo.Cancel)
                                    {
                                        if (traceInfo.Index != null)
                                        {
                                            //
                                            // NOTE: If the interpreter is in 'immutable' mode, prevent
                                            //       array elements from being changed (i.e. they may
                                            //       only be added).
                                            //
                                            if (immutable &&
                                                !EntityOps.IsUndefined(variable) &&
                                                !EntityOps.IsMutable(variable) &&
                                                !FlagOps.HasFlags(traceInfo.Flags,
                                                    VariableFlags.ImmutableMask, false))
                                            {
                                                ElementDictionary arrayValue2 = variable.ArrayValue;

                                                if ((arrayValue2 != null) &&
                                                    arrayValue2.ContainsKey(traceInfo.Index))
                                                {
                                                    error = String.Format(
                                                        "can't set {0}: interpreter is immutable",
                                                        FormatOps.ErrorVariableName(
                                                            variable, linkIndex, name, traceInfo.Index));

                                                    return ReturnCode.Error;
                                                }
                                            }

                                            //
                                            // BUGFIX: The variable may have been a link to a variable
                                            //         in an undefined call frame.
                                            //
                                            wasUndefined = false;

                                            if (ClearVariableFlagsOrLink(
                                                    frame, savedVariable, variable, traceInfo, traces,
                                                    ref wasUndefined, ref localError) != ReturnCode.Ok)
                                            {
                                                error = String.Format(
                                                    "can't set {0}: {1}",
                                                    FormatOps.ErrorVariableName(name),
                                                    localError);

                                                return ReturnCode.Error;
                                            }

                                            //
                                            // NOTE: Grab the array value, if any, from the variable.
                                            //
                                            ElementDictionary arrayValue = variable.ArrayValue;

                                            //
                                            // NOTE: If there is a element limit, make sure that there
                                            //       is still room for one more variable.
                                            //
                                            if (arrayElementLimit != 0)
                                            {
                                                if (((arrayValue == null) && (arrayElementLimit < 1)) ||
                                                    ((arrayValue != null) &&
                                                        (arrayValue.Count >= arrayElementLimit) &&
                                                        !arrayValue.ContainsKey(traceInfo.Index)))
                                                {
                                                    error = String.Format(
                                                        "can't set {0}: array element limit exceeded",
                                                        FormatOps.ErrorVariableName(
                                                            variable, linkIndex, name, traceInfo.Index));

                                                    return ReturnCode.Error;
                                                }
                                            }

                                            //
                                            // BUGFIX: (PART 2) We need to tag the variable as an array and
                                            //         create the underlying dictionary now if the variable
                                            //         was previously undefined.  Also, make sure the array
                                            //         value dictionary is created (or recreated) before
                                            //         continuing.
                                            //
                                            if (wasUndefined || (arrayValue == null))
                                            {
                                                variable.ArrayValue = arrayValue =
                                                    new ElementDictionary(variableEvent);
                                            }

                                            variable.Value = null; /* TODO: Was in the "if" block above. */
                                            EntityOps.SetArray(variable, true);

                                            arrayValue[traceInfo.Index] = traceInfo.NewValue;

                                            //
                                            // BUGFIX: Mark the variable as "dirty" AFTER the
                                            //         actual modifications have been completed.
                                            //
                                            EntityOps.SignalDirty(variable, traceInfo.Index);
                                        }
                                        else
                                        {
                                            error = String.Format(
                                                "can't set {0}: variable is array",
                                                FormatOps.ErrorVariableName(name));

                                            return ReturnCode.Error;
                                        }
                                    }

                                    return traceInfo.ReturnCode;
                                }
                                else
                                {
                                    error = String.Format(
                                        "can't set {0}: variable is read-only",
                                        FormatOps.ErrorVariableName(
                                            variable, linkIndex, name, index));
                                }
                            }
                            else
                            {
                                error = String.Format(
                                    "can't set {0}: variable isn't array",
                                    FormatOps.ErrorVariableName(
                                        variable, linkIndex, name, index));
                            }
                        }
                        else
                        {
                            //
                            // BUGFIX: (PART 3) If the variable was previously undefined,
                            //         we cannot validate it as a scalar variable.
                            //
                            bool wasUndefined = EntityOps.IsUndefined(variable);

                            if (wasUndefined || !EntityOps.IsArray2(variable))
                            {
                                if (wasUndefined ||
                                    (!EntityOps.IsReadOnly(variable) && !EntityOps.IsInvariant(variable)))
                                {
                                    object oldValue = (variable.Value != null) ?
                                        variable.Value : ScriptOps.GetDefaultValue(
                                            BreakpointType.BeforeVariableSet);

                                    object newValue = EntityOps.GetNewValue(
                                        flags, oldValue, value);

                                    ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                                        this, null, BreakpointType.BeforeVariableSet, savedFrame,
                                        variable, name, index, flags, oldValue, newValue, null,
                                        null, null, NeedNewTraceInfo(flags), false,
                                        !EntityOps.IsNoPostProcess(variable), ReturnCode.Ok);

                                    bool wasArray = EntityOps.IsArray(traceInfo);

                                    //
                                    // BUGFIX: If the variable was undefined, make sure it now has the
                                    //         right traces, both local and global.  Prior to this fix,
                                    //         running the test "debug-5.1" (in file "writebox.eagle")
                                    //         after test file "upvar-tcl.eagle" resulted in a failure.
                                    //         This was caused by a recycling of the "x" variable, which
                                    //         removed all of its traces.  Later, when the value was set
                                    //         to a freshly created opaque object handle, the reference
                                    //         count was not incremented due to the lack of traces (e.g.
                                    //         ObjectTraceCallback handle trace), which caused it to be
                                    //         removed during subsequent FixupByRefArguments processing.
                                    //
                                    if (wasUndefined)
                                    {
                                        variable.Traces = GetTraces(
                                            traces, name, index, newValue, wasArray);
                                    }

                                    bool redidCallbacks = false;

                                redoCallbacks:

#if DEBUGGER && DEBUGGER_VARIABLE
                                    if (!FlagOps.HasFlags(traceInfo.Flags,
                                            VariableFlags.NonWatchpoint, false) &&
                                        CanHitWatchpoints(traceInfo.BreakpointType) &&
                                        !EntityOps.IsNoWatchpoint(variable) &&
                                        EntityOps.IsBreakOnSet(variable))
                                    {
                                        //
                                        // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                        //       set access for this variable.
                                        //
                                        Result localResult = null;

                                        if (CheckWatchpoints(
                                                ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                                traceInfo, ref localResult) != ReturnCode.Ok)
                                        {
                                            error = localResult;
                                            return ReturnCode.Error;
                                        }
                                    }
#endif

                                    if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                        !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                        !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                                    {
                                        try
                                        {
                                            if (ScriptOps.FireTraces(
                                                    variable, traceInfo.BreakpointType, this, traceInfo,
                                                    ref error) != ReturnCode.Ok)
                                            {
                                                return ReturnCode.Error;
                                            }
                                        }
                                        catch (Exception e)
                                        {
                                            error = String.Format(
                                                "caught exception while firing variable traces: {0}",
                                                e);

                                            return ReturnCode.Error;
                                        }
                                    }

#if NOTIFY
                                    if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                        !EntityOps.IsNoNotify(variable))
                                    {
                                        /* IGNORED */
                                        CheckNotification(
                                            NotifyType.Variable, NotifyFlags.Trace,
                                            new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                            this, null, null, null, ref error);
                                    }
#endif

                                    if (!redidCallbacks && !wasArray && EntityOps.IsArray(traceInfo))
                                    {
                                        redidCallbacks = true;

                                        variable.Traces = GetTraces(traces,
                                            traceInfo.Name, traceInfo.Index, traceInfo.NewValue,
                                            true);

                                        goto redoCallbacks;
                                    }

                                    //
                                    // NOTE: If the trace(s) did not cancel the operation, proceed.
                                    //
                                    if (!traceInfo.Cancel)
                                    {
                                        if (immutable &&
                                            !EntityOps.IsUndefined(variable) &&
                                            !EntityOps.IsMutable(variable) &&
                                            !FlagOps.HasFlags(traceInfo.Flags,
                                                VariableFlags.ImmutableMask, false))
                                        {
                                            error = String.Format(
                                                "can't set {0}: interpreter is immutable",
                                                FormatOps.ErrorVariableName(name));

                                            return ReturnCode.Error;
                                        }

                                        //
                                        // BUGFIX: The variable may have been a link to a variable
                                        //         in an undefined call frame.
                                        //
                                        wasUndefined = false;

                                        if (ClearVariableFlagsOrLink(
                                                frame, savedVariable, variable, traceInfo, traces,
                                                ref wasUndefined, ref localError) != ReturnCode.Ok)
                                        {
                                            error = String.Format(
                                                "can't set {0}: {1}",
                                                FormatOps.ErrorVariableName(name),
                                                localError);

                                            return ReturnCode.Error;
                                        }

                                        //
                                        // BUGFIX: (PART 4) We need to tag the variable as a scalar and
                                        //         remove the underlying dictionary now if the variable
                                        //         was previously undefined or if array value dictionary
                                        //         is actually present.
                                        //
                                        ElementDictionary arrayValue = variable.ArrayValue;

                                        if (wasUndefined || (arrayValue != null))
                                            variable.ArrayValue = arrayValue = null;

                                        variable.Value = traceInfo.NewValue;
                                        EntityOps.SetArray(variable, false);

                                        //
                                        // BUGFIX: Mark the variable as "dirty" AFTER the
                                        //         actual modifications have been completed.
                                        //
                                        EntityOps.SignalDirty(variable, null);
                                    }

                                    return traceInfo.ReturnCode;
                                }
                                else
                                {
                                    error = String.Format(
                                        "can't set {0}: variable is read-only",
                                        FormatOps.ErrorVariableName(name));
                                }
                            }
                            else
                            {
                                error = String.Format(
                                    "can't set {0}: variable is array",
                                    FormatOps.ErrorVariableName(name));
                            }
                        }
                    }
                    else
                    {
                        if (FlagOps.HasFlags(flags, VariableFlags.NotFound, true))
                        {
                            //
                            // COMPAT: Tcl, if the index was specified, make sure the name
                            //         itself does not contain an array element reference.
                            //
                            if (index == null)
                            {
                                VariableFlags splitFlags = flags;
                                string splitIndex = null;

                                if (ScriptOps.SplitVariableName(
                                        this, splitFlags, name, ref name,
                                        ref splitIndex, ref error) == ReturnCode.Ok)
                                {
                                    if (splitIndex != null)
                                        index = splitIndex;
                                }
                                else
                                {
                                    return ReturnCode.Error;
                                }
                            }

                            //
                            // NOTE: Make sure we are allowed to add new variables (i.e.
                            //       and not just change existing ones).
                            //
                            if (!FlagOps.HasFlags(flags, VariableFlags.NoCreate, true))
                            {
                                ICallFrame variableFrame = frame;
                                string newName = name;

                                if (GetVariableFrameViaResolvers(
                                        LookupFlags.Default, ref variableFrame, ref newName,
                                        ref flags, ref error) != ReturnCode.Ok)
                                {
                                    return ReturnCode.Error;
                                }

                                if (variableFrame == null)
                                {
                                    error = "invalid call frame from resolver";
                                    return ReturnCode.Error;
                                }

                                bool isGlobalCallFrame = IsGlobalCallFrame(variableFrame);

                                bool wasArray = (index != null) ||
                                    FlagOps.HasFlags(flags, VariableFlags.Array, true);

                                object newValue = EntityOps.GetNewValue(
                                    flags, null, value);

                                variable = new Variable(variableFrame, newName,
                                    (flags & ~VariableFlags.NonSetMask | VariableFlags.Undefined) |
                                    CallFrameOps.GetNewVariableFlags(variableFrame) |
                                    GetNewVariableFlags(isGlobalCallFrame), null,
                                    GetTraces(traces, newName, null, newValue, wasArray),
                                    variableEvent);

                                MaybeSetQualifiedName(variable);

                                if (isGlobalCallFrame)
                                    EntityOps.SetGlobal(variable, true);
                                else
                                    EntityOps.SetLocal(variable, true);

                                ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                                    this, null, BreakpointType.BeforeVariableSet, variableFrame,
                                    variable, name, index, flags, null, newValue, null,
                                    null, null, NeedNewTraceInfo(flags), false,
                                    !EntityOps.IsNoPostProcess(variable), ReturnCode.Ok);

                                bool redidCallbacks = false;

                            redoCallbacks:

#if DEBUGGER && DEBUGGER_VARIABLE
                                if (CanHitWatchpoints(traceInfo.BreakpointType) &&
                                    EntityOps.IsBreakOnSet(variable))
                                {
                                    //
                                    // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                    //       set access for this variable.
                                    //
                                    Result localResult = null;

                                    if (CheckWatchpoints(
                                            ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                            traceInfo, ref localResult) != ReturnCode.Ok)
                                    {
                                        error = localResult;
                                        return ReturnCode.Error;
                                    }
                                }
#endif

                                if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                    !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                    !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                                {
                                    try
                                    {
                                        if (ScriptOps.FireTraces(
                                                variable, traceInfo.BreakpointType, this, traceInfo,
                                                ref error) != ReturnCode.Ok)
                                        {
                                            return ReturnCode.Error;
                                        }
                                    }
                                    catch (Exception e)
                                    {
                                        error = String.Format(
                                            "caught exception while firing variable traces: {0}",
                                            e);

                                        return ReturnCode.Error;
                                    }
                                }

#if NOTIFY
                                if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                    !EntityOps.IsNoNotify(variable))
                                {
                                    /* IGNORED */
                                    CheckNotification(
                                        NotifyType.Variable, NotifyFlags.Trace,
                                        new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                        this, null, null, null, ref error);
                                }
#endif

                                if (!redidCallbacks && !wasArray && EntityOps.IsArray(traceInfo))
                                {
                                    redidCallbacks = true;

                                    variable.Traces = GetTraces(traces,
                                        traceInfo.Name, traceInfo.Index, traceInfo.NewValue,
                                        true);

                                    goto redoCallbacks;
                                }

                                //
                                // NOTE: If the trace(s) did not cancel the operation, proceed.
                                //
                                if (!traceInfo.Cancel)
                                {
                                    VariableDictionary variables = variableFrame.Variables;

                                    if (variables == null)
                                    {
                                        error = String.Format(
                                            "can't set {0}: call frame does not support variables",
                                            FormatOps.ErrorVariableName(variable, null, name, index));

                                        return ReturnCode.Error;
                                    }

                                    //
                                    // NOTE: If there is a variable limit, make sure that there
                                    //       is still room for one more variable.
                                    //
                                    if ((variableLimit != 0) &&
                                        (variables.Count >= variableLimit) &&
                                        (variables.GetDefinedCount() >= variableLimit))
                                    {
                                        error = String.Format(
                                            "can't set {0}: variable limit exceeded",
                                            FormatOps.ErrorVariableName(variable, null, name, index));

                                        return ReturnCode.Error;
                                    }

                                    bool haveIndex = (traceInfo.Index != null);

                                    if (haveIndex || EntityOps.IsArray2(variable))
                                    {
                                        ElementDictionary arrayValue =
                                            new ElementDictionary(variableEvent);

                                        //
                                        // NOTE: If there is a element limit, make sure that there
                                        //       is still room for one more variable.
                                        //
                                        if (haveIndex && (arrayElementLimit != 0) &&
                                            (arrayValue.Count >= arrayElementLimit))
                                        {
                                            error = String.Format(
                                                "can't set {0}: array element limit exceeded",
                                                FormatOps.ErrorVariableName(variable, null, name, index));

                                            return ReturnCode.Error;
                                        }

                                        variable.Value = null;
                                        variable.ArrayValue = arrayValue;
                                        EntityOps.SetArray(variable, true);

                                        if (haveIndex)
                                            arrayValue.Add(traceInfo.Index, traceInfo.NewValue);
                                    }
                                    else
                                    {
                                        variable.Value = traceInfo.NewValue;
                                    }

                                    variables.Add(newName, variable);

                                    //
                                    // BUGFIX: Mark the variable as "dirty" AFTER the
                                    //         actual modifications have been completed.
                                    //
                                    EntityOps.SetUndefined(variable, false);
                                    EntityOps.SignalDirty(variable, traceInfo.Index);
                                }

                                return traceInfo.ReturnCode;
                            }
                            else
                            {
                                error = String.Format(
                                    "can't set {0}: no such variable",
                                    FormatOps.ErrorVariableName(
                                        variable, null, name, index));
                            }
                        }
                        else
                        {
                            //
                            // NOTE: We did not actually search for the variable,
                            //       inform the caller as to why.
                            //
                            error = localError;
                        }
                    }
                }
                else
                {
                    error = String.Format(
                        "can't set {0}: interpreter is read-only",
                        FormatOps.ErrorVariableName(name, index));
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool HasZeroString(
            VariableFlags variableFlags
            )
        {
#if !MONO && NATIVE && WINDOWS
            return FlagOps.HasFlags(
                variableFlags, VariableFlags.ZeroString, true);
#else
            return false;
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode UnsetLibraryVariable(
            VariableFlags flags,
            string name,
            ref Result error
            )
        {
            flags |= VariableFlags.Library;
            return UnsetVariable2(flags, name, null, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode UnsetVariable2(
            VariableFlags flags,
            string name,
            string index,
            ref Result error
            )
        {
            return UnsetVariable2(flags, name, index, null, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode UnsetVariable2(
            VariableFlags flags,
            string name,
            string index,
            IVariable variable,
            ref Result error
            )
        {
            return UnsetVariable2(flags, null, name, index, variable, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode UnsetVariable2( /* PRIMARY */
            VariableFlags flags,
            ICallFrame frame,
            string name,
            string index,
            IVariable variable,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // HACK: Make use of the configured "extra" variable flags
                //       for this operation.
                //
                flags |= unsetVariableFlags;

                if (immutable && !FlagOps.HasFlags(flags, VariableFlags.ImmutableMask, false))
                {
                    error = String.Format(
                        "can't unset {0}: interpreter is immutable",
                        FormatOps.ErrorVariableName(name, index));

                    return ReturnCode.Error;
                }

                if (!readOnly || FlagOps.HasFlags(flags, VariableFlags.ReadOnlyMask, false))
                {
                    //
                    // BUGBUG: This may need revision; we do need some way to remove
                    //         "stale" undefined variables from the call frame even
                    //         though the only way to officially create one is via the
                    //         global or upvar commands and those get cleaned up
                    //         automatically upon procedure exit.
                    //
                    bool haveVariable = (variable != null);
                    Result localError = null;

                    if ((haveVariable ||
                        (GetVariableViaResolversWithSplit(frame, name, index, ref flags,
                            ref variable, ref localError) == ReturnCode.Ok)) &&
                        !EntityOps.IsUndefined(variable, "unset", name, index,
                            ref localError))
                    {
                        //
                        // COMPAT: Tcl, if the index was specified, make sure the name
                        //         itself does not contain an array element reference.
                        //
                        if (haveVariable || (index == null))
                        {
                            VariableFlags splitFlags = flags;
                            string splitIndex = null;

                            if (index != null)
                                splitFlags |= VariableFlags.NoElement;

                            if (ScriptOps.SplitVariableName(
                                    this, splitFlags, name, ref name,
                                    ref splitIndex, ref error) == ReturnCode.Ok)
                            {
                                if ((index == null) && (splitIndex != null))
                                    index = splitIndex;
                            }
                            else
                            {
                                return ReturnCode.Error;
                            }
                        }

                        //
                        // NOTE: Make sure we have a variable.
                        //
                        if (variable == null)
                        {
                            error = String.Format(
                                "can't unset {0}: variable is invalid",
                                FormatOps.ErrorVariableName(name, index));

                            return ReturnCode.Error;
                        }

                        //
                        // NOTE: For linked variables, we may be linking to an array
                        //       element.
                        //
                        string linkIndex = null;

                        //
                        // NOTE: Save original call frame for traces.
                        //
                        ICallFrame savedFrame = variable.Frame;

                        //
                        // NOTE: For linked variables, save a reference to the original
                        //       variable link itself.
                        //
                        IVariable savedVariable = null;

                        //
                        // NOTE: Is the variable really a link to another variable?
                        //
                        // BUGFIX: Also, does the variable at the end of the link exist
                        //         in a defined call frame?
                        //
                        Result linkError = null; /* REUSED */

                        if (EntityOps.HasValidLink(
                                variable, false, ref linkError))
                        {
                            //
                            // NOTE: Get the array element index
                            //       of the link, if any.
                            //
                            linkIndex = variable.LinkIndex;

                            //
                            // NOTE: Save the link itself because
                            //       we may need to mark it as
                            //       undefined (below).
                            //
                            savedVariable = variable;

                            //
                            // NOTE: Follow the linked variable.
                            //
                            linkError = null;

                            variable = EntityOps.FollowLinks(
                                variable, flags, ref linkError);

                            if (variable == null)
                            {
                                error = linkError;
                                return ReturnCode.Error;
                            }
                        }
                        else if (linkError != null)
                        {
                            error = linkError;
                            return ReturnCode.Error;
                        }

                        if (!EntityOps.IsUndefined(variable))
                        {
                            if ((index != null) || (linkIndex != null))
                            {
                                if (EntityOps.IsArray2(variable) &&
                                        ((index == null) || (linkIndex == null)))
                                {
                                    //
                                    // NOTE: If there was no element index specified, use
                                    //       the one from the variable link.
                                    //
                                    if (index == null)
                                        index = linkIndex;

                                    if (!EntityOps.IsReadOnly(variable) && !EntityOps.IsInvariant(variable))
                                    {
                                        ElementDictionary arrayValue = variable.ArrayValue;

                                        if ((arrayValue != null) && arrayValue.ContainsKey(index))
                                        {
                                            object oldValue = EntityOps.GetOldValue(
                                                flags, variable, index, ScriptOps.GetDefaultValue(
                                                    BreakpointType.BeforeVariableUnset));

                                            ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                                                this, null, BreakpointType.BeforeVariableUnset, savedFrame,
                                                variable, name, index, flags, oldValue, null, null,
                                                null, null, NeedNewTraceInfo(flags), false,
                                                !EntityOps.IsNoPostProcess(variable), ReturnCode.Ok);

#if DEBUGGER && DEBUGGER_VARIABLE
                                            if (!FlagOps.HasFlags(traceInfo.Flags,
                                                    VariableFlags.NonWatchpoint, false) &&
                                                CanHitWatchpoints(traceInfo.BreakpointType) &&
                                                !EntityOps.IsNoWatchpoint(variable) &&
                                                EntityOps.IsBreakOnUnset(variable))
                                            {
                                                //
                                                // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                                //       unset access for this variable.
                                                //
                                                Result localResult = null;

                                                if (CheckWatchpoints(
                                                        ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                                        traceInfo, ref localResult) != ReturnCode.Ok)
                                                {
                                                    error = localResult;
                                                    return ReturnCode.Error;
                                                }
                                            }
#endif

                                            if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                                !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                                !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                                            {
                                                try
                                                {
                                                    if (ScriptOps.FireTraces(
                                                            variable, traceInfo.BreakpointType, this, traceInfo,
                                                            ref error) != ReturnCode.Ok)
                                                    {
                                                        return ReturnCode.Error;
                                                    }
                                                }
                                                catch (Exception e)
                                                {
                                                    error = String.Format(
                                                        "caught exception while firing variable traces: {0}",
                                                        e);

                                                    return ReturnCode.Error;
                                                }
                                            }

#if NOTIFY
                                            if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                                !EntityOps.IsNoNotify(variable))
                                            {
                                                /* IGNORED */
                                                CheckNotification(
                                                    NotifyType.Variable, NotifyFlags.Trace,
                                                    new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                                    this, null, null, null, ref error);
                                            }
#endif

                                            bool reset = FlagOps.HasFlags(
                                                traceInfo.Flags, VariableFlags.ResetValue, true);

                                            bool zero = HasZeroString() && HasZeroString(traceInfo.Flags);

                                            //
                                            // NOTE: If the trace(s) did not cancel the operation, proceed.
                                            //
                                            if (!traceInfo.Cancel)
                                            {
                                                if (traceInfo.Index != null)
                                                {
                                                    arrayValue = variable.ArrayValue; /* REFRESH */

                                                    if (arrayValue != null)
                                                    {
                                                        if (reset)
                                                        {
                                                            /* IGNORED */
                                                            arrayValue.ResetValue(
                                                                this, traceInfo.Index, zero);
                                                        }
                                                        else
                                                        {
                                                            /* IGNORED */
                                                            arrayValue.Remove(traceInfo.Index);
                                                        }

                                                        //
                                                        // HACK: Even though the element itself has been
                                                        //       removed, we need to make sure any pending
                                                        //       waits for the array element are properly
                                                        //       signaled.
                                                        //
                                                        // BUGFIX: Mark the variable as "dirty" AFTER the
                                                        //         actual modifications have been completed.
                                                        //
                                                        EntityOps.SignalDirty(variable, traceInfo.Index);
                                                    }
                                                    else
                                                    {
                                                        error = String.Format(
                                                            "can't unset {0}: no longer an array",
                                                            FormatOps.ErrorVariableName(
                                                                variable, linkIndex, name, index));

                                                        return ReturnCode.Error;
                                                    }
                                                }
                                                else
                                                {
                                                    if ((savedVariable != null) &&
                                                        !Object.ReferenceEquals(savedVariable, variable))
                                                    {
                                                        //
                                                        // NOTE: Links to dead variable(s) should be dead too.
                                                        //
                                                        if (reset && (savedVariable is Variable))
                                                            ((Variable)savedVariable).ResetValue(this, zero);

                                                        EntityOps.SetUndefined(savedVariable, true); // TEST: Test this.
                                                    }

                                                    //
                                                    // NOTE: The variable is now dead.
                                                    //
                                                    if (reset && (variable is Variable))
                                                        ((Variable)variable).ResetValue(this, zero);

                                                    EntityOps.SetUndefined(variable, true);

                                                    //
                                                    // NOTE: Remove any pending array searches that may exist for this
                                                    //       variable.
                                                    //
                                                    CleanupArraySearches(variable);

                                                    //
                                                    // NOTE: Check for the variable purge flag.  If the purge flag is set,
                                                    //       we remove all undefined variables from the current call frame.
                                                    //
                                                    if (FlagOps.HasFlags(traceInfo.Flags, VariableFlags.Purge, true))
                                                    {
                                                        //
                                                        // NOTE: Purge all undefined variables in the call frame for the
                                                        //       variable to be unset.  This implies removal of the variable
                                                        //       to be unset because we just set it to be undefined (above).
                                                        //
                                                        /* IGNORED */
                                                        CallFrameOps.Cleanup(CurrentFrame, savedFrame, false);
                                                    }
                                                    else if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NoRemove, true))
                                                    {
                                                        if (savedFrame != null)
                                                        {
                                                            VariableDictionary variables = savedFrame.Variables;

                                                            //
                                                            // NOTE: Remove the entire array if there is one; otherwise,
                                                            //       just remove this scalar variable.
                                                            //
                                                            if (variables != null)
                                                                variables.Remove(name);
                                                        }
                                                    }

                                                    //
                                                    // HACK: Even though the variable itself has been
                                                    //       removed, we need to make sure any pending
                                                    //       waits for the array elements are properly
                                                    //       signaled.
                                                    //
                                                    // BUGFIX: Mark the variable as "dirty" AFTER the
                                                    //         actual modifications have been completed.
                                                    //
                                                    EntityOps.SignalDirty(variable, null);
                                                }
                                            }

                                            return traceInfo.ReturnCode;
                                        }
                                        else
                                        {
                                            ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                                                this, null, BreakpointType.BeforeVariableUnset, savedFrame,
                                                variable, name, index, flags, null, null, null,
                                                null, null, NeedNewTraceInfo(flags), false,
                                                !EntityOps.IsNoPostProcess(variable), ReturnCode.Error);

#if DEBUGGER && DEBUGGER_VARIABLE
                                            if (!FlagOps.HasFlags(traceInfo.Flags,
                                                    VariableFlags.NonWatchpoint, false) &&
                                                CanHitWatchpoints(traceInfo.BreakpointType) &&
                                                !EntityOps.IsNoWatchpoint(variable) &&
                                                EntityOps.IsBreakOnUnset(variable))
                                            {
                                                //
                                                // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                                //       unset access for this variable.
                                                //
                                                Result localResult = null;

                                                if (CheckWatchpoints(
                                                        ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                                        traceInfo, ref localResult) != ReturnCode.Ok)
                                                {
                                                    error = localResult;
                                                    return ReturnCode.Error;
                                                }
                                            }
#endif

                                            if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                                !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                                !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                                            {
                                                try
                                                {
                                                    if (ScriptOps.FireTraces(
                                                            variable, traceInfo.BreakpointType, this, traceInfo,
                                                            ref error) != ReturnCode.Ok)
                                                    {
                                                        return ReturnCode.Error;
                                                    }
                                                }
                                                catch (Exception e)
                                                {
                                                    error = String.Format(
                                                        "caught exception while firing variable traces: {0}",
                                                        e);

                                                    return ReturnCode.Error;
                                                }
                                            }

#if NOTIFY
                                            if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                                !EntityOps.IsNoNotify(variable))
                                            {
                                                /* IGNORED */
                                                CheckNotification(
                                                    NotifyType.Variable, NotifyFlags.Trace,
                                                    new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                                    this, null, null, null, ref error);
                                            }
#endif

                                            //
                                            // NOTE: If the trace(s) did not cancel the operation, proceed.
                                            //
                                            if (!traceInfo.Cancel)
                                            {
                                                //
                                                // BUGFIX: When the variable traces, if any, do not cancel
                                                //         the operation entirely, honor the NoComplain flag.
                                                //
                                                if (FlagOps.HasFlags(
                                                        traceInfo.Flags, VariableFlags.NoComplain, true))
                                                {
                                                    return ReturnCode.Ok;
                                                }

                                                error = String.Format(
                                                    "can't unset {0}: no such element in array",
                                                    FormatOps.ErrorVariableName(
                                                        variable, linkIndex, name, traceInfo.Index));
                                            }

                                            return traceInfo.ReturnCode;
                                        }
                                    }
                                    else
                                    {
                                        error = String.Format(
                                            "can't unset {0}: variable is read-only",
                                            FormatOps.ErrorVariableName(
                                                variable, linkIndex, name, index));
                                    }
                                }
                                else
                                {
                                    if (FlagOps.HasFlags(flags, VariableFlags.NoComplain, true))
                                    {
                                        return ReturnCode.Ok;
                                    }
                                    else
                                    {
                                        error = String.Format(
                                            "can't unset {0}: variable isn't array",
                                            FormatOps.ErrorVariableName(
                                                variable, linkIndex, name, index));
                                    }
                                }
                            }
                            else
                            {
                                if (!EntityOps.IsReadOnly(variable) && !EntityOps.IsInvariant(variable))
                                {
                                    ICallFrame variableFrame = frame;
                                    string newName = name;

                                    if (GetVariableFrameViaResolvers(
                                            LookupFlags.Default, ref variableFrame, ref newName,
                                            ref flags, ref error) != ReturnCode.Ok)
                                    {
                                        return ReturnCode.Error;
                                    }

                                    if (variableFrame == null)
                                    {
                                        error = String.Format(
                                            "can't unset {0}: invalid call frame from resolver",
                                            FormatOps.ErrorVariableName(name));

                                        return ReturnCode.Error;
                                    }

                                    VariableDictionary variables = variableFrame.Variables;

                                    if (variables == null)
                                    {
                                        error = String.Format(
                                            "can't unset {0}: call frame does not support variables",
                                            FormatOps.ErrorVariableName(name));

                                        return ReturnCode.Error;
                                    }

                                    object oldValue = EntityOps.GetOldValue(
                                        flags, variable, index, ScriptOps.GetDefaultValue(
                                            BreakpointType.BeforeVariableUnset));

                                    ITraceInfo traceInfo = ScriptOps.NewTraceInfo(
                                        this, null, BreakpointType.BeforeVariableUnset, savedFrame,
                                        variable, name, index, flags, oldValue, null, null,
                                        null, null, NeedNewTraceInfo(flags), false,
                                        !EntityOps.IsNoPostProcess(variable), ReturnCode.Ok);

#if DEBUGGER && DEBUGGER_VARIABLE
                                    if (!FlagOps.HasFlags(traceInfo.Flags,
                                            VariableFlags.NonWatchpoint, false) &&
                                        CanHitWatchpoints(traceInfo.BreakpointType) &&
                                        !EntityOps.IsNoWatchpoint(variable) &&
                                        EntityOps.IsBreakOnUnset(variable))
                                    {
                                        //
                                        // NOTE: Debugger support, call Debugger.Trace if we are breaking on
                                        //       unset access for this variable.
                                        //
                                        Result localResult = null;

                                        if (CheckWatchpoints(
                                                ReturnCode.Ok, traceInfo.BreakpointType, name, null,
                                                traceInfo, ref localResult) != ReturnCode.Ok)
                                        {
                                            error = localResult;
                                            return ReturnCode.Error;
                                        }
                                    }
#endif

                                    if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonTrace, false) &&
                                        !HasPendingTraces() && EntityOps.HasTraces(variable) &&
                                        !EntityOps.IsNoTrace(variable) && (TraceLevels == 0))
                                    {
                                        try
                                        {
                                            if (ScriptOps.FireTraces(
                                                    variable, traceInfo.BreakpointType, this, traceInfo,
                                                    ref error) != ReturnCode.Ok)
                                            {
                                                return ReturnCode.Error;
                                            }
                                        }
                                        catch (Exception e)
                                        {
                                            error = String.Format(
                                                "caught exception while firing variable traces: {0}",
                                                e);

                                            return ReturnCode.Error;
                                        }
                                    }

#if NOTIFY
                                    if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NonNotify, false) &&
                                        !EntityOps.IsNoNotify(variable))
                                    {
                                        /* IGNORED */
                                        CheckNotification(
                                            NotifyType.Variable, NotifyFlags.Trace,
                                            new ObjectPair(traceInfo.BreakpointType, traceInfo),
                                            this, null, null, null, ref error);
                                    }
#endif

                                    bool reset = FlagOps.HasFlags(
                                        traceInfo.Flags, VariableFlags.ResetValue, true);

                                    bool zero = HasZeroString() && HasZeroString(traceInfo.Flags);

                                    //
                                    // NOTE: If the trace(s) did not cancel the operation, proceed.
                                    //
                                    if (!traceInfo.Cancel)
                                    {
                                        if ((savedVariable != null) &&
                                            !Object.ReferenceEquals(savedVariable, variable))
                                        {
                                            //
                                            // NOTE: Links to dead variable(s) should be dead too.
                                            //
                                            if (reset && (savedVariable is Variable))
                                                ((Variable)savedVariable).ResetValue(this, zero);

                                            EntityOps.SetUndefined(savedVariable, true); // TEST: Test this.
                                        }

                                        //
                                        // NOTE: The variable is now dead.
                                        //
                                        if (reset && (variable is Variable))
                                            ((Variable)variable).ResetValue(this, zero);

                                        EntityOps.SetUndefined(variable, true);

                                        //
                                        // NOTE: Remove any pending array searches that may exist for this
                                        //       variable.
                                        //
                                        CleanupArraySearches(variable);

                                        //
                                        // NOTE: Check for the variable purge flag.  If the purge flag is set,
                                        //       we remove all undefined variables from the current call frame.
                                        //
                                        if (FlagOps.HasFlags(traceInfo.Flags, VariableFlags.Purge, true))
                                        {
                                            //
                                            // NOTE: Purge all undefined variables in the call frame for the
                                            //       variable to be unset.  This implies removal of the variable
                                            //       to be unset because we just set it to be undefined (above).
                                            //
                                            /* IGNORED */
                                            CallFrameOps.Cleanup(CurrentFrame, variableFrame, false);
                                        }
                                        else if (!FlagOps.HasFlags(traceInfo.Flags, VariableFlags.NoRemove, true))
                                        {
                                            //
                                            // NOTE: Remove the entire array if there is one; otherwise,
                                            //       just remove this scalar variable.
                                            //
                                            variables.Remove(newName);
                                        }

                                        //
                                        // HACK: Even though the variable itself has been
                                        //       removed, we need to make sure any pending
                                        //       waits for the array elements are properly
                                        //       signaled.
                                        //
                                        // BUGFIX: Mark the variable as "dirty" AFTER the
                                        //         actual modifications have been completed.
                                        //
                                        EntityOps.SignalDirty(variable, null);
                                    }

                                    return traceInfo.ReturnCode;
                                }
                                else
                                {
                                    error = String.Format(
                                        "can't unset {0}: variable is read-only",
                                        FormatOps.ErrorVariableName(name));
                                }
                            }
                        }
                        else
                        {
                            //
                            // BUGBUG: This may need revision; we do need some way to remove
                            //         "stale" undefined variables from the call frame even
                            //         though the only way to officially create one is via the
                            //         global or upvar commands and those get cleaned up
                            //         automatically upon procedure exit.
                            //
                            if (FlagOps.HasFlags(flags, VariableFlags.NoComplain, true))
                            {
                                return ReturnCode.Ok;
                            }
                            else
                            {
                                error = String.Format(
                                    "can't unset {0}: no such variable",
                                    FormatOps.ErrorVariableName(
                                        variable, linkIndex, name, index));
                            }
                        }
                    }
                    else
                    {
                        if (FlagOps.HasFlags(flags, VariableFlags.NotFound, true))
                        {
                            if (FlagOps.HasFlags(flags, VariableFlags.NoComplain, true))
                            {
                                return ReturnCode.Ok;
                            }
                            else
                            {
                                error = String.Format(
                                    "can't unset {0}: no such variable",
                                    FormatOps.ErrorVariableName(
                                        variable, null, name, index));
                            }
                        }
                        else
                        {
                            if (FlagOps.HasFlags(flags, VariableFlags.NoComplain, true))
                            {
                                return ReturnCode.Ok;
                            }
                            else
                            {
                                //
                                // NOTE: We did not actually search for the variable,
                                //       inform the caller as to why.
                                //
                                error = localError;
                            }
                        }
                    }
                }
                else
                {
                    error = String.Format(
                        "can't unset {0}: interpreter is read-only",
                        FormatOps.ErrorVariableName(name, index));
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode MakeVariableFast( /* NOTE: For script library only. */
            string name,
            bool fast
            )
        {
            Result error = null;

            return MakeVariableFast(name, fast, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal long? GetVariableWaitThreadId()
        {
            /* EXEMPT */
            if (FlagOps.HasFlags(interpreterFlags,
                    InterpreterFlags.EventThreadAffinity, true))
            {
                return GlobalState.GetCurrentSystemThreadId();
            }

            return null; /* COMPAT: Eagle beta. */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReturnCode ClearVariableNameWait(
            Interpreter interpreter,       /* in */
            string name,                   /* in */
            EventWaitFlags eventWaitFlags, /* in */
            VariableFlags variableFlags    /* in */
            )
        {
            Result error = null;

            return ClearVariableNameWait(
                interpreter, name, eventWaitFlags, variableFlags,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static ReturnCode ClearVariableNameWait(
            Interpreter interpreter,       /* in */
            string name,                   /* in */
            EventWaitFlags eventWaitFlags, /* in */
            VariableFlags variableFlags,   /* in */
            ref Result error               /* out */
            ) /* THREAD-SAFE */
        {
            if (interpreter != null)
            {
                if (name != null)
                {
                    //
                    // BUGFIX: If the interpreter is disposed, skip clearing the variable
                    //         wait flags because the variable belongs to the interpreter,
                    //         which is now invalid.
                    //
                    lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
                    {
                        if (!IsDeletedOrDisposed(interpreter, false, ref error))
                        {
                            //
                            // NOTE: Attempt to search for the variable in current
                            //       variable call frame.
                            //
                            string varName = null;
                            string varIndex = null;
                            IVariable variable = null;

                            if (interpreter.GetVariableViaResolversWithSplit(
                                    null, name, null, ref varName, ref varIndex,
                                    ref variableFlags, ref variable,
                                    ref error) == ReturnCode.Ok)
                            {
                                //
                                // NOTE: Is the variable really a link to another
                                //       variable?
                                //
                                if (FlagOps.HasFlags(eventWaitFlags,
                                        EventWaitFlags.FollowLink, true) &&
                                    EntityOps.IsLink(variable))
                                {
                                    //
                                    // NOTE: Follow the linked variable.
                                    //
                                    variable = EntityOps.FollowLinks(
                                        variable, variableFlags, ref error);

                                    if (variable == null)
                                        return ReturnCode.Error;
                                }

                                //
                                // NOTE: Was the variable name actually a reference to
                                //       an array element?  Tcl allows this; therefore,
                                //       we must as well.
                                //
                                if (FlagOps.HasFlags(variableFlags,
                                        VariableFlags.WasElement, true) &&
                                    EntityOps.IsArray(variable) && (varIndex != null))
                                {
                                    //
                                    // NOTE: Clear the array element wakeup
                                    //       flag now.
                                    //
                                    /* IGNORED */
                                    EntityOps.SetElementWait(
                                        variable, varIndex, false);
                                }
                                else
                                {
                                    //
                                    // NOTE: Clear the variable wakeup flag
                                    //       now.
                                    //
                                    /* IGNORED */
                                    EntityOps.SetWait(variable, false);
                                }

                                return ReturnCode.Ok;
                            }
                        }
                    }
                }
                else
                {
                    error = "invalid variable name";
                }
            }
            else
            {
                error = "invalid interpreter";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void CheckVariableNameUndefined(
            Interpreter interpreter,       /* in */
            string name,                   /* in */
            EventWaitFlags eventWaitFlags, /* in */
            VariableFlags variableFlags,   /* in */
            ref bool wasUndefined          /* out */
            ) /* THREAD-SAFE */
        {
            //
            // NOTE: *WARNING* Empty variable names are allowed, please do not
            //       change these to "!String.IsNullOrEmpty".
            //
            if ((interpreter == null) || (name == null))
                return;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                //
                // BUGFIX: Avoid disposal race condition.
                //
                if (IsDeletedOrDisposed(interpreter, false))
                    return;

                //
                // NOTE: Attempt to search for the variable in current
                //       variable call frame.
                //
                IVariable variable = null;

                if (interpreter.GetVariableViaResolversWithSplit(
                        name, ref variableFlags,
                        ref variable) == ReturnCode.Ok)
                {
                    //
                    // NOTE: Is the variable really a link to another
                    //       variable?
                    //
                    if (FlagOps.HasFlags(eventWaitFlags,
                            EventWaitFlags.FollowLink, true) &&
                        EntityOps.IsLink(variable))
                    {
                        //
                        // NOTE: Follow the linked variable.
                        //
                        variable = EntityOps.FollowLinks(
                            variable, variableFlags);

                        if (variable == null)
                            return;
                    }

                    //
                    // NOTE: Check the variable we just found and see
                    //       if it is already undefined (i.e. from a
                    //       previous call to [vwait], etc).
                    //
                    wasUndefined = EntityOps.IsUndefined(variable);
                }
                else
                {
                    //
                    // NOTE: There is no variable; therefore, it cannot
                    //       be undefined.
                    //
                    wasUndefined = false;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReturnCode IsVariableNameSignaled(
            Interpreter interpreter,       /* in */
            string name,                   /* in */
            EventWaitFlags eventWaitFlags, /* in */
            VariableFlags variableFlags,   /* in */
            bool onlyWaiting,              /* in */
            bool onlyExists,               /* in */
            ref bool wasUndefined,         /* in */
            ref bool once,                 /* in, out */
            ref bool exists,               /* in, out */
            ref bool dirty,                /* out */
            ref Result error               /* out */
            ) /* THREAD-SAFE */
        {
            if (interpreter != null)
            {
                //
                // NOTE: *WARNING* Empty variable names are allowed, please do not
                //       change these to "!String.IsNullOrEmpty".
                //
                if (name != null)
                {
                    lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
                    {
                        //
                        // BUGFIX: Avoid disposal race condition.
                        //
                        if (!IsDeletedOrDisposed(interpreter, false, ref error))
                        {
                            //
                            // NOTE: Attempt to search for the variable in current
                            //       variable call frame.
                            //
                            string varName = null;
                            string varIndex = null;
                            IVariable variable = null;
                            Result localError = null;

                            if (interpreter.GetVariableViaResolversWithSplit(
                                    null, name, null, ref varName, ref varIndex,
                                    ref variableFlags, ref variable,
                                    ref localError) == ReturnCode.Ok)
                            {
                                //
                                // NOTE: Is the variable really a link to another
                                //       variable?
                                //
                                if (FlagOps.HasFlags(eventWaitFlags,
                                        EventWaitFlags.FollowLink, true) &&
                                    EntityOps.IsLink(variable))
                                {
                                    //
                                    // NOTE: Follow the linked variable.
                                    //
                                    variable = EntityOps.FollowLinks(
                                        variable, variableFlags, ref error);

                                    if (variable == null)
                                        goto error;
                                }

                                //
                                // NOTE: Was the variable name actually a reference to
                                //       an array element?  Tcl allows this; therefore,
                                //       we must as well.
                                //
                                if (FlagOps.HasFlags(variableFlags,
                                        VariableFlags.WasElement, true) &&
                                    EntityOps.IsArray(variable) && (varIndex != null))
                                {
                                    if (onlyWaiting)
                                    {
                                        //
                                        // NOTE: Set the dirty flag based on whether or
                                        //       not the specified element is currently
                                        //       being waited on.
                                        //
                                        dirty = EntityOps.IsWait(variable, varIndex);
                                    }
                                    else if (onlyExists)
                                    {
                                        //
                                        // NOTE: If we only care if the variable exists,
                                        //       always mark dirty now, if the specified
                                        //       array element exists.
                                        //
                                        dirty = EntityOps.IsPresent(variable, varIndex);
                                    }
                                    //
                                    // NOTE: Have we seen this array element already?
                                    //
                                    else if (once)
                                    {
                                        //
                                        // NOTE: Check if the dirty flag is set on the
                                        //       array element involved.
                                        //
                                        dirty = EntityOps.IsDirty(variable, varIndex,
                                            wasUndefined);
                                    }
                                    else
                                    {
                                        //
                                        // NOTE: Initially, this array element does exist.
                                        //
                                        exists = true;

                                        //
                                        // NOTE: Flag the array element clean now.  This
                                        //       starts the waiting process for this array
                                        //       element.  Hopefully, the array element
                                        //       will subsequently be flagged dirty and
                                        //       the wait will be over.
                                        //
                                        /* IGNORED */
                                        EntityOps.SignalClean(variable, varIndex);

                                        //
                                        // NOTE: We have now seen this variable at least
                                        //       once.
                                        //
                                        once = true;
                                    }
                                }
                                else
                                {
                                    if (onlyWaiting)
                                    {
                                        //
                                        // NOTE: Set the dirty flag based on whether or
                                        //       not the specified variable is currently
                                        //       being waited on.
                                        //
                                        dirty = EntityOps.IsWait(variable);
                                    }
                                    else if (onlyExists)
                                    {
                                        //
                                        // NOTE: If we only care if the variable exists,
                                        //       always mark dirty now.
                                        //
                                        dirty = !EntityOps.IsUndefined(variable);
                                    }
                                    //
                                    // NOTE: Have we seen this variable already?
                                    //
                                    else if (once)
                                    {
                                        //
                                        // NOTE: If the dirty flag is set, the variable
                                        //       is considered to be dirty.
                                        //
                                        dirty = EntityOps.IsDirty(variable);
                                    }
                                    else
                                    {
                                        //
                                        // NOTE: Initially, this variable does exist.
                                        //
                                        exists = true;

                                        //
                                        // NOTE: Flag the variable clean now.  This starts
                                        //       the waiting process for this variable.
                                        //       Hopefully, the variable will subsequently
                                        //       be flagged dirty and the wait will be over.
                                        //
                                        /* IGNORED */
                                        EntityOps.SignalClean(variable);

                                        //
                                        // NOTE: We have now seen this variable at least
                                        //       once.
                                        //
                                        once = true;
                                    }
                                }

                                //
                                // NOTE: If the variable is dirty and tracing is enabled,
                                //       display debugging information before returning.
                                //
                                if (dirty && FlagOps.HasFlags(
                                        eventWaitFlags, EventWaitFlags.Trace, true))
                                {
                                    TraceOps.DebugTrace(String.Format(
                                        "IsVariableNameSignaled: variable resolved, code = Ok, " +
                                        "interpreter = {0}, name = {1}, varName = {2}, " +
                                        "varIndex = {3}, eventWaitFlags = {4}, " +
                                        "variableFlags = {5}, onlyWaiting = {6}, " +
                                        "onlyExists = {7}, wasUndefined = {8}, once = {9}, " +
                                        "exists = {10}, dirty = {11}, error = {12}",
                                        FormatOps.InterpreterNoThrow(interpreter),
                                        FormatOps.WrapOrNull(name), FormatOps.WrapOrNull(
                                        varName), FormatOps.WrapOrNull(varIndex),
                                        FormatOps.WrapOrNull(eventWaitFlags),
                                        FormatOps.WrapOrNull(variableFlags), onlyWaiting,
                                        onlyExists, wasUndefined, once, exists, dirty,
                                        FormatOps.WrapOrNull(true, true, error)),
                                        typeof(Interpreter).Name, TracePriority.EventDebug);
                                }

                                return ReturnCode.Ok;
                            }
                            else
                            {
                                //
                                // NOTE: Did we actually search for the variable?
                                //
                                if (FlagOps.HasFlags(variableFlags, VariableFlags.NotFound, true))
                                {
                                    //
                                    // NOTE: Have we seen this variable already?
                                    //
                                    if (once)
                                    {
                                        //
                                        // NOTE: If the variable existed previously and
                                        //       it does not exist now then it is dirty.
                                        //
                                        if (!onlyWaiting && exists)
                                            dirty = true;
                                    }
                                    else
                                    {
                                        //
                                        // NOTE: Initially, this variable does not exist.
                                        //
                                        exists = false;

                                        //
                                        // NOTE: We have now seen this variable at least
                                        //       once.
                                        //
                                        once = true;
                                    }

                                    //
                                    // BUGFIX: If we previously waited on another
                                    //         variable that happened to exist, the
                                    //         variable event for the interpreter may
                                    //         already be in a signaled state and we
                                    //         do not want that; therefore, reset it
                                    //         now.
                                    //
                                    /* IGNORED */
                                    ThreadOps.ResetEvent(interpreter.PrivateVariableEvent);

                                    //
                                    // NOTE: If the variable is dirty and tracing is enabled,
                                    //       display debugging information before returning.
                                    //
                                    if (dirty && FlagOps.HasFlags(
                                            eventWaitFlags, EventWaitFlags.Trace, true))
                                    {
                                        TraceOps.DebugTrace(String.Format(
                                            "IsVariableNameSignaled: variable unresolved, " +
                                            "code = Ok, interpreter = {0}, name = {1}, " +
                                            "varName = {2}, varIndex = {3}, " +
                                            "eventWaitFlags = {4}, variableFlags = {5}, " +
                                            "onlyWaiting = {6}, onlyExists = {7}, " +
                                            "wasUndefined = {8}, once = {9}, exists = {10}, " +
                                            "dirty = {11}, error = {12}",
                                            FormatOps.InterpreterNoThrow(interpreter),
                                            FormatOps.WrapOrNull(name), FormatOps.WrapOrNull(
                                            varName), FormatOps.WrapOrNull(varIndex),
                                            FormatOps.WrapOrNull(eventWaitFlags),
                                            FormatOps.WrapOrNull(variableFlags), onlyWaiting,
                                            onlyExists, wasUndefined, once, exists, dirty,
                                            FormatOps.WrapOrNull(true, true, error)),
                                            typeof(Interpreter).Name, TracePriority.EventDebug);
                                    }

                                    return ReturnCode.Ok;
                                }
                                else
                                {
                                    //
                                    // NOTE: We could not search for the variable, let the
                                    //       caller know why.
                                    //
                                    error = localError;
                                }
                            }
                        }
                    }
                }
                else
                {
                    error = "invalid variable name";
                }
            }
            else
            {
                error = "invalid interpreter";
            }

        error:

            //
            // NOTE: If the variable is dirty and tracing is enabled,
            //       display debugging information before returning.
            //
            if (dirty && FlagOps.HasFlags(
                    eventWaitFlags, EventWaitFlags.Trace, true))
            {
                TraceOps.DebugTrace(String.Format(
                    "IsVariableNameSignaled: code = Error, " +
                    "interpreter = {0}, name = {1}, " +
                    "eventWaitFlags = {2}, variableFlags = {3}, " +
                    "onlyWaiting = {4}, onlyExists = {5}, " +
                    "wasUndefined = {6}, once = {7}, " +
                    "exists = {8}, dirty = {9}, error = {10}",
                    FormatOps.InterpreterNoThrow(interpreter),
                    FormatOps.WrapOrNull(name),
                    FormatOps.WrapOrNull(eventWaitFlags),
                    FormatOps.WrapOrNull(variableFlags), onlyWaiting,
                    onlyExists, wasUndefined, once, exists, dirty,
                    FormatOps.WrapOrNull(true, true, error)),
                    typeof(Interpreter).Name, TracePriority.EventError);
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool ShouldWaitVariable()
        {
            //
            // BUGFIX: Prevent possible future deadlock caused by holding
            //         the interpreter lock while calling the Enabled and
            //         EventCount properties method, which may at some
            //         point acquire and hold the event manager lock.
            //
            IEventManager eventManager = TryGetEventManager();

            if (EventOps.ManagerIsOk(eventManager))
            {
                bool locked = false;
                bool enabled = false;
                int totalEventCount = 0;

                try
                {
                    eventManager.TryLock(ref locked); /* TRANSACTIONAL */

                    if (locked)
                    {
                        enabled = eventManager.Enabled;
                        totalEventCount = eventManager.TotalEventCount;
                    }
                    else
                    {
                        TraceOps.DebugTrace(
                            "ShouldWaitVariable: unable to acquire lock",
                            typeof(Interpreter).Name,
                            TracePriority.LockError);

                        return false;
                    }
                }
                catch (Exception e)
                {
                    TraceOps.DebugTrace(
                        e, typeof(Interpreter).Name,
                        TracePriority.LockError);
                }
                finally
                {
                    eventManager.ExitLock(ref locked); /* TRANSACTIONAL */
                }

                return enabled && ((totalEventCount > 0)
#if NETWORK
                    || (serverSockets > 0)
#endif
                    );
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // TODO: When calling this method, be extremely careful when
        //       passing "false" as the "waitForLock" parameter; it
        //       should not be used when the caller cannot handle a
        //       null return value gracefully (e.g. from the method
        //       ShouldWaitVariable).  In this context, "gracefully"
        //       means that the caller would end up providing mostly
        //       the same functionality to its caller regardless of
        //       the return value of this method.
        //
        private EventWaitHandle[] GetEventWaitHandles(
            EventWaitHandle auxiliaryEvent,
            int timeout,
            bool waitForLock,
            bool noEventManager,
            bool resetEvents
            )
        {
            //
            // NOTE: If the variable event cannot be obtained, e.g. lock
            //       failure, the caller cannot meaningfully wait for any
            //       events.
            //
            EventWaitHandle variableEvent = TryGetVariableEvent(
                timeout, waitForLock);

            if (variableEvent == null)
                return null;

            EventWaitHandle emptyEvent = null;
            EventWaitHandle enqueueEvent = null;
            EventWaitHandle idleEmptyEvent = null;
            EventWaitHandle idleEnqueueEvent = null;
            EventWaitHandle[] userEvents = null;

            if (!noEventManager)
            {
                IEventManager eventManager = TryGetEventManager(
                    timeout, waitForLock);

                //
                // NOTE: Actually, the event manager is optional here.
                //       We can wait for a variable (i.e. to be changed
                //       or unset) without it.
                //
                // if (eventManager == null)
                //     return null;
                //
                if (EventOps.ManagerIsOk(eventManager))
                {
                    bool locked = false;

                    try
                    {
                        eventManager.TryLock(ref locked); /* TRANSACTIONAL */

                        if (locked)
                        {
                            emptyEvent = eventManager.EmptyEvent;
                            enqueueEvent = eventManager.EnqueueEvent;
                            idleEmptyEvent = eventManager.IdleEmptyEvent;
                            idleEnqueueEvent = eventManager.IdleEnqueueEvent;
                            userEvents = eventManager.UserEvents;
                        }
                        else
                        {
                            TraceOps.DebugTrace(
                                "GetEventWaitHandles: unable to acquire lock",
                                typeof(Interpreter).Name,
                                TracePriority.LockError);
                        }
                    }
                    catch (Exception e)
                    {
                        TraceOps.DebugTrace(
                            e, typeof(Interpreter).Name,
                            TracePriority.LockError);
                    }
                    finally
                    {
                        eventManager.ExitLock(ref locked); /* TRANSACTIONAL */
                    }
                }
            }

            int length = 0;

            if (variableEvent != null)
                length++;

            if (emptyEvent != null)
                length++;

            if (enqueueEvent != null)
                length++;

            if (idleEmptyEvent != null)
                length++;

            if (idleEnqueueEvent != null)
                length++;

            if (auxiliaryEvent != null)
                length++;

            if (userEvents != null)
                length += userEvents.Length;

            if (length > 0)
            {
                EventWaitHandle[] events = new EventWaitHandle[length];
                int startIndex = 0;

                if ((length > startIndex) && (variableEvent != null))
                    events[startIndex++] = variableEvent;

                if ((length > startIndex) && (emptyEvent != null))
                    events[startIndex++] = emptyEvent;

                if ((length > startIndex) && (enqueueEvent != null))
                    events[startIndex++] = enqueueEvent;

                if ((length > startIndex) && (idleEmptyEvent != null))
                    events[startIndex++] = idleEmptyEvent;

                if ((length > startIndex) && (idleEnqueueEvent != null))
                    events[startIndex++] = idleEnqueueEvent;

                //
                // NOTE: *HOOK* Allow the immediate caller to inject an event
                //       into the array to wait for.
                //
                if ((length > startIndex) && (auxiliaryEvent != null))
                    events[startIndex++] = auxiliaryEvent;

                //
                // NOTE: *HOOK* Allow external applications and/or users to
                //       cleanly interact with the core event loop.
                //
                if (length > startIndex)
                {
                    for (int index = startIndex; index < length; index++)
                    {
                        EventWaitHandle userEvent =
                            userEvents[index - startIndex];

                        if (userEvent != null)
                            events[index] = userEvent;
                    }
                }

                if (resetEvents)
                {
                    //
                    // NOTE: Minimally, we need to reset the shared variable
                    //       event to make sure we do not [always] return
                    //       immediately from the wait call inside the loop.
                    //
                    for (int index = 0; index < length; index++)
                    {
                        EventWaitHandle @event = events[index];

                        if (@event != null)
                            ThreadOps.ResetEvent(@event);
                    }
                }

                return events;
            }

            return null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateLockVariable(
            EventWaitFlags eventWaitFlags, /* in */
            VariableFlags variableFlags,   /* in */
            string name,                   /* in */
            long microseconds,             /* in */
            EventWaitHandle @event,        /* in, optional */
            ref Result error               /* out */
            ) /* THREAD-SAFE */
        {
            if (microseconds < 0)
            {
                error = "number of microseconds cannot be negative";
                return ReturnCode.Error;
            }

            //
            // TODO: Maybe make this more adjustable?
            //
            int readyMilliseconds = (microseconds != 0) ?
                DefaultReadyTimeout : 0;

            bool noTimeout = (readyMilliseconds <= 0) || FlagOps.HasFlags(
                eventWaitFlags, EventWaitFlags.NoTimeout, true);

            bool noCancel = FlagOps.HasFlags(
                eventWaitFlags, EventWaitFlags.NoCancel, true);

            bool noGlobalCancel = FlagOps.HasFlags(
                eventWaitFlags, EventWaitFlags.NoGlobalCancel, true);

            bool noWindows = FlagOps.HasFlags(
                eventWaitFlags, EventWaitFlags.NoWindows, true);

            bool noWait = FlagOps.HasFlags(
                eventWaitFlags, EventWaitFlags.NoWait, true);

            bool noSleep = FlagOps.HasFlags(
                eventWaitFlags, EventWaitFlags.NoSleep, true);

            long startCount = PerformanceOps.GetCount();

            long slopMicroseconds = EventOps.GetSlopMicroseconds(
                microseconds);

            int sleepMilliseconds = GetMinimumSleepTime(
                SleepType.Variable, EventOps.GetMilliseconds(
                microseconds));

            Result localError = null; /* REUSED */

            while ((microseconds == 0) || !PerformanceOps.HasElapsed(
                    startCount, microseconds, slopMicroseconds))
            {
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    VariableFlags localVariableFlags = variableFlags;
                    IVariable variable = null;

                    localVariableFlags |= VariableFlags.NoUsable;
                    localError = null;

                    if (GetVariableViaResolversWithSplit(
                            name, ref localVariableFlags, ref variable,
                            ref localError) != ReturnCode.Ok)
                    {
                        error = localError;
                        break;
                    }

                    localError = null;

                    if (variable.Lock(ref localError))
                        return ReturnCode.Ok;

                    if (noWait)
                    {
                        error = localError;
                        return ReturnCode.Error;
                    }
                }

                if (!noSleep) // NOTE: Somewhat dangerous for CPU usage.
                {
                    localError = null;

                    if (EventOps.Wait(
                            this, @event, PerformanceOps.GetMicroseconds(
                            sleepMilliseconds), PerformanceOps.GetMicroseconds(
                            readyMilliseconds), !noTimeout, noWindows, noCancel,
                            noGlobalCancel, ref localError) != ReturnCode.Ok)
                    {
                        error = localError;
                        break;
                    }
                }
            }

            if (localError != null)
            {
                error = localError;
            }
            else
            {
                error = String.Format(
                    "timed out attempting to lock variable {0}",
                    FormatOps.ErrorVariableName(name));
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateUnlockVariable(
            VariableFlags variableFlags, /* in */
            string name,                 /* in */
            ref Result error             /* out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                IVariable variable = null;
                Result localError; /* REUSED */

                variableFlags |= VariableFlags.NoUsable;
                localError = null;

                if (GetVariableViaResolversWithSplit(
                        name, ref variableFlags, ref variable,
                        ref localError) != ReturnCode.Ok)
                {
                    error = localError;
                    return ReturnCode.Error;
                }

                localError = null;

                if (!variable.Unlock(ref localError))
                {
                    error = localError;
                    return ReturnCode.Error;
                }

                return ReturnCode.Ok;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Variable Management (Multiple)
        public ReturnCode ListVariables(
            string pattern,      /* in */
            bool noCase,         /* in */
            bool stopOnError,    /* in: NOT USED */
            ref StringList list, /* out */
            ref Result error     /* out */
            )
        {
            CheckDisposed();

            return ListVariables(
                VariableFlags.None, pattern, noCase, stopOnError,
                ref list, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode ListVariables(
            VariableFlags variableFlags, /* in */
            string pattern,              /* in */
            bool noCase,                 /* in */
            bool stopOnError,            /* in: NOT USED */
            ref StringList list,         /* out */
            ref Result error             /* out */
            )
        {
            CheckDisposed();

            list = VariablesToList(variableFlags, pattern, noCase, ref error);
            return (list != null) ? ReturnCode.Ok : ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetVariableValues(
            IDictionary<string, object> variables, /* in, out */
            bool stopOnError,                      /* in */
            ref int getOk,                         /* in, out */
            ref Result error                       /* out */
            )
        {
            CheckDisposed();

            return GetVariableValues(
                VariableFlags.None, variables, stopOnError,
                ref getOk, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode GetVariableValues(
            VariableFlags flags,                   /* in */
            IDictionary<string, object> variables, /* in, out */
            bool stopOnError,                      /* in */
            ref int getOk,                         /* in, out */
            ref Result error                       /* out */
            )
        {
            CheckDisposed();

            if (variables == null)
            {
                error = "invalid variable list";
                return ReturnCode.Error;
            }

            StringList names = new StringList(variables.Keys);

            foreach (string name in names)
            {
                if (name == null) /* IMPOSSIBLE? */
                    continue;

                ReturnCode code;
                Result value = null;
                Result localError = null;

                code = GetVariableValue(
                    flags, name, ref value, ref localError);

                //
                // NOTE: Non-strict mode allows us to unconditionally
                //       query a group of variables without worrying
                //       that some of them may not actually exist.
                //
                if (code == ReturnCode.Ok)
                {
                    //
                    // NOTE: Success, replace contained value with
                    //       queried value.
                    //
                    variables[name] = Result.GetValue(value);

                    //
                    // NOTE: Another variable value was fetched.
                    //
                    getOk++;
                }
                else if (stopOnError)
                {
                    //
                    // NOTE: Failure, return error code to caller.
                    //
                    error = localError;
                    return code;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SetVariableValues(
            IDictionary<string, object> variables, /* in */
            bool stopOnError,                      /* in */
            ref int setOk,                         /* in, out */
            ref Result error                       /* out */
            )
        {
            CheckDisposed();

            return SetVariableValues(
                VariableFlags.None, null, variables, stopOnError,
                ref setOk, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode SetVariableValues(
            VariableFlags flags,                   /* in */
            TraceList traces,                      /* in */
            IDictionary<string, object> variables, /* in */
            bool stopOnError,                      /* in */
            ref int setOk,                         /* in, out */
            ref Result error                       /* out */
            )
        {
            CheckDisposed();

            if (variables == null)
            {
                error = "invalid variable list";
                return ReturnCode.Error;
            }

            foreach (KeyValuePair<string, object> pair in variables)
            {
                string name = pair.Key;

                if (name == null) /* IMPOSSIBLE? */
                    continue;

                ReturnCode code;
                object value = pair.Value;
                Result localError = null;

                code = SetVariableValue2(
                    flags, name, value, traces, ref localError);

                //
                // NOTE: Non-strict mode allows us to unconditionally
                //       change a group of variables without worrying
                //       that some of them may actually be read-only,
                //       etc.
                //
                if (code == ReturnCode.Ok)
                {
                    //
                    // NOTE: Another variable value was changed.
                    //
                    setOk++;
                }
                else if (stopOnError)
                {
                    //
                    // NOTE: Failure, return error code to caller.
                    //
                    error = localError;
                    return code;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode UnsetVariables(
            IDictionary<string, object> variables, /* in */
            bool stopOnError,                      /* in */
            ref int unsetOk,                       /* in, out */
            ref Result error                       /* out */
            )
        {
            CheckDisposed();

            return UnsetVariables(
                VariableFlags.None, variables, stopOnError,
                ref unsetOk, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public ReturnCode UnsetVariables(
            VariableFlags flags,                   /* in */
            IDictionary<string, object> variables, /* in */
            bool stopOnError,                      /* in */
            ref int unsetOk,                       /* in, out */
            ref Result error                       /* out */
            )
        {
            CheckDisposed();

            if (variables == null)
            {
                error = "invalid variable list";
                return ReturnCode.Error;
            }

            foreach (KeyValuePair<string, object> pair in variables)
            {
                string name = pair.Key;

                if (name == null) /* IMPOSSIBLE? */
                    continue;

                ReturnCode code;
                Result localError = null;

                code = UnsetVariable(flags, name, ref localError);

                //
                // NOTE: Non-strict mode allows us to unconditionally
                //       delete a group of variables without worrying
                //       that some of them may actually be read-only,
                //       etc.
                //
                if (code == ReturnCode.Ok)
                {
                    //
                    // NOTE: Another variable was deleted.
                    //
                    unsetOk++;
                }
                else if (stopOnError)
                {
                    //
                    // NOTE: Failure, return error code to caller.
                    //
                    error = localError;
                    return code;
                }
            }

            return ReturnCode.Ok;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Status Data
#if WINFORMS
        internal bool MaybeSetStatusThread(
            Thread thread
            )
        {
            return Object.ReferenceEquals(Interlocked.CompareExchange(
                ref statusThread, thread, null), null);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool MaybeResetStatusThread(
            Thread thread,
            bool ignoreNull
            )
        {
            Thread oldThread = Interlocked.CompareExchange(
                ref statusThread, null, thread);

            if (oldThread == null)
            {
                TraceOps.DebugTrace(
                    "MaybeResetStatusThread: old thread was already null",
                    typeof(Interpreter).Name, TracePriority.StatusError);

                return ignoreNull;
            }

            return Object.ReferenceEquals(oldThread, thread);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal Thread StatusThread
        {
            get { return Interlocked.CompareExchange(ref statusThread, null, null); }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string StatusStartEventName
        {
            get { return Interlocked.CompareExchange(ref statusStartEventName, null, null); }
            set { Interlocked.Exchange(ref statusStartEventName, value); }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string StatusDoneEventName
        {
            get { return Interlocked.CompareExchange(ref statusDoneEventName, null, null); }
            set { Interlocked.Exchange(ref statusDoneEventName, value); }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal object StatusObject
        {
            get { return Interlocked.CompareExchange(ref statusObject, null, null); }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal StatusCallback StatusCallback
        {
            set { Interlocked.Exchange(ref statusCallback, value); }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool MaybeSetStatusObject(
            object value
            )
        {
            return Object.ReferenceEquals(Interlocked.CompareExchange(
                ref statusObject, value, null), null);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool MaybeResetStatusObject(
            object value,
            bool ignoreNull
            )
        {
            object oldValue = Interlocked.CompareExchange(
                ref statusObject, null, value);

            if (oldValue == null)
            {
                TraceOps.DebugTrace(
                    "MaybeResetStatusObject: old object was already null",
                    typeof(Interpreter).Name, TracePriority.StatusError);

                return ignoreNull;
            }

            return Object.ReferenceEquals(oldValue, value);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool MaybeInvokeStatusCallback(
            IClientData clientData,
            string text,
            bool clear,
            ref Result error
            )
        {
            StatusCallback callback = Interlocked.CompareExchange(
                ref statusCallback, null, null);

            if (callback != null)
            {
                try
                {
                    ReturnCode code = callback(
                        this, clientData, text, clear,
                        ref error); /* throw */

                    if (code == ReturnCode.Return)
                        return true;
                }
                catch (Exception e)
                {
                    error = e;
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterStatusLevel()
        {
            return Interlocked.Increment(ref statusLevels);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitStatusLevel()
        {
            return Interlocked.Decrement(ref statusLevels);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool CheckStatusDisposed()
        {
            return Interlocked.CompareExchange(ref statusDisposed, 0, 0) > 0;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int MarkStatusDisposed()
        {
            return Interlocked.Increment(ref statusDisposed);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ResetStatusDisposed()
        {
            return Interlocked.Exchange(ref statusDisposed, 0);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal long GetStatusIterations()
        {
            return Interlocked.CompareExchange(ref statusIterations, 0, 0);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal long AnotherStatusIteration()
        {
            return Interlocked.Increment(ref statusIterations);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Creation, Pre-Setup, Setup, & Initialization
        #region Creation
        internal CreateFlags FilterCreateFlags(
            bool debug,
            bool safe,
            bool standard
            )
        {
            CreateFlags result = CreateFlags.None;

            lock (syncRoot) /* TRANSACTIONAL */
            {
#if DEBUGGER
                if (debug)
                    result |= (createFlags & CreateFlags.DebuggerUse);
#endif

                if (safe)
                    result |= (createFlags & CreateFlags.SafeAndHideUnsafe);

                if (standard)
                    result |= (createFlags & CreateFlags.StandardAndHideNonStandard);
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal HostCreateFlags FilterHostCreateFlags(
            bool debug
            )
        {
            HostCreateFlags result = HostCreateFlags.None;

            lock (syncRoot) /* TRANSACTIONAL */
            {
#if DEBUGGER
                if (debug)
                    result |= (hostCreateFlags & HostCreateFlags.DebuggerUse);
#endif
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NATIVE && NATIVE_UTILITY
        internal static bool IsVerbose(
            Interpreter interpreter
            )
        {
            if (interpreter == null)
                return false;

            return FlagOps.HasFlags(
                interpreter.CreateFlagsNoLock, CreateFlags.Verbose, true);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // BUGBUG: This method is currently a no-op if the TEST or SHELL compile-times option are not
        //         defined.
        //
        public static ReturnCode GetStartupLogFileName(
            IEnumerable<string> args,
            OptionOriginFlags originFlags,
            bool console,
            bool verbose,
            ref string fileName,
            ref Result error
            )
        {
            ReturnCode code = ReturnCode.Ok;
            StringList argv = (args != null) ? new StringList(args) : null;

            TraceOps.DebugTrace(String.Format(
                "GetStartupLogFileName: entered, argv = {0}, originFlags = {1}, " +
                "console = {2}, verbose = {3}, fileName = {4}, code = {5}, " +
                "error = {6}", FormatOps.WrapOrNull(true, true, argv),
                FormatOps.WrapOrNull(originFlags), console, verbose,
                FormatOps.WrapOrNull(fileName), code, FormatOps.WrapOrNull(
                true, true, error)), typeof(Interpreter).Name,
                TracePriority.StartupDebug);

#if SHELL && TEST
            string localFileName = null;

            code = ShellOps.GetArgumentValue(
                argv, CommandLineOption.StartupLogFile, true, ref localFileName,
                ref error);

            if (code == ReturnCode.Ok)
            {
                fileName = (localFileName != null) ?
                    CommonOps.Environment.ExpandVariables(localFileName) :
                    localFileName;

                if ((argv != null) &&
                    FlagOps.HasFlags(originFlags, OptionOriginFlags.Remove, true))
                {
                    IList<string> list = args as IList<string>;

                    if (list != null)
                    {
                        list.Clear();

                        foreach (string arg in argv)
                            list.Add(arg);
                    }
                }
            }
#endif

            TraceOps.DebugTrace(String.Format(
                "GetStartupLogFileName: exited, argv = {0}, originFlags = {1}, " +
                "console = {2}, verbose = {3}, fileName = {4}, code = {5}, " +
                "error = {6}", FormatOps.WrapOrNull(true, true, argv),
                FormatOps.WrapOrNull(originFlags), console, verbose,
                FormatOps.WrapOrNull(fileName), code, FormatOps.WrapOrNull(
                true, true, error)), typeof(Interpreter).Name,
                TracePriority.StartupDebug);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void RefreshConsoleAndVerbose(
            HostCreateFlags hostCreateFlags, /* in */
            out bool console,                /* out */
            out bool verbose                 /* out */
            )
        {
            console = !FlagOps.HasFlags(
                hostCreateFlags, HostCreateFlags.Disable, true) &&
            !FlagOps.HasFlags(
                hostCreateFlags, HostCreateFlags.NoConsole, true);

            verbose = !FlagOps.HasFlags(
                hostCreateFlags, HostCreateFlags.NoVerbose, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static CreateFlags GetStartupCreateFlags(
            IEnumerable<string> args,
            CreateFlags createFlags,
            OptionOriginFlags originFlags,
            bool console,
            bool verbose
            )
        {
            StringList argv = (args != null) ? new StringList(args) : null;

            TraceOps.DebugTrace(String.Format(
                "GetStartupCreateFlags: entered, argv = {0}, createFlags = {1}, " +
                "originFlags = {2}, console = {3}, verbose = {4}",
                FormatOps.WrapOrNull(true, true, argv),
                FormatOps.WrapOrNull(createFlags), FormatOps.WrapOrNull(originFlags),
                console, verbose), typeof(Interpreter).Name,
                TracePriority.StartupDebug);

            if (verbose)
            {
// #if CONSOLE
//                 ConsoleOps.MaybeWritePrompt(
//                     _Constants.Prompt.Verbose,
//                     console, verbose);
// #endif

                createFlags |= CreateFlags.Verbose;
            }

            if (FlagOps.HasFlags(
                    originFlags, OptionOriginFlags.Environment, true))
            {
                //
                // NOTE: Check for the debug environment variable.
                //       If it is set (to anything) then set the
                //       debug flag for the interpreter right now.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.Debug, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(String.Format(
                        _Constants.Prompt.Debug,
                        _Constants.Prompt.ViaEnvironment),
                        console, verbose);
#endif

                    createFlags |= CreateFlags.Debug;
                }

                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.MeasureTime, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(
                        _Constants.Prompt.MeasureTime,
                        console, verbose);
#endif

                    createFlags |= CreateFlags.MeasureTime;
                }

                //
                // NOTE: Check for the "safe" environment variable.
                //       If it is set (to anything) then enable the
                //       appropriate "safe mode" flags for the
                //       interpreter.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.Safe, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(String.Format(
                        _Constants.Prompt.Safe,
                        _Constants.Prompt.ViaEnvironment),
                        console, verbose);
#endif

                    createFlags |= CreateFlags.SafeAndHideUnsafe;
                }

                //
                // NOTE: Check for the "standard" environment variable.
                //       If it is set (to anything) then enable the
                //       appropriate "standard mode" flags for the
                //       interpreter.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.Standard, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(String.Format(
                        _Constants.Prompt.Standard,
                        _Constants.Prompt.ViaEnvironment),
                        console, verbose);
#endif

                    createFlags |= CreateFlags.StandardAndHideNonStandard;
                }

                //
                // NOTE: Check for the no-initialize environment variable.
                //       If it is set (to anything) then skip initialization
                //       of the interpreter.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.NoInitialize, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(String.Format(
                        _Constants.Prompt.NoInitialize,
                        _Constants.Prompt.ViaEnvironment),
                        console, verbose);
#endif

                    createFlags &= ~CreateFlags.Initialize;
                }

                //
                // NOTE: Check for the no-throw-on-disposed environment variable.
                //       If it is set (to anything) then we will not throw exceptions
                //       when a disposed object is accessed.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.NoThrowOnDisposed, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(
                        _Constants.Prompt.NoThrowOnDisposed,
                        console, verbose);
#endif

                    createFlags &= ~CreateFlags.ThrowOnDisposed;
                }

#if NATIVE && NATIVE_UTILITY
                //
                // NOTE: Check for the no-utility environment variable.
                //       If it is set (to anything) then the native utility
                //       library will not be loaded.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.NoNativeUtility, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(
                        _Constants.Prompt.NoNativeUtility,
                        console, verbose);
#endif

                    createFlags |= CreateFlags.NoNativeUtility;
                }
#endif

                //
                // NOTE: Does the caller want to allow the CreateFlags to be
                //       overridden directly via the environment?
                //
                if (FlagOps.HasFlags(
                        originFlags, OptionOriginFlags.Override, true))
                {
                    //
                    // NOTE: Check for the CreateFlags environment variable.
                    //       If it is set (and valid) then we will use it to
                    //       modify the creation flags for the interpreter.
                    //
                    string value = GlobalConfiguration.GetValue(
                        EnvVars.CreateFlags, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose));

                    if (!String.IsNullOrEmpty(value))
                    {
#if CONSOLE
                        ConsoleOps.MaybeWritePrompt(String.Format(
                            _Constants.Prompt.CreateFlags, value),
                            console, verbose);
#endif

                        object enumValue;
                        Result enumError = null;

                        enumValue = EnumOps.TryParseFlags(
                            null, typeof(CreateFlags), createFlags.ToString(),
                            value, null, true, true, true, ref enumError);

                        if (enumValue is CreateFlags)
                            createFlags = (CreateFlags)enumValue;
                        else
                            DebugOps.Complain(ReturnCode.Error, enumError);
                    }
                }
            }

            TraceOps.DebugTrace(String.Format(
                "GetStartupCreateFlags: exited, argv = {0}, createFlags = {1}, " +
                "originFlags = {2}, console = {3}, verbose = {4}",
                FormatOps.WrapOrNull(true, true, argv),
                FormatOps.WrapOrNull(createFlags), FormatOps.WrapOrNull(originFlags),
                console, verbose), typeof(Interpreter).Name,
                TracePriority.StartupDebug);

            return createFlags;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static HostCreateFlags GetStartupHostCreateFlags(
            IEnumerable<string> args,
            HostCreateFlags hostCreateFlags,
            OptionOriginFlags originFlags,
            bool console,
            bool verbose
            )
        {
            StringList argv = (args != null) ? new StringList(args) : null;

            TraceOps.DebugTrace(String.Format(
                "GetStartupHostCreateFlags: entered, argv = {0}, " +
                "hostCreateFlags = {1}, originFlags = {2}, " +
                "console = {3}, verbose = {4}",
                FormatOps.WrapOrNull(true, true, argv),
                FormatOps.WrapOrNull(hostCreateFlags),
                FormatOps.WrapOrNull(originFlags),
                console, verbose), typeof(Interpreter).Name,
                TracePriority.StartupDebug);

            if (FlagOps.HasFlags(
                    originFlags, OptionOriginFlags.Environment, true))
            {
                //
                // NOTE: Check for the debug environment variable.
                //       If it is set (to anything) then set the
                //       debug flag for the interpreter right now.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.Debug, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(String.Format(
                        _Constants.Prompt.Debug,
                        _Constants.Prompt.ViaHostEnvironment),
                        console, verbose);
#endif

                    hostCreateFlags |= HostCreateFlags.Debug;
                }

                //
                // NOTE: Check for the use-attach environment variable.
                //       If it is set (to anything) then make sure the
                //       console will be attached if necessary.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.UseAttach, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(
                        _Constants.Prompt.UseAttach,
                        console, verbose);
#endif

                    hostCreateFlags |= HostCreateFlags.UseAttach;
                }

#if CONSOLE
                //
                // NOTE: Check for the no-close environment variable.
                //       If it is set (to anything) then make sure the
                //       console window cannot be closed.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.NoClose, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(
                        _Constants.Prompt.NoClose,
                        console, verbose);
#endif

                    hostCreateFlags |= HostCreateFlags.NoCloseConsole;
                }
#endif

                //
                // NOTE: Check for the no-color environment variable.
                //       If it is set (to anything) then make sure the
                //       console output will not be in color.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.NoColor, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(
                        _Constants.Prompt.NoColor,
                        console, verbose);
#endif

                    hostCreateFlags |= HostCreateFlags.NoColor;
                }

                //
                // NOTE: Check for the no-title environment variable.
                //       If it is set (to anything) then skip setting the
                //       console title.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.NoTitle, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(
                        _Constants.Prompt.NoTitle,
                        console, verbose);
#endif

                    hostCreateFlags |= HostCreateFlags.NoTitle;
                }

                //
                // NOTE: Check for the no-icon environment variable.
                //       If it is set (to anything) then skip setting the
                //       console icon.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.NoIcon, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(
                        _Constants.Prompt.NoIcon,
                        console, verbose);
#endif

                    hostCreateFlags |= HostCreateFlags.NoIcon;
                }

                //
                // NOTE: Check for the no-profile environment variable.
                //       If it is set (to anything) then skip loading the
                //       host profile.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.NoProfile, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(
                        _Constants.Prompt.NoProfile,
                        console, verbose);
#endif

                    hostCreateFlags |= HostCreateFlags.NoProfile;
                }

                //
                // NOTE: Check for the no-cancel environment variable.
                //       If it is set (to anything) then skip setting up the
                //       console script cancellation keypress, etc.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.NoCancel, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose)))
                {
#if CONSOLE
                    ConsoleOps.MaybeWritePrompt(
                        _Constants.Prompt.NoCancel,
                        console, verbose);
#endif

                    hostCreateFlags |= HostCreateFlags.NoCancel;
                }

                //
                // NOTE: Does the caller want to allow the HostCreateFlags
                //       to be overridden directly via the environment?
                //
                if (FlagOps.HasFlags(
                        originFlags, OptionOriginFlags.Override, true))
                {
                    //
                    // NOTE: Check for HostCreateFlags in the environment.
                    //       If it is set (and valid) then we will use it to
                    //       modify the creation flags for the interpreter.
                    //
                    string value = GlobalConfiguration.GetValue(
                        EnvVars.HostCreateFlags, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose));

                    if (!String.IsNullOrEmpty(value))
                    {
#if CONSOLE
                        ConsoleOps.MaybeWritePrompt(String.Format(
                            _Constants.Prompt.HostCreateFlags, value),
                            console, verbose);
#endif

                        object enumValue;
                        Result enumError = null;

                        enumValue = EnumOps.TryParseFlags(
                            null, typeof(HostCreateFlags),
                            hostCreateFlags.ToString(), value,
                            null, true, true, true, ref enumError);

                        if (enumValue is HostCreateFlags)
                            hostCreateFlags = (HostCreateFlags)enumValue;
                        else
                            DebugOps.Complain(ReturnCode.Error, enumError);
                    }
                }
            }

            TraceOps.DebugTrace(String.Format(
                "GetStartupHostCreateFlags: exited, argv = {0}, " +
                "hostCreateFlags = {1}, originFlags = {2}, " +
                " console = {3}, verbose = {4}",
                FormatOps.WrapOrNull(true, true, argv),
                FormatOps.WrapOrNull(hostCreateFlags),
                FormatOps.WrapOrNull(originFlags),
                console, verbose), typeof(Interpreter).Name,
                TracePriority.StartupDebug);

            return hostCreateFlags;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static InitializeFlags GetStartupInitializeFlags(
            IEnumerable<string> args,
            InitializeFlags initializeFlags,
            OptionOriginFlags originFlags,
            bool console,
            bool verbose
            )
        {
            StringList argv = (args != null) ? new StringList(args) : null;

            TraceOps.DebugTrace(String.Format(
                "GetStartupInitializeFlags: entered, argv = {0}, " +
                "initializeFlags = {1}, originFlags = {2}, " +
                "console = {3}, verbose = {4}",
                FormatOps.WrapOrNull(true, true, argv),
                FormatOps.WrapOrNull(initializeFlags),
                FormatOps.WrapOrNull(originFlags),
                console, verbose), typeof(Interpreter).Name,
                TracePriority.StartupDebug);

            if (FlagOps.HasFlags(
                    originFlags, OptionOriginFlags.Environment, true))
            {
                //
                // NOTE: Does the caller want to allow the InitializeFlags
                //       to be overridden directly via the environment?
                //
                if (FlagOps.HasFlags(
                        originFlags, OptionOriginFlags.Override, true))
                {
                    //
                    // NOTE: Check for InitializeFlags in the environment.
                    //       If it is set (and valid) then we will use it to
                    //       modify the creation flags for the interpreter.
                    //
                    string value = GlobalConfiguration.GetValue(
                        EnvVars.InitializeFlags, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose));

                    if (!String.IsNullOrEmpty(value))
                    {
#if CONSOLE
                        ConsoleOps.MaybeWritePrompt(String.Format(
                            _Constants.Prompt.InitializeFlags, value),
                            console, verbose);
#endif

                        object enumValue;
                        Result enumError = null;

                        enumValue = EnumOps.TryParseFlags(
                            null, typeof(InitializeFlags),
                            initializeFlags.ToString(), value,
                            null, true, true, true, ref enumError);

                        if (enumValue is InitializeFlags)
                            initializeFlags = (InitializeFlags)enumValue;
                        else
                            DebugOps.Complain(ReturnCode.Error, enumError);
                    }
                }
            }

            TraceOps.DebugTrace(String.Format(
                "GetStartupInitializeFlags: exited, argv = {0}, " +
                "initializeFlags = {1}, originFlags = {2}, " +
                " console = {3}, verbose = {4}",
                FormatOps.WrapOrNull(true, true, argv),
                FormatOps.WrapOrNull(initializeFlags),
                FormatOps.WrapOrNull(originFlags),
                console, verbose), typeof(Interpreter).Name,
                TracePriority.StartupDebug);

            return initializeFlags;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static ScriptFlags GetStartupScriptFlags(
            IEnumerable<string> args,
            ScriptFlags scriptFlags,
            OptionOriginFlags originFlags,
            bool console,
            bool verbose
            )
        {
            StringList argv = (args != null) ? new StringList(args) : null;

            TraceOps.DebugTrace(String.Format(
                "GetStartupScriptFlags: entered, argv = {0}, " +
                "scriptFlags = {1}, originFlags = {2}, " +
                "console = {3}, verbose = {4}",
                FormatOps.WrapOrNull(true, true, argv),
                FormatOps.WrapOrNull(scriptFlags),
                FormatOps.WrapOrNull(originFlags),
                console, verbose), typeof(Interpreter).Name,
                TracePriority.StartupDebug);

            if (FlagOps.HasFlags(
                    originFlags, OptionOriginFlags.Environment, true))
            {
                //
                // NOTE: Does the caller want to allow the ScriptFlags
                //       to be overridden directly via the environment?
                //
                if (FlagOps.HasFlags(
                        originFlags, OptionOriginFlags.Override, true))
                {
                    //
                    // NOTE: Check for ScriptFlags in the environment.
                    //       If it is set (and valid) then we will use it to
                    //       modify the creation flags for the interpreter.
                    //
                    string value = GlobalConfiguration.GetValue(
                        EnvVars.ScriptFlags, GlobalConfiguration.GetFlags(
                        ConfigurationFlags.Interpreter, verbose));

                    if (!String.IsNullOrEmpty(value))
                    {
#if CONSOLE
                        ConsoleOps.MaybeWritePrompt(String.Format(
                            _Constants.Prompt.ScriptFlags, value),
                            console, verbose);
#endif

                        object enumValue;
                        Result enumError = null;

                        enumValue = EnumOps.TryParseFlags(
                            null, typeof(ScriptFlags),
                            scriptFlags.ToString(), value,
                            null, true, true, true, ref enumError);

                        if (enumValue is ScriptFlags)
                            scriptFlags = (ScriptFlags)enumValue;
                        else
                            DebugOps.Complain(ReturnCode.Error, enumError);
                    }
                }
            }

            TraceOps.DebugTrace(String.Format(
                "GetStartupScriptFlags: exited, argv = {0}, " +
                "scriptFlags = {1}, originFlags = {2}, " +
                " console = {3}, verbose = {4}",
                FormatOps.WrapOrNull(true, true, argv),
                FormatOps.WrapOrNull(scriptFlags),
                FormatOps.WrapOrNull(originFlags),
                console, verbose), typeof(Interpreter).Name,
                TracePriority.StartupDebug);

            return scriptFlags;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // BUGBUG: This method is currently a no-op if the SHELL compile-time option is not defined
        //         -OR- if the ENTERPRISE_LOCKDOWN compile-time option is defined.
        //
        public static ReturnCode GetStartupPreInitializeText(
            IEnumerable<string> args,
            CreateFlags createFlags,
            OptionOriginFlags originFlags,
            bool console,
            bool verbose,
            ref string text,
            ref Result error
            )
        {
            ReturnCode code = ReturnCode.Ok;
            StringList argv = (args != null) ? new StringList(args) : null;

            TraceOps.DebugTrace(String.Format(
                "GetStartupPreInitializeText: entered, argv = {0}, createFlags = {1}, " +
                "originFlags = {2}, console = {3}, verbose = {4}, text = {5}, " +
                "code = {6}, error = {7}",
                FormatOps.WrapOrNull(true, true, argv), FormatOps.WrapOrNull(createFlags),
                FormatOps.WrapOrNull(originFlags), console, verbose, FormatOps.WrapOrNull(
                text), code, FormatOps.WrapOrNull(true, true, error)),
                typeof(Interpreter).Name, TracePriority.StartupDebug);

#if SHELL && !ENTERPRISE_LOCKDOWN
            code = ShellOps.GetArgumentValue(
                argv, CommandLineOption.StartupPreInitialize, true, ref text, ref error);

            if ((code == ReturnCode.Ok) && (argv != null) &&
                FlagOps.HasFlags(originFlags, OptionOriginFlags.Remove, true))
            {
                IList<string> list = args as IList<string>;

                if (list != null)
                {
                    list.Clear();

                    foreach (string arg in argv)
                        list.Add(arg);
                }
            }
#endif

            TraceOps.DebugTrace(String.Format(
                "GetStartupPreInitializeText: exited, argv = {0}, createFlags = {1}, " +
                "originFlags = {2}, console = {3}, verbose = {4}, text = {5}, " +
                "code = {6}, error = {7}",
                FormatOps.WrapOrNull(true, true, argv), FormatOps.WrapOrNull(createFlags),
                FormatOps.WrapOrNull(originFlags), console, verbose, FormatOps.WrapOrNull(
                text), code, FormatOps.WrapOrNull(true, true, error)),
                typeof(Interpreter).Name, TracePriority.StartupDebug);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // BUGBUG: This method is currently a no-op if the SHELL compile-time option is not defined.
        //
        public static ReturnCode GetStartupLibraryPath(
            IEnumerable<string> args,
            CreateFlags createFlags,
            OptionOriginFlags originFlags,
            bool console,
            bool verbose,
            ref string libraryPath,
            ref Result error
            )
        {
            ReturnCode code = ReturnCode.Ok;
            StringList argv = (args != null) ? new StringList(args) : null;

            TraceOps.DebugTrace(String.Format(
                "GetStartupLibraryPath: entered, argv = {0}, createFlags = {1}, " +
                "originFlags = {2}, console = {3}, verbose = {4}, libraryPath = {5}, " +
                "code = {6}, error = {7}",
                FormatOps.WrapOrNull(true, true, argv), FormatOps.WrapOrNull(createFlags),
                FormatOps.WrapOrNull(originFlags), console, verbose, FormatOps.WrapOrNull(
                libraryPath), code, FormatOps.WrapOrNull(true, true, error)),
                typeof(Interpreter).Name, TracePriority.StartupDebug);

#if SHELL
            code = ShellOps.GetArgumentValue(
                argv, CommandLineOption.StartupLibrary, true, ref libraryPath, ref error);

            if ((code == ReturnCode.Ok) && (argv != null) &&
                FlagOps.HasFlags(originFlags, OptionOriginFlags.Remove, true))
            {
                IList<string> list = args as IList<string>;

                if (list != null)
                {
                    list.Clear();

                    foreach (string arg in argv)
                        list.Add(arg);
                }
            }
#endif

            TraceOps.DebugTrace(String.Format(
                "GetStartupLibraryPath: exited, argv = {0}, createFlags = {1}, " +
                "originFlags = {2}, console = {3}, verbose = {4}, libraryPath = {5}, " +
                "code = {6}, error = {7}",
                FormatOps.WrapOrNull(true, true, argv), FormatOps.WrapOrNull(createFlags),
                FormatOps.WrapOrNull(originFlags), console, verbose, FormatOps.WrapOrNull(
                libraryPath), code, FormatOps.WrapOrNull(true, true, error)),
                typeof(Interpreter).Name, TracePriority.StartupDebug);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static ReturnCode ProcessStartupOptions(
            Interpreter interpreter,
            IEnumerable<string> args,
            CreateFlags createFlags,
            OptionOriginFlags originFlags,
            bool console,
            bool verbose,
            ref Result error
            )
        {
            bool initialize = false;

            return ProcessStartupOptions(interpreter, args, createFlags, originFlags,
                console, verbose, ref initialize, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static ReturnCode ProcessStartupOptions(
            Interpreter interpreter,
            IEnumerable<string> args,
            CreateFlags createFlags,
            OptionOriginFlags originFlags,
            bool console,
            bool verbose,
            ref bool initialize,
            ref Result error
            )
        {
            bool loop = false;

            return ProcessStartupOptions(interpreter, args, createFlags, originFlags,
                console, verbose, ref initialize, ref loop, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static ReturnCode ProcessStartupOptions(
            Interpreter interpreter,
            IEnumerable<string> args,
            CreateFlags createFlags,
            OptionOriginFlags originFlags,
            bool console,
            bool verbose,
            ref bool initialize,
            ref bool loop,
            ref Result error
            )
        {
            StringList argv = (args != null) ? new StringList(args) : null;

            TraceOps.DebugTrace(String.Format(
                "ProcessStartupOptions: entered, interpreter = {0}, argv = {1}, " +
                "createFlags = {2}, originFlags = {3}, console = {4}, " +
                "verbose = {5}, initialize = {6}, loop = {7}, error = {8}",
                FormatOps.InterpreterNoThrow(interpreter),
                FormatOps.WrapOrNull(true, true, argv), FormatOps.WrapOrNull(createFlags),
                FormatOps.WrapOrNull(originFlags), console, verbose, initialize, loop,
                FormatOps.WrapOrNull(true, true, error)),
                typeof(Interpreter).Name, TracePriority.StartupDebug);

            try
            {
                if (interpreter != null)
                {
                    if (FlagOps.HasFlags(originFlags, OptionOriginFlags.Environment, true))
                    {
                        #region Trace Listeners
                        //
                        // NOTE: Check for the no-trace environment variable.  If it
                        //       is set (to anything) then we clear all the trace
                        //       listeners.
                        //
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.ClearTrace, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose))) /* GLOBAL */
                        {
                            //
                            // NOTE: Attempt to clear the trace (and debug?) listeners
                            //       now.  This may fail; however, the success and/or
                            //       failure messages will be displayed on the console
                            //       from inside the method.
                            //
                            /* NO RESULT */
                            DebugOps.ClearTraceListeners( /* GLOBAL */
                                true, interpreter.Debug, console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        //
                        // NOTE: Check for the trace environment variable.
                        //       If it is set (to anything) then we add the console
                        //       trace listener so that we can see debugging output.
                        //
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.SetupTrace, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose))) /* GLOBAL */
                        {
                            //
                            // NOTE: Attempt to setup the trace listeners in verbose
                            //       mode.  This may fail; however, the success and/or
                            //       failure messages will be displayed on the console
                            //       from inside the method.
                            //
                            /* NO RESULT */
                            DebugOps.SetupTraceListeners(
                                DebugOps.GetTraceListenerType(console), null,
                                /* GLOBAL */ true, interpreter.Debug, console,
                                verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        string value; /* REUSED */

                        ///////////////////////////////////////////////////////////////////////////////

#if TEST
                        value = GlobalConfiguration.GetValue(
                            EnvVars.ScriptTrace, GlobalConfiguration.GetFlags(
                            ConfigurationFlags.Interpreter, verbose)); /* GLOBAL */

                        if (value != null)
                        {
                            ReturnCode scriptCode;
                            Result scriptError = null;

                            scriptCode = DebugOps.AddScriptTraceListener(
                                interpreter, value, interpreter.Debug,
                                false, ref error);

                            if (scriptCode == ReturnCode.Ok)
                            {
#if CONSOLE
                                ConsoleOps.MaybeWritePrompt(String.Format(
                                    _Constants.Prompt.ScriptTrace,
                                    _Constants.Prompt.ViaEnvironment),
                                    console, verbose);
#endif
                            }
                            else
                            {
                                DebugOps.Complain(interpreter, scriptCode, scriptError);
                            }
                        }
#endif
                        #endregion

                        ///////////////////////////////////////////////////////////////////////////////

#if CONSOLE
                        TraceOps.MaybeWriteInitializationMessages(console, verbose);
#endif

                        ///////////////////////////////////////////////////////////////////////////////

                        #region Trace Subsystem Settings
                        value = GlobalConfiguration.GetValue(
                            EnvVars.TraceCategories, GlobalConfiguration.GetFlags(
                            ConfigurationFlags.InterpreterSkipUnprefixedEnvironment,
                            verbose));

                        if (value != null)
                        {
#if CONSOLE
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.TraceCategories,
                                TraceCategoryType.Enabled.ToString(), value),
                                console, verbose);
#endif

                            ReturnCode categoryCode;
                            StringList categories = null;
                            Result categoryError = null;

                            categoryCode = ParserOps<string>.SplitList(
                                interpreter, value, 0, Length.Invalid, true,
                                ref categories, ref categoryError);

                            if (categoryCode == ReturnCode.Ok)
                            {
                                TraceOps.SetTraceCategories(
                                    TraceCategoryType.Enabled, categories, 1);
                            }
                            else
                            {
                                DebugOps.Complain(
                                    interpreter, categoryCode, categoryError);
                            }
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        value = GlobalConfiguration.GetValue(
                            EnvVars.NoTraceCategories, GlobalConfiguration.GetFlags(
                            ConfigurationFlags.InterpreterSkipUnprefixedEnvironment,
                            verbose));

                        if (value != null)
                        {
#if CONSOLE
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.TraceCategories,
                                TraceCategoryType.Disabled.ToString(), value),
                                console, verbose);
#endif

                            ReturnCode categoryCode;
                            StringList categories = null;
                            Result categoryError = null;

                            categoryCode = ParserOps<string>.SplitList(
                                interpreter, value, 0, Length.Invalid, true,
                                ref categories, ref categoryError);

                            if (categoryCode == ReturnCode.Ok)
                            {
                                TraceOps.SetTraceCategories(
                                    TraceCategoryType.Disabled, categories, 1);
                            }
                            else
                            {
                                DebugOps.Complain(
                                    interpreter, categoryCode, categoryError);
                            }
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        value = GlobalConfiguration.GetValue(
                            EnvVars.PenaltyTraceCategories, GlobalConfiguration.GetFlags(
                            ConfigurationFlags.InterpreterSkipUnprefixedEnvironment,
                            verbose));

                        if (value != null)
                        {
#if CONSOLE
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.TraceCategories,
                                TraceCategoryType.Penalty.ToString(), value),
                                console, verbose);
#endif

                            ReturnCode categoryCode;
                            StringList categories = null;
                            Result categoryError = null;

                            categoryCode = ParserOps<string>.SplitList(
                                interpreter, value, 0, Length.Invalid, true,
                                ref categories, ref categoryError);

                            if (categoryCode == ReturnCode.Ok)
                            {
                                TraceOps.SetTraceCategories(
                                    TraceCategoryType.Penalty, categories, 1);
                            }
                            else
                            {
                                DebugOps.Complain(
                                    interpreter, categoryCode, categoryError);
                            }
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        value = GlobalConfiguration.GetValue(
                            EnvVars.BonusTraceCategories, GlobalConfiguration.GetFlags(
                            ConfigurationFlags.InterpreterSkipUnprefixedEnvironment,
                            verbose));

                        if (value != null)
                        {
#if CONSOLE
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.TraceCategories,
                                TraceCategoryType.Bonus.ToString(), value),
                                console, verbose);
#endif

                            ReturnCode categoryCode;
                            StringList categories = null;
                            Result categoryError = null;

                            categoryCode = ParserOps<string>.SplitList(
                                interpreter, value, 0, Length.Invalid, true,
                                ref categories, ref categoryError);

                            if (categoryCode == ReturnCode.Ok)
                            {
                                TraceOps.SetTraceCategories(
                                    TraceCategoryType.Bonus, categories, 1);
                            }
                            else
                            {
                                DebugOps.Complain(
                                    interpreter, categoryCode, categoryError);
                            }
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        value = GlobalConfiguration.GetValue(
                            EnvVars.TracePriorities, GlobalConfiguration.GetFlags(
                            ConfigurationFlags.InterpreterSkipUnprefixedEnvironment,
                            verbose));

                        if (value != null)
                        {
#if CONSOLE
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.TracePriorities, value),
                                console, verbose);
#endif

                            object enumValue;
                            Result enumError = null;

                            enumValue = EnumOps.TryParseFlags(
                                null, typeof(TracePriority),
                                TraceOps.GetTracePriorities().ToString(),
                                value, null, true, true, true, ref enumError);

                            if (enumValue is TracePriority)
                                TraceOps.SetTracePriorities((TracePriority)enumValue);
                            else
                                DebugOps.Complain(interpreter, ReturnCode.Error, enumError);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        value = GlobalConfiguration.GetValue(
                            EnvVars.TracePriority, GlobalConfiguration.GetFlags(
                            ConfigurationFlags.InterpreterSkipUnprefixedEnvironment,
                            verbose));

                        if (value != null)
                        {
#if CONSOLE
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.TracePriority, value),
                                console, verbose);
#endif

                            object enumValue;
                            Result enumError = null;

                            enumValue = EnumOps.TryParseFlags(
                                null, typeof(TracePriority),
                                TraceOps.GetTracePriority().ToString(),
                                value, null, true, true, true, ref enumError);

                            if (enumValue is TracePriority)
                                TraceOps.SetTracePriority((TracePriority)enumValue);
                            else
                                DebugOps.Complain(interpreter, ReturnCode.Error, enumError);
                        }
                        #endregion

                        ///////////////////////////////////////////////////////////////////////////////

                        #region Notification-Only [Global] Environment Variables
#if CONSOLE
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NoBreak, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.NoBreakNotify,
                                ProcessOps.GetId()),
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

#if NATIVE && WINDOWS
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NoNativeConsole, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.NoNativeConsole,
                                console, verbose);
                        }
#endif

                        ///////////////////////////////////////////////////////////////////////////////

#if NATIVE
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NoNativeStack, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.NoNativeStack,
                                console, verbose);
                        }
#endif

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.ResultStack, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Result, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.ResultStack,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NoPopulateOsExtra, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.NoPopulateOsExtra,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.DefaultQuiet, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.DefaultQuiet,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.Quiet, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.Quiet, "enabled",
                                _Constants.Prompt.ViaEnvironment),
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.DefaultTraceStack, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.DefaultTraceStack,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        value = GlobalConfiguration.GetValue(
                            EnvVars.UtilityPath, GlobalConfiguration.GetFlags(
                            ConfigurationFlags.Interpreter | ConfigurationFlags.NativePathValue,
                            verbose));

                        if (value != null)
                        {
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.UtilityPath, value),
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        value = GlobalConfiguration.GetValue(
                            EnvVars.VendorPath, GlobalConfiguration.GetFlags(
                            ConfigurationFlags.Interpreter | ConfigurationFlags.NativePathValue,
                            verbose));

                        if (value != null)
                        {
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.VendorPath, value),
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        value = GlobalConfiguration.GetValue(
                            EnvVars.EllipsisLimit, GlobalConfiguration.GetFlags(
                            ConfigurationFlags.Interpreter, verbose));

                        if (value != null)
                        {
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.EllipsisLimit, value),
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NoTraceLimits, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.NoTraceLimits,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NoVerbose, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.NoVerbose,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NoTrusted, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.NoTrusted,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NoVerified, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.NoVerified,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.Throw, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.Throw,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NeverGC, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.NeverGC,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NeverWaitForGC, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.NeverWaitForGC,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.AlwaysWaitForGC, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.AlwaysWaitForGC,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.TreatAsFramework20, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.TreatAsFramework20,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.TreatAsFramework40, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.TreatAsFramework40,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.TreatAsMono, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.TreatAsMono,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.TreatAsDotNetCore, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.TreatAsDotNetCore,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NoAppSettings, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.NoAppSettings,
                                _Constants.Prompt.ViaEnvironment),
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

#if CONFIGURATION
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.RefreshAppSettings, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.RefreshAppSettings,
                                console, verbose);
                        }
#endif

                        ///////////////////////////////////////////////////////////////////////////////

#if XML
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.UseXmlFiles, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.UseXmlFiles,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.MergeXmlAppSettings, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.MergeXmlAppSettings,
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.MergeAllAppSettings, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.MergeAllAppSettings,
                                console, verbose);
                        }
#endif

                        ///////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
                        value = GlobalConfiguration.GetValue(
                            EnvVars.BumpCacheLevel, GlobalConfiguration.GetFlags(
                            ConfigurationFlags.CacheConfiguration, verbose));

                        if (value != null)
                        {
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.BumpCacheLevel, value),
                                console, verbose);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        value = GlobalConfiguration.GetValue(
                            EnvVars.CacheFlags, GlobalConfiguration.GetFlags(
                            ConfigurationFlags.Interpreter, verbose));

                        if (value != null)
                        {
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.CacheFlags, value),
                                console, verbose);
                        }
#endif
#endif
                        #endregion

                        ///////////////////////////////////////////////////////////////////////////////

                        #region Interpreter Flags & Settings
                        //
                        // NOTE: Check for the trace-to-host environment variable.
                        //       If it is set (to anything) then set the trace-to-host
                        //       flag for the interpreter right now.
                        //
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.TraceToHost, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
#if CONSOLE
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.TraceToHost,
                                console, verbose);
#endif

                            interpreter.InterpreterFlags |= InterpreterFlags.TraceToHost;
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        //
                        // NOTE: Check for the InterpreterFlags environment variable.
                        //       If it is set (and valid) then we will use it to
                        //       modify the instance flags for the interpreter.
                        //
                        value = GlobalConfiguration.GetValue(
                            EnvVars.InterpreterFlags, GlobalConfiguration.GetFlags(
                            ConfigurationFlags.Interpreter, verbose));

                        if (!String.IsNullOrEmpty(value))
                        {
#if CONSOLE
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.InterpreterFlags, value),
                                console, verbose);
#endif

                            object enumValue;
                            Result enumError = null;

                            enumValue = EnumOps.TryParseFlags(
                                null, typeof(InterpreterFlags),
                                interpreter.InterpreterFlags.ToString(),
                                value, null, true, true, true, ref enumError);

                            if (enumValue is InterpreterFlags)
                                interpreter.InterpreterFlags = (InterpreterFlags)enumValue;
                            else
                                DebugOps.Complain(interpreter, ReturnCode.Error, enumError);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        //
                        // NOTE: Check for the interactive environment variable.
                        //       If it is set (to anything) then set the
                        //       interactive flag for the interpreter right now.
                        //
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.Interactive, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
#if CONSOLE
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.Interactive,
                                _Constants.Prompt.ViaEnvironment),
                                console, verbose);
#endif

                            interpreter.InternalInteractive = true;
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        //
                        // NOTE: Check for the single-step environment variable.
                        //       If it is set (to anything) then set the single
                        //       step flag for the interpreter right now.
                        //
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.Step, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
#if DEBUGGER
#if CONSOLE
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.SingleStep,
                                _Constants.Prompt.ViaEnvironment),
                                console, verbose);
#endif

                            interpreter.SingleStep = true;
#else
#if CONSOLE
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.NoDebugger,
                                _Constants.Prompt.ViaEnvironment),
                                console, verbose);
#endif
#endif
                        }

                        ///////////////////////////////////////////////////////////////////////////////

#if SHELL
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NoInitializeShell, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
#if CONSOLE
                            ConsoleOps.MaybeWritePrompt(
                                _Constants.Prompt.NoInitializeShell,
                                console, verbose);
#endif

                            interpreter.ShouldInitializeShell = false;
                        }
#endif
                        #endregion

                        ///////////////////////////////////////////////////////////////////////////////

                        #region Output Parameter Handling
                        //
                        // NOTE: Check for the no-initialize environment variable.
                        //       If it is set (to anything) then skip initialization
                        //       of the interpreter.
                        //
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NoInitialize, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
#if CONSOLE
                            //
                            // NOTE: Do not bother notifying the user that the script
                            //       library initialization of the interpreter will
                            //       be skipped if it is likely that they have already
                            //       been notified (i.e. if the "Initialize" flag has
                            //       already been disabled via GetStartupCreateFlags).
                            //
                            if (FlagOps.HasFlags(
                                    createFlags, CreateFlags.Initialize, true))
                            {
                                ConsoleOps.MaybeWritePrompt(String.Format(
                                    _Constants.Prompt.NoInitialize,
                                    _Constants.Prompt.ViaEnvironment),
                                    console, verbose);
                            }
#endif

                            initialize = false;
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        //
                        // NOTE: Check for the no-loop environment variable.
                        //       If it is set (to anything) then skip entering
                        //       the interactive loop.
                        //
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NoLoop, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose)))
                        {
#if CONSOLE
                            ConsoleOps.MaybeWritePrompt(String.Format(
                                _Constants.Prompt.NoLoop,
                                _Constants.Prompt.ViaEnvironment),
                                console, verbose);
#endif

                            loop = false;
                        }
                        #endregion

                        ///////////////////////////////////////////////////////////////////////////////

                        #region Engine Settings
                        //
                        // NOTE: Check for the no-throw-on-disposed environment variable.
                        //       If it is set (to anything) then we will not throw exceptions
                        //       when a disposed object is accessed.
                        //
                        if (GlobalConfiguration.DoesValueExist(
                                EnvVars.NoThrowOnDisposed, GlobalConfiguration.GetFlags(
                                ConfigurationFlags.Interpreter, verbose))) /* GLOBAL */
                        {
#if CONSOLE
                            if (FlagOps.HasFlags(
                                    createFlags, CreateFlags.ThrowOnDisposed, true))
                            {
                                ConsoleOps.MaybeWritePrompt(
                                    _Constants.Prompt.NoThrowOnDisposed,
                                    console, verbose);
                            }
#endif

                            Engine.SetThrowOnDisposed(null, false, false); /* GLOBAL */
                        }
                        #endregion
                    }

                    TraceOps.DebugTrace(String.Format(
                        "ProcessStartupOptions: exited, interpreter = {0}, argv = {1}, " +
                        "createFlags = {2}, originFlags = {3}, console = {4}, " +
                        "verbose = {5}, initialize = {6}, loop = {7}, error = {8}",
                        FormatOps.InterpreterNoThrow(interpreter),
                        FormatOps.WrapOrNull(true, true, argv), FormatOps.WrapOrNull(createFlags),
                        FormatOps.WrapOrNull(originFlags), console, verbose, initialize, loop,
                        FormatOps.WrapOrNull(true, true, error)),
                        typeof(Interpreter).Name, TracePriority.StartupDebug);

                    return ReturnCode.Ok;
                }
                else
                {
                    error = "invalid interpreter";
                }
            }
            catch (Exception e)
            {
                error = e;
            }

#if CONSOLE
            ConsoleOps.MaybeWriteError(
                ResultOps.Format(ReturnCode.Error, error),
                console);
#endif

            TraceOps.DebugTrace(String.Format(
                "ProcessStartupOptions: exited, interpreter = {0}, argv = {1}, " +
                "createFlags = {2}, originFlags = {3}, console = {4}, " +
                "verbose = {5}, initialize = {6}, loop = {7}, error = {8}",
                FormatOps.InterpreterNoThrow(interpreter),
                FormatOps.WrapOrNull(true, true, argv), FormatOps.WrapOrNull(createFlags),
                FormatOps.WrapOrNull(originFlags), console, verbose, initialize, loop,
                FormatOps.WrapOrNull(true, true, error)),
                typeof(Interpreter).Name, TracePriority.StartupError);

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Profiler Support
        internal IProfilerState Profiler
        {
            get { lock (syncRoot) { return GetProfiler(); } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HaveProfiler()
        {
            return (profiler != null); /* NO-LOCK */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool TryReuseProfiler(
            out IProfilerState profiler
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (FlagOps.HasFlags(interpreterStateFlags,
                        InterpreterStateFlags.ReUseProfiler, true))
                {
                    profiler = GetProfiler();
                    return true;
                }

                profiler = null;
                return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IProfilerState GetProfiler()
        {
            return profiler; /* NO-LOCK */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void SetProfiler(
            IProfilerState profiler /* in */
            )
        {
            this.profiler = profiler; /* NO-LOCK */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void CreateProfiler(
            IProfilerState profiler /* in */
            )
        {
            this.profiler = ProfilerState.CreateWithTotalsFrom(
                profiler); /* NO-LOCK */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode EnableProfiler(
            bool enable,                 /* in */
            ref Result error             /* out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (enable)
                {
                    if (!HaveProfiler())
                    {
                        CreateProfiler(null);
                    }
                    else
                    {
                        error = "profiler already enabled";
                        return ReturnCode.Error;
                    }
                }
                else if (HaveProfiler())
                {
                    DisposeProfiler();
                }
                else
                {
                    error = "profiler already disabled";
                    return ReturnCode.Error;
                }

                return ReturnCode.Ok;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Static "Factory" Methods
        #region Private Static "Factory" Helper Methods
        internal static bool IsCreationDisabled(
            bool persistentOnly, /* in */
            ref Result error     /* out */
            )
        {
            #region Check Transient Status
            if (!persistentOnly && Interlocked.CompareExchange(
                    ref globalDisableCreationCount, 0, 0) > 0)
            {
                error = "interpreter creation is temporarily disabled";
                return true;
            }
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Check Persistent Status
            #region Grab Interpreter Context
            Interpreter interpreter = GlobalState.GetStubInterpreter();
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Check AppDomain Status
            ArgumentList arguments = new ArgumentList();

            arguments.Add("stub");     /* NOTE: Stub command name. */
            arguments.Add("creation"); /* NOTE: Stub sub-command name. */

            bool allowCreation;

            if (GlobalState.IsStubAssemblyInAppDomain(
                    interpreter, null, arguments, null, false,
                    out allowCreation) == ReturnCode.Ok)
            {
                error = "interpreter creation is persistently disabled (1)";
                return true;
            }
            else if (allowCreation)
            {
                return false;
            }
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Check Process Status
            if (GlobalState.IsStubAssemblyInProcess(
                    interpreter, ProcessOps.GetCurrent()))
            {
                error = "interpreter creation is persistently disabled (2)";
                return true;
            }
            #endregion
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void CheckPersistentCreationDisabled(
            string methodName,        /* in */
            DisableFlags disableFlags /* in */
            ) /* throw */
        {
            Result error = null;

            if (IsCreationDisabled(true, ref error))
            {
                TraceOps.DebugTrace(String.Format(
                    "{0}: error = {1}", methodName,
                    FormatOps.WrapOrNull(error)),
                    typeof(Interpreter).Name,
                    TracePriority.SecurityError);

                if (FlagOps.HasFlags(
                        disableFlags, DisableFlags.Quiet, true))
                {
                    return;
                }

                throw new ScriptException(ReturnCode.Error, error);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void PersistentDisableCreationOrMaybeThrow(
            IClientData clientData,   /* in: OPTIONAL */
            DisableFlags disableFlags /* in */
            ) /* throw */
        {
            if (!GlobalState.IsStubAssemblyAnywhere())
            {
                ReturnCode code;
                Result error = null;

                code = GlobalState.TryToLoadStubAssembly(
                    clientData, true, ref error);

                if (code != ReturnCode.Ok)
                {
                    TraceOps.DebugTrace(String.Format(
                        "PersistentDisableCreationOrMaybeThrow: " +
                        "code = {0}, error = {1}", code,
                        FormatOps.WrapOrNull(error)),
                        typeof(Interpreter).Name,
                        TracePriority.SecurityError);

                    if (FlagOps.HasFlags(
                            disableFlags, DisableFlags.Quiet, true))
                    {
                        return;
                    }

                    throw new ScriptException(code, error);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void EnableCreation(
            DisableFlags flags /* in */
            ) /* throw */
        {
            CheckPersistentCreationDisabled("EnableCreation", flags);
            Interlocked.Decrement(ref globalDisableCreationCount);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void DisableCreation(
            DisableFlags flags /* in */
            ) /* throw */
        {
            Result error; /* REUSED */

            if (!FlagOps.HasFlags(flags, DisableFlags.Override, true) &&
                (GlobalState.CountInterpreters() <= 0))
            {
                error = "cannot disable interpreter creation, " +
                    "none appear to exist";

                TraceOps.DebugTrace(String.Format(
                    "DisableCreation: flags = {0}, " +
                    "error = {1}", flags,
                    FormatOps.WrapOrNull(error)),
                    typeof(Interpreter).Name,
                    TracePriority.SecurityError);

                if (FlagOps.HasFlags(flags, DisableFlags.Quiet, true))
                    return;

                throw new ScriptException(ReturnCode.Error, error);
            }

            Interlocked.Increment(ref globalDisableCreationCount);

            if (FlagOps.HasFlags(flags, DisableFlags.Persistent, true))
            {
                if (Interlocked.CompareExchange(
                        ref globalStubAssemblyCount, 0, 0) > 0)
                {
                    PersistentDisableCreationOrMaybeThrow(null, flags);
                }
                else
                {
                    error = "cannot persistently disable interpreter " +
                        "creation, stub assembly not enabled";

                    TraceOps.DebugTrace(String.Format(
                        "DisableCreation: flags = {0}, " +
                        "error = {1}", flags,
                        FormatOps.WrapOrNull(error)),
                        typeof(Interpreter).Name,
                        TracePriority.SecurityError);

                    if (FlagOps.HasFlags(flags, DisableFlags.Quiet, true))
                        return;

                    throw new ScriptException(ReturnCode.Error, error);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void EnableStubAssembly(
            DisableFlags flags /* in */
            ) /* throw */
        {
            CheckPersistentCreationDisabled("EnableStubAssembly", flags);
            Interlocked.Increment(ref globalStubAssemblyCount);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void DisableStubAssembly(
            DisableFlags flags /* in */
            ) /* throw */
        {
            CheckPersistentCreationDisabled("DisableStubAssembly", flags);
            Interlocked.Decrement(ref globalStubAssemblyCount);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void MaybeMutateCreateFlags(
            ulong? token,               /* in */
            ref CreateFlags createFlags /* in, out */
            )
        {
            if (token != null)
                createFlags |= CreateFlags.IfNecessary;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private Static "Factory" Methods
        internal static Interpreter Create( /* NativePackage */
            IEnumerable<string> args,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            InitializeFlags initializeFlags,
            ScriptFlags scriptFlags,
            string text,
            string libraryPath,
            ref Result result
            )
        {
            return Create(null, null,
                _ClientData.Empty, args, null, createFlags,
                hostCreateFlags, initializeFlags, scriptFlags,
                Defaults.InterpreterFlags, Defaults.PluginFlags,
                null, null, null, null, null, null, null, null,
                null, null, text, libraryPath, null, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static Interpreter Create( /* For CreateInterpreterForSettings only. */
            IClientData clientData,
            IEnumerable<string> args,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            InitializeFlags initializeFlags,
            ScriptFlags scriptFlags,
            InterpreterFlags interpreterFlags,
            PluginFlags pluginFlags,
            ref Result result
            )
        {
            return Create(null, null,
                clientData, args, null, createFlags, hostCreateFlags,
                initializeFlags, scriptFlags, interpreterFlags,
                pluginFlags, null, null, null, null, null, null, null,
                null, null, null, null, null, null, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static Interpreter Create( /* For child interpreters only. */
            IRuleSet ruleSet,
            IEnumerable<string> args,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            InitializeFlags initializeFlags,
            ScriptFlags scriptFlags,
            InterpreterFlags interpreterFlags,
            PluginFlags pluginFlags,
            ref Result result
            )
        {
            return Create(null, ruleSet,
                _ClientData.Empty, args, null, createFlags,
                hostCreateFlags, initializeFlags, scriptFlags,
                interpreterFlags, pluginFlags, null, null, null,
                null, null, null, null, null, null, null, null,
                null, null, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static Interpreter Create( /* For ScriptThread use. */
            IEnumerable<string> args,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            InitializeFlags initializeFlags,
            ScriptFlags scriptFlags,
            InterpreterFlags interpreterFlags,
            IHost host,
            ref Result result
            )
        {
            return Create(null, null,
                _ClientData.Empty, args, null, createFlags,
                hostCreateFlags, initializeFlags, scriptFlags,
                interpreterFlags, Defaults.PluginFlags, null,
                host, null, null, null, null, null, null, null,
                null, null, null, null, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static Interpreter Create( /* InterpreterHelper.Create and [test2] */
            IRuleSet ruleSet,
            IEnumerable<string> args,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            InitializeFlags initializeFlags,
            ScriptFlags scriptFlags,
            InterpreterFlags interpreterFlags,
            PluginFlags pluginFlags,
            string text,
            string libraryPath,
            StringList autoPathList,
            ref Result result
            )
        {
            return Create(null, ruleSet,
                _ClientData.Empty, args, null, createFlags,
                hostCreateFlags, initializeFlags, scriptFlags,
                interpreterFlags, pluginFlags, null, null, null,
                null, null, null, null, null, null, null, text,
                libraryPath, autoPathList, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static Interpreter Create( /* NOTE: INTERNAL DEBUGGER USE ONLY. */
            string culture,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            InitializeFlags initializeFlags,
            ScriptFlags scriptFlags,
            InterpreterFlags interpreterFlags,
            PluginFlags pluginFlags,
            AppDomain appDomain,
            IHost host,
            string libraryPath,
            StringList autoPathList,
            ref Result result
            )
        {
            return Create(null, null,
                _ClientData.Empty, null, culture, createFlags,
                hostCreateFlags, initializeFlags, scriptFlags,
                interpreterFlags, pluginFlags, appDomain, host,
                null, null, null, null, null, null, null, null,
                null, libraryPath, autoPathList, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static Interpreter Create( /* CORE */
            ulong? token,                      // 01: secure lookup token for IfNecessary interpreter lookup.
            IRuleSet ruleSet,                  // 02: the ruleset used to determine which commands should be added.
            IClientData clientData,            // 03: the client data to pass to the new interpreter callback.
            IEnumerable<string> args,          // 04: original arguments to the host application, where applicable.
            string culture,                    // 05: currently, used only for parsing (error messages are same).
            CreateFlags createFlags,           // 06: special creation flags.
            HostCreateFlags hostCreateFlags,   // 07: special host creation flags.
            InitializeFlags initializeFlags,   // 08: special initialization flags.
            ScriptFlags scriptFlags,           // 09: the default script flags used by the engine.
            InterpreterFlags interpreterFlags, // 10: the initial interpreter configuration flags.
            PluginFlags pluginFlags,           // 11: the initial plugin flags.
            AppDomain appDomain,               // 12: pass null to use the current application domain.
            IHost host,                        // 13: pass null to use the default host.
            string profile,                    // 14: the host profile to load (pass null for none).
            object owner,                      // 15: the logical "owner" of the new interpreter.
            object applicationObject,          // 16: this is reserved for use by the application (pass null if not needed).
            object policyObject,               // 17: this is reserved for use by custom policies (pass null if not needed).
            object resolverObject,             // 18: this is reserved for use by custom resolvers (pass null if not needed).
            object userObject,                 // 19: this is reserved for use by the user (pass null if not needed).
            PolicyList policies,               // 20: interpreter policies (e.g. "safe", etc), if any.
            TraceList traces,                  // 21: interpreter wide variable traces, if any.
            string text,                       // 22: the "pre-init" (actually "post-setup") script, if any.
            string libraryPath,                // 23: location of the script library (i.e. "init" script).
            StringList autoPathList,           // 24: extra dirs to check for packages.
            ref Result result                  // 25: result of script library initialization or error upon failure.
            )
        {
            MaybeStaticInitialize();

            //
            // NOTE: Set the console and verbose (output control flags) to
            //       their initial values based on the host creation flags
            //       (which may change just below).  These values will be
            //       refreshed again if necessary.
            //
            bool console;
            bool verbose;

            RefreshConsoleAndVerbose(
                hostCreateFlags, out console, out verbose);

            //
            // HACK: *SECURITY* The creation flags are security sensitive;
            //       however, they will only be modified when the caller
            //       opts-in via the "GetFlags" meta-creation flag.
            //
            if (FlagOps.HasFlags(createFlags, CreateFlags.GetFlags, true))
            {
                createFlags = GetStartupCreateFlags(
                    args, createFlags, OptionOriginFlags.Create,
                    console, verbose);

                hostCreateFlags = Interpreter.GetStartupHostCreateFlags(
                    args, hostCreateFlags, OptionOriginFlags.Create,
                    console, verbose);

                RefreshConsoleAndVerbose(
                    hostCreateFlags, out console, out verbose);
            }

            DateTime now = TimeOps.GetUtcNow();
            Interpreter interpreter = null;
            bool locked = false;
            IProfilerState profiler = null;

            try
            {
                if (FlagOps.HasFlags(
                        createFlags, CreateFlags.MeasureTime, true))
                {
                    profiler = ProfilerState.Create();
                }

                if (profiler != null)
                    profiler.Start();

                if (ruleSet != null)
                    ruleSet.MakeReadOnly();

                ReturnCode code;
                StringList argv = (args != null) ? new StringList(args) : null;

                TraceOps.DebugTrace(String.Format(
                    "Create ({0}): token = {1}, ruleSet = {2}, clientData = {3}, " +
                    "argv = {4}, culture = {5}, createFlags = {6}, " +
                    "hostCreateFlags = {7}, initializeFlags = {8}, " +
                    "scriptFlags = {9}, interpreterFlags = {10}, " +
                    "pluginFlags = {11}, appDomain = {12}, host = {13}, " +
                    "profile = {14}, owner = {15}, applicationObject = {16}, " +
                    "policyObject = {17}, resolverObject = {18}, " +
                    "userObject = {19}, policies = {20}, traces = {21}, " +
                    "text = {22}, libraryPath = {23}, autoPathList = {24}, " +
                    "now = {25}, console = {26}, verbose = {27}, result = {28}",
                    AppDomainOps.GetCurrentId(), FormatOps.WrapOrNull(
                    token != null), FormatOps.WrapOrNull(ruleSet),
                    FormatOps.WrapOrNull(clientData), FormatOps.WrapOrNull(
                    true, true, argv), FormatOps.WrapOrNull(culture),
                    FormatOps.WrapOrNull(createFlags), FormatOps.WrapOrNull(
                    hostCreateFlags), FormatOps.WrapOrNull(initializeFlags),
                    FormatOps.WrapOrNull(scriptFlags), FormatOps.WrapOrNull(
                    interpreterFlags), FormatOps.WrapOrNull(pluginFlags),
                    FormatOps.DisplayAppDomain(appDomain),
                    FormatOps.WrapOrNull(host), FormatOps.WrapOrNull(profile),
                    FormatOps.WrapOrNull(owner), FormatOps.WrapOrNull(
                    applicationObject), FormatOps.WrapOrNull(policyObject),
                    FormatOps.WrapOrNull(resolverObject), FormatOps.WrapOrNull(
                    userObject), FormatOps.WrapOrNull(policies),
                    FormatOps.WrapOrNull(traces), FormatOps.WrapOrNull(text),
                    FormatOps.WrapOrNull(libraryPath),
                    FormatOps.WrapOrNull(true, true, autoPathList),
                    FormatOps.WrapOrNull(FormatOps.Iso8601FullDateTime(now)),
                    console, verbose, FormatOps.WrapOrNull(true, true, result)),
                    typeof(Interpreter).Name, TracePriority.StartupDebug);

                //
                // NOTE: Pause for them to attach a debugger, if requested.  For
                //       embedders, we really need the ability to break into the
                //       debugger here; otherwise, being able to easily attach a
                //       debugger at a predictable point becomes a problem.
                //
                if (FlagOps.HasFlags(createFlags, CreateFlags.BreakOnCreate, true) ||
                    ((GlobalConfiguration.DoesValueExist(
                        EnvVars.Break, ConfigurationFlags.Interpreter)) &&
                     (Interlocked.Increment(ref globalBreakCount) == 1)))
                {
                    #region Requires Console Support
#if CONSOLE
                    /* NO RESULT */
                    ConsoleOps.DebugBreak();
#endif
                    #endregion

                    ///////////////////////////////////////////////////////////

                    DebugOps.Break(); /* throw */
                }

                ///////////////////////////////////////////////////////////////

                EventCallback useInterpreterCallback = UseInterpreterCallback;
                EventCallback newInterpreterCallback = NewInterpreterCallback;

                ///////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(
                        createFlags, CreateFlags.IfNecessary, true))
                {
                    //
                    // NOTE: Is there already at least one matching
                    //       interpreter created in this AppDomain?
                    //
                    bool notFound = false;
                    Result getError = null;

                    if (token != null)
                    {
                        interpreter = GlobalState.GetTokenInterpreter(
                            (ulong)token, ref notFound, ref getError);
                    }
                    else
                    {
                        interpreter = GlobalState.GetFirstInterpreter(
                            createFlags, ref notFound, ref getError);
                    }

                    //
                    // NOTE: Did we find a pre-existing interpreter that
                    //       we can use (and/or that matched the specified
                    //       token)?
                    //
                    if (interpreter != null)
                    {
                        //
                        // NOTE: Is there a callback for using an existing
                        //       interpreter?
                        //
                        // HACK: Token-based interpreters are exempt from
                        //       this handling, i.e. will not be seen by
                        //       any registered "interpreter callbacks".
                        //       This design decision may be revised in
                        //       the future.
                        //
                        /* IGNORED */
                        interpreter.BumpCreateCount();

                        if ((token == null) &&
                            (useInterpreterCallback != null))
                        {
                            //
                            // NOTE: Invoke the callback now, if
                            //       the return code is Ok, just
                            //       use this interpreter as-is.
                            //       If the return code is Error,
                            //       then fail creation now -AND-
                            //       return; otherwise, create an
                            //       interpreter.
                            //
                            code = useInterpreterCallback(
                                interpreter, clientData, ref result);

                            if (code != ReturnCode.Ok)
                            {
                                TraceOps.DebugTrace(String.Format(
                                    "Create ({0}): " +
                                    "use callback failure, " +
                                    "code = {1}, result = {2}",
                                    AppDomainOps.GetCurrentId(),
                                    code, FormatOps.WrapOrNull(
                                        true, true, result)),
                                    typeof(Interpreter).Name,
                                    TracePriority.StartupError);

                                interpreter = null;
                            }

                            if ((code == ReturnCode.Ok) ||
                                (code == ReturnCode.Error))
                            {
                                goto done;
                            }
                        }
                        else
                        {
                            goto done;
                        }
                    }
                    else if (!notFound)
                    {
                        //
                        // HACK: If this condition is hit, that means
                        //       we did not simply fail to "find" the
                        //       interpreter, but were actually unable
                        //       to even search for it (e.g. locking
                        //       error, etc).  Therefore, transform it
                        //       into a real creation error.
                        //
                        result = getError;

                        TraceOps.DebugTrace(String.Format(
                            "Create ({0}): " +
                            "{1} failure, result = {2}",
                            AppDomainOps.GetCurrentId(),
                            (token != null) ?
                                "token" : "first",
                            FormatOps.WrapOrNull(
                                true, true, result)),
                            typeof(Interpreter).Name,
                            TracePriority.StartupError);

                        goto done;
                    }
                    else
                    {
                        TraceOps.DebugTrace(String.Format(
                            "Create ({0}): not found",
                            AppDomainOps.GetCurrentId()),
                            typeof(Interpreter).Name,
                            TracePriority.StartupError2);
                    }
                }

                ///////////////////////////////////////////////////////////////

                if (IsCreationDisabled(false, ref result))
                    goto done;

                ///////////////////////////////////////////////////////////////

                bool throwOnError = FlagOps.HasFlags(
                    createFlags, CreateFlags.ThrowOnError, true);

                try
                {
                    //
                    // NOTE: Create a brand new (empty) interpreter instance.  This
                    //       interpreter instance will not be readily visible outside
                    //       of this method until this method returns it; that being
                    //       said, some care is taken to avoid "deadlocks" with other
                    //       subsystems.
                    //
                    interpreter = new Interpreter(token);

                    /* IGNORED */
                    interpreter.BumpCreateCount();

                    /* IGNORED */
                    Interlocked.Increment(ref globalCreateCount);

                    //
                    // BUGFIX: Build the auto-path without holding the interpreter
                    //         lock; otherwise, a deadlock could result.  This can
                    //         happen because building the global portion of the
                    //         auto-path requires holding the static GlobalState
                    //         lock.
                    //
                    StringList localAutoPathList = FlagOps.HasFlags(
                        initializeFlags, InitializeFlags.GlobalAutoPath, true) ?
                        GlobalState.GetAutoPathList(interpreter, libraryPath,
                        autoPathList, createFlags, false) : null;

                    try
                    {
                        //
                        // NOTE: Acquire the lock for the new interpreter instance.
                        //       This is being used instead of a lock statement here
                        //       so that lock can be released and then re-obtained as
                        //       necessary within this block.
                        //
                        interpreter.InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                        if (locked)
                        {
                            //
                            // NOTE: Push the new interpreter instance onto the active
                            //       interpreter stack for this thread.  This does not
                            //       allow any other thread to obtain this interpreter
                            //       instance.
                            //
                            GlobalState.PushActiveInterpreter(interpreter);

                            try
                            {
                                //
                                // NOTE: Perform the preliminary initialiation of this
                                //       interpreter instance.  Generally, this cannot
                                //       fail.  Typically, an interpreter host will be
                                //       created (or cloned) from within it.  That new
                                //       interpreter host will be passed a reference
                                //       to this interpreter instance.  In theory, it
                                //       could then "escape" and be visisble by other
                                //       threads; however, this is unlikely, e.g. none
                                //       of the built-in interpreter hosts permit this
                                //       to happen.
                                //
                                Result localResult = null; /* REUSED */

                                code = interpreter.PreSetup(
                                    ruleSet, culture, createFlags, hostCreateFlags,
                                    initializeFlags, scriptFlags, interpreterFlags,
                                    pluginFlags, appDomain, host, profile, owner,
                                    applicationObject, policyObject, resolverObject,
                                    userObject, new ClientDataDictionary(), text,
                                    libraryPath, autoPathList, ref localResult);

                                if ((code != ReturnCode.Ok) &&
                                    (localResult != null))
                                {
                                    result = localResult;
                                }

                                //*****************************************************

                                if (code == ReturnCode.Ok)
                                {
                                    //
                                    // NOTE: Perform general setup of this interpreter
                                    //       instance.  At this point, it is still not
                                    //       really capable of evaluating scripts.  It
                                    //       should be noted that this method contains
                                    //       a call to the notification subsystem, and
                                    //       in theory that could permit other threads
                                    //       and/or external components to be able to
                                    //       see this interpreter instance, primarily
                                    //       via other interpreter instances that were
                                    //       already created.
                                    //
                                    localResult = null;

                                    code = interpreter.Setup(
                                        createFlags, hostCreateFlags, interpreterFlags,
                                        pluginFlags, ruleSet, args, localAutoPathList,
                                        policies, traces, ref localResult);

                                    if ((code != ReturnCode.Ok) &&
                                        (localResult != null))
                                    {
                                        result = localResult;
                                    }
                                }

                                //*****************************************************
                                // WARNING: No scripts of any kind may be evaluated
                                //          using the interpreter until after this
                                //          point.
                                //*****************************************************

                                if (code == ReturnCode.Ok)
                                {
                                    bool initialize = true;

                                    if (FlagOps.HasFlags(
                                            createFlags, CreateFlags.Startup, true))
                                    {
                                        //
                                        // NOTE: Perform any operations necessary
                                        //       based on the configured "startup"
                                        //       options.  This method consults the
                                        //       environment and configuration file
                                        //       in order to do its work, which is
                                        //       quite linear and mostly harmless.
                                        //       It does not readily permit other
                                        //       threads of external components to
                                        //       access this interpreter instance.
                                        //
                                        localResult = null;

                                        code = ProcessStartupOptions(
                                            interpreter, args, createFlags,
                                            OptionOriginFlags.Standard,
                                            console, verbose, ref initialize,
                                            ref localResult);

                                        if ((code != ReturnCode.Ok) &&
                                            (localResult != null))
                                        {
                                            result = localResult;
                                        }
                                    }

                                    //*************************************************

#if DEBUGGER
                                    if (code == ReturnCode.Ok)
                                    {
                                        //
                                        // NOTE: This must be prior to the Initialize()
                                        //       call below if we want to be able to
                                        //       debug the startup script.
                                        //
                                        // BUGFIX: Use the same host as we were passed,
                                        //         never create a new one here.
                                        //
                                        if (FlagOps.HasFlags(
                                                createFlags, CreateFlags.Debugger,
                                                true))
                                        {
                                            //
                                            // TODO: Make possible to disable copying
                                            //       the library path and/or auto-path
                                            //       here?
                                            //
                                            // NOTE: Create optional script debugger,
                                            //       if possible.  This *MAY* result in
                                            //       another interpreter instance being
                                            //       created.  If that fails, the
                                            //       script debugger itself is still
                                            //       created.  However, this static
                                            //       method must be re-entrant.  In
                                            //       order to prevent infinite (mutual)
                                            //       recursion at this point, callers
                                            //       of this method (e.g. the Debugger
                                            //       class) *MUST* mask off the
                                            //       "Debugger" interpreter creation
                                            //       flag.
                                            //
                                            IDebugger debugger = DebuggerOps.Create(
                                                FlagOps.HasFlags(createFlags,
                                                    CreateFlags.DebuggerInterpreter,
                                                    true),
                                                culture, createFlags, hostCreateFlags,
                                                initializeFlags, scriptFlags,
                                                interpreterFlags, pluginFlags,
                                                interpreter.GetAppDomain(),
                                                interpreter.InternalHost,
                                                DebuggerOps.GetLibraryPath(interpreter),
                                                DebuggerOps.GetAutoPathList(interpreter));

                                            if (debugger != null)
                                            {
                                                //
                                                // NOTE: Associate new script debugger
                                                //       instance into new interpreter
                                                //       instance.
                                                //
                                                interpreter.Debugger = debugger;
                                            }
                                            else
                                            {
                                                //
                                                // NOTE: Currently, this cannot happen
                                                //       as script debugger creation
                                                //       cannot currently fail.  This
                                                //       may change in the future.
                                                //
                                                result = "unable to create script debugger";
                                                code = ReturnCode.Error;
                                            }
                                        }
                                    }
#endif

                                    if (code == ReturnCode.Ok)
                                    {
                                        //
                                        // NOTE: If script library initialization was
                                        //       requested, do it now.
                                        //
                                        // WARNING: This performs evaluation of a few
                                        //          script library files.  To further
                                        //          complicate matters, any (or all)
                                        //          of these script library files may
                                        //          be user-defined.  Should one of
                                        //          these script library files raise a
                                        //          script error or throw exceptions,
                                        //          the overall creation process for
                                        //          the new interpreter instance may
                                        //          fail.
                                        //
                                        // LOCKING: Exit the interpreter lock prior
                                        //          to script evaluation.  Skip any
                                        //          attempts to reacquire the lock
                                        //          as it should not be needed after
                                        //          this point within this method.
                                        //          It should be noted here that the
                                        //          PrivateInitialize method and all
                                        //          other parts of the script library
                                        //          initialization pipeline perform
                                        //          their own locking.
                                        //
                                        // NOTE: Check the creation flags and the
                                        //       initialization override to determine
                                        //       if script library initialization is
                                        //       desired.
                                        //
                                        bool wantInitialize = initialize &&
                                            FlagOps.HasFlags(createFlags,
                                                CreateFlags.Initialize, true);

                                        if (wantInitialize)
                                        {
                                            interpreter.InternalExitLock(
                                                ref locked); /* TRANSACTIONAL */

                                            Result initializeError = null;

                                            code = interpreter.PrivateInitialize(
                                                false, false, ref initializeError);

                                            interpreter.MaybeIgnoreInitializeError(
                                                ref code, ref initializeError);

                                            if ((code != ReturnCode.Ok) &&
                                                (initializeError != null))
                                            {
                                                result = initializeError;
                                            }
                                        }
                                    }
                                }

                                //*****************************************************

                                if (code == ReturnCode.Ok)
                                {
                                    //
                                    // NOTE: Check for the optional new interpreter
                                    //       instance callback (delegate).  When it
                                    //       is set, all new interpreter instances
                                    //       created in this AppDomain will be sent
                                    //       to it for review prior to them being
                                    //       returned from this method.  This could
                                    //       certainly allow other threads and/or
                                    //       external components to obtain this new
                                    //       interpreter instance.
                                    //
                                    // LOCKING: Exit the interpreter lock prior to
                                    //          executing the callback delegate and
                                    //          skip any attempts to reacquire the
                                    //          lock as it should not be needed after
                                    //          this point within this method.
                                    //
                                    // HACK: Token-based interpreters are exempt from
                                    //       this handling, i.e. will not be seen by
                                    //       any registered "interpreter callbacks".
                                    //       This design decision may be revised in
                                    //       the future.
                                    //
                                    if ((token == null) &&
                                        (newInterpreterCallback != null))
                                    {
                                        GlobalState.PopActiveInterpreter();

                                        try
                                        {
                                            interpreter.InternalExitLock(
                                                ref locked); /* TRANSACTIONAL */

                                            code = newInterpreterCallback(
                                                interpreter, clientData, ref result);

                                            if (code != ReturnCode.Ok)
                                            {
                                                TraceOps.DebugTrace(String.Format(
                                                    "Create ({0}): " +
                                                    "new callback failure, " +
                                                    "code = {1}, result = {2}",
                                                    AppDomainOps.GetCurrentId(),
                                                    code, FormatOps.WrapOrNull(
                                                        true, true, result)),
                                                    typeof(Interpreter).Name,
                                                    TracePriority.StartupError);
                                            }
                                        }
                                        finally
                                        {
                                            GlobalState.PushActiveInterpreter(
                                                interpreter);
                                        }
                                    }
                                }

                                //*****************************************************

                                if (code == ReturnCode.Ok)
                                {
                                    //
                                    // NOTE: Add this new interpreter instance to the
                                    //       global tracking list.  This must succeed
                                    //       or interpreter creation will fail.
                                    //
                                    if (token != null)
                                    {
                                        if (!GlobalState.AddTokenInterpreter(
                                                interpreter, ref result))
                                        {
                                            code = ReturnCode.Error;
                                        }
                                    }
                                    else
                                    {
                                        if (GlobalState.AddInterpreter(
                                                interpreter) == 0)
                                        {
                                            result = "failed to add interpreter";
                                            code = ReturnCode.Error;
                                        }
                                    }
                                }

                                //*****************************************************

                                if (code == ReturnCode.Ok)
                                {
#if NOTIFY && NOTIFY_GLOBAL
                                    //
                                    // NOTE: When global notifications are enabled
                                    //       (rare), notify other interpreters that
                                    //       a new interpreter has been crated and
                                    //       added to the global list.
                                    //
                                    // LOCKING: Exit the interpreter lock prior to
                                    //          firing the global notification and
                                    //          skip any attempts to reacquire the
                                    //          lock as it should not be needed after
                                    //          this point within this method.
                                    //
                                    if (interpreter.PrivateGlobalNotify)
                                    {
                                        interpreter.InternalExitLock(
                                            ref locked); /* TRANSACTIONAL */

                                        /* IGNORED */
                                        CheckNotifications(
                                            null, false,
                                            NotifyType.Interpreter, NotifyFlags.Added,
                                            new ObjectList(culture,
                                                createFlags, hostCreateFlags, host),
                                            interpreter, null, null, null, ref result);
                                    }
#endif
                                }
                                else
                                {
                                    //
                                    // NOTE: At this point, somehow the interpreter
                                    //       creation process has failed.  The new
                                    //       interpreter instance must be disposed
                                    //       to cleanup any resources it may have
                                    //       allocated prior to this point.
                                    //
                                    // LOCKING: Exit the interpreter lock prior to
                                    //          disposing the interpreter instance
                                    //          and skip any attempts to reacquire
                                    //          the lock as it should not be needed
                                    //          after this point within this method.
                                    //          The process of interpreter disposal
                                    //          process may reacquire the lock, and
                                    //          that should be fine.
                                    //
                                    interpreter.InternalExitLock(
                                        ref locked); /* TRANSACTIONAL */

                                    ObjectOps.TryDisposeOrComplain<Interpreter>(
                                        interpreter, ref interpreter);

                                    interpreter = null;
                                }

                                //*****************************************************

                                if ((interpreter == null) && throwOnError)
                                {
                                    TraceOps.DebugTrace(String.Format(
                                        "Create ({0}): failure (with throw), " +
                                        "code = {1}, result = {2}",
                                        AppDomainOps.GetCurrentId(), code,
                                        FormatOps.WrapOrNull(true, true, result)),
                                        typeof(Interpreter).Name,
                                        TracePriority.StartupError);

                                    //
                                    // NOTE: If we get to this point then we have
                                    //       failed to fully create or initialize
                                    //       the interpreter -AND- they requested
                                    //       that we throw an exception in that
                                    //       case.
                                    //
                                    throw new ScriptException(code, result, null);
                                }
                            }
                            finally
                            {
                                /* IGNORED */
                                GlobalState.PopActiveInterpreter();
                            }
                        }
                        else
                        {
                            TraceOps.DebugTrace(String.Format(
                                "Create ({0}): unable to acquire lock (1)",
                                AppDomainOps.GetCurrentId()),
                                typeof(Interpreter).Name,
                                TracePriority.LockError);
                        }
                    }
                    finally
                    {
                        if (interpreter != null)
                        {
                            interpreter.InternalExitLock(
                                ref locked); /* TRANSACTIONAL */
                        }
                    }
                }
                catch (Exception e)
                {
                    TraceOps.DebugTrace(
                        e, typeof(Interpreter).Name,
                        TracePriority.StartupError);

                    if (interpreter != null)
                    {
                        interpreter.InternalExitLock(
                            ref locked); /* TRANSACTIONAL */

                        ObjectOps.TryDisposeOrComplain<Interpreter>(
                            interpreter, ref interpreter);

                        interpreter = null;
                    }

                    if (throwOnError)
                        throw;
                    else
                        result = e;
                }

            done:

                if (interpreter != null)
                {
                    if (FlagOps.HasFlags(
                            initializeFlags, InitializeFlags.Health, true))
                    {
                        //
                        // HACK: This method ends up calling quite a few
                        //       other methods that may throw exceptions
                        //       if the target interpreter is disposed,
                        //       etc (this was pointed out by Coverity);
                        //       therefore, use a special variant that
                        //       simply catches everything.
                        //
                        if (interpreter.PrivateWatchdogControlNoThrow(
                                WatchdogType.Health,
                                WatchdogOperation.StartAndFlags,
                                TimeoutFlags.Default, clientData,
                                null, ref result) != ReturnCode.Ok)
                        {
                            ObjectOps.TryDisposeOrComplain<Interpreter>(
                                interpreter, ref interpreter);

                            interpreter = null;

                            goto done;
                        }
                    }

                    TraceOps.DebugTrace(String.Format(
                        "Create ({0}): success, interpreter = {1}, " +
                        "result = {2}",
                        AppDomainOps.GetCurrentId(),
                        FormatOps.InterpreterNoThrow(interpreter),
                        FormatOps.WrapOrNull(true, true, result)),
                        typeof(Interpreter).Name,
                        TracePriority.StartupDebug);
                }
                else
                {
                    TraceOps.DebugTrace(String.Format(
                        "Create ({0}): failure (without throw), " +
                        "interpreter = {1}, result = {2}",
                        AppDomainOps.GetCurrentId(),
                        FormatOps.InterpreterNoThrow(interpreter),
                        FormatOps.WrapOrNull(true, true, result)),
                        typeof(Interpreter).Name,
                        TracePriority.StartupError);
                }
            }
            finally
            {
                if (profiler != null)
                {
                    profiler.Stop();

                    TraceOps.DebugTrace(String.Format(
                        "Create ({0}): return, interpreter = {1}, " +
                        "result = {2}, completed in {3}",
                        AppDomainOps.GetCurrentId(),
                        FormatOps.InterpreterNoThrow(interpreter),
                        FormatOps.WrapOrNull(true, true, result),
                        FormatOps.MaybeNull(profiler)),
                        typeof(Interpreter).Name,
                        TracePriority.StartupDebug3);

                    if (interpreter != null)
                    {
                        try
                        {
                            interpreter.InternalHardTryLock(
                                ref locked); /* TRANSACTIONAL */

                            if (locked)
                            {
                                interpreter.CreateProfiler(
                                    profiler);
                            }
                            else
                            {
                                TraceOps.DebugTrace(String.Format(
                                    "Create ({0}): unable to acquire lock (2)",
                                    AppDomainOps.GetCurrentId()),
                                    typeof(Interpreter).Name,
                                    TracePriority.LockError);
                            }
                        }
                        finally
                        {
                            interpreter.InternalExitLock(
                                ref locked); /* TRANSACTIONAL */
                        }
                    }

                    ObjectOps.TryDisposeOrTrace<IProfilerState>(
                        ref profiler);
                }
            }

            return interpreter;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Public Static "Factory" Methods
        //
        // NOTE: This is the "simplest" possible method that can
        //       be used to create an interpreter.
        //
        public static Interpreter Create( /* Kapok, null InterpreterSettings, test suite, etc. */
            ref Result result
            )
        {
            return Create(null, null,
                _ClientData.Empty, null, null, Defaults.CreateFlags,
                Defaults.HostCreateFlags, Defaults.InitializeFlags,
                Defaults.ScriptFlags, Defaults.InterpreterFlags,
                Defaults.PluginFlags, null, null, null, null, null,
                null, null, null, null, null, null, null, null,
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static Interpreter Create(
            ulong? token,
            ref Result result
            )
        {
            CreateFlags createFlags = Defaults.CreateFlags;

            MaybeMutateCreateFlags(token, ref createFlags);

            return Create(token, null,
                _ClientData.Empty, null, null, createFlags,
                Defaults.HostCreateFlags, Defaults.InitializeFlags,
                Defaults.ScriptFlags, Defaults.InterpreterFlags,
                Defaults.PluginFlags, null, null, null, null, null,
                null, null, null, null, null, null, null, null,
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static Interpreter Create( /* Example.Program, test suite, etc. */
            IEnumerable<string> args,
            ref Result result
            )
        {
            return Create(null, null,
                _ClientData.Empty, args, null, Defaults.CreateFlags,
                Defaults.HostCreateFlags, Defaults.InitializeFlags,
                Defaults.ScriptFlags, Defaults.InterpreterFlags,
                Defaults.PluginFlags, null, null, null, null,
                null, null, null, null, null, null, null, null,
                null, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static Interpreter Create(
            ulong? token,
            IEnumerable<string> args,
            ref Result result
            )
        {
            CreateFlags createFlags = Defaults.CreateFlags;

            MaybeMutateCreateFlags(token, ref createFlags);

            return Create(token, null,
                _ClientData.Empty, args, null, createFlags,
                Defaults.HostCreateFlags, Defaults.InitializeFlags,
                Defaults.ScriptFlags, Defaults.InterpreterFlags,
                Defaults.PluginFlags, null, null, null, null,
                null, null, null, null, null, null, null, null,
                null, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static Interpreter Create( /* Engine.EvaluateOneScript, MSBuild, WiX, etc. */
            IEnumerable<string> args,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            ref Result result
            )
        {
            return Create(null, null,
                _ClientData.Empty, args, null, createFlags,
                hostCreateFlags, Defaults.InitializeFlags,
                Defaults.ScriptFlags, Defaults.InterpreterFlags,
                Defaults.PluginFlags, null, null, null, null,
                null, null, null, null, null, null, null, null,
                null, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static Interpreter Create( /* Harpy SDK */
            ulong? token,
            IEnumerable<string> args,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            InitializeFlags initializeFlags,
            ScriptFlags scriptFlags,
            PluginFlags pluginFlags,
            string text,
            ref Result result
            )
        {
            return Create(token, null,
                _ClientData.Empty, args, null, createFlags,
                hostCreateFlags, initializeFlags, scriptFlags,
                Defaults.InterpreterFlags, pluginFlags, null,
                null, null, null, null, null, null, null, null,
                null, text, null, null, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static Interpreter Create( /* InterpreterHelper, etc. */
            InterpreterSettings interpreterSettings,
            bool strict,
            ref Result result
            )
        {
            if (interpreterSettings != null)
            {
                return Create(null, null, _ClientData.Empty,
                    interpreterSettings.Args, interpreterSettings.Culture,
                    interpreterSettings.CreateFlags, interpreterSettings.HostCreateFlags,
                    interpreterSettings.InitializeFlags, interpreterSettings.ScriptFlags,
                    interpreterSettings.InterpreterFlags, interpreterSettings.PluginFlags,
                    interpreterSettings.AppDomain, interpreterSettings.Host,
                    interpreterSettings.Profile, interpreterSettings.Owner,
                    interpreterSettings.ApplicationObject, interpreterSettings.PolicyObject,
                    interpreterSettings.ResolverObject, interpreterSettings.UserObject,
                    interpreterSettings.Policies, interpreterSettings.Traces,
                    interpreterSettings.Text, interpreterSettings.LibraryPath,
                    interpreterSettings.AutoPathList, ref result);
            }

            if (strict)
            {
                result = "invalid interpreter settings";
                return null;
            }

            return Create(ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static Interpreter Create(
            ulong? token,
            InterpreterSettings interpreterSettings,
            bool strict,
            ref Result result
            )
        {
            if (interpreterSettings != null)
            {
                return Create(token, null, _ClientData.Empty,
                    interpreterSettings.Args, interpreterSettings.Culture,
                    interpreterSettings.CreateFlags, interpreterSettings.HostCreateFlags,
                    interpreterSettings.InitializeFlags, interpreterSettings.ScriptFlags,
                    interpreterSettings.InterpreterFlags, interpreterSettings.PluginFlags,
                    interpreterSettings.AppDomain, interpreterSettings.Host,
                    interpreterSettings.Profile, interpreterSettings.Owner,
                    interpreterSettings.ApplicationObject, interpreterSettings.PolicyObject,
                    interpreterSettings.ResolverObject, interpreterSettings.UserObject,
                    interpreterSettings.Policies, interpreterSettings.Traces,
                    interpreterSettings.Text, interpreterSettings.LibraryPath,
                    interpreterSettings.AutoPathList, ref result);
            }

            if (strict)
            {
                result = "invalid interpreter settings";
                return null;
            }

            return Create(ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static Interpreter Create( /* Sample.Class1 */
            IEnumerable<string> args,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            TraceList traces,
            ref Result result
            )
        {
            return Create(null, null,
                _ClientData.Empty, args, null, createFlags,
                hostCreateFlags, Defaults.InitializeFlags,
                Defaults.ScriptFlags, Defaults.InterpreterFlags,
                Defaults.PluginFlags, null, null, null, null,
                null, null, null, null, null, traces, null,
                null, null, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static Interpreter Create( /* Eagle._Services.Eagle, etc. */
            IEnumerable<string> args,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            string libraryPath,
            ref Result result
            )
        {
            return Create(null, null,
                _ClientData.Empty, args, null, createFlags,
                hostCreateFlags, Defaults.InitializeFlags,
                Defaults.ScriptFlags, Defaults.InterpreterFlags,
                Defaults.PluginFlags, null, null, null, null,
                null, null, null, null, null, null, null,
                libraryPath, null, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static Interpreter Create( /* Eagle._Shell.Test.Main, etc. */
            IEnumerable<string> args,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            string text,
            string libraryPath,
            ref Result result
            )
        {
            return Create(null, null,
                _ClientData.Empty, args, null, createFlags,
                hostCreateFlags, Defaults.InitializeFlags,
                Defaults.ScriptFlags, Defaults.InterpreterFlags,
                Defaults.PluginFlags, null, null, null, null,
                null, null, null, null, null, null, text,
                libraryPath, null, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static Interpreter Create( /* Featherlight.Components.Private.CommonOps */
            IEnumerable<string> args,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            string text,
            string libraryPath,
            StringList autoPathList,
            ref Result result
            )
        {
            return Create(null, null,
                _ClientData.Empty, args, null, createFlags,
                hostCreateFlags, Defaults.InitializeFlags,
                Defaults.ScriptFlags, Defaults.InterpreterFlags,
                Defaults.PluginFlags, null, null, null, null,
                null, null, null, null, null, null, text,
                libraryPath, autoPathList, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static Interpreter Create( /* Eagle._Cmdlets.Script */
            IEnumerable<string> args,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            InitializeFlags initializeFlags,
            ScriptFlags scriptFlags,
            InterpreterFlags interpreterFlags,
            object applicationObject,
            object policyObject,
            object resolverObject,
            object userObject,
            PolicyList policies,
            TraceList traces,
            string text,
            string libraryPath,
            StringList autoPathList,
            ref Result result
            )
        {
            return Create(null, null,
                _ClientData.Empty, args, null, createFlags,
                hostCreateFlags, initializeFlags, scriptFlags,
                interpreterFlags, Defaults.PluginFlags, null,
                null, null, null, applicationObject, policyObject,
                resolverObject, userObject, policies, traces,
                text, libraryPath, autoPathList, ref result);
        }
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Pre-Setup
        private ReturnCode PreSetupCulture(
            string culture,
            bool specific,
            ref Result error
            )
        {
            //
            // NOTE: Empty string is valid here, we use it to select the current
            //       culture.
            //
            if (culture != null)
            {
                try
                {
                    //
                    // NOTE: Attempt to set the culture based on using the parameter
                    //       "culture" as a name (either neutral or specific).  Empty
                    //       string is valid here and selects the invariant culture.
                    //
                    if (specific)
                        cultureInfo = CultureInfo.CreateSpecificCulture(culture);
                    else
                        cultureInfo = CultureInfo.GetCultureInfo(culture);

                    return ReturnCode.Ok;
                }
                catch
                {
                    //
                    // NOTE: Ok, it was not a valid culture name, try to interpret the
                    //       parameter "culture" as an Id integer.
                    //
                    int cultureId = 0;

                    if (Value.GetInteger2(
                            culture, ValueFlags.AnyInteger, null /* no culture yet! */,
                            ref cultureId, ref error) == ReturnCode.Ok)
                    {
                        try
                        {
                            cultureInfo = CultureInfo.GetCultureInfo(cultureId);

                            return ReturnCode.Ok;
                        }
                        catch (Exception e)
                        {
                            //
                            // NOTE: It parsed as a valid integer; however, the culture
                            //       specified by the Id was not found.
                            //
                            error = FormatOps.ErrorWithException(String.Format(
                                CultureInfoError, culture), e);

                            return ReturnCode.Error;
                        }
                    }
                    else
                    {
                        //
                        // NOTE: It did not parse as a valid integer, fail.
                        //
                        error = String.Format(CultureInfoError, culture);

                        return ReturnCode.Error;
                    }
                }
            }
            else
            {
                //
                // NOTE: Getting this property value is documented to never fail.
                //
                cultureInfo = Value.GetDefaultCulture();

                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the _Hosts.Core class only.
        //
        internal ResourceManager ResourceManager
        {
            get { return resourceManager; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PreSetupResourceManager(ref Result error)
        {
            if (cultureInfo != null)
            {
                string resourceBaseName = GlobalState.GetResourceBaseName();

                if (resourceBaseName != null)
                {
                    try
                    {
                        //
                        // FIXME: PRI 4: Now that this resource management code
                        //        is in place and working properly, we need to
                        //        migrate all the error messages and other
                        //        static strings to be managed resources.  The
                        //        original intention was to do this right from
                        //        the start; however, time constraints prevented
                        //        that vision from becoming a reality.
                        //
                        resourceManager = new ResourceManager(
                            resourceBaseName, GlobalState.GetAssembly());

                        return ReturnCode.Ok;
                    }
                    catch (Exception e)
                    {
                        error = FormatOps.ErrorWithException(String.Format(
                            ResourceManagerError, resourceBaseName), e);
                    }
                }
                else
                {
                    error = InvalidBaseResourceName;
                }
            }
            else
            {
                error = InvalidCultureInfoError;
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PreSetupHostColors(
            IHost host,
            bool strict,
            ref Result error
            )
        {
            //
            // NOTE: Set the system default values for the "default" foreground
            //       and background colors now.  That way, even if there is no
            //       interpreter host or it decides not to do anything, these
            //       values will still be explicitly initialized.
            //
            defaultForegroundColor = _ConsoleColor.Default;
            defaultBackgroundColor = _ConsoleColor.Default;

            //
            // NOTE: If this IHost call fails, the caller will fail to setup
            //       the interpreter.  This is considered to be legitimate,
            //       even in non-strict mode, because IHost implementations are
            //       free to simply return "Ok" without having to do anything
            //       else (i.e. the default colors have already been set to the
            //       system defaults before this call).  Therefore, an IHost
            //       implementation that returns "Error" here is explicitly
            //       saying "the interpreter setup should fail".  Furthermore,
            //       we attempt to further minimize the risk of failure here
            //       by explicitly requesting the default hard-coded colors
            //       from the host (i.e. both the "foreground" and "background"
            //       boolean arguments are set to "false") because that should
            //       be even less likely to fail (and it _is_ less likely to
            //       fail with the "stock" implementation of this method, as
            //       provided by the _Hosts.Core host).
            //
            return HostOps.GetColors(
                host, ColorName.Default, false, false, strict,
                ref defaultForegroundColor, ref defaultBackgroundColor,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void PreSetupNamespaces(
            bool enable,
            bool dispose,
            bool flags
            )
        {
            TraceOps.DebugTrace(String.Format(
                "PreSetupNamespaces: interpreter = {0}, " +
                "enable = {1}, dispose = {2}, flags = {3}",
                FormatOps.InterpreterNoThrow(this), enable, dispose, flags),
                typeof(Interpreter).Name, TracePriority.StartupDebug);

            ///////////////////////////////////////////////////////////////////////////////////////////

            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // HACK: Make 100% sure that we are not about to overwrite valid
                //       disposable object instances when enabling or disabling
                //       namespace support.
                //
                if (dispose)
                {
                    ClearAndMaybeResetNamespacePodObjects(true);
                    DisposeNamespaces();
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                if (enable)
                {
                    if (globalNamespace == null)
                        globalNamespace = NamespaceOps.CreateGlobal(this);

                    if (pendingNamespaces == null)
                        pendingNamespaces = new Dictionary<string, INamespace>();

                    if (namespaceMappings == null)
                        namespaceMappings = NamespaceOps.CreateMappings(this);

                    if (flags)
                        createFlags |= CreateFlags.UseNamespaces;
                }
                else if (flags)
                {
                    createFlags &= ~CreateFlags.UseNamespaces;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || EXECUTE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
#if CACHE_DICTIONARY
        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private CacheFlags SetPropertiesOnCaches()
        {
            return SetPropertiesOnCaches(cacheFlags, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private CacheFlags SetPropertiesOnCaches(
            CacheFlags flags,
            bool enable
            )
        {
            CacheFlags newFlags = CacheFlags.None;

            ///////////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE
            if ((argumentCache != null) &&
                FlagOps.HasFlags(flags, CacheFlags.Argument, true))
            {
                CacheConfiguration.SetProperties<Argument, Argument>(
                    argumentCache, enable);

                newFlags |= CacheFlags.Argument;
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if LIST_CACHE
            if ((stringListCache != null) &&
                FlagOps.HasFlags(flags, CacheFlags.StringList, true))
            {
                CacheConfiguration.SetProperties<string, StringList>(
                    stringListCache, enable);

                newFlags |= CacheFlags.StringList;
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if PARSE_CACHE
            if ((parseStateCache != null) &&
                FlagOps.HasFlags(flags, CacheFlags.IParseState, true))
            {
                CacheConfiguration.SetProperties<string, IParseState>(
                    parseStateCache, enable);

                newFlags |= CacheFlags.IParseState;
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if TYPE_CACHE
            if ((typeCache != null) &&
                FlagOps.HasFlags(flags, CacheFlags.Type, true))
            {
                CacheConfiguration.SetProperties<string, Type>(
                    typeCache, enable);

                newFlags |= CacheFlags.Type;
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if COM_TYPE_CACHE
            if ((comTypeListCache != null) &&
                FlagOps.HasFlags(flags, CacheFlags.ComTypeList, true))
            {
                CacheConfiguration.SetProperties<IntPtr, TypeList>(
                    comTypeListCache, enable);

                newFlags |= CacheFlags.ComTypeList;
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (FlagOps.HasFlags(newFlags, flags & CacheFlags.ObjectMask, true))
                return CacheFlags.SetProperties;
            else
                return CacheFlags.None;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        internal CacheFlags PreSetupCaches()
        {
            return PreSetupCaches(cacheFlags, null);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private CacheFlags PreSetupCaches(
            CacheFlags flags,
            Dictionary<CacheFlags, long[]> savedCacheCounts
            )
        {
            CacheFlags newFlags = CacheFlags.None;

            ///////////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE || LIST_CACHE
            int capacity = CacheConfiguration.GetCapacity();
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE
            if (FlagOps.HasFlags(flags, CacheFlags.Argument, true))
            {
                if (argumentCache == null)
                {
                    argumentCache = new ArgumentCacheDictionary(
                        capacity >= 0 ? capacity : 0);

#if CACHE_STATISTICS
                    if (FlagOps.HasFlags(
                            flags, CacheFlags.KeepCounts, true))
                    {
                        /* IGNORED */
                        RuntimeOps.MaybeRestoreCacheCounts(
                            CacheFlags.Argument, argumentCache, false,
                            false, ref savedCacheCounts);
                    }
#endif

                    newFlags |= CacheFlags.Argument;
                }
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if LIST_CACHE
            if (FlagOps.HasFlags(flags, CacheFlags.StringList, true))
            {
                if (stringListCache == null)
                {
                    stringListCache = new StringListDictionary(
                        capacity >= 0 ? capacity : 0, true);

#if CACHE_STATISTICS
                    if (FlagOps.HasFlags(
                            flags, CacheFlags.KeepCounts, true))
                    {
                        /* IGNORED */
                        RuntimeOps.MaybeRestoreCacheCounts(
                            CacheFlags.StringList, stringListCache, false,
                            false, ref savedCacheCounts);
                    }
#endif

                    newFlags |= CacheFlags.StringList;
                }
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if PARSE_CACHE
            if (FlagOps.HasFlags(flags, CacheFlags.IParseState, true))
            {
                if (parseStateCache == null)
                {
                    parseStateCache = new ParseStateDictionary();

#if CACHE_STATISTICS
                    if (FlagOps.HasFlags(
                            flags, CacheFlags.KeepCounts, true))
                    {
                        /* IGNORED */
                        RuntimeOps.MaybeRestoreCacheCounts(
                            CacheFlags.IParseState, parseStateCache, false,
                            false, ref savedCacheCounts);
                    }
#endif

                    newFlags |= CacheFlags.IParseState;
                }
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if EXECUTE_CACHE
            if (FlagOps.HasFlags(flags, CacheFlags.IExecute, true))
            {
                if (executeCache == null)
                {
                    executeCache = new ExecuteCache();

#if CACHE_STATISTICS
                    if (FlagOps.HasFlags(
                            flags, CacheFlags.KeepCounts, true))
                    {
                        /* IGNORED */
                        RuntimeOps.MaybeRestoreCacheCounts(
                            CacheFlags.IExecute, executeCache, false,
                            false, ref savedCacheCounts);
                    }
#endif

                    newFlags |= CacheFlags.IExecute; /* NOTE: Not a typo. */
                }

                if (hiddenExecuteCache == null)
                {
                    hiddenExecuteCache = new ExecuteCache();

#if CACHE_STATISTICS
                    if (FlagOps.HasFlags(
                            flags, CacheFlags.KeepCounts, true))
                    {
                        /* IGNORED */
                        RuntimeOps.MaybeRestoreCacheCounts(
                            CacheFlags.HiddenIExecute, hiddenExecuteCache, false,
                            false, ref savedCacheCounts);
                    }
#endif

                    newFlags |= CacheFlags.IExecute; /* NOTE: Not a typo. */
                }
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if TYPE_CACHE
            if (FlagOps.HasFlags(flags, CacheFlags.Type, true))
            {
                if (typeCache == null)
                {
                    typeCache = new TypeDictionary();

#if CACHE_STATISTICS
                    if (FlagOps.HasFlags(
                            flags, CacheFlags.KeepCounts, true))
                    {
                        /* IGNORED */
                        RuntimeOps.MaybeRestoreCacheCounts(
                            CacheFlags.Type, typeCache, false,
                            false, ref savedCacheCounts);
                    }
#endif

                    newFlags |= CacheFlags.Type;
                }
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if COM_TYPE_CACHE
            if (FlagOps.HasFlags(flags, CacheFlags.ComTypeList, true))
            {
                if (comTypeListCache == null)
                {
                    comTypeListCache = new IntPtrTypeListDictionary();

#if CACHE_STATISTICS
                    if (FlagOps.HasFlags(
                            flags, CacheFlags.KeepCounts, true))
                    {
                        /* IGNORED */
                        RuntimeOps.MaybeRestoreCacheCounts(
                            CacheFlags.ComTypeList, comTypeListCache, false,
                            false, ref savedCacheCounts);
                    }
#endif

                    newFlags |= CacheFlags.ComTypeList;
                }
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (FlagOps.HasFlags(newFlags, flags & CacheFlags.ObjectMask, true))
                return CacheFlags.Reset;
            else
                return CacheFlags.None;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if !THREADING
        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private void PreSetupCallFramesPhase1()
        {
            CallStack = new CallStack(this.PrivateRecursionLimit, false);
            GlobalFrame = NewGlobalCallFrame(CallStack);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private void PreSetupCallFramesPhase2()
        {
            PushGlobalCallFrame(false); // NOTE: This call frame is never popped.

            GlobalScopeFrame = null;
            // CurrentFrame = null; // HACK: *SPECIAL* Via Push*CallFrame() only.
            ProcedureFrame = null;
            UplevelFrame = null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PreSetupHost(
            IHost host,
            HostCreateFlags hostCreateFlags,
            string profile,
            ref Result error
            )
        {
            //
            // NOTE: Create and/or setup our host environment first because this
            //       will be used to communicate all other initialization failures.
            //
            IHost localHost = null;
            bool localHostOwned = false;
            Result createError = null;

            if (host != null)
            {
                if (FlagOps.HasFlags(hostCreateFlags, HostCreateFlags.Clone, true))
                {
                    //
                    // NOTE: Use a clone of the specified hosting environment.
                    //
                    try
                    {
                        localHost = host.Clone(this); /* throw */

                        if (localHost != null)
                            localHostOwned = true;
                    }
                    catch (Exception e)
                    {
                        createError = e;
                    }
                }
                else
                {
                    //
                    // NOTE: Use the specified hosting environment.
                    //
                    localHost = host;
                }
            }
            else if (!FlagOps.HasFlags(hostCreateFlags, HostCreateFlags.Disable, true))
            {
                if ((profile == null) &&
                    !FlagOps.HasFlags(hostCreateFlags, HostCreateFlags.NoProfile, true))
                {
                    profile = GlobalConfiguration.GetValue(
                        EnvVars.Profile, ConfigurationFlags.Interpreter);
                }

                ///////////////////////////////////////////////////////////////////////////////////////

#if CONSOLE
                if (!String.IsNullOrEmpty(profile))
                {
                    ConsoleOps.MaybeWritePrompt(String.Format(
                        _Constants.Prompt.Profile, profile));
                }

                ///////////////////////////////////////////////////////////////////////////////////////

                if (!FlagOps.HasFlags(
                        hostCreateFlags, HostCreateFlags.NoNativeConsole, true))
                {
                    HostOps.SetupNativeConsole(this, hostCreateFlags);
                }
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

                //
                // NOTE: *HOOK* Allow the default host to be overridden by
                //       an external application or third-party plugin.
                //
                NewHostCallback callback = NewHostCallback; /* STATIC */

            retry:

                if (callback != null)
                {
                    //
                    // HACK: The lock is held while the custom host is
                    //       being created.  In theory, this could cause
                    //       a deadlock if the callback is not careful.
                    //
                    localHost = HostOps.NewCustom(
                        callback, this, null, profile, hostCreateFlags,
                        ref createError);

                    if (localHost != null)
                        localHostOwned = true;

                    if ((localHost == null) && FlagOps.HasFlags(
                            hostCreateFlags, HostCreateFlags.MustCreate,
                            true))
                    {
                        //
                        // NOTE: We failed to create a new host using the
                        //       configured creation callback -AND- we are
                        //       not permitted to fail; therefore, disable
                        //       the creation callback (for this call only)
                        //       and then fallback to default semantics.
                        //
                        callback = null;
                        goto retry;
                    }
                }
                else
                {
#if CONSOLE
                    //
                    // NOTE: Default hosting environment (i.e. optimized
                    //       for console apps, like the interactive shell).
                    //
                    if (!FlagOps.HasFlags(
                            hostCreateFlags, HostCreateFlags.NoConsole,
                            true))
                    {
                        localHost = HostOps.NewConsole(
                            this, null, profile, hostCreateFlags);

                        if (localHost != null)
                            localHostOwned = true;
                    }
                    else
#endif
                    if (!FlagOps.HasFlags(
                            hostCreateFlags, HostCreateFlags.NoDiagnostic,
                            true))
                    {
                        //
                        // NOTE: Debugging hosting environment, for builds
                        //       that do not have System.Console support.
                        //
                        localHost = HostOps.NewDiagnostic(
                            this, null, profile, hostCreateFlags);

                        if (localHost != null)
                            localHostOwned = true;
                    }
                    else if (!FlagOps.HasFlags(
                            hostCreateFlags, HostCreateFlags.NoNull,
                            true))
                    {
                        localHost = HostOps.NewNull(
                            this, null, profile, hostCreateFlags);

                        if (localHost != null)
                            localHostOwned = true;
                    }
                    else if (!FlagOps.HasFlags(
                            hostCreateFlags, HostCreateFlags.NoFake,
                            true))
                    {
                        localHost = HostOps.NewFake(
                            this, null, profile, hostCreateFlags);

                        if (localHost != null)
                            localHostOwned = true;
                    }
                }
            }
            else
            {
                //
                // NOTE: No interpreter host.  This probably won't work
                //       very well in most circumstances.
                //
                localHost = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // TODO: Force use of the host wrapper?  How is this actually useful?
            //       At the moment, this is primarily useful when testing.
            //
            Result wrapError = null;

#if ISOLATED_PLUGINS
            bool overwriteIsolatedHost = false;
#endif

            if ((localHost != null) && FlagOps.HasFlags(
                    hostCreateFlags, HostCreateFlags.UseWrapper, true))
            {
                if (!localHostOwned && FlagOps.HasFlags(
                        hostCreateFlags, HostCreateFlags.OwnWrapper, true))
                {
                    localHostOwned = true;
                }

                HostOps.WrapOrDispose(
                    this, null, profile, localHost.HostCreateFlags,
                    ref localHost, ref localHostOwned, ref wrapError);

#if ISOLATED_PLUGINS
                overwriteIsolatedHost = true;
#endif
            }
#if ISOLATED_PLUGINS
            else if (FlagOps.HasFlags(
                    hostCreateFlags, HostCreateFlags.ResetIsolated, true))
            {
                overwriteIsolatedHost = true;
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            if ((localHost == null) && !FlagOps.HasFlags(
                    hostCreateFlags, HostCreateFlags.Disable, true) &&
                FlagOps.HasFlags(
                    hostCreateFlags, HostCreateFlags.MustCreate, true))
            {
                ResultList errors = new ResultList();

                if (createError != null)
                    errors.Add(createError);

                if (wrapError != null)
                    errors.Add(wrapError);

                errors.Add("failed to create interpreter host");

                error = errors;
                return ReturnCode.Error;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Either we successfully created a new host -OR- failures
            //       to create the host can be safely ignored.
            //
            this.host = localHost;

            //
            // NOTE: If the isolated host (may) need to be updated, attempt to
            //       do that now.
            //
#if ISOLATED_PLUGINS
            /* IGNORED */
            AppDomainOps.MaybeSetIsolatedHost(
                this, localHost, overwriteIsolatedHost);
#endif

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is held.
        //
        private ReturnCode PreSetup(
            IRuleSet ruleSet,
            string culture,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            InitializeFlags initializeFlags,
            ScriptFlags scriptFlags,
            InterpreterFlags interpreterFlags,
            PluginFlags pluginFlags,
            AppDomain appDomain,
            IHost host,
            string profile,
            object owner,
            object applicationObject,
            object policyObject,
            object resolverObject,
            object userObject,
            ClientDataDictionary runtimeOptions,
            string text,
            string libraryPath,
            StringList autoPathList,
            ref Result result
            )
        {
            #region Thread Affinity / AppDomain Identity
            //
            // NOTE: Keep track of the thread that this interpreter was created on.
            //
            this.Thread = Thread.CurrentThread;
            this.ThreadId = GlobalState.GetCurrentSystemThreadId();
            this.ManagedThreadId = GlobalState.GetCurrentManagedThreadId();
            this.NativeThreadId = GlobalState.GetCurrentNativeThreadId();
            this.VariableEvent = ThreadOps.CreateEvent(false);
            this.SetupEvent = ThreadOps.CreateEvent(false);

            //
            // NOTE: What is the rule set used to create / populate this interpreter?
            //
            this.ruleSet = ruleSet;

            //
            // NOTE: What is the application domain for this interpreter?
            //
            this.appDomain = (appDomain != null) ? appDomain : AppDomainOps.GetCurrent();
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Owning Object
            //
            // NOTE: What object is logically the "owner" of this interpreter?
            //
            this.owner = owner;
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Application Integration
            //
            // NOTE: Set the application and user objects now, in case they are necessary
            //       during the later phases of interpreter initialization (e.g. for use
            //       with a custom security policy callback).
            //
            this.applicationObject = applicationObject;
            this.policyObject = policyObject;
            this.resolverObject = resolverObject;
            this.userObject = userObject;
            this.runtimeOptions = runtimeOptions;

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // BUGBUG: There is no (longer an) easy way to disable this feature; however,
            //         it can only be used via a Utility method call and is currently not
            //         used.
            //
            this.throwOnFeatureNotSupported = true;
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Status Data
#if WINFORMS
            this.statusThread = null;
            this.statusStartEventName = null;
            this.statusDoneEventName = null;
            this.statusObject = null;
            this.statusCallback = null;
            this.statusLevels = 0;
            this.statusDisposed = 0;
            this.statusIterations = 0;
            this.statusSynchronous = false;
            this.keyEventMap = null;
#endif
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: We must have a culture and resource manager setup before we do anything
            //       further because they are required to get access to our string resources
            //       (error messages, etc).
            //
            if ((PreSetupCulture(culture, false, ref result) == ReturnCode.Ok) &&
                (PreSetupResourceManager(ref result) == ReturnCode.Ok) &&
                (PreSetupHost(host, hostCreateFlags, profile, ref result) == ReturnCode.Ok) &&
                (PreSetupHostColors(this.host, false, ref result) == ReturnCode.Ok))
            {
                #region Private Properties (Part 1)
                this.PrivateReadOnly = false;
                this.PrivateImmutable = false;
                this.PrivateReadyLimit = DefaultReadyLimit;
                this.PrivateRecursionLimit = DefaultRecursionLimit;
                this.InternalTimeout = DefaultTimeout;
                this.PrivateFinallyTimeout = DefaultFinallyTimeout;
                this.InternalNetworkTimeout = DefaultTimeout;
                this.PrivateSleepTime = _Public.EventManager.DefaultSleepTime;
                this.PrivateExitCode = ResultOps.SuccessExitCode();
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Public Properties
                this.DateTimeFormat = ObjectOps.GetDefaultDateTimeFormat();
                this.DateTimeKind = ObjectOps.GetDefaultDateTimeKind();
                this.DateTimeStyles = ObjectOps.GetDefaultDateTimeStyles();
                this.TimeServers = ObjectOps.GetDefaultTimeServers();

                ///////////////////////////////////////////////////////////////////////////////////////

                this.Quiet = DebugOps.GetDefaultQuiet(DefaultQuiet);

                ///////////////////////////////////////////////////////////////////////////////////////

                this.CommandDecision = PolicyDecision.None;
                this.ScriptDecision = PolicyDecision.None;
                this.FileDecision = PolicyDecision.None;
                this.StreamDecision = PolicyDecision.None;
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Private Properties (Part 2)
                if (FlagOps.HasFlags(createFlags, CreateFlags.Safe, true))
                {
#if CALLBACK_QUEUE
                    this.InternalCallbackLimit = DefaultSafeCallbackLimit;
#endif

                    this.InternalEventLimit = DefaultSafeEventLimit;
                    this.InternalProcedureLimit = DefaultSafeProcedureLimit;
                    this.InternalVariableLimit = DefaultSafeVariableLimit;
                    this.InternalArrayElementLimit = DefaultSafeArrayElementLimit;
                }
                else
                {
#if CALLBACK_QUEUE
                    this.InternalCallbackLimit = DefaultUnsafeCallbackLimit;
#endif

                    this.InternalEventLimit = DefaultUnsafeEventLimit;
                    this.InternalProcedureLimit = DefaultUnsafeProcedureLimit;
                    this.InternalVariableLimit = DefaultUnsafeVariableLimit;
                    this.InternalArrayElementLimit = DefaultUnsafeArrayElementLimit;
                }

                ///////////////////////////////////////////////////////////////////////////////////////

#if RESULT_LIMITS
                if (FlagOps.HasFlags(createFlags, CreateFlags.Safe, true))
                {
                    this.InternalExecuteResultLimit = DefaultSafeExecuteResultLimit;
                    this.InternalNestedResultLimit = DefaultSafeNestedResultLimit;
                }
                else
                {
                    this.InternalExecuteResultLimit = DefaultUnsafeExecuteResultLimit;
                    this.InternalNestedResultLimit = DefaultUnsafeNestedResultLimit;
                }
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

#if NATIVE && TCL
                this.PrivateTclReadOnly = FlagOps.HasFlags(createFlags, CreateFlags.TclReadOnly, true);
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Script Library Pre-Initialization
                preInitializeText = text;
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Script Library Paths
                this.libraryPath = libraryPath;
                this.autoPathList = autoPathList;
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Script Library Miscellaneous
                preSetup = false;
                setup = false;
                initialized = false;
                initializedPath = null;

#if SHELL
                initializedShell = false;
                initializedShellPath = null;
#endif

                trustedPaths = new StringList();
                trustedUris = new UriDictionary<object>();
                trustedTypes = new ObjectDictionary();
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Flags
                this.createFlags = createFlags;
                this.defaultCreateFlags = CreateFlags.NestedUse; /* [interp create] */
                this.hostCreateFlags = hostCreateFlags;
                this.defaultHostCreateFlags = HostCreateFlags.NestedUse; /* [interp create] */
                this.initializeFlags = initializeFlags;
                this.defaultInitializeFlags = Defaults.InitializeFlags;
                this.scriptFlags = scriptFlags;
                this.defaultScriptFlags = Defaults.ScriptFlags;
                this.interpreterFlags = interpreterFlags;
                this.defaultInterpreterFlags = Defaults.InterpreterFlags;
                this.interpreterStateFlags = Defaults.InterpreterStateFlags;

                ///////////////////////////////////////////////////////////////////////////////////////

                this.pluginFlags = pluginFlags;

#if ISOLATED_PLUGINS
                if (FlagOps.HasFlags(createFlags, CreateFlags.IsolatePlugins, true))
                    EnablePluginIsolation();

                if (FlagOps.HasFlags(createFlags, CreateFlags.NoPluginPreview, true))
                    DisablePluginPreview();
#endif

                this.defaultPluginFlags = Defaults.PluginFlags;

                ///////////////////////////////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(createFlags, CreateFlags.NoDispose, true))
                {
                    /* IGNORED */
                    SetDisposalEnabled(false, false);
                }

                ///////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || EXECUTE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
                string value = GlobalConfiguration.GetValue(
                    EnvVars.CacheFlags, ConfigurationFlags.Interpreter);

                if (!String.IsNullOrEmpty(value))
                {
                    cacheFlags = CacheFlags.Default;

                    object enumValue;
                    Result localError = null;

                    enumValue = EnumOps.TryParseFlags(
                        this, typeof(CacheFlags),
                        cacheFlags.ToString(), value,
                        cultureInfo, true, true, true,
                        ref localError);

                    if (enumValue is CacheFlags)
                    {
                        cacheFlags = (CacheFlags)enumValue;
                    }
                    else
                    {
                        DebugOps.Complain(
                            this, ReturnCode.Error, localError);
                    }
                }
                else
                {
                    cacheFlags = CacheFlags.Default;
                }
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

                existVariableFlags = VariableFlags.None;
                getVariableFlags = VariableFlags.None;
                setVariableFlags = VariableFlags.None;
                resetVariableFlags = VariableFlags.None;
                unsetVariableFlags = VariableFlags.None;
                addVariableFlags = VariableFlags.None;
                systemArrayVariableFlags = VariableFlags.None;

                ///////////////////////////////////////////////////////////////////////////////////////

                pathComparisonType = PathComparisonType.Default;
                packageIndexFlags = PackageIndexFlags.AutoPath; /* TODO: Good default? */

#if APPDOMAINS || ISOLATED_INTERPRETERS || ISOLATED_PLUGINS
                if (FlagOps.HasFlags(createFlags, CreateFlags.ProbePlugins, true))
                    packageIndexFlags |= PackageIndexFlags.Plugin;
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

                eventVariableFlags = VariableFlags.None;
                eventWaitFlags = EventWaitFlags.Default;
                readyFlags = ReadyFlags.None;
                engineFlags = EngineFlags.None;
                substitutionFlags = SubstitutionFlags.Default;
                expressionFlags = ExpressionFlags.Default;

                ///////////////////////////////////////////////////////////////////////////////////////

                afterEventFlags = EventFlags.After;
                engineEventFlags = EventFlags.Engine;
                queueEventFlags = EventFlags.Queue;
                serviceEventFlags = EventFlags.Service;
                updateEventFlags = EventFlags.Wait;
                waitEventFlags = EventFlags.Wait;

                ///////////////////////////////////////////////////////////////////////////////////////

                updateFlags = UpdateFlags.Default;

                ///////////////////////////////////////////////////////////////////////////////////////

#if DEBUGGER || SHELL
                headerFlags = HeaderFlags.Invalid;
                detailFlags = DetailFlags.Invalid;
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

#if SHELL && INTERACTIVE_COMMANDS
                interactiveCommandsEnabled = true; // COMPAT: Eagle beta.
                interactiveEngineFlags = EngineFlags.None;
                interactiveSubstitutionFlags = SubstitutionFlags.None;
                interactiveEventFlags = EventFlags.None;
                interactiveExpressionFlags = ExpressionFlags.None;
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

                newGlobalVariableFlags = VariableFlags.None;
                newLocalVariableFlags = VariableFlags.None;

                ///////////////////////////////////////////////////////////////////////////////////////

                packageFlags = PackageFlags.None;
                procedureFlags = ProcedureFlags.None;

                ///////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY || NOTIFY_OBJECT
                notifyTypes = NotifyType.None;
                notifyFlags = NotifyFlags.None;

                //
                // NOTE: For now, default the "global" notification setting to
                //       enabled.  This can be overridden prior to any "global"
                //       notifications being fired by changing this setting
                //       from the "init" script or by using the NoGlobalNotify
                //       flag.
                //
                notify = !FlagOps.HasFlags(
                    createFlags, CreateFlags.NoGlobalNotify, true) ? 1 : 0;
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

#if NATIVE && TCL
                tclFindFlags = FindFlags.Default;
                tclLoadFlags = LoadFlags.Default;
                tclCommandUnloadFlags = UnloadFlags.Default;
                tclExitUnloadFlags = UnloadFlags.None;
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Plugin Tokens
                corePluginToken = 0;

#if NOTIFY || NOTIFY_OBJECT
                objectPluginToken = 0;

#if TEST
                scriptNotifyPluginToken = 0;
#endif
#endif

#if NOTIFY && NOTIFY_ARGUMENTS
                monitorPluginToken = 0;
#endif

#if TEST_PLUGIN || DEBUG
                testPluginToken = 0;
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Core Entities
                //
                // NOTE: How many times has the [unknown] script been executed?
                //
                unknownCount = 0;

                //
                // NOTE: How many discrete operations have been executed?
                //
                operationCount = 0;

                //
                // NOTE: How many commands have been executed?
                //
                commandCount = 0;

                //
                // NOTE: How many readiness checks have been executed?
                //
                readyCount = 0;

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Packages
                packageIndexes = new PackageIndexDictionary();
                packages = new PackageWrapperDictionary();
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Error Handling
                backgroundError = TclVars.Command.BackgroundError;
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Unknown Handling
                unknownCallback = null;
                unknown = TclVars.Command.Unknown; /* BUGFIX: Must be before PreSetupNamespaces. */
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Package Handling
                packageFallback = null;
                packageUnknown = TclVars.Command.PackageUnknown;
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Namespaces
                PreSetupNamespaces(AreNamespacesEnabled(), true, false);
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Core Extensibility
                pluginArguments = new StringDictionary();
                plugins = new PluginWrapperDictionary();
                commands = new CommandWrapperDictionary();
                hiddenCommands = new CommandWrapperDictionary();
                policies = new PolicyWrapperDictionary();
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Executable Objects
                procedures = new ProcedureWrapperDictionary();
                hiddenProcedures = new ProcedureWrapperDictionary();

                #region Dead Code
#if DEAD_CODE
                lambdas = new LambdaWrapperDictionary();
#endif
                #endregion

                executes = new ExecuteWrapperDictionary();
                hiddenExecutes = new ExecuteWrapperDictionary();
                operators = new OperatorWrapperDictionary();
                operatorCache = new IOperator[(int)Lexeme.Maximum + 1];
                functions = new FunctionWrapperDictionary();
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Event Manager
                //
                // NOTE: Create the event manager now.
                //
                eventManager = new EventManager(this);

                //
                // NOTE: How many events have been processed?
                //
                eventCount = 0;

#if NATIVE && TCL
                //
                // NOTE: How many native Tcl events have been processed?
                //
                tclEventCount = 0;
                tclSleepCount = 0;
#endif

                //
                // NOTE: Initialize the count of pending wait calls to zero.
                //
                waitCount = 0;

                //
                // NOTE: How many times have we waited for an event (in WaitVariable)?
                //
                waitSpinCount = 0;
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Variables
                missingVariableValue = null;
                missingVariableDirty = true;
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Variable Traces
                traces = new TraceWrapperDictionary();
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Variable Scopes
                scopes = new CallFrameDictionary();
                #endregion
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region CLR Integration
                binder = new ScriptBinder(
                    this, null, FlagOps.HasFlags(createFlags,
                    CreateFlags.NoDefaultBinder, true), this.Debug);

                createInstanceBindingFlags =
                    ObjectOps.GetBindingFlags(
                        MetaBindingFlags.PublicCreateInstance, true);

                objects = new ObjectWrapperDictionary();
                aliases = new AliasWrapperDictionary();
                callbacks = new CallbackDictionary();

                ///////////////////////////////////////////////////////////////////////////////////////

                objectTypes = new StringDictionary();

                ///////////////////////////////////////////////////////////////////////////////////////

                ObjectOps.GetNamespaces(this, out objectNamespaces);

                ///////////////////////////////////////////////////////////////////////////////////////

                objectInterfaces = new TypePairDictionary<string, long>();
                objectAliasNamespaces = new StringDictionary();

                ///////////////////////////////////////////////////////////////////////////////////////

                pluginBaseDirectory = null;

                ///////////////////////////////////////////////////////////////////////////////////////

                #region XML Integration
#if XML
                if (FlagOps.HasFlags(createFlags, CreateFlags.Safe, true))
                    retryXml = XmlErrorTypes.SafeInterpreter;
                else
                    retryXml = XmlErrorTypes.UnsafeInterpreter;

                validateXml = false;
                relaxedXml = false;
                allXml = false;
#endif
                #endregion
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Interpreters
                parentInterpreter = null;
                childName = null;

#if APPDOMAINS && ISOLATED_INTERPRETERS
                childAppDomainName = null;
#endif

                childInterpreters = new InterpreterDictionary();
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Other Entities
#if DATA
                connections = new DbConnectionDictionary();
                transactions = new DbTransactionDictionary();
#endif

#if CALLBACK_QUEUE
                callbackQueue = new CallbackQueue();
#endif

#if APPDOMAINS
                appDomains = new AppDomainDictionary();
#endif

#if NATIVE && TCL
                lock (tclSyncRoot) // NOTE: Pedantic.
                {
                    tclInterps = new IntPtrDictionary();

#if TCL_THREADS
                    tclThreads = new TclThreadDictionary();
#endif

                    tclBridges = new TclBridgeDictionary();
                }
#endif

#if EMIT && NATIVE && LIBRARY
                modules = new ModuleWrapperDictionary();
                delegates = new DelegateWrapperDictionary();
#endif

                cleanupPaths = new PathDictionary<CleanupPathClientData>();
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Random Number Generators
                if (!FlagOps.HasFlags(createFlags, CreateFlags.NoRandom, true))
                {
                    random = new Random();
                    randomNumberGenerator = RNGCryptoServiceProvider.Create();

                    ///////////////////////////////////////////////////////////////////////////////////
                    //
                    // NOTE: Prepare entropy buffers for use by various script commands,
                    //       e.g. the [info context] sub-command.  Different buffers are
                    //       used for "safe" and "unsafe" modes.  In spite of that fact,
                    //       these buffers are NOT considered to be a security feature.
                    //
                    entropy = new byte[DefaultEntropySize];

                    /* NO RESULT */
                    GetRandomBytes(ref entropy);

                    ///////////////////////////////////////////////////////////////////////////////////

                    safeEntropy = new byte[DefaultEntropySize];

                    /* NO RESULT */
                    GetRandomBytes(ref safeEntropy);
                }
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Object Identifiers
#if RANDOMIZE_ID
                //
                // NOTE: If possible, randomize the starting Id for objects.
                //
                nextId = (random != null) ? Math.Abs(random.Next()) : 0;
#else
                nextId = 0;
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Channels & Encodings
                channels = new ChannelDictionary();

                //
                // NOTE: Initialize the "well-known" encodings.
                //
                encodings = new EncodingDictionary(new _Comparers.Custom(
                    SharedStringOps.GetSystemComparisonType(true)));

                encodings.Add(StringOps.NullEncodingName, null);

                encodings.Add(StringOps.BinaryEncodingName,
                    StringOps.GetEncoding(EncodingType.Binary));

                encodings.Add(StringOps.ChannelEncodingName,
                    StringOps.GetEncoding(EncodingType.Channel));

                encodings.Add(StringOps.DefaultEncodingName,
                    StringOps.GetEncoding(EncodingType.Default));

                encodings.Add(StringOps.SystemEncodingName,
                    StringOps.GetEncoding(EncodingType.System));

                encodings.Add(StringOps.TclEncodingName,
                    StringOps.GetEncoding(EncodingType.Tcl));

                encodings.Add(StringOps.TextEncodingName,
                    StringOps.GetEncoding(EncodingType.Text));

                encodings.Add(StringOps.ScriptEncodingName,
                    StringOps.GetEncoding(EncodingType.Script));

                encodings.Add(StringOps.XmlEncodingName,
                    StringOps.GetEncoding(EncodingType.Xml));

                encodings.Add(IdentityEncoding.webName, IdentityEncoding.Identity);
                encodings.Add(OneByteEncoding.webName, OneByteEncoding.OneByte);
                encodings.Add(TwoByteEncoding.webName, TwoByteEncoding.TwoByte);
                encodings.Add(TclEncoding.webName, TclEncoding.Tcl);
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Static Lock Held
                lock (staticSyncRoot)
                {
#if NATIVE
                    #region Native Stack Checking
                    RuntimeOps.MaybeInitializeStackChecking();
                    #endregion
#endif

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Cache Settings
#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
                    InitializeCaches(false);
#endif
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Context Manager (Threaded Only)
#if THREADING
                    ContextManager.Initialize();
#endif
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Native Tcl/Tk Integration Data
#if NATIVE && TCL
                    #region Transfer Global Tcl/Tk Integration Data
                    MaybeTransferFromTclPurgatory();
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Re-Initialize Global Tcl/Tk Integration Data
                    MaybeInitializeTclPurgatory();
                    #endregion
#endif
                    #endregion
                }
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Cached Entities
#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || EXECUTE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
                /* IGNORED */
                PreSetupCaches();

                ///////////////////////////////////////////////////////////////////////////////////////

#if CACHE_DICTIONARY
                /* IGNORED */
                SetPropertiesOnCaches();
#endif
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Context Manager (Threaded Only)
#if THREADING
                //
                // NOTE: This must be done AFTER the static Initialize method
                //       of the ContextManager class has been called (above).
                //
                contextManager = new ContextManager(this);

                ResetDisposeContextCounts();
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Variable Content Members (Non-Threaded Only)
#if !THREADING
                PreSetupCallFramesPhase1();

                ///////////////////////////////////////////////////////////////////////////////////////

                PreSetupCallFramesPhase2();
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Command & Variable Resolvers
                //
                // NOTE: For now, just add the core resolver.  This must refer
                //       to the "CurrentGlobalFrame" property so that it gets
                //       created now, if necessary.
                //
                resolvers = new List<IResolve>(new IResolve[] {
                    RuntimeOps.NewResolver(this, CurrentGlobalFrame, globalNamespace, createFlags)
                });
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Engine Context Members
                GlobalCancel = false;
                GlobalUnwind = false;
                GlobalHalt = false;

                GlobalCancelResult = null;
                GlobalHaltResult = null;
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Engine Context Members (Non-Threaded Only)
#if !THREADING
                ContextClientData = null;

                InternalLevels = 0;
                MaximumLevels = 0;

                ParserLevels = 0;
                MaximumParserLevels = 0;

                ExpressionLevels = 0;
                EntryExpressionLevels = 0;
                MaximumExpressionLevels = 0;

                PreviousLevels = 0;
                CatchLevels = 0;
                UnknownLevels = 0;
                TraceLevels = 0;
                SubCommandLevels = 0;
                SettingLevels = 0;
                PackageLevels = 0;

#if ARGUMENT_CACHE
                CacheArgument = Argument.InternalCreate();
#endif

#if DEBUGGER
                WatchpointLevels = 0;
#endif

#if NOTIFY || NOTIFY_OBJECT
                NotifyLevels = 0;
                NotifyTypes = NotifyType.None;
                NotifyFlags = NotifyFlags.None;
#endif

                SecurityLevels = 0;
                PolicyLevels = 0;
                TestLevels = 0;

#if DEBUGGER
                IsDebuggerExiting = false;
#endif

                StackOverflow = false;

#if DEBUGGER
                Debugger = null;
                InteractiveLoopCallback = null;
#endif

#if SHELL
                PreviewArgumentCallback = null;
                UnknownArgumentCallback = null;
                EvaluateScriptCallback = null;
                EvaluateFileCallback = null;
                EvaluateEncodedFileCallback = null;
#endif

#if PREVIOUS_RESULT
                PreviousResult = null;
#endif

                SharedEngineFlags = EngineFlags.None;

                ParseState = null;

                ReturnCode = ReturnCode.Ok;

                ErrorLine = 0;
                ErrorCode = null;
                ErrorInfo = null;
                ErrorFrames = 0;
                Exception = null;

                ScriptLocation = null;
                ScriptLocations = new ScriptLocationList();

                PreviousProcessId = 0;

                ArraySearches = new ArraySearchDictionary();

#if HISTORY
                HistoryEngineFilter = null;
                _History = new ClientDataList();
#endif

                Complaint = null;
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Interactive Non-Context Members
#if SHELL
                pausedInteractiveLoops = new LongLongDictionary();
                globalInteractiveLoops = 0;
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Interactive Context Members (Non-Threaded Only)
#if !THREADING
                // Interactive = false; // HACK: *SPECIAL* Setup() only.
                InteractiveInput = null;
                PreviousInteractiveInput = null;
                InteractiveMode = null;

                ///////////////////////////////////////////////////////////////////////////////////////

                // ActiveInteractiveLoops = 0; // HACK: *SPECIAL* Setup() only.
                TotalInteractiveLoops = 0;
                TotalInteractiveInputs = 0;

                ///////////////////////////////////////////////////////////////////////////////////////

#if SHELL
                ShellCallbackData = null;
                InteractiveLoopData = null;
                UpdateData = null;
#endif

                InteractiveCommandCallback = null;

                ///////////////////////////////////////////////////////////////////////////////////////

#if HISTORY
                HistoryLoadData = null;
                HistorySaveData = null;

                HistoryInfoFilter = null;
                HistoryLoadFilter = null;
                HistorySaveFilter = null;

                HistoryFileName = null;
#endif
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Test Context Members (Non-Threaded Only)
#if !THREADING
                //
                // NOTE: Initialize the test related data.
                //
                TestTargetInterpreter = null;
                TestStatistics = new long[(int)TestInformationType.SizeOf];
                TestConstraints = new StringList();
                TestKnownBugs = new IntDictionary();
                TestSkipped = new StringListDictionary();
                TestFailures = new StringList();
                TestCounts = new IntDictionary();
                TestMatch = new StringList(); /* TODO: Should this default to all (*)? */
                TestSkip = new StringList();
                TestReturnCodeMessages = TestOps.GetReturnCodeMessages();

#if DEBUGGER
                TestBreakpoints = new StringDictionary();
#endif

                TestComparer = null;
                TestPath = null;
                TestVerbose = TestOutputType.Default;
                TestRepeatCount = Count.Invalid;
                TestCurrent = null;
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Interactive Loop Members
#if SHELL
                interactiveLoopSemaphore = ThreadOps.CreateSemaphore(1, 1);
                interactiveLoopDoneEvent = ThreadOps.CreateEvent(false);
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                preSetup = true;
                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Setup
#if DEBUGGER
        private ReturnCode SetupDebuggerHost(
            IHost host,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // NOTE: If this interpreter has no debugger then we
                //       can simply do nothing.
                //
                IDebugger debugger = this.Debugger;

                if (debugger != null)
                {
                    //
                    // NOTE: Extract the isolated debugger interpreter
                    //       and check its validity.
                    //
                    Interpreter debugInterpreter = debugger.Interpreter;

                    if (debugInterpreter != null)
                    {
                        try
                        {
                            //
                            // NOTE: If the provided host is valid, clone it
                            //       into the isolated debugger interpreter;
                            //       otherwise, just use the provided null
                            //       value (i.e. if the parent interpreter
                            //       does not have a valid host then the
                            //       isolated debugger interpreter should not
                            //       have one either).
                            //
                            IHost newHost = (host != null) ?
                                host.Clone(debugInterpreter) : null;

                            //
                            // NOTE: Set the host for the isolated debugger
                            //       interpreter (may be null).
                            //
                            debugInterpreter.Host = newHost;

                            //
                            // BUGFIX: There is no need to call SetupHostChannels
                            //         here for the debug interpreter because that
                            //         should have been automatically in response
                            //         to the above host reassignment.
                            //
                            return ReturnCode.Ok;
                        }
                        catch (Exception e)
                        {
                            error = e;
                            return ReturnCode.Error;
                        }
                    }
                    else
                    {
                        //
                        // NOTE: Ok, the debugger interpreter is not available.
                        //       This is not an error.
                        //
                        return ReturnCode.Ok;
                    }
                }
                else
                {
                    //
                    // NOTE: Ok, the debugger is not available.  This is not
                    //       an error.
                    //
                    return ReturnCode.Ok;
                }
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Assumes the interpreter lock is held.
        //
        private ReturnCode SetupTraceLists(
            IPlugin plugin,
            IClientData clientData,
            bool force,
            ref Result error /* NOT USED */
            )
        {
            if (force || (autoPathTraceList == null))
            {
                autoPathTraceList = new TraceList(
                    clientData, TraceFlags.None, plugin,
                    new TraceCallback[] { AutoPathTraceCallback });
            }

            if (force || (environmentTraceList == null))
            {
                environmentTraceList = new TraceList(
                    clientData, TraceFlags.None, plugin,
                    new TraceCallback[] { EnvironmentTraceCallback });
            }

            if (force || (enumerableVariableTraceList == null))
            {
                enumerableVariableTraceList = new TraceList(
                    clientData, TraceFlags.None, plugin,
                    new TraceCallback[] { EnumerableVariableTraceCallback });
            }

            if (force || (linkedVariableTraceList == null))
            {
                linkedVariableTraceList = new TraceList(
                    clientData, TraceFlags.None, plugin,
                    new TraceCallback[] { LinkedVariableTraceCallback });
            }

            if (force || (systemArrayTraceList == null))
            {
                systemArrayTraceList = new TraceList(
                    clientData, TraceFlags.None, plugin,
                    new TraceCallback[] { SystemArrayTraceCallback });
            }

            if (force || (objectTraceList == null))
            {
                objectTraceList = new TraceList(
                    clientData, TraceFlags.Global, plugin,
                    new TraceCallback[] { ObjectTraceCallback });
            }

            if (force || (precisionTraceList == null))
            {
                precisionTraceList = new TraceList(
                    clientData, TraceFlags.None, plugin,
                    new TraceCallback[] { PrecisionTraceCallback });
            }

            if (force || (testsTraceList == null))
            {
                testsTraceList = new TraceList(
                    clientData, TraceFlags.None, plugin,
                    new TraceCallback[] { TestsTraceCallback });
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetupTraces(
            TraceList traces,
            IClientData clientData,
            ref Result error
            )
        {
            if (traces != null)
            {
                foreach (ITrace trace in traces)
                {
                    Result localResult = null;

                    if (AddTrace(trace, clientData,
                            ref localResult) != ReturnCode.Ok)
                    {
                        error = localResult;
                        return ReturnCode.Error;
                    }
                }

                return ReturnCode.Ok;
            }
            else
            {
                error = "invalid traces";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Assumes the interpreter lock is held.
        //
        private ReturnCode SetupTraces(
            CreateFlags createFlags,
            TraceList traces,
            ref Result error
            )
        {
            IPlugin plugin = GetCorePlugin(ref error);

            if (plugin == null)
                return ReturnCode.Error;

            ///////////////////////////////////////////////////////////////////

            if (SetupTraceLists(plugin,
                    _ClientData.Empty, false, ref error) != ReturnCode.Ok)
            {
                return ReturnCode.Error;
            }

            ///////////////////////////////////////////////////////////////////

            //
            // NOTE: Setup interpreter wide variable traces now.  Traces
            //       provided by the caller are added first followed by
            //       traces needed for proper operation of features like
            //       core opaque object handle reference counting.
            //
            if (traces != null)
            {
                if (SetupTraces(
                        traces, null, ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }
            }

            ///////////////////////////////////////////////////////////////////

            if (!FlagOps.HasFlags(
                    createFlags, CreateFlags.NoCoreTraces, true) &&
                (objectTraceList != null))
            {
                if (SetupTraces(
                        objectTraceList, null, ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetupPolicies(
            PolicyList policies,
            IPlugin plugin,
            IClientData clientData,
            ref Result error
            )
        {
            if (policies != null)
            {
                foreach (IPolicy policy in policies)
                {
                    if (policy == null)
                        continue;

                    Result localResult = null;

                    if (AddPolicy(
                            policy.Callback, plugin, clientData,
                            ref localResult) != ReturnCode.Ok)
                    {
                        error = localResult;
                        return ReturnCode.Error;
                    }
                }

                return ReturnCode.Ok;
            }
            else
            {
                error = "invalid policies";
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Assumes the interpreter lock is held.
        //
        private ReturnCode SetupPolicies(
            CreateFlags createFlags,
            PolicyList policies,
            bool noCommands,
            ref Result error
            )
        {
            IPlugin plugin = GetCorePlugin(ref error);

            if (plugin == null)
                return ReturnCode.Error;

            ///////////////////////////////////////////////////////////////////

            //
            // NOTE: For "safe" interpreters, setup the interpreter policies
            //       now.  Policies provided by the caller are added first
            //       followed by the policies needed for proper operation of
            //       various features (e.g. script library initialization).
            //
            if (policies != null)
            {
                if (SetupPolicies(
                        policies, null, null,
                        ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }
            }

            ///////////////////////////////////////////////////////////////////

            if (!noCommands && !FlagOps.HasFlags(
                    createFlags, CreateFlags.NoCorePolicies, true))
            {
                PolicyList corePolicies = new PolicyList(
                    PolicyOps.CommandCallbacks);

                if (corePolicies != null)
                {
                    if (SetupPolicies(
                            corePolicies, plugin, null,
                            ref error) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetupObjects(
            CreateFlags createFlags,
            ref Result error
            )
        {
            if (!FlagOps.HasFlags(
                    createFlags, CreateFlags.NoObjects, true))
            {
                if (AddNullObject(ref error) != ReturnCode.Ok)
                    return ReturnCode.Error;

                if (!FlagOps.HasFlags(
                        createFlags, CreateFlags.NoVariablesMask, false)) /* EXEMPT */
                {
                    Result result = null;

                    if (SetLibraryVariableValue(
                            VariableFlags.Invariant, Vars.Core.Null,
                            Vars.Core.Null, ref result) != ReturnCode.Ok)
                    {
                        error = result;
                        return ReturnCode.Error;
                    }
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateIsNoVariables()
        {
            //
            // NOTE: Assumes lock is already held if needed.
            //
            return FlagOps.HasFlags(
                createFlags, CreateFlags.NoVariablesMask, false);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private string GetAutoPathValue(
            StringList autoPathList,
            bool? safe
            )
        {
            bool localSafe = (safe != null) ?
                (bool)safe : InternalIsSafe();

            if (localSafe)
                return null;

            return (autoPathList != null) ?
                autoPathList.ToString() : null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Assumes the interpreter lock is held.
        //
        internal ReturnCode SetupMinimumVariables(
            StringList autoPathList,
            ref Result result
            )
        {
            //
            // HACK: Even when "NoPlatform" flag is set, always set the
            //       "tcl_platform(engine)" (see TIP #440) array element
            //       because it is required by the [isEagle] core script
            //       library procedure, which is absolutely critical to
            //       proper core script library initialization.
            //
            ReturnCode code = ReturnCode.Ok;

            if (!FlagOps.HasFlags(
                    createFlags, CreateFlags.NoVariables, true)) /* EXEMPT */
            {
                if (code == ReturnCode.Ok)
                {
                    code = SetLibraryVariableValue2(
                        VariableFlags.None, TclVars.Platform.Name,
                        TclVars.Platform.Engine, Vars.Package.Name,
                        ref result);
                }

                if ((code == ReturnCode.Ok) && initialized)
                {
                    InitializeFlags localInitializeFlags;

                    lock (syncRoot)
                    {
                        localInitializeFlags = initializeFlags;
                    }

                    code = SetAutoPathList(
                        autoPathList, FlagOps.HasFlags(localInitializeFlags,
                        InitializeFlags.NoTraceAutoPath, true), ref result);
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Assumes the interpreter lock is held.
        //
        internal ReturnCode SetupVariables(
            CreateFlags createFlags,
            IEnumerable<string> args,
            bool strict,
            ref Result result
            )
        {
            ReturnCode code = ReturnCode.Ok;

            if (!FlagOps.HasFlags(
                    createFlags, CreateFlags.NoVariablesMask, false)) /* EXEMPT */
            {
                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue(
                        VariableFlags.None, TclVars.Package.VersionName,
                        TclVars.Package.VersionValue, ref result);

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue(
                        VariableFlags.None, TclVars.Package.PatchLevelName,
                        TclVars.Package.PatchLevelValue, ref result);

                bool success; /* REUSED */
                ThreadVariable threadVariable; /* REUSED */

                if (code == ReturnCode.Ok)
                {
                    success = false;
                    threadVariable = null;

                    try
                    {
                        threadVariable = ThreadVariable.Create();

                        if (threadVariable != null)
                        {
                            code = threadVariable.AddVariable(
                                this, Engine.ErrorCodeVariableFlags,
                                TclVars.Core.ErrorCode, ref result);

                            if (code == ReturnCode.Ok)
                                success = true;
                        }
                        else
                        {
                            result = String.Format(
                                "could not create thread variable {0}",
                                FormatOps.ErrorVariableName(
                                    TclVars.Core.ErrorCode));

                            code = ReturnCode.Error;
                        }
                    }
                    finally
                    {
                        if (!success && (threadVariable != null))
                        {
                            threadVariable.Dispose();
                            threadVariable = null;
                        }
                    }
                }

                if (code == ReturnCode.Ok)
                {
                    success = false;
                    threadVariable = null;

                    try
                    {
                        threadVariable = ThreadVariable.Create();

                        if (threadVariable != null)
                        {
                            code = threadVariable.AddVariable(
                                this, Engine.ErrorInfoVariableFlags,
                                TclVars.Core.ErrorInfo, ref result);

                            if (code == ReturnCode.Ok)
                                success = true;
                        }
                        else
                        {
                            result = String.Format(
                                "could not create thread variable {0}",
                                FormatOps.ErrorVariableName(
                                    TclVars.Core.ErrorInfo));

                            code = ReturnCode.Error;
                        }
                    }
                    finally
                    {
                        if (!success && (threadVariable != null))
                        {
                            threadVariable.Dispose();
                            threadVariable = null;
                        }
                    }
                }

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue(
                        VariableFlags.None, TclVars.Core.PrecisionName,
                        TclVars.Expression.DefaultPrecision.ToString(),
                        precisionTraceList, ref result);

                if (code == ReturnCode.Ok)
                    code = AddLibraryVariable(VariableFlags.Array,
                        Vars.Core.Tests, testsTraceList, strict, ref result);

                if (code == ReturnCode.Ok)
                {
                    if (!InternalIsSafe())
                    {
                        if (args != null)
                        {
                            StringList arguments = new StringList(args);

                            if (code == ReturnCode.Ok)
                                code = SetLibraryVariableValue(
                                    VariableFlags.None, TclVars.Core.ShellArgumentCount,
                                    arguments.Count.ToString(), ref result);

                            if (code == ReturnCode.Ok)
                                code = SetLibraryVariableValue(
                                    VariableFlags.None, TclVars.Core.ShellArguments,
                                    arguments.ToString(), ref result);
                        }
                        else if (FlagOps.HasFlags(
                                createFlags, CreateFlags.SetArguments, true))
                        {
                            if (code == ReturnCode.Ok)
                                code = SetLibraryVariableValue(
                                    VariableFlags.None, TclVars.Core.ShellArgumentCount,
                                    Value.ZeroString, ref result);

                            if (code == ReturnCode.Ok)
                                code = SetLibraryVariableValue(
                                    VariableFlags.None, TclVars.Core.ShellArguments,
                                    null, ref result);
                        }

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue(
                                VariableFlags.None, TclVars.Core.ShellArgument0,
                                PathOps.GetExecutableName(), ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue(
                                VariableFlags.None, TclVars.Core.RunCommandsFileName,
                                TclVars.Path.RunCommands, ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue(
                                VariableFlags.None, TclVars.Core.NonWordCharacters,
                                null, ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue(
                                VariableFlags.None, TclVars.Core.WordCharacters,
                                null, ref result);

                        if (code == ReturnCode.Ok)
                            code = AddLibraryVariable(
                                VariableFlags.None, TclVars.Core.AutoSourcePath,
                                null, strict, ref result);

                        if (code == ReturnCode.Ok)
                            code = AddLibraryVariable(VariableFlags.Array,
                                TclVars.Core.Environment, environmentTraceList, strict,
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = AddLibraryVariable(VariableFlags.Array,
                                Vars.Core.Shell, null, strict, ref result);

                        if (code == ReturnCode.Ok)
                            code = AddLibraryVariable(VariableFlags.Array,
                                Vars.Core.Debugger, null, strict, ref result);

                        if (code == ReturnCode.Ok)
                            code = AddLibraryVariable(VariableFlags.Array,
                                Vars.Core.Paths, null, strict, ref result);

                        if (code == ReturnCode.Ok)
                            code = AddLibraryVariable(VariableFlags.Array,
                                TclVars.Core.AutoIndex, null, strict, ref result);
                    }
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool NeedTypesForSetup(
            CreateFlags createFlags
            )
        {
            if (!ShouldUseBuiltIns(IdentifierKind.Command) && !FlagOps.HasFlags(
                    createFlags, CreateFlags.NoCommands, true))
            {
                TraceOps.DebugTrace(
                    "NeedTypesForSetup: not using built-in commands",
                    typeof(Interpreter).Name, TracePriority.StartupDebug);

                return true;
            }

            if (!ShouldUseBuiltIns(IdentifierKind.Function) && !FlagOps.HasFlags(
                    createFlags, CreateFlags.NoFunctions, true))
            {
                TraceOps.DebugTrace(
                    "NeedTypesForSetup: not using built-in functions",
                    typeof(Interpreter).Name, TracePriority.StartupDebug);

                return true;
            }

            if (!ShouldUseBuiltIns(IdentifierKind.Operator))
            {
                TraceOps.DebugTrace(
                    "NeedTypesForSetup: not using built-in operators",
                    typeof(Interpreter).Name, TracePriority.StartupDebug);

                return true;
            }

            TraceOps.DebugTrace(
                "NeedTypesForSetup: assembly types are not needed",
                typeof(Interpreter).Name, TracePriority.StartupDebug);

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Assumes the interpreter lock is held.
        //
        private ReturnCode SetupFunctions(
            CreateFlags createFlags,
            PluginFlags pluginFlags,
            bool useBuiltIn,
            ref Result error
            )
        {
            bool verbose = FlagOps.HasFlags(
                pluginFlags, PluginFlags.Verbose, true);

            TypeList types = null;
            ResultList errors = null;

            if (!RuntimeOps.GetTypes(
                    verbose, ref types, ref errors))
            {
                error = errors;
                return ReturnCode.Error;
            }

            return SetupFunctions(
                types, createFlags, pluginFlags, useBuiltIn, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Assumes the interpreter lock is held.
        //
        private ReturnCode SetupFunctions(
            TypeList types,
            CreateFlags createFlags,
            PluginFlags pluginFlags,
            bool useBuiltIn,
            ref Result error
            )
        {
            if (FlagOps.HasFlags(
                    createFlags, CreateFlags.NoFunctions, true))
            {
                return ReturnCode.Ok;
            }

            IPlugin plugin = GetCorePlugin(ref error);

            if (plugin == null)
                return ReturnCode.Error;

            List<IFunctionData> functions = null;

            if (useBuiltIn)
            {
                if (RuntimeOps.GetBuiltInFunctions(
                        plugin, pluginFlags, InternalIsStandard(),
                        ref functions, ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }
            }
            else
            {
                if (RuntimeOps.GetPluginFunctions(
                        plugin, types, pluginFlags, InternalIsStandard(),
                        ref functions, ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }
            }

            foreach (IFunctionData functionData in functions)
            {
                IFunction function = null;
                Result localResult; /* REUSED */

                localResult = null;

                if (RuntimeOps.CreateFunction(functionData,
                        ref function, ref localResult) != ReturnCode.Ok)
                {
                    error = localResult;
                    return ReturnCode.Error;
                }

                localResult = null;

                if (AddFunction(
                        function, null, ref localResult) != ReturnCode.Ok)
                {
                    error = localResult;
                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetupOperators(
            TypeList types,
            CreateFlags createFlags,
            InterpreterFlags interpreterFlags,
            PluginFlags pluginFlags,
            OperatorFlags? operatorFlags,
            bool useBuiltIn,
            ref Result error
            )
        {
            if (FlagOps.HasFlags(
                    createFlags, CreateFlags.NoOperators, true))
            {
                return ReturnCode.Ok;
            }

            IPlugin plugin = GetCorePlugin(ref error);

            if (plugin == null)
                return ReturnCode.Error;

            List<IOperatorData> operators = null;

            if (useBuiltIn)
            {
                if (RuntimeOps.GetBuiltInOperators(
                        plugin, StringOps.GetComparisonType(
                        interpreterFlags, false), pluginFlags,
                        InternalIsStandard(), ref operators,
                        ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }
            }
            else
            {
                if (RuntimeOps.GetPluginOperators(
                        plugin, types, StringOps.GetComparisonType(
                        interpreterFlags, false), pluginFlags,
                        InternalIsStandard(), ref operators,
                        ref error) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }
            }

            foreach (IOperatorData operatorData in operators)
            {
                if (operatorData == null)
                    continue;

                if ((operatorFlags != null) && !FlagOps.HasFlags(
                        operatorData.Flags, (OperatorFlags)operatorFlags,
                        false))
                {
                    continue;
                }

                IOperator @operator = null;
                Result localResult; /* REUSED */

                localResult = null;

                if (RuntimeOps.CreateOperator(operatorData,
                        ref @operator, ref localResult) != ReturnCode.Ok)
                {
                    error = localResult;
                    return ReturnCode.Error;
                }

                localResult = null;

                if (AddOperator(
                        @operator, null, ref localResult) != ReturnCode.Ok)
                {
                    error = localResult;
                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode SetupHostChannels(
            IStreamHost streamHost,
            InterpreterFlags interpreterFlags,
            ref Result error
            )
        {
            ChannelType channelType = ChannelType.StandardChannels |
                ChannelType.AllowExist;

            //
            // NOTE: Allow transparent proxies for the standard channel
            //       streams from the specified host only if it is also
            //       a transparent proxy.
            //
            // TODO: This is really a "policy" decision and may need to
            //       be reevaluated in the future.  There is now a flag
            //       to control this behavior; however, that decision
            //       may need to be reevaluated in the future as well.
            //
            /* EXEMPT */
            if (FlagOps.HasFlags(interpreterFlags,
                    InterpreterFlags.AllowProxyStream, true) ||
                AppDomainOps.IsTransparentProxy(streamHost))
            {
                channelType |= ChannelType.AllowProxy;
            }

            return ModifyStandardChannels(
                streamHost, null, channelType, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Assumes the interpreter lock is held.
        //
        private ReturnCode Setup(
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            InterpreterFlags interpreterFlags,
            PluginFlags pluginFlags,
            IRuleSet ruleSet,
            IEnumerable<string> args,
            StringList autoPathList,
            PolicyList policies,
            TraceList traces,
            ref Result result
            )
        {
            ReturnCode code = ReturnCode.Ok;

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Standard Channels
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            if (code == ReturnCode.Ok)
            {
                if (!InternalIsSafe() &&
                    !FlagOps.HasFlags(hostCreateFlags, HostCreateFlags.Disable, true) &&
                    !FlagOps.HasFlags(createFlags, CreateFlags.NoChannels, true))
                {
                    code = ModifyStandardChannels(
                        host, null, ChannelType.StandardChannels, ref result);
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Core Library Types
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            TypeList types = null;

            if ((code == ReturnCode.Ok) && NeedTypesForSetup(createFlags))
            {
                ResultList errors = null;

                if (!RuntimeOps.GetTypes(FlagOps.HasFlags(
                        pluginFlags, PluginFlags.Verbose, true), ref types, ref errors))
                {
                    result = errors;
                    code = ReturnCode.Error;
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Shared Global Flags
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            bool noCommands = FlagOps.HasFlags(createFlags, CreateFlags.NoCommands, true);

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Core Library Plugins
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            if (code == ReturnCode.Ok)
            {
                CommandFlags? commandFlags = null;

                if (FlagOps.HasFlags(
                        createFlags, CreateFlags.SdkMask, false))
                {
                    CommandFlags localCommandFlags = CommandFlags.None;

                    if (FlagOps.HasFlags(
                            createFlags, CreateFlags.Initialize, true) &&
                        !FlagOps.HasFlags(
                            createFlags, CreateFlags.NoLibrary, true))
                    {
                        localCommandFlags |= CommandFlags.Initialize;
                    }

                    if (FlagOps.HasFlags(
                            createFlags, CreateFlags.LicenseSdk, true))
                    {
                        localCommandFlags |= CommandFlags.LicenseSdk;
                    }

                    if (FlagOps.HasFlags(
                            createFlags, CreateFlags.SecuritySdk, true))
                    {
                        localCommandFlags |= CommandFlags.SecuritySdk;
                    }

                    commandFlags = localCommandFlags;
                }

                code = SetupPlugins(
                    ruleSet, types, createFlags, commandFlags, true,
                    ShouldUseBuiltIns(IdentifierKind.Command), noCommands,
                    ref result);
            }

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Namespace Support (optional)
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            if (code == ReturnCode.Ok)
            {
                if (!noCommands && RuntimeOps.AreNamespacesEnabled(createFlags))
                {
                    Result localError = null;

                    if (NamespaceOps.HaveRequiredCommands(this, true, ref localError))
                    {
                        code = NamespaceOps.Enable(this, null, true, false, ref result);
                    }
                    else
                    {
                        if (localError != null)
                        {
                            result = new ResultList(
                                "cannot enable namespace support", localError);
                        }
                        else
                        {
                            result = "cannot enable namespace support: no command?";
                        }

                        code = ReturnCode.Error;
                    }
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Core command policies (for safe interpreters).
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            if (code == ReturnCode.Ok)
                code = SetupPolicies(createFlags, policies, noCommands, ref result);

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Pre-defined Trace Lists
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            if (code == ReturnCode.Ok)
                code = SetupTraces(createFlags, traces, ref result);

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Pre-defined Global Variables
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            if (code == ReturnCode.Ok)
                code = SetupMinimumVariables(autoPathList, ref result);

            if (code == ReturnCode.Ok)
                code = SetupVariables(createFlags, args, true, ref result);

            if (code == ReturnCode.Ok)
                code = SetupPlatform(createFlags, true, ref result);

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Pre-defined Environment Variables
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            if (code == ReturnCode.Ok)
                code = SetupHome(createFlags, ref result);

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Update script-level interactive status.
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            if (code == ReturnCode.Ok)
            {
                this.InternalInteractive = FlagOps.HasFlags(
                    createFlags, CreateFlags.Interactive, true);

                this.ActiveInteractiveLoops = 0;
                this.Precision = TclVars.Expression.DefaultPrecision;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Predefined Objects
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            if (code == ReturnCode.Ok)
                code = SetupObjects(createFlags, ref result);

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Expression Functions
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            if (code == ReturnCode.Ok)
            {
                code = SetupFunctions(
                    types, createFlags, pluginFlags, ShouldUseBuiltIns(
                    IdentifierKind.Function), ref result);
            }

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Expression Operators
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            if (code == ReturnCode.Ok)
            {
                OperatorFlags? operatorFlags = null;

                if (FlagOps.HasFlags(createFlags, CreateFlags.SecuritySdk, true))
                    operatorFlags = OperatorFlags.Initialize | OperatorFlags.SecuritySdk;

                code = SetupOperators(
                    types, createFlags, interpreterFlags, pluginFlags, operatorFlags,
                    ShouldUseBuiltIns(IdentifierKind.Operator), ref result);
            }

            ///////////////////////////////////////////////////////////////////////////////////////////
            //
            // Evaluate the "pre-init" script, if any...
            // Cannot do this without commands (obviously?)...
            //
            ///////////////////////////////////////////////////////////////////////////////////////////

            if ((code == ReturnCode.Ok) && !noCommands)
                code = PrivatePreInitialize(false, ref result);

            ///////////////////////////////////////////////////////////////////////////////////////////

            if ((code == ReturnCode.Ok) && !noCommands)
            {
                if (!InternalIsSafe())
                {
                    IPlugin plugin = GetCorePlugin(ref result);

                    if (plugin != null)
                    {
                        code = PackageOps.MaybeAddSourceWithInfoCommand(
                            this, plugin, ruleSet, ref result);
                    }
                    else
                    {
                        code = ReturnCode.Error;
                    }
                }
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY && NOTIFY_GLOBAL
            if ((code == ReturnCode.Ok) && this.PrivateGlobalNotify)
            {
                /* IGNORED */
                CheckNotifications(
                    null, false,
                    NotifyType.Interpreter, NotifyFlags.Setup,
                    new ObjectPair(createFlags, args), this,
                    null, null, null, ref result);
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (code == ReturnCode.Ok)
                setup = true;

            ///////////////////////////////////////////////////////////////////////////////////////////

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static string GetHome(
            HomeFlags homeFlags,
            Priority priority,
            bool reverse
            )
        {
            //
            // NOTE: Initially, search for an appropriate "override" value
            //       for the HOME environment variable.  This will only be
            //       used when the HOME environment variable is not set.
            //
            IAnyPair<HomeFlags, string> homePair =
                PathOps.GetAnyHomeDirectoryPair(homeFlags, priority, reverse);

            if (homePair != null)
            {
                //
                // NOTE: Found an "overridden" home directory value, return
                //       it verbatim.
                //
                return homePair.Y;
            }
            else
            {
                //
                // NOTE: Start with an empty string.  The Win32 drive letter
                //       and path will be added to this string, if available,
                //       before it is returned.
                //
                string home = String.Empty;

                //
                // NOTE: Check for HOMEDRIVE environment variable and append
                //       its value, if any, to the value that we are going to
                //       return.
                //
                string homeDrive = GlobalConfiguration.GetValue(
                    EnvVars.HomeDrive, ConfigurationFlags.Interpreter);

                if (homeDrive != null)
                    home += homeDrive;

                //
                // NOTE: Check for HOMEPATH environment variable and append
                //       its value, if any, to the value that we are going to
                //       return.
                //
                string homePath = GlobalConfiguration.GetValue(
                    EnvVars.HomePath, ConfigurationFlags.Interpreter |
                    ConfigurationFlags.NativePathValue);

                if (homePath != null)
                    home += homePath;

                //
                // BUGFIX: There is (almost?) no point in returning an empty
                //         string here; therefore, transform it into a null
                //         value instead.
                //
                if (home.Length == 0)
                    home = null;

                return home;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReturnCode SetupHome(
            CreateFlags createFlags,
            ref Result error /* NOT USED */
            )
        {
            if (!FlagOps.HasFlags(createFlags, CreateFlags.Safe, true) &&
                !FlagOps.HasFlags(createFlags, CreateFlags.NoHome, true))
            {
                if (!PathOps.HaveHomeDirectory(HomeFlags.SetupHomeSetMask))
                {
                    string home = GetHome(
                        HomeFlags.SetupHomeGetMask, Priority.Highest, true);

                    if (!String.IsNullOrEmpty(home) && Directory.Exists(home))
                    {
                        PathOps.SetHomeDirectory(
                            HomeFlags.SetupHomeSetMask, PathOps.GetUnixPath(
                            home));
                    }
                    else
                    {
                        TraceOps.DebugTrace(String.Format(
                            "SetupHome: home directory is unavailable: {0}",
                            FormatOps.WrapOrNull(home)),
                            typeof(Interpreter).Name,
                            TracePriority.FileSystemWarning);
                    }
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool HavePlatformVariables()
        {
            if (FlagOps.HasFlags(
                    createFlags, CreateFlags.NoPlatformMask, false))
            {
                return false;
            }

            if (DoesVariableExist(VariableFlags.GlobalOnly,
                    TclVars.Platform.Name) != ReturnCode.Ok)
            {
                return false;
            }

            if (DoesVariableExist(VariableFlags.GlobalOnly,
                    Vars.Platform.Name) != ReturnCode.Ok)
            {
                return false;
            }

            return true;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Assumes the interpreter lock is held.
        //
        internal ReturnCode SetupPlatform(
            CreateFlags createFlags,
            bool create,
            ref Result result
            )
        {
            ReturnCode code = ReturnCode.Ok;

            if (!FlagOps.HasFlags(
                    createFlags, CreateFlags.NoPlatformMask, false))
            {
                if (code == ReturnCode.Ok)
                {
                    string byteOrder = BitConverter.IsLittleEndian ?
                        TclVars.Platform.LittleEndianValue :
                        TclVars.Platform.BigEndianValue;

                    code = SetLibraryVariableValue2(VariableFlags.None,
                        TclVars.Platform.Name, TclVars.Platform.ByteOrder,
                        byteOrder, ref result);
                }

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        TclVars.Platform.Name, TclVars.Platform.CharacterSize,
                        sizeof(char).ToString() + Characters.MinusSign +
                            sizeof(char).ToString(),
                        ref result);

#if DEBUG
                //
                // NOTE: When built with DEBUG, we are always debug-enabled.
                //
                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        TclVars.Platform.Name, TclVars.Platform.Debug,
                        ConversionOps.ToInt(true).ToString(), ref result);
#endif

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        TclVars.Platform.Name, TclVars.Platform.DirectorySeparator,
                        PathOps.NativeDirectorySeparatorChar.ToString(), ref result);

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        TclVars.Platform.Name, TclVars.Platform.PatchLevel,
                        TclVars.Package.PatchLevelValue, ref result);

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        TclVars.Platform.Name, TclVars.Platform.PathSeparator,
                        Path.PathSeparator.ToString(), ref result);

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        TclVars.Platform.Name, TclVars.Platform.PlatformName,
                        PlatformOps.GetPlatformName(), ref result);

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        TclVars.Platform.Name, TclVars.Platform.OsProductType,
                        PlatformOps.GetProductTypeName(), ref result);

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        TclVars.Platform.Name, TclVars.Platform.PointerSize,
                        IntPtr.Size.ToString(), ref result);

                if (code == ReturnCode.Ok) /* we are always threads-enabled */
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        TclVars.Platform.Name, TclVars.Platform.Threaded,
                        ConversionOps.ToInt(true).ToString(), ref result);

                if (code == ReturnCode.Ok) /* we are always unicode-enabled */
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        TclVars.Platform.Name, TclVars.Platform.Unicode,
                        ConversionOps.ToInt(true).ToString(), ref result);

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        TclVars.Platform.Name, TclVars.Platform.Version,
                        TclVars.Package.VersionValue, ref result);

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        TclVars.Platform.Name, TclVars.Platform.WordSize,
                        sizeof(int).ToString(), ref result);

                Version version; /* REUSED */
                Uri uri; /* REUSED */

                if (code == ReturnCode.Ok)
                {
                    version = GlobalState.GetAssemblyVersion();

                    code = SetLibraryVariableValue2(VariableFlags.None,
                        Vars.Platform.Name, Vars.Platform.Version,
                        FormatOps.MajorMinor(version), ref result);

                    if (code == ReturnCode.Ok)
                        code = SetLibraryVariableValue2(VariableFlags.None,
                            Vars.Platform.Name, Vars.Platform.PatchLevel,
                            (version != null) ? version.ToString() : null,
                            ref result);
                }

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        Vars.Platform.Name, Vars.Platform.Configuration,
                        AttributeOps.GetAssemblyConfiguration(
                            GlobalState.GetAssembly()),
                        ref result);

                if (code == ReturnCode.Ok)
                {
                    DateTime timeStamp = Created; /* PROPERTY */

                    code = SetLibraryVariableValue2(VariableFlags.None,
                        Vars.Platform.Name, Vars.Platform.InterpreterTimeStamp,
                        FormatOps.Iso8601DateTime(timeStamp, true),
                        ref result);
                }

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        Vars.Platform.Name, Vars.Platform.Vendor,
                        RuntimeOps.GetVendor(false), ref result);

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        Vars.Platform.Name, Vars.Platform.Suffix,
                        PathOps.GetBaseSuffix(GlobalState.GetAssembly()),
                        ref result);

                if (code == ReturnCode.Ok)
                    code = SetLibraryVariableValue2(VariableFlags.None,
                        Vars.Platform.Name, Vars.Platform.TextOrSuffix,
                        RuntimeOps.GetAssemblyTextOrSuffix(GlobalState.GetAssembly()),
                        ref result);

                if (code == ReturnCode.Ok)
                {
                    if (!InternalIsSafe())
                    {
                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                TclVars.Platform.Name, TclVars.Platform.Processors,
                                Environment.ProcessorCount.ToString(),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                TclVars.Platform.Name, TclVars.Platform.Host,
                                Environment.MachineName, ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                TclVars.Platform.Name, TclVars.Platform.Machine,
                                PlatformOps.GetMachineName(), ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                TclVars.Platform.Name, TclVars.Platform.OsName,
                                PlatformOps.GetOperatingSystemName(), ref result);

                        if (code == ReturnCode.Ok)
                        {
                            OperatingSystem operatingSystem = PlatformOps.GetOperatingSystem();

                            code = SetLibraryVariableValue2(VariableFlags.None,
                                TclVars.Platform.Name, TclVars.Platform.OsString,
                                (operatingSystem != null) ?
                                    operatingSystem.ToString() : null,
                                ref result);
                        }

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                TclVars.Platform.Name, TclVars.Platform.OsVersion,
                                PlatformOps.GetOperatingSystemMajorMinor(),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                TclVars.Platform.Name, TclVars.Platform.OsPatchLevel,
                                PlatformOps.GetOperatingSystemPatchLevel(),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                TclVars.Platform.Name, TclVars.Platform.OsServicePack,
                                PlatformOps.GetOperatingSystemServicePack(),
                                ref result);

#if !NET_STANDARD_20
                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                TclVars.Platform.Name, TclVars.Platform.OsReleaseId,
                                PlatformOps.GetOperatingSystemReleaseId(),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                TclVars.Platform.Name, TclVars.Platform.OsExtra,
                                PlatformOps.GetOperatingSystemExtra(this, false),
                                ref result);

                        if ((code == ReturnCode.Ok) && !FlagOps.HasFlags(
                                createFlags, CreateFlags.NoPopulateOsExtra, true))
                        {
                            /* ASYNCHRONOUS */
                            PlatformOps.PopulateOperatingSystemExtra(
                                this, true, true, true);
                        }
#else
                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                TclVars.Platform.Name, TclVars.Platform.OsExtra,
                                null, ref result);
#endif

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                TclVars.Platform.Name, TclVars.Platform.ProcessBits,
                                PlatformOps.GetProcessBits().ToString(),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                TclVars.Platform.Name, TclVars.Platform.User,
                                PlatformOps.GetUserName(false), ref result);

#if CAS_POLICY
                        if (code == ReturnCode.Ok)
                        {
                            Result permissionSetResult = null;

                            try
                            {
#if NET_40
                                if (AppDomainOps.IsLegacyCasPolicyEnabled())
#endif
                                {
                                    Evidence evidence = GlobalState.GetAssemblyEvidence();

                                    PermissionSet permissionSet = (evidence != null) ?
                                        SecurityManager.ResolvePolicy(evidence) : null;

                                    permissionSetResult = (permissionSet != null) ?
                                        StringOps.NormalizeWhiteSpace(
                                            permissionSet.ToString(), Characters.Space,
                                            WhiteSpaceFlags.VariableUse) : null;
                                }
                            }
                            catch (Exception e)
                            {
                                permissionSetResult = e;
                            }

                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.PermissionSet,
                                permissionSetResult, ref result);
                        }
#endif

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.SourceId,
                                _Shared.AttributeOps.GetAssemblySourceId(
                                    GlobalState.GetAssembly()),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.SourceTimeStamp,
                                _Shared.AttributeOps.GetAssemblySourceTimeStamp(
                                    GlobalState.GetAssembly()),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.Administrator,
                                RuntimeOps.IsAdministrator().ToString(),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.ApplicationAddressRange,
                                PlatformOps.GetApplicationAddressRange(),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.Culture,
                                FormatOps.CultureName(
                                    GlobalState.GetAssemblyCultureInfo(), false),
                                ref result);

                        if (code == ReturnCode.Ok)
                        {
                            version = CommonOps.Runtime.GetFrameworkVersion();

                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.FrameworkVersion,
                                (version != null) ? version.ToString() : null,
                                ref result);
                        }

#if !NET_STANDARD_20
                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.FrameworkExtraVersion,
                                CommonOps.Runtime.GetFrameworkExtraVersion(),
                                ref result);
#else
                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.FrameworkExtraVersion,
                                null, ref result);
#endif

#if NATIVE && WINDOWS
                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.ProcessorAffinityMasks,
                                NativeOps.GetProcessorAffinityMasks().ToString(),
                                ref result);
#endif

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.Wow64,
                                PlatformOps.GetWin32onWin64().ToString(),
                                ref result);

                        if (code == ReturnCode.Ok)
                        {
                            version = CommonOps.Runtime.GetRuntimeVersion();

                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.RuntimeVersion,
                                (version != null) ? version.ToString() : null,
                                ref result);
                        }

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.RuntimeBuild,
                                CommonOps.Runtime.GetRuntimeBuild(), ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.RuntimeExtraVersion,
                                CommonOps.Runtime.GetRuntimeExtraVersion(), ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.ImageRuntimeVersion,
                                AssemblyOps.GetImageRuntimeVersion(
                                    GlobalState.GetAssembly()),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.Epoch,
                                FormatOps.Iso8601DateTime(TimeOps.UnixEpoch, true),
                                ref result);

                        if (code == ReturnCode.Ok)
                        {
                            Assembly assembly = GlobalState.GetAssembly();

                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.GlobalAssemblyCache,
                                (assembly != null) ?
                                    assembly.GlobalAssemblyCache.ToString() :
                                    false.ToString(),
                                ref result);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            StringList options = DefineConstants.OptionList;

                            if (options != null)
                            {
                                options = new StringList(options);
                                options.Sort();
                            }

                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.CompileOptions,
                                (options != null) ? options.ToString(false) : null,
                                ref result);
                        }

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.CSharpOptionsName,
                                Vars.Platform.CSharpOptionsValue, ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.RuntimeOptions,
                                runtimeOptions.ToString(), ref result);

                        if (!FlagOps.HasFlags(createFlags, CreateFlags.NoObjectIds, true))
                        {
                            StringPairList objectIds =
                                AttributeOps.GetObjectIds(GlobalState.GetAssembly(), false);

                            if (code == ReturnCode.Ok)
                                code = SetLibraryVariableValue2(VariableFlags.None,
                                    Vars.Platform.Name, Vars.Platform.ObjectIds,
                                    (objectIds != null) ? objectIds.ToString() : null,
                                    ref result);
                        }

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.MinimumDate,
                                FormatOps.Iso8601DateTime(DateTime.MinValue, true),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.MaximumDate,
                                FormatOps.Iso8601DateTime(DateTime.MaxValue, true),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.TimeStamp,
                                FormatOps.Iso8601DateTime(
                                    _Shared.AttributeOps.GetAssemblyDateTime(
                                        GlobalState.GetAssembly()), true),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.Release,
                                _Shared.AttributeOps.GetAssemblyRelease(
                                    GlobalState.GetAssembly()),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.Tag,
                                _Shared.AttributeOps.GetAssemblyTag(
                                    GlobalState.GetAssembly()),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.Text,
                                _Shared.AttributeOps.GetAssemblyText(
                                    GlobalState.GetAssembly()),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.TargetFramework,
                                AttributeOps.GetAssemblyTargetFramework(
                                    GlobalState.GetAssembly()),
                                ref result);

#if NATIVE && NATIVE_UTILITY
                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.NativeUtility,
                                NativeUtility.GetVersion(this), ref result);
#endif

                        if (code == ReturnCode.Ok)
                        {
                            uri = GlobalState.GetAssemblyUri();

                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.Uri,
                                (uri != null) ? uri.ToString() : null,
                                ref result);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            uri = GlobalState.GetAssemblyUpdateBaseUri();

                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.UpdateBaseUri,
                                (uri != null) ? uri.ToString() : null,
                                ref result);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            uri = GlobalState.GetAssemblyDownloadBaseUri();

                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.DownloadBaseUri,
                                (uri != null) ? uri.ToString() : null,
                                ref result);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            uri = GlobalState.GetAssemblyScriptBaseUri();

                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.ScriptBaseUri,
                                (uri != null) ? uri.ToString() : null,
                                ref result);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            uri = GlobalState.GetAssemblyAuxiliaryBaseUri();

                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.AuxiliaryBaseUri,
                                (uri != null) ? uri.ToString() : null,
                                ref result);
                        }

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.PublicKey,
                                AssemblyOps.GetPublicKey(
                                    GlobalState.GetAssemblyName()),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.PublicKeyToken,
                                AssemblyOps.GetPublicKeyToken(
                                    GlobalState.GetAssemblyName()),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.ModuleVersionId,
                                AssemblyOps.GetModuleVersionId(
                                    GlobalState.GetAssembly()).ToString(),
                                ref result);

#if !NET_STANDARD_20
                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.Certificate,
                                FormatOps.Certificate(
                                    GlobalState.GetAssemblyLocation(), GetCertificate(),
                                    !create || RuntimeOps.ShouldCheckCoreFileTrusted(),
                                    false, false),
                                ref result);
#else
                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.Certificate,
                                FormatOps.Certificate(
                                    GlobalState.GetAssemblyLocation(),
                                    !create || RuntimeOps.ShouldCheckCoreFileTrusted(),
                                    false, false),
                                ref result);
#endif

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.UpdatePathAndQueryName,
                                String.Format(
                                    Vars.Platform.UpdatePathAndQueryValue,
                                    GlobalState.GetAssemblyUpdateVersion(),
                                    null),
                                ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.StrongName,
                                FormatOps.StrongName(
                                    GlobalState.GetAssembly(),
#if CAS_POLICY
                                    GetStrongName(),
#endif
                                    !create || (RuntimeOps.ShouldCheckStrongNameVerified()
#if !NET_STANDARD_20
                                        && SetupOps.ShouldCheckCoreVerified()
#endif
                                )), ref result);

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.StrongNameTag,
                                _Shared.AttributeOps.GetAssemblyStrongNameTag(
                                    GlobalState.GetAssembly()),
                                ref result);

#if CAS_POLICY
                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.Hash,
                                FormatOps.Hash(GetHash()), ref result);
#else
                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.Hash,
                                null, ref result);
#endif

                        if (code == ReturnCode.Ok)
                        {
                            version = GlobalState.GetEntryAssemblyVersion();

                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.ShellVersion,
                                FormatOps.MajorMinor(version),
                                ref result);

                            if (code == ReturnCode.Ok)
                            {
                                code = SetLibraryVariableValue2(VariableFlags.None,
                                    Vars.Platform.Name, Vars.Platform.ShellPatchLevel,
                                    (version != null) ? version.ToString() : null,
                                    ref result);
                            }
                        }

                        if (code == ReturnCode.Ok)
                            code = SetLibraryVariableValue2(VariableFlags.None,
                                Vars.Platform.Name, Vars.Platform.RuntimeName,
                                CommonOps.Runtime.GetRuntimeName(),
                                ref result);
                    }
                }
            }

            return code;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Initialization
        private static ReturnCode EvaluateScript(
            Interpreter interpreter,
            string name,
            bool core,
            bool direct,
            ref ScriptFlags scriptFlags,
            ref IClientData clientData,
            ref Result result
            )
        {
            string text = null;

            return EvaluateScript(
                interpreter, name, core, direct, ref scriptFlags, ref clientData,
                ref text, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReturnCode EvaluateScript(
            Interpreter interpreter,
            string name,
            bool core,
            bool direct,
            ref ScriptFlags scriptFlags,
            ref IClientData clientData,
            ref string text,
            ref Result result
            )
        {
            int errorLine = 0;

            ReturnCode code = EvaluateScript(
                interpreter, name, core, direct, ref scriptFlags,
                ref clientData, ref text, ref result,
                ref errorLine);

            if (errorLine != 0)
                SetErrorLine(interpreter, errorLine);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: *WARNING* This method is for use with named (i.e.
        //       predefined) script library and host scripts only.
        //       This method may be radically modified and/or
        //       removed in the future.
        //
        private static ReturnCode EvaluateScript(
            Interpreter interpreter,
            string name,
            bool core,
            bool direct,
            ref ScriptFlags scriptFlags,
            ref IClientData clientData,
            ref string text,
            ref Result result,
            ref int errorLine
            )
        {
            if (interpreter == null)
            {
                result = "invalid interpreter";
                errorLine = 0;

                return ReturnCode.Error;
            }

#if DEBUGGER && BREAKPOINTS
            InterpreterStateFlags savedInterpreterStateFlags = InterpreterStateFlags.None;
            interpreter.BeginArgumentLocation(ref savedInterpreterStateFlags);
#endif

            try
            {
#if ARGUMENT_CACHE
                CacheFlags savedCacheFlags = CacheFlags.None;
                interpreter.BeginNoArgumentCache(ref savedCacheFlags);

                try
                {
#endif
                    PackageFlags savedPackageFlags = interpreter.PackageFlags;
                    ProcedureFlags savedProcedureFlags = interpreter.ProcedureFlags;

                    try
                    {
                        PackageFlags newPackageFlags = savedPackageFlags;
                        ProcedureFlags newProcedureFlags = savedProcedureFlags;

                        ///////////////////////////////////////////////////////////////////////////////

                        bool library = FlagOps.HasFlags(scriptFlags, ScriptFlags.Library, true);
                        bool interactive = FlagOps.HasFlags(scriptFlags, ScriptFlags.Interactive, true);

                        ///////////////////////////////////////////////////////////////////////////////

                        if (core)
                        {
                            newPackageFlags |= PackageFlags.Core;
                            newProcedureFlags |= ProcedureFlags.Core;
                        }

                        if (library)
                        {
                            newPackageFlags |= PackageFlags.Library;
                            newProcedureFlags |= ProcedureFlags.Library;
                        }

                        if (interactive)
                        {
                            newPackageFlags |= PackageFlags.Interactive;
                            newProcedureFlags |= ProcedureFlags.Interactive;
                        }

                        ///////////////////////////////////////////////////////////////////////////////

                        interpreter.PackageFlags = newPackageFlags;
                        interpreter.ProcedureFlags = newProcedureFlags;

                        ///////////////////////////////////////////////////////////////////////////////

                        /* EXEMPT */
                        bool forceGlobal = FlagOps.HasFlags(
                            interpreter.InterpreterFlags, InterpreterFlags.ForceGlobalLibrary,
                            true);

                        ///////////////////////////////////////////////////////////////////////////////

                        IFileSystemHost fileSystemHost = interpreter.InternalHost;
                        Result localResult = null;

                        if ((library && (ScriptOps.GetLibrary(
                                interpreter, fileSystemHost, name, direct, ref scriptFlags,
                                ref clientData, ref localResult) == ReturnCode.Ok)) ||
                            (!library && (HostOps.GetScript(
                                interpreter, fileSystemHost, name, direct, ref scriptFlags,
                                ref clientData, ref localResult) == ReturnCode.Ok)))
                        {
                            text = localResult;

                            if (!String.IsNullOrEmpty(text))
                            {
                                if (FlagOps.HasFlags(scriptFlags, ScriptFlags.File, true))
                                {
                                    if (PathOps.IsRemoteUri(text) || File.Exists(text))
                                    {
                                        if (forceGlobal)
                                        {
                                            return interpreter.EvaluateGlobalFile(
                                                text, ref result, ref errorLine);
                                        }
                                        else
                                        {
                                            return interpreter.EvaluateFile(
                                                text, ref result, ref errorLine);
                                        }
                                    }
                                    else
                                    {
                                        result = String.Format(
                                            "the provided {0}{1} named script file " +
                                            "{2} is not a valid remote uri and does " +
                                            "not exist locally", forceGlobal ? "global " :
                                            String.Empty, FormatOps.WrapOrNull(name),
                                            FormatOps.WrapOrNull(text));
                                    }
                                }
                                else
                                {
                                    //
                                    // BUGFIX: Use the original script [file?] name, exactly
                                    //         as specified, for any contained [info script]
                                    //         calls.
                                    //
                                    bool pushed = false;

                                    interpreter.PushScriptLocation(name, true, ref pushed);

                                    try
                                    {
                                        if (forceGlobal)
                                        {
                                            return interpreter.EvaluateGlobalScript(
                                                text, ref result, ref errorLine);
                                        }
                                        else
                                        {
                                            return interpreter.EvaluateScript(
                                                text, ref result, ref errorLine);
                                        }
                                    }
                                    finally
                                    {
                                        interpreter.PopScriptLocation(true, ref pushed);
                                    }
                                }
                            }
                            else if (FlagOps.HasFlags(scriptFlags, ScriptFlags.Required, true))
                            {
                                //
                                // NOTE: The script is required; therefore, this
                                //       is an error.
                                //
                                result = String.Format(
                                    "the provided {0}{1} named script is " +
                                    "invalid (required)", forceGlobal ? "global " :
                                    String.Empty, FormatOps.WrapOrNull(name));
                            }
                            else if (FlagOps.HasFlags(scriptFlags, ScriptFlags.Optional, true))
                            {
                                //
                                // NOTE: Script is explicitly optional, this is OK.
                                //
                                result = String.Empty;
                                return ReturnCode.Ok;
                            }
                            else if (FlagOps.HasFlags(scriptFlags, ScriptFlags.ErrorOnEmpty, true))
                            {
                                //
                                // NOTE: The strict flag is set; therefore, this
                                //       is an error.
                                //
                                result = String.Format(
                                    "the provided {0}{1} named script is " +
                                    "invalid (strict)", forceGlobal ? "global " :
                                    String.Empty, FormatOps.WrapOrNull(name));
                            }
                            else
                            {
                                //
                                // TODO: Script is neither explicitly requierd nor
                                //       optional and the strict flag is not set;
                                //       therefore, just return success.  These
                                //       semantics may need fine-tuning later.
                                //
                                result = String.Empty;
                                return ReturnCode.Ok;
                            }
                        }
                        else if (FlagOps.HasFlags(scriptFlags, ScriptFlags.Required, true) ||
                            FlagOps.HasFlags(scriptFlags, ScriptFlags.ErrorOnEmpty, true))
                        {
                            //
                            // NOTE: No suitable script could be located to
                            //       satisfy the request.  Return the inner
                            //       error message verbatim.
                            //
                            result = localResult;
                        }
                        else
                        {
                            //
                            // TODO: Script is neither explicitly requierd nor
                            //       optional and the strict flag is not set;
                            //       therefore, just return success.  These
                            //       semantics may need fine-tuning later.
                            //
                            result = String.Empty;
                            return ReturnCode.Ok;
                        }
                    }
                    finally
                    {
                        //
                        // NOTE: Restore the saved package and procedure flags.
                        //
                        interpreter.ProcedureFlags = savedProcedureFlags;
                        interpreter.PackageFlags = savedPackageFlags;
                    }
#if ARGUMENT_CACHE
                }
                finally
                {
                    interpreter.EndNoArgumentCache(ref savedCacheFlags);
                }
#endif
            }
            catch (Exception e)
            {
                result = e;
            }
#if DEBUGGER && BREAKPOINTS
            finally
            {
                interpreter.EndArgumentLocation(
                    ref savedInterpreterStateFlags);
            }
#endif

            //
            // NOTE: If we get to this point, we have failed and we do
            //       not have error line information (i.e. we may not
            //       have evaluated anything).
            //
            errorLine = 0;

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReturnCode EvaluateStartupScript(
            Interpreter interpreter,
            string name,
            bool direct,
            ref ScriptFlags scriptFlags,
            ref IClientData clientData,
            ref Result result
            )
        {
            int errorLine = 0;

            ReturnCode code = EvaluateStartupScript(
                interpreter, name, direct, ref scriptFlags, ref clientData,
                ref result, ref errorLine);

            if (errorLine != 0)
                SetErrorLine(interpreter, errorLine);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReturnCode EvaluateStartupScript(
            Interpreter interpreter,
            string name,
            bool direct,
            ref ScriptFlags scriptFlags,
            ref IClientData clientData,
            ref Result result,
            ref int errorLine
            )
        {
            if (interpreter == null)
            {
                result = "invalid interpreter";
                errorLine = 0;

                return ReturnCode.Error;
            }

#if DEBUGGER && BREAKPOINTS
            InterpreterStateFlags savedInterpreterStateFlags = InterpreterStateFlags.None;
            interpreter.BeginArgumentLocation(ref savedInterpreterStateFlags);
#endif

            try
            {
#if ARGUMENT_CACHE
                CacheFlags savedCacheFlags = CacheFlags.None;
                interpreter.BeginNoArgumentCache(ref savedCacheFlags);

                try
                {
#endif
                    ProcedureFlags savedProcedureFlags = interpreter.ProcedureFlags;

                    try
                    {
                        ProcedureFlags newProcedureFlags = savedProcedureFlags;

                        ///////////////////////////////////////////////////////////////////////////////

                        bool library = FlagOps.HasFlags(scriptFlags, ScriptFlags.Library, true);
                        bool interactive = FlagOps.HasFlags(scriptFlags, ScriptFlags.Interactive, true);

                        ///////////////////////////////////////////////////////////////////////////////

                        if (library)
                            newProcedureFlags |= ProcedureFlags.Library;

                        if (interactive)
                            newProcedureFlags |= ProcedureFlags.Interactive;

                        ///////////////////////////////////////////////////////////////////////////////

                        interpreter.ProcedureFlags = newProcedureFlags;

                        ///////////////////////////////////////////////////////////////////////////////

                        /* EXEMPT */
                        bool forceGlobal = FlagOps.HasFlags(
                            interpreter.InterpreterFlags, InterpreterFlags.ForceGlobalLibrary,
                            true);

                        ///////////////////////////////////////////////////////////////////////////////

                        IFileSystemHost fileSystemHost = interpreter.InternalHost;
                        Result localResult = null;
                        ResultList errors = null;

                        if (ScriptOps.GetStartup(
                                interpreter, fileSystemHost, name, direct, ref scriptFlags,
                                ref clientData, ref localResult, ref errors) == ReturnCode.Ok)
                        {
                            string text = localResult;

                            if (!String.IsNullOrEmpty(text))
                            {
                                if (FlagOps.HasFlags(scriptFlags, ScriptFlags.File, true))
                                {
                                    if (PathOps.IsRemoteUri(text) || File.Exists(text))
                                    {
                                        if (forceGlobal)
                                        {
                                            return interpreter.EvaluateGlobalFile(
                                                text, ref result, ref errorLine);
                                        }
                                        else
                                        {
                                            return interpreter.EvaluateFile(
                                                text, ref result, ref errorLine);
                                        }
                                    }
                                    else
                                    {
                                        result = String.Format(
                                            "the provided {0}{1} startup script file " +
                                            "{2} is not a valid remote uri and does " +
                                            "not exist locally", forceGlobal ? "global " :
                                            String.Empty, FormatOps.WrapOrNull(name),
                                            FormatOps.WrapOrNull(text));
                                    }
                                }
                                else
                                {
                                    if (forceGlobal)
                                    {
                                        return interpreter.EvaluateGlobalScript(
                                            text, ref result, ref errorLine);
                                    }
                                    else
                                    {
                                        return interpreter.EvaluateScript(
                                            text, ref result, ref errorLine);
                                    }
                                }
                            }
                            else if (FlagOps.HasFlags(scriptFlags, ScriptFlags.Required, true))
                            {
                                //
                                // NOTE: The script is required; therefore, this
                                //       is an error.
                                //
                                result = String.Format(
                                    "the provided {0}{1} startup script is " +
                                    "invalid (required)", forceGlobal ? "global " :
                                    String.Empty, FormatOps.WrapOrNull(name));
                            }
                            else if (FlagOps.HasFlags(scriptFlags, ScriptFlags.Optional, true))
                            {
                                //
                                // NOTE: Script is explicitly optional, this is OK.
                                //
                                result = String.Empty;
                                return ReturnCode.Ok;
                            }
                            else if (FlagOps.HasFlags(scriptFlags, ScriptFlags.ErrorOnEmpty, true))
                            {
                                //
                                // NOTE: The strict flag is set; therefore, this
                                //       is an error.
                                //
                                result = String.Format(
                                    "the provided {0}{1} startup script is " +
                                    "invalid (strict)", forceGlobal ? "global " :
                                    String.Empty, FormatOps.WrapOrNull(name));
                            }
                            else
                            {
                                //
                                // TODO: Script is neither explicitly requierd nor
                                //       optional and the strict flag is not set;
                                //       therefore, just return success.  These
                                //       semantics may need fine-tuning later.
                                //
                                result = String.Empty;
                                return ReturnCode.Ok;
                            }
                        }
                        else if (FlagOps.HasFlags(scriptFlags, ScriptFlags.Required, true) ||
                            FlagOps.HasFlags(scriptFlags, ScriptFlags.ErrorOnEmpty, true))
                        {
                            //
                            // NOTE: No suitable script could be located to
                            //       satisfy the request.  Return the inner
                            //       error message verbatim.
                            //
                            result = errors;
                        }
                        else
                        {
                            //
                            // TODO: Script is neither explicitly requierd nor
                            //       optional and the strict flag is not set;
                            //       therefore, just return success.  These
                            //       semantics may need fine-tuning later.
                            //
                            result = String.Empty;
                            return ReturnCode.Ok;
                        }
                    }
                    finally
                    {
                        //
                        // NOTE: Restore the saved procedure flags.
                        //
                        interpreter.ProcedureFlags = savedProcedureFlags;
                    }
#if ARGUMENT_CACHE
                }
                finally
                {
                    interpreter.EndNoArgumentCache(ref savedCacheFlags);
                }
#endif
            }
            catch (Exception e)
            {
                result = e;
            }
#if DEBUGGER && BREAKPOINTS
            finally
            {
                interpreter.EndArgumentLocation(
                    ref savedInterpreterStateFlags);
            }
#endif

            //
            // NOTE: If we get to this point, we have failed and we do
            //       not have error line information (i.e. we may not
            //       have evaluated anything).
            //
            errorLine = 0;

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode ProvideCorePackages(
            ref Result error /* out */
            )
        {
            //
            // NOTE: These flags are used when automatically adding the static
            //       packages (i.e. "Tcl" and "Eagle") to the interpreter.
            //
            PackageFlags flags = PackageFlags.Static | PackageFlags.Core |
                PackageFlags.Automatic;

            //
            // NOTE: Provide the static Tcl package in the interpreter for the
            //       purpose of source compatibility with package index files.
            //
            ReturnCode code;
            Result localResult = null;

            code = PkgProvide(TclVars.Package.Name, TclVars.Package.Version,
                _ClientData.Empty, flags, ref localResult);

            if (code != ReturnCode.Ok)
            {
                error = localResult;
                return code;
            }

            //
            // NOTE: Provide the static Eagle package in the interpreter.
            //
            code = PkgProvide(
                GlobalState.GetPackageName(), GlobalState.GetAssemblyVersion(),
                _ClientData.Empty, flags, ref localResult);

            if (code != ReturnCode.Ok)
            {
                error = localResult;
                return code;
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void AllowInitializeLibrary()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                createFlags &= ~CreateFlags.NoLibrary;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateInitializeLibrary(
            ref Result error /* out */
            )
        {
            InitializeFlags localInitializeFlags;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                localInitializeFlags = initializeFlags;
            }

            ReturnCode code = ReturnCode.Ok;

            try
            {
                bool direct = FlagOps.HasFlags(
                    localInitializeFlags, InitializeFlags.Direct, true);

                ///////////////////////////////////////////////////////////////
                //               REQUIRED CORE SCRIPT LIBRARY                //
                ///////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(
                        localInitializeFlags, InitializeFlags.Initialization,
                        true))
                {
                    ScriptFlags scriptFlags = ScriptOps.GetFlags(
                        this, ScriptFlags.CoreLibraryRequiredFile,
                        false, false);

                    IClientData clientData = _ClientData.Empty;
                    string text = null;
                    Result localResult = null;

                    code = EvaluateScript(
                        this, FileName.Initialization, true, direct,
                        ref scriptFlags, ref clientData, ref text,
                        ref localResult);

                    if (code != ReturnCode.Ok)
                    {
                        error = localResult;
                        return code;
                    }

                    //
                    // NOTE: The "init" script is special.  After being
                    //       evaluated successfully, its location must
                    //       be saved -AND- used to populate the script
                    //       variable "tcl_library".
                    //
                    lock (syncRoot) /* TRANSACTIONAL */
                    {
                        if (FlagOps.HasFlags(
                                scriptFlags, ScriptFlags.File, true))
                        {
                            //
                            // BUGFIX: Save the directory where we found
                            //         the "init" script.
                            //
                            initializedPath = PathOps.TranslatePath(
                                PathOps.GetDirectoryName(text),
                                PathTranslationType.Default);
                        }
                        else
                        {
                            //
                            // BUGFIX: No file was used to find the "init"
                            //         script; however, we probably pulled
                            //         it from the assembly resources.
                            //
                            Assembly assembly = GlobalState.GetAssembly();

                            initializedPath = (assembly != null) ?
                                PathOps.TranslatePath(assembly.Location,
                                    PathTranslationType.Default) : null;
                        }
                    }
                }

                ///////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(
                        localInitializeFlags, InitializeFlags.Safe, true))
                {
                    ScriptFlags scriptFlags = ScriptOps.GetFlags(
                        this, ScriptFlags.CoreLibraryRequiredFile,
                        false, false);

                    IClientData clientData = _ClientData.Empty;
                    Result localResult = null;

                    code = EvaluateScript(
                        this, FileName.Safe, true, direct,
                        ref scriptFlags, ref clientData,
                        ref localResult);

                    if (code != ReturnCode.Ok)
                    {
                        error = localResult;
                        return code;
                    }
                }

                ///////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(
                        localInitializeFlags, InitializeFlags.Test, true))
                {
                    ScriptFlags scriptFlags = ScriptOps.GetFlags(
                        this, ScriptFlags.CoreLibraryRequiredFile,
                        false, false);

                    IClientData clientData = _ClientData.Empty;
                    Result localResult = null;

                    code = EvaluateScript(
                        this, FileName.Test, true, direct,
                        ref scriptFlags, ref clientData,
                        ref localResult);

                    if (code != ReturnCode.Ok)
                    {
                        error = localResult;
                        return code;
                    }
                }

                ///////////////////////////////////////////////////////////////
                //               OPTIONAL CORE SCRIPT LIBRARY                //
                ///////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(
                        localInitializeFlags, InitializeFlags.Embedding, true))
                {
                    ScriptFlags scriptFlags = ScriptOps.GetFlags(
                        this, ScriptFlags.ApplicationLibraryOptionalFile,
                        false, false);

                    IClientData clientData = _ClientData.Empty;
                    Result localResult = null;

                    code = EvaluateScript(
                        this, FileName.Embedding, true, direct,
                        ref scriptFlags, ref clientData,
                        ref localResult);

                    if (code != ReturnCode.Ok)
                    {
                        error = localResult;
                        return code;
                    }
                }

                ///////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(
                        localInitializeFlags, InitializeFlags.Vendor, true))
                {
                    ScriptFlags scriptFlags = ScriptOps.GetFlags(
                        this, ScriptFlags.VendorLibraryOptionalFile,
                        false, false);

                    IClientData clientData = _ClientData.Empty;
                    Result localResult = null;

                    code = EvaluateScript(
                        this, FileName.Vendor, true, direct,
                        ref scriptFlags, ref clientData,
                        ref localResult);

                    if (code != ReturnCode.Ok)
                    {
                        error = localResult;
                        return code;
                    }
                }

                ///////////////////////////////////////////////////////////////
                //               OPTIONAL USER SCRIPT LIBRARY                //
                ///////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(
                        localInitializeFlags, InitializeFlags.Startup1, true))
                {
                    ScriptFlags scriptFlags = ScriptOps.GetFlags(
                        this, ScriptFlags.ApplicationLibraryOptionalFile |
                        ScriptFlags.UserLibraryOptionalFile,
                        false, false);

                    IClientData clientData = _ClientData.Empty;
                    Result localResult = null;

                    code = EvaluateScript(
                        this, FileName.Startup, true, direct,
                        ref scriptFlags, ref clientData,
                        ref localResult);

                    if (code != ReturnCode.Ok)
                    {
                        error = localResult;
                        return code;
                    }
                }
            }
            finally
            {
#if ARGUMENT_CACHE
                //
                // HACK: Clear out any cached Argument objects that have
                //       location information to make room in the cache.
                //
                /* IGNORED */
                ClearCaches(CacheFlags.Argument, false);
#endif
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode SetAutoPathList(
            StringList autoPathList,
            bool skipTrace,
            ref Result error
            )
        {
            VariableFlags variableFlags;
            TraceList traceList;

            if (skipTrace)
            {
                variableFlags = VariableFlags.SkipTrace;
                traceList = null;
            }
            else
            {
                variableFlags = VariableFlags.None;

                lock (syncRoot)
                {
                    traceList = autoPathTraceList;
                }
            }

            ReturnCode code = SetLibraryVariableValue(
                variableFlags, TclVars.Core.AutoPath,
                GetAutoPathValue(autoPathList, null),
                traceList, ref error);

            TraceOps.DebugTrace(String.Format(
                "SetAutoPathList: autoPathList = {0}, code = {1}, " +
                "error = {2}", FormatOps.WrapOrNull(autoPathList),
                FormatOps.WrapOrNull(code), FormatOps.WrapOrNull(error)),
                typeof(Interpreter).Name, TracePriority.ScriptDebug3);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateInitializeAutoPath(
            ref Result error /* out */
            )
        {
            //
            // NOTE: Trigger the initialization of the package
            //       "subsystem".  This must be done after the
            //       library has been initialized; otherwise,
            //       the pkgIndex scripts will not be able to
            //       use those facilities.
            //
            InitializeFlags localInitializeFlags;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                localInitializeFlags = initializeFlags;
            }

            if (FlagOps.HasFlags(localInitializeFlags,
                    InitializeFlags.SetAutoPath, true))
            {
                //
                // WARNING: Do not "optimize" this code by not
                //          calling GlobalState.GetAutoPathList
                //          when the interpreter is "safe".  The
                //          GlobalState.GetAutoPathList method
                //          has a side-effect of initializing
                //          the global auto-path list as needed,
                //          and other code may rely on us doing
                //          just that.
                //
                StringList autoPathList;

                if (FlagOps.HasFlags(localInitializeFlags,
                        InitializeFlags.GlobalAutoPath, true))
                {
                    autoPathList = GlobalState.GetAutoPathList(
                        this, false);
                }
                else
                {
                    autoPathList = null;
                }

                return SetAutoPathList(
                    autoPathList, FlagOps.HasFlags(localInitializeFlags,
                    InitializeFlags.NoTraceAutoPath, true), ref error);
            }
            else
            {
                //
                // NOTE: Ok, skip setting the auto-path and just
                //       return success.
                //
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateInitializeLibraryPath(
            ref Result error /* out */
            )
        {
            InitializeFlags localInitializeFlags;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                localInitializeFlags = initializeFlags;
            }

            if (FlagOps.HasFlags(
                    localInitializeFlags, InitializeFlags.LibraryPath,
                    true))
            {
                string newPath;

                lock (syncRoot)
                {
                    newPath = initializedPath;
                }

                return SetLibraryVariableValue(
                    VariableFlags.None, TclVars.Core.Library, newPath,
                    ref error);
            }
            else
            {
                return ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if DEBUGGER
        private ReturnCode PrivateInitializeDebugger(
            bool force,      /* in */
            bool debug,      /* in */
            ref Result error /* out */
            )
        {
            //
            // NOTE: Now, see if we need still need to initialize
            //       isolated interpreter for our debugger (if we
            //       have one).
            //
            ReturnCode code = ReturnCode.Ok;
            IDebugger debugger = Debugger; /* PROPERTY */

            if (debugger != null)
            {
                Interpreter debugInterpreter = debugger.Interpreter;

                if ((debugInterpreter != null) &&
                    !debugInterpreter.PrivateInitialized)
                {
                    /* RECURSION */
                    code = debugInterpreter.PrivateInitialize(
                        force, debug, ref error);

                    debugInterpreter.MaybeIgnoreInitializeError(
                        ref code, ref error);
                }
            }

            return code;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MarkAsInitialized(
            bool force,          /* in */
            bool debug,          /* in */
            bool notify,         /* in */
            bool wasInitialized, /* in */
            bool didInitialize,  /* in */
            ref Result error     /* in, out */
            )
        {
#if NOTIFY && NOTIFY_GLOBAL
            string newPath;
#endif

            lock (syncRoot) /* TRANSACTIONAL */
            {
#if NOTIFY && NOTIFY_GLOBAL
                newPath = initializedPath;
#endif

                if (!initialized)
                    initialized = true;
            }

#if NOTIFY && NOTIFY_GLOBAL
            if (notify && this.PrivateGlobalNotify)
            {
                /* IGNORED */
                CheckNotifications(
                    null, false, NotifyType.Interpreter |
                    NotifyType.Library, NotifyFlags.Initialized,
                    new ObjectList(force, debug, newPath,
                        wasInitialized, didInitialize),
                    this, null, null, null, ref error);
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateInitialize(
            bool force,      /* in */
            bool debug,      /* in */
            ref Result error /* out */
            )
        {
            ReturnCode code = ReturnCode.Ok;
            bool wasInitialized;
            bool didInitialize = false;

            lock (syncRoot)
            {
                wasInitialized = initialized;
            }

            if (force || !wasInitialized)
            {
                #region Set Debugger Engine Flags (Optional)
#if DEBUGGER
                EngineFlags savedEngineFlags = EngineFlags.None;

                if (debug)
                    savedEngineFlags = BeginDebuggerExecution();

                try
#endif
                #endregion
                {
                    #region Phase 0: Copy Creation & Initialization Flags
                    CreateFlags localCreateFlags;
                    InitializeFlags localInitializeFlags;

                    lock (syncRoot)
                    {
                        localCreateFlags = createFlags;
                        localInitializeFlags = initializeFlags;
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Phase 1: Optional Plugin Isolation
#if ISOLATED_PLUGINS
                    if (FlagOps.HasFlags(
                            localInitializeFlags, InitializeFlags.Isolated, true))
                    {
                        //
                        // HACK: If requested via the (script library)
                        //       initialization flags, forcibly enable
                        //       plugin isolation now.  This is before
                        //       any script library scripts could have
                        //       been loaded or evaluated.  This is of
                        //       particular importance if the security
                        //       plugins (e.g. Harpy, Badge, etc) are
                        //       scheduled to be loaded as they may be
                        //       restricted to loading into isolated
                        //       application domains.  In general, the
                        //       only scripts evaluated prior to this
                        //       are the pre-initialization script(s)
                        //       specified via the command line or the
                        //       environment, etc.  Pre-initialization
                        //       scripts, if any, should not load any
                        //       plugins (e.g. via [package require]).
                        //       Since the auto-path is not setup at
                        //       that point, they would have to call
                        //       the [load] command directly, which
                        //       is not recommended.
                        //
                        EnablePluginIsolation();
                    }
#endif
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Phase 2: Auto-Path Diagnostics (Optional)
                    //
                    // NOTE: Debug all the key paths used to initialize the
                    //       interpreter.  This was created initially to
                    //       debug compliance with our path resolution
                    //       expectations (primarily on Mono).
                    //
                    if (FlagOps.HasFlags(
                            localCreateFlags, CreateFlags.ShowAutoPath, true))
                    {
                        GlobalState.DisplayPaths(this, DebugPathFlags.Automatic);
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Phase 3: Provide System Packages
                    if (code == ReturnCode.Ok)
                    {
                        code = ProvideCorePackages(ref error);
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Phase 4: Initialize Library
                    if (code == ReturnCode.Ok)
                    {
                        if (!FlagOps.HasFlags(
                                localCreateFlags, CreateFlags.NoLibrary, true))
                        {
                            code = PrivateInitializeLibrary(ref error);

                            if (code == ReturnCode.Ok)
                                didInitialize = true;
                        }
                        else
                        {
                            //
                            // HACK: After trying to automatically initialize
                            //       the core library, mask off the creation
                            //       flag that may have been used to prevent
                            //       the actual script file evaluation.
                            //
                            /* NO RESULT */
                            AllowInitializeLibrary();
                        }
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Phase 5: Set Auto-Path & Library Variables
                    if (code == ReturnCode.Ok)
                    {
                        if (!FlagOps.HasFlags(
                                localCreateFlags, CreateFlags.NoVariables, true)) /* EXEMPT */
                        {
                            code = PrivateInitializeAutoPath(ref error);

                            if (code == ReturnCode.Ok)
                                code = PrivateInitializeLibraryPath(ref error);
                        }
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Phase 6: Initialize Debugger Interpreter
#if DEBUGGER
                    if (code == ReturnCode.Ok)
                    {
                        code = PrivateInitializeDebugger(
                            force, debug, ref error);
                    }
#endif
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Phase 7: Load Security Package
                    if (code == ReturnCode.Ok)
                    {
                        if (FlagOps.HasFlags(
                                localInitializeFlags, InitializeFlags.Security, true))
                        {
                            code = ScriptOps.EnableOrDisableSecurity(
                                this, true, FlagOps.HasFlags(localCreateFlags,
                                CreateFlags.NoVariablesMask, false), ref error);
                        }
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Phase 8: Set Library Initialized Flag
                    //
                    // NOTE: Has everything succeeded?
                    //
                    if (code == ReturnCode.Ok)
                    {
                        MarkAsInitialized(
                            force, debug, true, wasInitialized, didInitialize,
                            ref error);
                    }
                    #endregion
                }
                #region Restore Saved Engine Flags
#if DEBUGGER
                finally
                {
                    if (debug)
                        EndDebuggerExecution(savedEngineFlags);
                }
#endif
                #endregion
            }

            TraceOps.DebugTrace(String.Format(
                "PrivateInitialize: interpreter = {0}, force = {1}, " +
                "debug = {2}, wasInitialized = {3}, didInitialize = {4}, " +
                "code = {5}, error = {6}",
                FormatOps.InterpreterNoThrow(this),
                force, debug, wasInitialized, didInitialize, code,
                FormatOps.WrapOrNull(true, true, error)),
                typeof(Interpreter).Name, TracePriority.StartupDebug);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateIsIgnoreOnError()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                return FlagOps.HasFlags(
                    createFlags, CreateFlags.IgnoreOnError, true);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeIgnoreInitializeError(
            ref ReturnCode code,
            ref Result error
            )
        {
            if ((code != ReturnCode.Ok) && PrivateIsIgnoreOnError())
            {
                TraceOps.DebugTrace(String.Format(
                    "MaybeIgnoreInitializeError: error is being " +
                    "ignored, interpreter = {0}, code = {1}, error = {2}",
                    FormatOps.InterpreterNoThrow(this), code,
                    FormatOps.WrapOrNull(true, true, error)),
                    typeof(Interpreter).Name, TracePriority.StartupError);

                error = null;
                code = ReturnCode.Ok;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL
        private void AllowInitializeShellLibrary()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                createFlags &= ~CreateFlags.NoShellLibrary;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateInitializeShellLibrary(
            ref Result error /* out */
            )
        {
            InitializeFlags localInitializeFlags;

            lock (syncRoot)
            {
                localInitializeFlags = initializeFlags;
            }

            ReturnCode code = ReturnCode.Ok;

            try
            {
                bool direct = FlagOps.HasFlags(
                    localInitializeFlags, InitializeFlags.Direct, true);

                ///////////////////////////////////////////////////////////////
                //               REQUIRED SHELL SCRIPT LIBRARY               //
                ///////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(
                        localInitializeFlags, InitializeFlags.Shell, true))
                {
                    ScriptFlags scriptFlags = ScriptOps.GetFlags(
                        this, ScriptFlags.Interactive |
                        ScriptFlags.CoreLibraryRequiredFile,
                        false, false);

                    IClientData clientData = _ClientData.Empty;
                    string text = null;
                    Result localResult = null;

                    code = EvaluateScript(
                        this, FileName.Shell, true, direct,
                        ref scriptFlags, ref clientData,
                        ref text, ref localResult);

                    if (code != ReturnCode.Ok)
                    {
                        error = localResult;
                        return code;
                    }

                    //
                    // NOTE: The "shell" script is special.  After being
                    //       evaluated successfully, its location must
                    //       be saved -AND- used to populate the script
                    //       variable "tcl_shellLibrary".
                    //
                    lock (syncRoot) /* TRANSACTIONAL */
                    {
                        if (FlagOps.HasFlags(
                                scriptFlags, ScriptFlags.File, true))
                        {
                            //
                            // NOTE: Save the directory where we found
                            //       the "shell" script.
                            //
                            initializedShellPath = PathOps.TranslatePath(
                                PathOps.GetDirectoryName(text),
                                PathTranslationType.Default);
                        }
                        else
                        {
                            //
                            // NOTE: No file was used to find the "shell"
                            //       script; however, we probably pulled
                            //       it from the assembly resources.
                            //
                            Assembly assembly = GlobalState.GetAssembly();

                            initializedShellPath = (assembly != null) ?
                                PathOps.TranslatePath(assembly.Location,
                                    PathTranslationType.Default) : null;
                        }
                    }
                }

                ///////////////////////////////////////////////////////////////
                //               OPTIONAL SHELL STARTUP SCRIPT               //
                ///////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(
                        localInitializeFlags, InitializeFlags.Startup2, true))
                {
                    ScriptFlags scriptFlags = ScriptOps.GetFlags(
                        this, ScriptFlags.Interactive |
                        ScriptFlags.ApplicationOptionalFile |
                        ScriptFlags.UserOptionalFile,
                        false, false);

                    IClientData clientData = _ClientData.Empty;
                    Result localResult = null;

                    code = EvaluateStartupScript(
                        this, TclVars.Core.RunCommandsFileName,
                        direct, ref scriptFlags, ref clientData,
                        ref localResult);

                    if (code != ReturnCode.Ok)
                    {
                        error = localResult;
                        return code;
                    }
                }
            }
            finally
            {
#if ARGUMENT_CACHE
                //
                // HACK: Clear out any cached Argument objects that have
                //       location information to make room in the cache.
                //
                /* IGNORED */
                ClearCaches(CacheFlags.Argument, false);
#endif
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateInitializeShellLibraryPath(
            ref Result error /* out */
            )
        {
            string newPath;

            lock (syncRoot)
            {
                newPath = initializedShellPath;
            }

            return SetLibraryVariableValue(
                VariableFlags.None, TclVars.Core.ShellLibrary,
                newPath, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MarkAsShellInitialized(
            bool force,          /* in */
            bool debug,          /* in */
            bool notify,         /* in */
            bool wasInitialized, /* in */
            bool didInitialize,  /* in */
            ref Result error     /* in, out */
            )
        {
#if NOTIFY && NOTIFY_GLOBAL
            string newPath;
#endif

            lock (syncRoot) /* TRANSACTIONAL */
            {
#if NOTIFY && NOTIFY_GLOBAL
                newPath = initializedShellPath;
#endif

                if (!initializedShell)
                    initializedShell = true;
            }

#if NOTIFY && NOTIFY_GLOBAL
            if (notify && this.PrivateGlobalNotify)
            {
                /* IGNORED */
                CheckNotifications(
                    null, false, NotifyType.Interpreter |
                    NotifyType.Shell, NotifyFlags.Initialized,
                    new ObjectList(force, debug, newPath,
                        wasInitialized, didInitialize),
                    this, null, null, null, ref error);
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PrivateInitializeShell(
            bool force,      /* in */
            bool debug,      /* in */
            ref Result error /* out */
            )
        {
            ReturnCode code = ReturnCode.Ok;
            bool wasInitialized;
            bool didInitialize = false;

            lock (syncRoot)
            {
                wasInitialized = initializedShell;
            }

            if (force || !wasInitialized)
            {
                #region Set Debugger Engine Flags (Optional)
#if DEBUGGER
                EngineFlags savedEngineFlags = EngineFlags.None;

                if (debug)
                    savedEngineFlags = BeginDebuggerExecution();

                try
#endif
                #endregion
                {
                    #region Phase 0: Copy Creation Flags
                    CreateFlags localCreateFlags;

                    lock (syncRoot)
                    {
                        localCreateFlags = createFlags;
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Phase 1: Auto-Path Diagnostics (Optional)
                    //
                    // NOTE: Debug all the key paths used to initialize the
                    //       interpreter.  This was created initially to
                    //       debug compliance with our path resolution
                    //       expectations (primarily on Mono).
                    //
                    if (FlagOps.HasFlags(
                            localCreateFlags, CreateFlags.ShowAutoPath, true))
                    {
                        GlobalState.DisplayPaths(this, DebugPathFlags.Automatic);
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Phase 2: Initialize Shell Library
                    if (code == ReturnCode.Ok)
                    {
                        if (!FlagOps.HasFlags(
                                localCreateFlags, CreateFlags.NoShellLibrary, true))
                        {
                            code = PrivateInitializeShellLibrary(ref error);

                            if (code == ReturnCode.Ok)
                                didInitialize = true;
                        }
                        else
                        {
                            //
                            // HACK: After trying to automatically initialize
                            //       the shell library, mask off the creation
                            //       flag that may have been used to prevent
                            //       the actual script file evaluation.
                            //
                            /* NO RESULT */
                            AllowInitializeShellLibrary();
                        }
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Phase 3: Set Shell Library Variable
                    if (code == ReturnCode.Ok)
                    {
                        if (!FlagOps.HasFlags(
                                localCreateFlags, CreateFlags.NoVariablesMask, false) &&
                            !FlagOps.HasFlags(
                                localCreateFlags, CreateFlags.Safe, true))
                        {
                            code = PrivateInitializeShellLibraryPath(ref error);
                        }
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////////////////////////////

                    #region Phase 4: Set Shell Initialized Flag
                    if (code == ReturnCode.Ok)
                    {
                        MarkAsShellInitialized(
                            force, debug, true, wasInitialized, didInitialize,
                            ref error);
                    }
                    #endregion
                }
                #region Restore Saved Engine Flags
#if DEBUGGER
                finally
                {
                    if (debug)
                        EndDebuggerExecution(savedEngineFlags);
                }
#endif
                #endregion
            }

            TraceOps.DebugTrace(String.Format(
                "PrivateInitializeShell: interpreter = {0}, force = {1}, " +
                "debug = {2}, wasInitialized = {3}, didInitialize = {4}, " +
                "code = {5}, error = {6}",
                FormatOps.InterpreterNoThrow(this),
                force, debug, wasInitialized, didInitialize, code,
                FormatOps.WrapOrNull(true, true, error)),
                typeof(Interpreter).Name, TracePriority.StartupDebug);

            return code;
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interpreter Settings Support
        private PolicyList GatherPolicyList(
            bool full /* in */
            )
        {
            PolicyList policies = null;
            PolicyList systemPolicies = MakePolicyList(true);

            //
            // HACK: Only include the list of global system
            //       policies if it is incomplete unless the
            //       "full" flag is specified.
            //
            if ((systemPolicies != null) && (full ||
                !PolicyOps.HasExecuteCallbacks(systemPolicies)))
            {
                if (policies == null)
                    policies = new PolicyList();

                policies.AddRange(systemPolicies);
            }

            PolicyList userPolicies = MakePolicyList(false);

            if (userPolicies != null)
            {
                if (policies == null)
                    policies = new PolicyList();

                policies.AddRange(userPolicies);
            }

            return policies;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private PolicyList MakePolicyList(
            bool? system /* in */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (policies == null)
                    return null;

                PolicyList result = null;

                foreach (KeyValuePair<string, _Wrappers.Policy> pair in policies)
                {
                    _Wrappers.Policy wrapper = pair.Value;

                    if (wrapper == null)
                        continue;

                    if (AppDomainOps.IsTransparentProxy(wrapper)) /* REDUNDANT */
                        continue;

                    IPolicy policy = wrapper.Object as IPolicy;

                    if (policy == null)
                        continue;

                    if (AppDomainOps.IsTransparentProxy(policy))
                        continue;

                    if ((system != null) && FlagOps.HasFlags(
                            policy.MethodFlags, MethodFlags.System,
                            true) != (bool)system)
                    {
                        continue;
                    }

                    if (result == null)
                        result = new PolicyList();

                    result.Add(policy);
                }

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private TraceList GatherTraceList(
            bool full /* in */
            )
        {
            TraceList traces = null;

            TraceList systemTraces = MakeTraceList(
                null, null, null, null, true);

            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // HACK: Only include the list of global system
                //       traces if it is incomplete unless the
                //       "full" flag is specified.
                //
                if ((systemTraces != null) && (full ||
                    !HasVariableTraces(systemTraces, true)))
                {
                    if (traces == null)
                        traces = new TraceList();

                    traces.AddRange(systemTraces);
                }
            }

            TraceList userTraces = MakeTraceList(
                null, null, null, null, false);

            if (userTraces != null)
            {
                if (traces == null)
                    traces = new TraceList();

                traces.AddRange(userTraces);
            }

            return traces;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private TraceList MakeTraceList(
            string varName,  /* in */
            string varIndex, /* in */
            object varValue, /* in */
            bool? array,     /* in */
            bool? system     /* in */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (traces == null)
                    return null;

                TraceList result = null;

                foreach (KeyValuePair<string, _Wrappers.Trace> pair in traces)
                {
                    _Wrappers.Trace wrapper = pair.Value;

                    if (wrapper == null)
                        continue;

                    if (AppDomainOps.IsTransparentProxy(wrapper)) /* REDUNDANT */
                        continue;

                    ITrace trace = wrapper.Object as ITrace;

                    if (trace == null)
                        continue;

                    if (AppDomainOps.IsTransparentProxy(trace))
                        continue;

                    if ((system != null) && FlagOps.HasFlags(
                            trace.MethodFlags, MethodFlags.System,
                            true) != (bool)system)
                    {
                        continue;
                    }

                    //
                    // HACK: *PERF* If the AutoTraceObject flag is set, we may
                    //       skip adding the ObjectTraceCallback, for reasons
                    //       of performance.  In those cases, it will only be
                    //       added "when necessary".  In this context, that is
                    //       taken to mean that the name, [array element] index,
                    //       and/or value of the variable refers to an existing
                    //       opaque object handle.  For reasons of consistency,
                    //       we will NOT skip adding the ObjectTraceCallback if
                    //       the variable is an array (i.e. because traces are
                    //       generally added only at variable creation time, not
                    //       at element creation time, and an array may contain
                    //       both simple values as well as values that refer to
                    //       opaque object handles).  This policy may be removed
                    //       in the future if other enhancements are made to the
                    //       array value handling.
                    //
                    if ((array != null) && !(bool)array && /* SCALAR-ONLY */
                        (varValue is string) && HasAutoTraceObject() &&
                        IsObjectTraceCallback(trace.Callback) &&
                        (DoesAnyObjectExist(varName,
                            varIndex, (string)varValue) != ReturnCode.Ok))
                    {
                        continue;
                    }

                    if (result == null)
                        result = new TraceList();

                    result.Add(trace);
                }

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode PopulateInterpreterSettings(
            bool recreate,                               /* in */
            bool full,                                   /* in */
            ref InterpreterSettings interpreterSettings, /* in, out */
            ref Result error                             /* out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                ReturnCode code;
                StringList list = null;

                code = GetListVariableValue(
                    VariableFlags.GlobalOnly, TclVars.Core.ShellArguments,
                    true, false, false, false, ref list, ref error);

                if (code != ReturnCode.Ok)
                    return code;

                if (interpreterSettings == null)
                    interpreterSettings = InterpreterSettings.Create();

                interpreterSettings.Args = list;

                interpreterSettings.Culture = (cultureInfo != null) ?
                    cultureInfo.Name : null;

                interpreterSettings.AppDomain = appDomain;

                //
                // BUGFIX: When being called in order to recreate an
                //         interpreter, existing host cannot be used
                //         because it will be disposed.
                //
                IHost localHost = recreate ? null : host;

                interpreterSettings.Host = localHost;

                interpreterSettings.Profile = (localHost != null) ?
                    localHost.Profile : null;

                //
                // BUGBUG: If this interpreter is within an isolated
                //         AppDomain, these could throw an exception;
                //         therefore, they now have their own checks
                //         for transparent proxies.
                //
                // NOTE: System policies and traces should be omitted
                //       if they represent complete sets without any
                //       customizations (i.e. if the user has removed
                //       a system policy and/or trace manually we do
                //       not want to accidentally re-add it) _unless_
                //       the "full" flag is specified.
                //
                interpreterSettings.Policies = GatherPolicyList(full);
                interpreterSettings.Traces = GatherTraceList(full);

                interpreterSettings.Text = preInitializeText;

                interpreterSettings.AutoPathList = (autoPathList != null) ?
                    new StringList(autoPathList) : null;

                return code;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Debugger Support
#if DEBUGGER
        private bool CanHitWatchpoints(
            BreakpointType breakpointType /* NOT USED */
            )
        {
            return !EngineFlagOps.HasNoWatchpoint(engineFlags) &&
                !PrivateIsDebuggerActive();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool CanHitBreakpoints(
            BreakpointType breakpointType
            )
        {
            bool viaReady = FlagOps.HasFlags(
                breakpointType, BreakpointType.Ready, false);

            return (!viaReady || !IsDebuggerExiting) &&
                !EngineFlagOps.HasNoBreakpoint(engineFlags) &&
                !PrivateIsDebuggerActive();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode TestBreakpointsToString(
            ref Result result
            )
        {
            StringDictionary testBreakpoints = TestBreakpoints;

            if (testBreakpoints == null)
            {
                result = "test breakpoints not available";
                return ReturnCode.Error;
            }

            result = testBreakpoints.ToString(null, false);
            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool HasTestBreakpoint(
            string name
            )
        {
            if (name != null)
            {
                StringDictionary testBreakpoints = TestBreakpoints;

                if (testBreakpoints != null)
                    return testBreakpoints.ContainsKey(name);
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool SetTestBreakpoint(
            string name,
            bool enable,
            ref Result error
            )
        {
            if (name == null)
            {
                error = "invalid test name";
                return false;
            }

            StringDictionary testBreakpoints = TestBreakpoints;

            if (testBreakpoints == null)
            {
                error = "test breakpoints not available";
                return false;
            }

            if (enable == testBreakpoints.ContainsKey(name))
            {
                error = String.Format(
                    "test {0} breakpoint is already {1}",
                    FormatOps.WrapOrNull(name),
                    enable ? "set" : "unset");

                return false;
            }

            if (enable)
                testBreakpoints.Add(name, null);
            else
                testBreakpoints.Remove(name);

            return true;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode CheckBreakpoints(
            ReturnCode code,
            BreakpointType breakpointType,
            string breakpointName,
            IToken token,
            ITraceInfo traceInfo,
            IExecute execute,
            IExecuteArgument executeArgument,
            IClientData clientData,
            ArgumentList arguments,
            ref Result result
            )
        {
            return Engine.CheckBreakpoints(
                code, breakpointType, breakpointName, token, traceInfo, engineFlags,
                substitutionFlags, engineEventFlags, expressionFlags, execute,
                executeArgument, this, clientData, arguments, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if DEBUGGER && DEBUGGER_VARIABLE
        private ReturnCode CheckWatchpoints(
            ReturnCode code,
            BreakpointType breakpointType,
            string breakpointName,
            IToken token,
            ITraceInfo traceInfo,
            ref Result result
            )
        {
            return Engine.CheckWatchpoints(
                code, breakpointType, breakpointName, token, traceInfo, engineFlags,
                substitutionFlags, engineEventFlags, expressionFlags, this, ref result);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DebuggerBreak(
            IDebugger debugger,
            IInteractiveLoopData loopData,
            ref Result result
            )
        {
            return _Private.DebuggerOps.Breakpoint(
                debugger, this, loopData, ref result);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Shell & Interactive Loop Support
        #region Shell Support
        #region Shell Script Evaluation Support
#if SHELL
        internal void RefreshShellCallbacks()
        {
            //
            // HACK: The lock statement here is not needed when compiled
            //       with THREADING enabled because all values referenced
            //       are from per-thread storage in that case.
            //
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                IShellCallbackData callbackData = ShellCallbackData;

                if (callbackData != null)
                {
                    callbackData.SetNewOrResetPreExisting(
                        this.PreviewArgumentCallback,
                        this.UnknownArgumentCallback,
                        this.EvaluateScriptCallback,
                        this.EvaluateFileCallback,
                        this.EvaluateEncodedFileCallback,
#if DEBUGGER
                        this.InteractiveLoopCallback,
#endif
                        false);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode ShellEvaluateScript(
            EvaluateScriptCallback evaluateScriptCallback, /* in */
            string text,                                   /* in */
            ref Result result,                             /* out */
            ref int errorLine                              /* out */
            )
        {
            try
            {
                if (evaluateScriptCallback == null)
                {
                    return EvaluateScript(
                        text, ref result, ref errorLine);
                }

                return evaluateScriptCallback(
                    this, text, ref result, ref errorLine);
            }
            catch (Exception e)
            {
                result = e;
                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode ShellEvaluateFile(
            EvaluateFileCallback evaluateFileCallback, /* in */
            string fileName,                           /* in */
            ref Result result,                         /* out */
            ref int errorLine                          /* out */
            )
        {
            try
            {
                if (evaluateFileCallback == null)
                {
                    return EvaluateFile(
                        fileName, ref result, ref errorLine);
                }

                return evaluateFileCallback(
                    this, fileName, ref result, ref errorLine);
            }
            catch (Exception e)
            {
                result = e;
                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode ShellEvaluateFile(
            EvaluateEncodedFileCallback evaluateEncodedFileCallback, /* in */
            Encoding encoding,                                       /* in */
            string fileName,                                         /* in */
            ref Result result,                                       /* out */
            ref int errorLine                                        /* out */
            )
        {
            try
            {
                if (evaluateEncodedFileCallback == null)
                {
                    return EvaluateFile(
                        encoding, fileName, ref result, ref errorLine);
                }

                return evaluateEncodedFileCallback(
                    this, encoding, fileName, ref result, ref errorLine);
            }
            catch (Exception e)
            {
                result = e;
                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode ShellEvaluateFile(
            IShellCallbackData callbackData, /* in */
            Encoding encoding,               /* in */
            string fileName,                 /* in */
            ref Result result,               /* out */
            ref int errorLine                /* out */
            )
        {
            if (callbackData == null)
            {
                result = "invalid shell callback data";
                return ReturnCode.Error;
            }

            if (encoding != null)
            {
                return ShellEvaluateFile(
                    callbackData.EvaluateEncodedFileCallback,
                    encoding, fileName, ref result, ref errorLine);
            }
            else
            {
                return ShellEvaluateFile(
                    callbackData.EvaluateFileCallback, fileName,
                    ref result, ref errorLine);
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Shell Core Support
#if SHELL
        private static int GetShellErrorLine(
            Interpreter interpreter,
            int errorLine
            )
        {
            if (errorLine != 0)
                return errorLine;

            return GetErrorLine(interpreter);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool IsShellMainCoreActive()
        {
            return Interlocked.CompareExchange(ref globalShellMainCoreCount, 0, 0) > 0;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ExitCode PrivateShellMainCore(
            Interpreter interpreter,         /* in */
            IShellCallbackData callbackData, /* in: OPTIONAL */
            IClientData clientData,          /* in: OPTIONAL */
            IEnumerable<string> args,        /* in: OPTIONAL */
            bool whatIf,                     /* in */
            ref bool initialize,             /* in, out */
            ref bool loop,                   /* in, out */
            ref bool interactive,            /* in, out */
            ref Result result                /* in, out */
            )
        {
            //
            // NOTE: This method is always called with a valid interpreter.
            //       Initially, that interpreter is used to process command
            //       line arguments and evaluate any requested scripts; at
            //       some point, the optional "-child" command line option
            //       may get used, which switches to a "child" interpreter,
            //       created on-demand.  When the "child" interpreter is in
            //       use, command line options and evaluated scripts will
            //       use it instead of the one originally specified by the
            //       caller.  If the optional "-parent" command line option
            //       is hit, the interpreter in use will be switched back
            //       to the original interpreter.
            //
            Interpreter activeInterpreter = interpreter;
            Interpreter parentInterpreter = interpreter;
            Interpreter childInterpreter = null;
            string childName = null;
            bool invalidInterpreter = false;

            IList<string> argv = (args != null) ? new StringList(args) : null;

            TraceOps.DebugTrace(String.Format(
                "PrivateShellMainCore: entered, interpreter = {0}, " +
                "callbackData = {1}, clientData = {2}, argv = {3}, " +
                "whatIf = {4}, initialize = {5}, loop = {6}, " +
                "interactive = {7}, result = {8}",
                FormatOps.InterpreterNoThrow(interpreter),
                FormatOps.ShellCallbackData(callbackData),
                FormatOps.WrapOrNull(clientData),
                FormatOps.WrapOrNull(true, true, argv), whatIf,
                initialize, loop, interactive, FormatOps.WrapOrNull(
                true, true, result)), typeof(Interpreter).Name,
                TracePriority.StartupDebug);

            ExitCode exitCode = ExitCode.Unknown;
            bool dispose = false; /* EXEMPT */
            bool quiet = false; /* TODO: Good default? */

            interactive = false;

            if (activeInterpreter == null)
            {
                result = "invalid interpreter";

                if (!whatIf)
                {
                    HostOps.WriteConsoleOrComplain(
                        ReturnCode.Error, result);
                }

                exitCode = ShellOps.FailureExitCode(activeInterpreter);

                goto done;
            }

            //
            // NOTE: Keep track of whether our direct caller provided each
            //       of the available shell callbacks.  This creates a deep
            //       copy of the shell callback data provided by the caller
            //       because we do not want to change the callers variable.
            //
            IShellCallbackData localCallbackData = _ShellCallbackData.Create(
                callbackData);

            if (localCallbackData != null)
            {
                /* NO RESULT */
                localCallbackData.CheckForPreExisting();
            }

            if (!whatIf)
            {
                //
                // NOTE: Save the shell callback data for this thread using
                //       the interactive context for the interpreter.
                //
                activeInterpreter.ShellCallbackData = localCallbackData;

                //
                // NOTE: Initially, grab each of the shell callbacks from
                //       the interpreter itself if they were not provided
                //       by our direct caller.
                //
                /* NO RESULT */
                activeInterpreter.RefreshShellCallbacks();
            }

            //
            // NOTE: Get the file name(s) that started the current process.
            //
            string executableFileName = PathOps.GetExecutableName();
            string managedExecutableFileName = PathOps.GetManagedExecutableName();

            //
            // NOTE: Get the file name where additional command line
            //       arguments may be found.
            //
            StringList argvFileNames = ShellOps.GetArgumentsFileNames(
                managedExecutableFileName);

            //
            // NOTE: Determine if the arguments file, if any, should really
            //       be used.
            //
            bool useArgvFileNames = ShellOps.ShouldUseArgumentsFileNames(
                argv);

            //
            // NOTE: Determine if the AppSettings, if any, should really be
            //       used.
            //
            bool useAppSettings = ShellOps.ShouldUseArgumentsAppSettings(
                argv);

            //
            // NOTE: Fetch the interpreter host now for result reporting
            //       purposes.
            //
            // NOTE: Also, during shell argument processing, should we
            //       attempt to be as quiet as possible?
            //
            IInteractiveHost interactiveHost = null;

            if (!whatIf)
                interactiveHost = activeInterpreter.GetInteractiveHost();

            //
            // NOTE: If the quiet flag for this method ends up being set
            //       explicitly via the command line, stop automatically
            //       refreshing it.
            //
            bool refreshQuiet = true;

            if (!whatIf && refreshQuiet)
                quiet = activeInterpreter.ShouldBeQuiet();

            //
            // NOTE: In debug mode, show the command line arguments just
            //       as we received them.
            //
            if (!whatIf && activeInterpreter.Debug)
            {
                HostOps.WriteLineOrConsole(interactiveHost, String.Format(
                    "The executable file name is: {0}", executableFileName));

                HostOps.WriteLineOrConsole(interactiveHost, String.Format(
                    "The managed executable file name is: {0}",
                    managedExecutableFileName));

                string commandLine = RuntimeOps.BuildCommandLine(argv, true);

                HostOps.WriteLineOrConsole(interactiveHost, String.Format(
                    "The original command line arguments are: {0}",
                    !String.IsNullOrEmpty(commandLine) ? commandLine :
                    FormatOps.DisplayNone));

                HostOps.WriteLineOrConsole(interactiveHost, String.Format(
                    "Use of arguments file name is: {0}", useArgvFileNames ?
                    "enabled" : "disabled"));

                HostOps.WriteLineOrConsole(interactiveHost, String.Format(
                    "Use of application settings is: {0}", useAppSettings ?
                    "enabled" : "disabled"));

                HostOps.WriteLineOrConsole(interactiveHost, String.Format(
                    "The arguments file names are: {0}",
                    FormatOps.DisplayList(argvFileNames)));

#if ENTERPRISE_LOCKDOWN
                HostOps.WriteLineOrConsole(interactiveHost,
                    "Enterprise script certificate enforcement is locked.");
#endif
            }

            //
            // NOTE: We need the return code all over the place in this
            //       method.
            //
            ReturnCode code;

            //
            // NOTE: If this is non-zero, it indicates that a brand new
            //       interpreter must be created an option is processed
            //       that requires mutating the current interpreter is
            //       being handled, e.g. "-safe" and/or "-standard".
            //
            bool[] create = new bool[] {
                false, /* FORCE NEW?      */
                false, /* FORCE CHILD?    */
                false, /* FORCE SAFE?     */
                false  /* FORCE STANDARD? */
            };

            if (!whatIf)
            {
                create[2] = activeInterpreter.InternalIsSafe();
                create[3] = activeInterpreter.InternalIsStandard();
            }

            //
            // NOTE: If this is non-zero, the command line arguments were
            //       "locked" by the interpreter host and other arguments
            //       are being ignored.  Its value will be checked if the
            //       interpreter is recreated via the "-recreate" command
            //       line option and it causes the startup-phase options
            //       (i.e. the creation flags, the pre-initialize text,
            //       and the library path) to be silently discarded.
            //
            bool lockArgv = false;

            //
            // NOTE: If this is non-zero, the Trim() method will not be
            //       used on command line arguments.  By default, it will
            //       be used because some platforms (e.g. .NET Core) are
            //       broken with respect to preserving arguments that are
            //       empty strings (i.e. they *will* preserve an argument
            //       that consists solely of whitespace).
            //
            bool noTrim = false;

            //
            // NOTE: If this is non-zero, the interpreter initialization
            //       will be forced (i.e. it will be performed even if it
            //       has already been done).
            //
            bool forceInitialize = false;

            //
            // NOTE: If this value is non-zero after a file is evaluated,
            //       we enter the interactive loop instead of exiting the
            //       process.
            //
            bool noExit = false;

            //
            // NOTE: If this value is non-zero after the interactive loop
            //       exits, it will be entered again.
            //
            bool kiosk = false;

            //
            // NOTE: This is the number of times the interactive loop has
            //       been reentered due to the kiosk lock.
            //
            int kioskLoops = 0;

            //
            // NOTE: Command line usage information variables.
            //
            bool showOptions = false;
            bool showEnvironment = false;

            //
            // NOTE: This is the encoding to use for reading a script file.
            //       It can be set using the "-encoding" command-line option.
            //
            Encoding encoding = null;

            //
            // NOTE: Are use of the "arguments" files enabled?  If so, then
            //       attempt to obtain command line arguments from the file
            //       system and/or the interpreter host.
            //
            if (useArgvFileNames)
            {
                //
                // NOTE: First, attempt to read some additional command line
                //       arguments from the interpreter host.  It should be
                //       noted that a lack of command line arguments from
                //       the interpreter host is not a failure.
                //
                string hostArgvFileName = null;
                IList<string> hostArgv = null;
                bool readArgv = false;
                ResultList errors = null;

                code = ShellOps.ReadArgumentsFromHost(
                    activeInterpreter, argvFileNames, encoding, /* POP */ 0,
                    false, false, ref hostArgvFileName, ref hostArgv,
                    ref readArgv, ref errors);

                if (code == ReturnCode.Ok)
                {
                    if (!whatIf && readArgv && activeInterpreter.Debug)
                    {
                        HostOps.WriteLineOrConsole(
                            interactiveHost, String.Format(
                            "Read arguments from host file: {0}",
                            FormatOps.WrapOrNull(hostArgvFileName)));
                    }
                }
                else
                {
                    result = errors;

                    exitCode = ShellOps.ReturnCodeToExitCode(
                        activeInterpreter, code, true);

                    goto done;
                }

                //
                // NOTE: Were some command line arguments actually read from
                //       the interpreter host?
                //
                if (readArgv)
                {
                    //
                    // NOTE: If the interpreter host locked the command line
                    //       arguments to the ones it provided, replace all
                    //       of the original command line arguments with those
                    //       -AND- skip checking the file system for any more;
                    //       otherwise, append the command line arguments
                    //       provided by the interpreter host to the original
                    //       command line arguments -AND- continue checking
                    //       on the file system for any more.
                    //
                    if (ShellOps.ShouldLockHostArguments(hostArgv))
                    {
                        argv = hostArgv;
                        lockArgv = true;

                        goto haveArgv;
                    }
                }

                //
                // NOTE: If the optional file containing additional command
                //       line arguments exits, attempt to read and process
                //       it now; otherwise, skip reading additional command
                //       line arguments from the file system.
                //
                string argvFileName = null;

                if (ShellOps.SomeFileExists(
                        argvFileNames, ref argvFileName) &&
                    (!readArgv || !PathOps.IsEqualFileName(
                        argvFileName, hostArgvFileName)))
                {
                    code = ShellOps.ReadArgumentsFromFile(
                        activeInterpreter, encoding, argvFileName,
                        /* POP */ 0, false, false, ref argv,
                        ref result);

                    if (code == ReturnCode.Ok)
                    {
                        if (!whatIf && activeInterpreter.Debug)
                        {
                            HostOps.WriteLineOrConsole(
                                interactiveHost, String.Format(
                                "Read arguments from automatic file: {0}",
                                FormatOps.WrapOrNull(argvFileName)));
                        }
                    }
                    else
                    {
                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);

                        goto done;
                    }
                }

                //
                // NOTE: If allowed (and available), attempt to read some
                //       command line arguments from the AppSettings.
                //
                if (useAppSettings)
                {
                    code = ShellOps.ReadArgumentsFromAppSettings(
                        activeInterpreter, /* POP */ 0, false, ref argv,
                        ref result);

                    if (code == ReturnCode.Ok)
                    {
                        if (!whatIf && activeInterpreter.Debug)
                        {
                            HostOps.WriteLineOrConsole(interactiveHost,
                                "Read arguments from application settings.");
                        }
                    }
                    else
                    {
                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);

                        goto done;
                    }
                }

                //
                // NOTE: Were some command line arguments actually read
                //       from the interpreter host, without the locking
                //       option being set?  If so, add them now.
                //
                if (readArgv && !lockArgv && (hostArgv != null))
                {
                    ShellOps.CommitToArguments(
                        hostArgv, /* POP */ 0, false, ref argv);
                }

            haveArgv:

                //
                // NOTE: In debug mode, always show the modified command
                //       line arguments.
                //
                if (!whatIf && activeInterpreter.Debug)
                {
                    string commandLine = RuntimeOps.BuildCommandLine(
                        argv, true);

                    HostOps.WriteLineOrConsole(
                        interactiveHost, String.Format(
                        "The modified command line arguments are: {0}",
                        !String.IsNullOrEmpty(commandLine) ?
                            commandLine : FormatOps.DisplayNone));
                }
            }

        retry: // NOTE: Used to continue processing arguments.

            int argc = (argv != null) ? argv.Count : 0;

            //
            // NOTE: Re-fetch interpreter host in case it has changed
            //       out from under us during argument processing.
            //
            if (!whatIf)
                interactiveHost = activeInterpreter.GetInteractiveHost();

            if (argc > 0)
            {
                //
                // NOTE: This is the starting argument index to use.
                //       Generally, this should always be zero.  The
                //       argument list will be modified as we process
                //       each argument.
                //
                int argIndex = 0;

                //
                // NOTE: Grab the first, second, and third arguments
                //       from the list, possibly invoking an argument
                //       preview callback.  Handle errors by halting
                //       further argument processing.
                //
                string arg0;
                string savedArg0;

                if (ShellOps.MaybeGetAndPreviewArgument(
                        activeInterpreter, localCallbackData, clientData,
                        ArgumentPhase.Phase0, noTrim, whatIf,
                        ref interactiveHost, ref argIndex, out arg0,
                        out savedArg0, ref argv, ref result, ref quiet,
                        ref exitCode) != ReturnCode.Ok)
                {
                    goto doneArgs;
                }

                string arg1;
                string savedArg1;

                if (ShellOps.MaybeGetAndPreviewArgument(
                        activeInterpreter, localCallbackData, clientData,
                        ArgumentPhase.Phase0, noTrim, whatIf,
                        ref interactiveHost, ref argIndex, out arg1,
                        out savedArg1, ref argv, ref result, ref quiet,
                        ref exitCode) != ReturnCode.Ok)
                {
                    goto doneArgs;
                }

                string arg2;
                string savedArg2;

                if (ShellOps.MaybeGetAndPreviewArgument(
                        activeInterpreter, localCallbackData, clientData,
                        ArgumentPhase.Phase0, noTrim, whatIf,
                        ref interactiveHost, ref argIndex, out arg2,
                        out savedArg2, ref argv, ref result, ref quiet,
                        ref exitCode) != ReturnCode.Ok)
                {
                    goto doneArgs;
                }

                //
                // NOTE: By default, the arguments for a command line
                //       option need to be removed (i.e. popped) from
                //       its handler; however, when "goto option" is
                //       used, that must be skipped.
                //
                bool popArgv = true;

            option:

                //
                // NOTE: At this point, a first argument is required.
                //       If there is none, we are done with processing
                //       arguments.  Maybe enter the interactive loop?
                //
                if (arg0 == null)
                {
                    argv = null;
                    goto retry;
                }

                //
                // NOTE: This is the number of switch chars in front
                //       of the current argument.
                //
                int count = 0;

                //
                // NOTE: This trims any leading switch chars from the
                //       current argument and sets the count to the
                //       number of switch chars actually removed.
                //
                arg0 = StringOps.TrimSwitchChars(arg0, ref count);

                if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.AnyFile))
                {
                    if (arg1 != null)
                    {
                        int errorLine = 0;

                        if (whatIf)
                        {
                            code = ReturnCode.Ok;
                        }
                        else
                        {
                            code = activeInterpreter.ShellEvaluateFile(
                                localCallbackData, encoding, arg1,
                                ref result, ref errorLine);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            //
                            // NOTE: The shell callbacks may have been
                            //       changed via the evaluated script;
                            //       therefore, refresh the ones which
                            //       were not directly supplied by the
                            //       caller.
                            //
                            if (!whatIf)
                            {
                                /* NO RESULT */
                                activeInterpreter.RefreshShellCallbacks();
                            }

                            //
                            // NOTE: Must refresh the quiet flag now as
                            //       it could have been changed by the
                            //       evaluated script.
                            //
                            if (!whatIf && refreshQuiet)
                                quiet = activeInterpreter.ShouldBeQuiet();

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }
                        else
                        {
                            //
                            // BUGFIX: We may have evaluated some code and
                            //         the host may have been changed; grab
                            //         it again.
                            //
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                GetShellErrorLine(activeInterpreter, errorLine),
                                true, true, whatIf, ref argv,
                                ref interactiveHost, ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <fileName>\"",
                            CommandLineOption.AnyFile), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
#if !ENTERPRISE_LOCKDOWN
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.AnyInitialize))
                {
                    if (arg1 != null)
                    {
                        int errorLine = 0;

                        if (whatIf)
                        {
                            code = ReturnCode.Ok;
                        }
                        else
                        {
                            code = activeInterpreter.ShellEvaluateScript(
                                _ShellCallbackData.GetEvaluateScriptCallback(
                                    localCallbackData), arg1, ref result,
                                ref errorLine);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            //
                            // NOTE: The shell callbacks may have been
                            //       changed via the evaluated script;
                            //       therefore, refresh the ones which
                            //       were not directly supplied by the
                            //       caller.
                            //
                            if (!whatIf)
                            {
                                /* NO RESULT */
                                activeInterpreter.RefreshShellCallbacks();
                            }

                            //
                            // NOTE: Must refresh the quiet flag now as
                            //       it could have been changed by the
                            //       evaluated script.
                            //
                            if (!whatIf && refreshQuiet)
                                quiet = activeInterpreter.ShouldBeQuiet();

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }
                        else
                        {
                            //
                            // BUGFIX: We may have evaluated some code and
                            //         the host may have been changed; grab
                            //         it again.
                            //
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                GetShellErrorLine(activeInterpreter, errorLine),
                                true, true, whatIf, ref argv,
                                ref interactiveHost, ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <script>\"",
                            CommandLineOption.AnyInitialize), whatIf,
                            ref argv, ref interactiveHost, ref quiet,
                            ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
#endif
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Arguments))
                {
                    if (arg1 != null)
                    {
                        //
                        // NOTE: This method pops its own arguments from the
                        //       list.  The literal "2" in the parameter list
                        //       for ReadArgumentsFromFile is the number of
                        //       arguments that need to be popped from the
                        //       front of the list prior to appending any of
                        //       the arguments found in the specified file.
                        //
                        code = ShellOps.ReadArgumentsFromFile(
                            activeInterpreter, encoding, arg1, /* POP */ 2,
                            true, false, ref argv, ref result);

                        if (code == ReturnCode.Ok)
                        {
                            if (!whatIf && activeInterpreter.Debug)
                            {
                                HostOps.WriteLineOrConsole(
                                    interactiveHost, String.Format(
                                    "Read arguments from specific file: {0}",
                                    FormatOps.WrapOrNull(arg1)));
                            }

                            goto retry;
                        }
                        else
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <fileName>\"",
                            CommandLineOption.Arguments), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Break))
                {
                    #region Requires Console Support
#if CONSOLE
                    if (!whatIf)
                    {
                        /* NO RESULT */
                        ConsoleOps.DebugBreak();
                    }
#endif
                    #endregion

                    ///////////////////////////////////////////////////////

                    //
                    // NOTE: Break into the managed debugger, skipping no
                    //       method to obtain the method name, and force
                    //       the issue because this is the result of a
                    //       direct user request.
                    //
                    if (!whatIf)
                    {
                        /* NO RESULT */
                        DebugOps.Break(activeInterpreter, null, true); /* throw */
                    }

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.ClearTrace))
                {
                    if (whatIf)
                    {
                        code = ReturnCode.Ok;
                    }
                    else
                    {
                        code = DebugOps.ClearTraceListeners(
                            true, activeInterpreter.Debug, true, true,
                            ref result);
                    }

                    if (code == ReturnCode.Ok)
                    {
                        if (popArgv)
                        {
                            GenericOps<string>.PopFirstArgument(ref argv);
                            popArgv = false;
                        }

                        goto retry;
                    }

                    ShellOps.ShellMainCoreError(
                        activeInterpreter, savedArg0, arg0, code, result,
                        whatIf, ref argv, ref interactiveHost,
                        ref quiet, ref result);

                    exitCode = ShellOps.ReturnCodeToExitCode(
                        activeInterpreter, code, true);
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Child))
                {
                    create[1] = true;

                    if (childInterpreter != null)
                    {
                        if (!whatIf && !quiet)
                        {
                            ShellOps.WritePrompt(activeInterpreter,
                                _Constants.Prompt.Child);
                        }

                        activeInterpreter = childInterpreter;

                        if (popArgv)
                        {
                            GenericOps<string>.PopFirstArgument(ref argv);
                            popArgv = false;
                        }

                        goto retry;
                    }
                    else if (create[0])
                    {
                        if (!whatIf && !quiet)
                        {
                            ShellOps.WritePrompt(activeInterpreter,
                                _Constants.Prompt.Child);
                        }

                        activeInterpreter = null;

                        arg0 = Characters.MinusSign + CommandLineOption.Recreate;

                        if (popArgv)
                        {
                            GenericOps<string>.PopFirstArgument(ref argv);
                            popArgv = false;
                        }

                        goto option;
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0,
                            "child interpreter unavailable", whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Debug))
                {
                    if (!whatIf)
                    {
                        activeInterpreter.Debug = true;

                        if (!quiet)
                        {
                            ShellOps.WritePrompt(
                                interactiveHost, String.Format(
                                _Constants.Prompt.Debug,
                                _Constants.Prompt.ViaCommandLine));
                        }
                    }

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
#if !ENTERPRISE_LOCKDOWN
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Evaluate))
                {
                    if (initialize && !whatIf)
                    {
                        code = activeInterpreter.PrivateInitialize(
                            forceInitialize, false, ref result);

                        activeInterpreter.MaybeIgnoreInitializeError(
                            ref code, ref result);
                    }
                    else
                    {
                        code = ReturnCode.Ok;
                    }

                    int errorLine = 0;

                    if (code == ReturnCode.Ok)
                    {
                        if (argv != null)
                        {
                            IList<string> localArgv = new StringList(argv);
                            int localArgc = localArgv.Count;

                            for (int localArgIndex = 1;
                                    localArgIndex < localArgc;
                                    localArgIndex++)
                            {
                                string text;

                                if (!ShellOps.MaybeGetArgument(
                                        localArgv, localArgIndex, noTrim,
                                        out text))
                                {
                                    break;
                                }

                                code = ShellOps.PreviewArgument(
                                    activeInterpreter, interactiveHost, clientData,
                                    localCallbackData, ArgumentPhase.Phase1,
                                    whatIf, ref localArgIndex, ref text,
                                    ref localArgv, ref result);

                                if (code != ReturnCode.Ok)
                                    break;

                                if (!ShellOps.MaybeSetArgument(
                                        localArgv, localArgIndex, text,
                                        ref localArgc))
                                {
                                    break;
                                }
                            }

                            if ((code == ReturnCode.Ok) && (localArgv != null))
                            {
                                localArgc = localArgv.Count;

                                for (int localArgIndex = 1;
                                        localArgIndex < localArgc;
                                        localArgIndex++)
                                {
                                    string text;

                                    if (!ShellOps.MaybeGetArgument(
                                            localArgv, localArgIndex, noTrim,
                                            out text))
                                    {
                                        break;
                                    }

                                    if (!whatIf)
                                    {
                                        code = activeInterpreter.ShellEvaluateScript(
                                            _ShellCallbackData.GetEvaluateScriptCallback(
                                                localCallbackData), text, ref result,
                                            ref errorLine);

                                        if (code != ReturnCode.Ok)
                                            break;
                                    }
                                }
                            }
                        }
                    }

                    if (code != ReturnCode.Ok)
                    {
                        //
                        // BUGFIX: We may have evaluated some code and
                        //         the host may have been changed; grab
                        //         it again.
                        //
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, code, result,
                            GetShellErrorLine(activeInterpreter, errorLine),
                            true, true, whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);
                    }

                    //
                    // NOTE: If the exit code for the interpreter is successful,
                    //       use the return code to figure out what this method
                    //       should return (i.e. just in case of a failure to
                    //       initialize, evaluate a script, etc).
                    //
                    ShellOps.GetExitCode(activeInterpreter, code, out exitCode);
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.EvaluateEncoded))
                {
                    if (initialize && !whatIf)
                    {
                        code = activeInterpreter.PrivateInitialize(
                            forceInitialize, false, ref result);

                        activeInterpreter.MaybeIgnoreInitializeError(
                            ref code, ref result);
                    }
                    else
                    {
                        code = ReturnCode.Ok;
                    }

                    int errorLine = 0;

                    if (code == ReturnCode.Ok)
                    {
                        if (argv != null)
                        {
                            IList<string> localArgv = new StringList(argv);
                            int localArgc = localArgv.Count;

                            for (int localArgIndex = 1;
                                    localArgIndex < localArgc;
                                    localArgIndex++)
                            {
                                string text;

                                if (!ShellOps.MaybeGetArgument(
                                        localArgv, localArgIndex, noTrim,
                                        out text))
                                {
                                    break;
                                }

                                code = ShellOps.PreviewArgument(
                                    activeInterpreter, interactiveHost, clientData,
                                    localCallbackData, ArgumentPhase.Phase1,
                                    whatIf, ref localArgIndex, ref text,
                                    ref localArgv, ref result);

                                if (code == ReturnCode.Ok)
                                {
                                    try
                                    {
                                        code = StringOps.GetString(encoding,
                                            Convert.FromBase64String(text),
                                            EncodingType.Base64, ref text,
                                            ref result);
                                    }
                                    catch (Exception e)
                                    {
                                        result = e;
                                        code = ReturnCode.Error;
                                    }
                                }

                                if (code != ReturnCode.Ok)
                                    break;

                                if (!ShellOps.MaybeGetArgumentCount(
                                        localArgv, ref localArgc))
                                {
                                    break;
                                }
                            }

                            if ((code == ReturnCode.Ok) && (localArgv != null))
                            {
                                localArgc = localArgv.Count;

                                for (int localArgIndex = 1;
                                        localArgIndex < localArgc;
                                        localArgIndex++)
                                {
                                    string text;

                                    if (!ShellOps.MaybeGetArgument(
                                            localArgv, localArgIndex, noTrim,
                                            out text))
                                    {
                                        break;
                                    }

                                    if (!whatIf)
                                    {
                                        code = activeInterpreter.ShellEvaluateScript(
                                            _ShellCallbackData.GetEvaluateScriptCallback(
                                                localCallbackData), text, ref result,
                                            ref errorLine);

                                        if (code != ReturnCode.Ok)
                                            break;
                                    }
                                }
                            }
                        }
                    }

                    if (code != ReturnCode.Ok)
                    {
                        //
                        // BUGFIX: We may have evaluated some code and
                        //         the host may have been changed; grab
                        //         it again.
                        //
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, code, result,
                            GetShellErrorLine(activeInterpreter, errorLine),
                            true, true, whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);
                    }

                    //
                    // NOTE: If the exit code for the interpreter is successful,
                    //       use the return code to figure out what this method
                    //       should return (i.e. just in case of a failure to
                    //       initialize, evaluate a script, etc).
                    //
                    ShellOps.GetExitCode(activeInterpreter, code, out exitCode);
                }
#endif
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Encoding))
                {
                    if (arg1 != null)
                    {
                        if (whatIf)
                        {
                            code = ReturnCode.Ok;
                        }
                        else
                        {
                            code = activeInterpreter.GetEncoding(
                                arg1, LookupFlags.Default, ref encoding,
                                ref result);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }
                        else
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <encodingName>\"",
                            CommandLineOption.Encoding), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.File))
                {
                    if (argc >= 2)
                    {
                        if (whatIf)
                        {
                            code = ReturnCode.Ok;
                        }
                        else
                        {
                            code = activeInterpreter.SetArguments(
                                new StringList(argv, 2, noTrim),
                                ref result);
                        }

                        if ((code == ReturnCode.Ok) && initialize && !whatIf)
                        {
                            code = activeInterpreter.PrivateInitialize(
                                forceInitialize, false, ref result);

                            activeInterpreter.MaybeIgnoreInitializeError(
                                ref code, ref result);
                        }

                        int errorLine = 0;

                        if ((code == ReturnCode.Ok) && !whatIf)
                        {
                            code = activeInterpreter.ShellEvaluateFile(
                                localCallbackData, encoding, arg1,
                                ref result, ref errorLine);
                        }

                        if (code != ReturnCode.Ok)
                        {
                            //
                            // BUGFIX: We may have evaluated some code and
                            //         the host may have been changed; grab
                            //         it again.
                            //
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                GetShellErrorLine(activeInterpreter, errorLine),
                                true, true, whatIf, ref argv,
                                ref interactiveHost, ref quiet, ref result);
                        }

                        //
                        // NOTE: If the exit code for the interpreter is successful,
                        //       use the return code to figure out what this method
                        //       should return (i.e. just in case of a failure to
                        //       initialize, evaluate a script, etc).
                        //
                        ShellOps.GetExitCode(activeInterpreter, code, out exitCode);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <fileName> [arguments]\"",
                            CommandLineOption.File), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.About))
                {
                    showOptions = false;
                    showEnvironment = false;

                    arg0 = Characters.MinusSign + CommandLineOption.Help;

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto option;
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.CommandHelp))
                {
                    showOptions = true;
                    showEnvironment = false;

                    arg0 = Characters.MinusSign + CommandLineOption.Help;

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto option;
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.EnvironmentHelp))
                {
                    showOptions = false;
                    showEnvironment = true;

                    arg0 = Characters.MinusSign + CommandLineOption.Help;

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto option;
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.ForceInitialize))
                {
                    forceInitialize = true;

                    if (!whatIf && !quiet)
                    {
                        ShellOps.WritePrompt(interactiveHost,
                            _Constants.Prompt.ForceInitialize);
                    }

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.FullHelp))
                {
                    showOptions = true;
                    showEnvironment = true;

                    arg0 = Characters.MinusSign + CommandLineOption.Help;

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto option;
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Help))
                {
                    if (whatIf)
                    {
                        code = ReturnCode.Ok;
                    }
                    else
                    {
                        bool compactMode = !showOptions &&
                            !showEnvironment;

                        code = HelpOps.WriteUsage(
                            activeInterpreter, null, true, true,
                            showOptions, showEnvironment,
                            compactMode, ref result);
                    }

                    if (code == ReturnCode.Ok)
                    {
                        if (!whatIf && !quiet &&
                            (interactiveHost != null) &&
                            !showOptions && !showEnvironment)
                        {
                            interactiveHost.WriteLine();
                            interactiveHost.WriteLine(String.Format(
                                "Use the \"-{0}\", \"-{1}\", \"-{2}\", or " +
                                "\"-{3}\" options for more information.",
                                CommandLineOption.About,
                                CommandLineOption.CommandHelp,
                                CommandLineOption.EnvironmentHelp,
                                CommandLineOption.FullHelp));
                        }
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, code, result,
                            whatIf, ref argv, ref interactiveHost,
                            ref quiet, ref result);
                    }

                    exitCode = ShellOps.ReturnCodeToExitCode(
                        activeInterpreter, code, true);
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Interactive))
                {
                    if (!whatIf)
                    {
                        activeInterpreter.InternalInteractive = true;

                        if (!quiet)
                        {
                            ShellOps.WritePrompt(
                                interactiveHost, String.Format(
                                _Constants.Prompt.Interactive,
                                _Constants.Prompt.ViaCommandLine));
                        }
                    }

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Initialize))
                {
                    if (initialize && !whatIf)
                    {
                        code = activeInterpreter.PrivateInitialize(
                            forceInitialize, false, ref result);

                        activeInterpreter.MaybeIgnoreInitializeError(
                            ref code, ref result);
                    }
                    else
                    {
                        code = ReturnCode.Ok;
                    }

                    if (code == ReturnCode.Ok)
                    {
                        if (popArgv)
                        {
                            GenericOps<string>.PopFirstArgument(ref argv);
                            popArgv = false;
                        }

                        goto retry;
                    }
                    else
                    {
                        //
                        // BUGFIX: We may have evaluated some code and
                        //         the host may have been changed; grab
                        //         it again.
                        //
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, code, result,
                            Interpreter.GetErrorLine(activeInterpreter), true,
                            true, whatIf, ref argv, ref interactiveHost,
                            ref quiet, ref result);
                    }

                    exitCode = ShellOps.ReturnCodeToExitCode(
                        activeInterpreter, code, true);
                }
#if ISOLATED_PLUGINS
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Isolated))
                {
                    if (arg1 != null)
                    {
                        bool enable = false;

                        code = Value.GetBoolean2(
                            arg1, ValueFlags.AnyBoolean,
                            ShellOps.GetCultureInfo(activeInterpreter),
                            ref enable, ref result);

                        if (code == ReturnCode.Ok)
                        {
                            if (!whatIf)
                            {
                                if (enable)
                                    activeInterpreter.EnablePluginIsolation();
                                else
                                    activeInterpreter.DisablePluginIsolation();

                                if (!quiet)
                                {
                                    ShellOps.WritePrompt(
                                        interactiveHost, String.Format(
                                        _Constants.Prompt.Isolated, enable ?
                                            "enabled" : "disabled"));
                                }
                            }

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }

                        if (code != ReturnCode.Ok)
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <enable>\"",
                            CommandLineOption.Isolated), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
#endif
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Kiosk))
                {
                    if (arg1 != null)
                    {
                        bool processed = false;

                        if (whatIf)
                        {
                            code = ReturnCode.Ok;
                        }
                        else
                        {
                            code = ShellOps.ProcessKioskArgument(
                                activeInterpreter, arg1, kioskLoops,
                                ref processed, ref result);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            if (processed && !whatIf)
                            {
                                kiosk = activeInterpreter.IsKioskLock();

                                if (!quiet)
                                {
                                    ShellOps.WritePrompt(
                                        interactiveHost, String.Format(
                                        _Constants.Prompt.Kiosk,
                                        ShellOps.GetKioskDescription(
                                            activeInterpreter)));
                                }
                            }

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }

                        if (code != ReturnCode.Ok)
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <enable>\"",
                            CommandLineOption.Kiosk), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.LockHostArguments))
                {
                    if (!whatIf && !quiet)
                    {
                        ShellOps.WritePrompt(interactiveHost,
                            _Constants.Prompt.LockHostArguments);
                    }

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Namespaces))
                {
                    if (arg1 != null)
                    {
                        bool enable = false;

                        code = Value.GetBoolean2(
                            arg1, ValueFlags.AnyBoolean,
                            ShellOps.GetCultureInfo(activeInterpreter),
                            ref enable, ref result);

                        if ((code == ReturnCode.Ok) && !whatIf)
                        {
                            code = NamespaceOps.Enable(
                                activeInterpreter, clientData, enable, true,
                                ref result);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            if (!whatIf && !quiet)
                            {
                                ShellOps.WritePrompt(
                                    interactiveHost, String.Format(
                                    _Constants.Prompt.Namespaces, enable ?
                                        "enabled" : "disabled"));
                            }

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }

                        if (code != ReturnCode.Ok)
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <enable>\"",
                            CommandLineOption.Namespaces), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.NoAppSettings))
                {
                    if (!whatIf && !quiet)
                    {
                        ShellOps.WritePrompt(
                            interactiveHost, String.Format(
                            _Constants.Prompt.NoAppSettings,
                            _Constants.Prompt.ViaCommandLine));
                    }

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.NoArgumentsFileNames))
                {
                    if (!whatIf && !quiet)
                    {
                        ShellOps.WritePrompt(interactiveHost,
                            _Constants.Prompt.NoArgumentsFileNames);
                    }

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.NoExit))
                {
                    noExit = true;

                    if (!whatIf && !quiet)
                    {
                        ShellOps.WritePrompt(interactiveHost,
                            _Constants.Prompt.NoExit);
                    }

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.NoTrim))
                {
                    noTrim = true;

                    if (!whatIf && !quiet)
                    {
                        ShellOps.WritePrompt(interactiveHost,
                            _Constants.Prompt.NoTrim);
                    }

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Parent))
                {
                    create[1] = false;

                    if (parentInterpreter != null)
                    {
                        if (!whatIf && !quiet)
                        {
                            ShellOps.WritePrompt(activeInterpreter,
                                _Constants.Prompt.Parent);
                        }

                        activeInterpreter = parentInterpreter;

                        if (popArgv)
                        {
                            GenericOps<string>.PopFirstArgument(ref argv);
                            popArgv = false;
                        }

                        goto retry;
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0,
                            "parent interpreter unavailable", whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Pause))
                {
                    if (interactiveHost != null) /* EXEMPT */
                    {
                        if (!whatIf)
                        {
                            ShellOps.WritePrompt(
                                interactiveHost, String.Format(
                                _Constants.Prompt.Debugger,
                                ProcessOps.GetId()));

                            interactiveHost.Pause();
                        }

                        if (popArgv)
                        {
                            GenericOps<string>.PopFirstArgument(ref argv);
                            popArgv = false;
                        }

                        goto retry;
                    }
                    else
                    {
                        if (!whatIf)
                        {
                            HostOps.WriteConsoleOrComplain(
                                ReturnCode.Error, "interpreter host not available");
                        }

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.PluginArguments))
                {
                    if ((arg1 != null) && (arg2 != null))
                    {
                        if (whatIf ||
                            (activeInterpreter.AddPluginArguments(arg1, arg2) > 0))
                        {
                            if (!whatIf && !quiet)
                            {
                                ShellOps.WritePrompt(
                                    interactiveHost, String.Format(
                                    _Constants.Prompt.PluginArguments,
                                    arg1));
                            }

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }
                        else
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0,
                                "failed to add plugin arguments", whatIf,
                                ref argv, ref interactiveHost, ref quiet,
                                ref result);

                            exitCode = ShellOps.FailureExitCode(activeInterpreter);
                        }
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <pluginName> <arguments>\"",
                            CommandLineOption.PluginArguments), whatIf,
                            ref argv, ref interactiveHost, ref quiet,
                            ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.PostFile))
                {
                    if (arg1 != null)
                    {
                        if (whatIf || activeInterpreter.PrivateInitialized)
                        {
                            int errorLine = 0;

                            if (whatIf)
                            {
                                code = ReturnCode.Ok;
                            }
                            else
                            {
                                code = activeInterpreter.ShellEvaluateFile(
                                    localCallbackData, encoding, arg1,
                                    ref result, ref errorLine);
                            }

                            if (code == ReturnCode.Ok)
                            {
                                //
                                // NOTE: The shell callbacks may have been
                                //       changed via the evaluated script;
                                //       therefore, refresh the ones which
                                //       were not directly supplied by the
                                //       caller.
                                //
                                if (!whatIf)
                                {
                                    /* NO RESULT */
                                    activeInterpreter.RefreshShellCallbacks();
                                }

                                //
                                // NOTE: Must refresh the quiet flag now as
                                //       it could have been changed by the
                                //       evaluated script.
                                //
                                if (!whatIf && refreshQuiet)
                                    quiet = activeInterpreter.ShouldBeQuiet();

                                if (popArgv)
                                {
                                    GenericOps<string>.PopFirstArgument(ref argv);
                                    GenericOps<string>.PopFirstArgument(ref argv);
                                    popArgv = false;
                                }

                                goto retry;
                            }
                            else
                            {
                                //
                                // BUGFIX: We may have evaluated some code and
                                //         the host may have been changed; grab
                                //         it again.
                                //
                                ShellOps.ShellMainCoreError(
                                    activeInterpreter, savedArg0, arg0, code, result,
                                    GetShellErrorLine(activeInterpreter, errorLine),
                                    true, true, whatIf, ref argv,
                                    ref interactiveHost, ref quiet, ref result);
                            }

                            exitCode = ShellOps.ReturnCodeToExitCode(
                                activeInterpreter, code, true);
                        }
                        else
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0,
                                "script library is not initialized", whatIf,
                                ref argv, ref interactiveHost, ref quiet,
                                ref result);

                            exitCode = ShellOps.FailureExitCode(activeInterpreter);
                        }
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <fileName>\"",
                            CommandLineOption.PostFile), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
#if !ENTERPRISE_LOCKDOWN
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.PostInitialize))
                {
                    if (arg1 != null)
                    {
                        if (whatIf || activeInterpreter.PrivateInitialized)
                        {
                            int errorLine = 0;

                            if (whatIf)
                            {
                                code = ReturnCode.Ok;
                            }
                            else
                            {
                                code = activeInterpreter.ShellEvaluateScript(
                                    _ShellCallbackData.GetEvaluateScriptCallback(
                                        localCallbackData), arg1, ref result,
                                    ref errorLine);
                            }

                            if (code == ReturnCode.Ok)
                            {
                                //
                                // NOTE: The shell callbacks may have been
                                //       changed via the evaluated script;
                                //       therefore, refresh the ones which
                                //       were not directly supplied by the
                                //       caller.
                                //
                                if (!whatIf)
                                {
                                    /* NO RESULT */
                                    activeInterpreter.RefreshShellCallbacks();
                                }

                                //
                                // NOTE: Must refresh the quiet flag now as
                                //       it could have been changed by the
                                //       evaluated script.
                                //
                                if (!whatIf && refreshQuiet)
                                    quiet = activeInterpreter.ShouldBeQuiet();

                                if (popArgv)
                                {
                                    GenericOps<string>.PopFirstArgument(ref argv);
                                    GenericOps<string>.PopFirstArgument(ref argv);
                                    popArgv = false;
                                }

                                goto retry;
                            }
                            else
                            {
                                //
                                // BUGFIX: We may have evaluated some code and
                                //         the host may have been changed; grab
                                //         it again.
                                //
                                ShellOps.ShellMainCoreError(
                                    activeInterpreter, savedArg0, arg0, code, result,
                                    GetShellErrorLine(activeInterpreter, errorLine),
                                    true, true, whatIf, ref argv,
                                    ref interactiveHost, ref quiet, ref result);
                            }

                            exitCode = ShellOps.ReturnCodeToExitCode(
                                activeInterpreter, code, true);
                        }
                        else
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0,
                                "script library is not initialized", whatIf,
                                ref argv, ref interactiveHost, ref quiet,
                                ref result);

                            exitCode = ShellOps.FailureExitCode(activeInterpreter);
                        }
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <script>\"",
                            CommandLineOption.PostInitialize), whatIf,
                            ref argv, ref interactiveHost, ref quiet,
                            ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
#endif
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.PreFile))
                {
                    if (arg1 != null)
                    {
                        if (whatIf || !activeInterpreter.PrivateInitialized)
                        {
                            int errorLine = 0;

                            if (whatIf)
                            {
                                code = ReturnCode.Ok;
                            }
                            else
                            {
                                code = activeInterpreter.ShellEvaluateFile(
                                    localCallbackData, encoding, arg1,
                                    ref result, ref errorLine);
                            }

                            if (code == ReturnCode.Ok)
                            {
                                //
                                // NOTE: The shell callbacks may have been
                                //       changed via the evaluated script;
                                //       therefore, refresh the ones which
                                //       were not directly supplied by the
                                //       caller.
                                //
                                if (!whatIf)
                                {
                                    /* NO RESULT */
                                    activeInterpreter.RefreshShellCallbacks();
                                }

                                //
                                // NOTE: Must refresh the quiet flag now as
                                //       it could have been changed by the
                                //       evaluated script.
                                //
                                if (!whatIf && refreshQuiet)
                                    quiet = activeInterpreter.ShouldBeQuiet();

                                if (popArgv)
                                {
                                    GenericOps<string>.PopFirstArgument(ref argv);
                                    GenericOps<string>.PopFirstArgument(ref argv);
                                    popArgv = false;
                                }

                                goto retry;
                            }
                            else
                            {
                                //
                                // BUGFIX: We may have evaluated some code and
                                //         the host may have been changed; grab
                                //         it again.
                                //
                                ShellOps.ShellMainCoreError(
                                    activeInterpreter, savedArg0, arg0, code, result,
                                    GetShellErrorLine(activeInterpreter, errorLine),
                                    true, true, whatIf, ref argv,
                                    ref interactiveHost, ref quiet, ref result);
                            }

                            exitCode = ShellOps.ReturnCodeToExitCode(
                                activeInterpreter, code, true);
                        }
                        else
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0,
                                "script library is already initialized",
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);

                            exitCode = ShellOps.FailureExitCode(activeInterpreter);
                        }
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <fileName>\"",
                            CommandLineOption.PreFile), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
#if !ENTERPRISE_LOCKDOWN
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.PreInitialize))
                {
                    if (arg1 != null)
                    {
                        if (whatIf || !activeInterpreter.PrivateInitialized)
                        {
                            int errorLine = 0;

                            if (whatIf)
                            {
                                code = ReturnCode.Ok;
                            }
                            else
                            {
                                code = activeInterpreter.ShellEvaluateScript(
                                    _ShellCallbackData.GetEvaluateScriptCallback(
                                        localCallbackData), arg1, ref result,
                                    ref errorLine);
                            }

                            if (code == ReturnCode.Ok)
                            {
                                //
                                // NOTE: The shell callbacks may have been
                                //       changed via the evaluated script;
                                //       therefore, refresh the ones which
                                //       were not directly supplied by the
                                //       caller.
                                //
                                if (!whatIf)
                                {
                                    /* NO RESULT */
                                    activeInterpreter.RefreshShellCallbacks();
                                }

                                //
                                // NOTE: Must refresh the quiet flag now as
                                //       it could have been changed by the
                                //       evaluated script.
                                //
                                if (!whatIf && refreshQuiet)
                                    quiet = activeInterpreter.ShouldBeQuiet();

                                if (popArgv)
                                {
                                    GenericOps<string>.PopFirstArgument(ref argv);
                                    GenericOps<string>.PopFirstArgument(ref argv);
                                    popArgv = false;
                                }

                                goto retry;
                            }
                            else
                            {
                                //
                                // BUGFIX: We may have evaluated some code and
                                //         the host may have been changed; grab
                                //         it again.
                                //
                                ShellOps.ShellMainCoreError(
                                    activeInterpreter, savedArg0, arg0, code, result,
                                    GetShellErrorLine(activeInterpreter, errorLine),
                                    true, true, whatIf, ref argv,
                                    ref interactiveHost, ref quiet, ref result);
                            }

                            exitCode = ShellOps.ReturnCodeToExitCode(
                                activeInterpreter, code, true);
                        }
                        else
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0,
                                "script library is already initialized",
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);

                            exitCode = ShellOps.FailureExitCode(activeInterpreter);
                        }
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <script>\"",
                            CommandLineOption.PreInitialize), whatIf,
                            ref argv, ref interactiveHost, ref quiet,
                            ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
#endif
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Profile))
                {
                    if (arg1 != null)
                    {
                        if (whatIf || (HostOps.LoadProfile(
                                activeInterpreter, interactiveHost, arg1,
                                encoding, ref result) == ReturnCode.Ok))
                        {
                            if (!whatIf && !quiet)
                            {
                                ShellOps.WritePrompt(
                                    interactiveHost, String.Format(
                                    _Constants.Prompt.Profile, arg1));
                            }

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }
                        else
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, String.Format(
                                "failed to reload host profile: {0}", result),
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);

                            exitCode = ShellOps.FailureExitCode(activeInterpreter);
                        }
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <profile>\"",
                            CommandLineOption.Profile), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Quiet))
                {
                    if (arg1 != null)
                    {
                        bool enable = false;

                        code = Value.GetBoolean2(
                            arg1, ValueFlags.AnyBoolean,
                            ShellOps.GetCultureInfo(activeInterpreter),
                            ref enable, ref result);

                        if (code == ReturnCode.Ok)
                        {
                            quiet = enable;
                            refreshQuiet = false;

                            if (!whatIf && !quiet)
                            {
                                ShellOps.WritePrompt(
                                    interactiveHost, String.Format(
                                    _Constants.Prompt.Quiet, enable ?
                                        "enabled" : "disabled",
                                    _Constants.Prompt.ViaCommandLine));
                            }

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }

                        if (code != ReturnCode.Ok)
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <enable>\"",
                            CommandLineOption.Quiet), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Reconfigure))
                {
                    if (arg1 != null)
                    {
#if XML && SERIALIZATION
                        bool wasParent = Object.ReferenceEquals(
                            activeInterpreter, parentInterpreter);

                        if (!create[1] || !wasParent)
                        {
                            bool wasIsolated;
                            bool wasSecurity;

                            InterpreterSettings interpreterSettings = null;

                            if (activeInterpreter != null)
                            {
#if ISOLATED_PLUGINS
                                wasIsolated = AppDomainOps.IsIsolated(activeInterpreter);
#else
                                wasIsolated = false;
#endif

                                wasSecurity = activeInterpreter.HasSecurity();

                                code = InterpreterSettings.LoadFrom(
                                    activeInterpreter, true, true, false,
                                    ref interpreterSettings, ref result);
                            }
                            else
                            {
#if ISOLATED_PLUGINS
                                wasIsolated = AppDomainOps.IsIsolated(interpreter);
#else
                                wasIsolated = false;
#endif

                                wasSecurity = interpreter.HasSecurity(); /* EXEMPT */

                                code = InterpreterSettings.LoadFrom(
                                    interpreter, true, true, false, /* EXEMPT */
                                    ref interpreterSettings, ref result);
                            }

                            if (code == ReturnCode.Ok)
                            {
                                invalidInterpreter = true;

                                try
                                {
                                    //
                                    // NOTE: We plan on re-creating the active
                                    //       interpreter (below); therefore, we
                                    //       must dispose the current one first.
                                    //
                                    if (activeInterpreter != null)
                                    {
                                        if (!whatIf)
                                        {
                                            if (wasParent)
                                            {
                                                activeInterpreter.Dispose(); /* throw */
                                            }
                                            else if (childName != null)
                                            {
                                                parentInterpreter.RemoveChildInterpreterOrComplain(
                                                    childName, null, true);
                                            }
                                            else
                                            {
                                                activeInterpreter.Dispose(); /* throw */
                                            }

                                            activeInterpreter = null;

                                            if (wasParent)
                                            {
                                                parentInterpreter = null;
                                                childInterpreter = null;
                                            }
                                            else
                                            {
                                                childInterpreter = null;
                                            }

                                            invalidInterpreter = false;
                                        }

                                        //
                                        // NOTE: If this command line option has
                                        //       been used before, the disposal
                                        //       flag will be set (i.e. because
                                        //       we created the interpreter that
                                        //       was just disposed).  Therefore,
                                        //       reset it now since the disposal
                                        //       of the interpreter is complete.
                                        //
                                        dispose = false;
                                    }
                                }
                                catch (Exception e)
                                {
                                    result = e;
                                    code = ReturnCode.Error;
                                }
                            }

                            if (code == ReturnCode.Ok)
                            {
                                if (!whatIf)
                                {
                                    if (create[2])
                                        interpreterSettings.MakeSafe();

                                    if (create[3])
                                        interpreterSettings.MakeStandard();

                                    if (create[1])
                                    {
                                        if (parentInterpreter.CreateChildInterpreter(
                                                null, clientData, interpreterSettings,
                                                wasIsolated, wasSecurity,
                                                ref result) == ReturnCode.Ok)
                                        {
                                            childName = result;

                                            if (parentInterpreter.GetNestedChildInterpreter(
                                                    childName, LookupFlags.Interpreter,
                                                    false, ref activeInterpreter,
                                                    ref result) != ReturnCode.Ok)
                                            {
                                                activeInterpreter = null; /* REDUNDANT? */
                                            }
                                        }
                                        else
                                        {
                                            activeInterpreter = null; /* REDUNDANT */
                                        }
                                    }
                                    else
                                    {
                                        activeInterpreter = Create(
                                            interpreterSettings, true, ref result);
                                    }
                                }

                                if (activeInterpreter != null)
                                {
                                    //
                                    // NOTE: This method has now re-created the
                                    //       active interpreter; therefore, it
                                    //       must be disposed by this method
                                    //       before exiting.
                                    //
                                    dispose = true;

                                    if (!whatIf)
                                    {
                                        if (wasParent)
                                            parentInterpreter = activeInterpreter;
                                        else
                                            childInterpreter = activeInterpreter;
                                    }

                                    if (!whatIf && !quiet)
                                    {
                                        ShellOps.WritePrompt(activeInterpreter,
                                            String.Format(_Constants.Prompt.Reconfigure,
                                            wasParent ? "Parent" : "Child",
                                            FormatOps.InterpreterNoThrow(activeInterpreter),
                                            arg1));
                                    }

                                    if (popArgv)
                                    {
                                        GenericOps<string>.PopFirstArgument(ref argv);
                                        GenericOps<string>.PopFirstArgument(ref argv);
                                        popArgv = false;
                                    }

                                    goto retry;
                                }
                                else
                                {
                                    code = ReturnCode.Error;
                                }
                            }

                            if (code != ReturnCode.Ok)
                            {
                                ShellOps.ShellMainCoreError(
                                    activeInterpreter, savedArg0, arg0, code, result,
                                    whatIf, ref argv, ref interactiveHost,
                                    ref quiet, ref result);
                            }

                            exitCode = ShellOps.ReturnCodeToExitCode(
                                activeInterpreter, code, true);
                        }
                        else
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0,
                                "cannot reconfigure parent interpreter " +
                                "with child interpreter", whatIf, ref argv,
                                ref interactiveHost, ref quiet, ref result);

                            exitCode = ShellOps.FailureExitCode(activeInterpreter);
                        }
#else
                        result = "not implemented";
                        code = ReturnCode.Error;
#endif
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <settings>\"",
                            CommandLineOption.Reconfigure), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Recreate))
                {
                    bool wasParent = Object.ReferenceEquals(
                        activeInterpreter, parentInterpreter);

                    if (!create[1] || !wasParent)
                    {
                        bool wasIsolated;
                        bool wasSecurity;

                        InterpreterSettings interpreterSettings = null;

                        if (activeInterpreter != null)
                        {
#if ISOLATED_PLUGINS
                            wasIsolated = AppDomainOps.IsIsolated(activeInterpreter);
#else
                            wasIsolated = false;
#endif

                            wasSecurity = activeInterpreter.HasSecurity();

                            code = InterpreterSettings.LoadFrom(
                                activeInterpreter, true, true, false,
                                ref interpreterSettings, ref result);
                        }
                        else
                        {
#if ISOLATED_PLUGINS
                            wasIsolated = AppDomainOps.IsIsolated(interpreter); /* EXEMPT */
#else
                            wasIsolated = false;
#endif

                            wasSecurity = interpreter.HasSecurity(); /* EXEMPT */

                            code = InterpreterSettings.LoadFrom(
                                interpreter, true, true, false, /* EXEMPT */
                                ref interpreterSettings, ref result);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            if (lockArgv)
                            {
                                code = InterpreterSettings.UseStartupDefaults(
                                    interpreterSettings, CreateFlags.CoreShellUse,
                                    HostCreateFlags.CoreShellUse, ref result);
                            }
                            else
                            {
                                /* NO RESULT */
                                InterpreterSettings.CheckPoliciesAndTraces(
                                    interpreterSettings);
                            }
                        }

                        if (code == ReturnCode.Ok)
                        {
                            invalidInterpreter = true;

                            try
                            {
                                //
                                // NOTE: We plan on re-creating the active
                                //       interpreter (below); therefore, we
                                //       must dispose the current one first.
                                //
                                if (activeInterpreter != null)
                                {
                                    if (!whatIf)
                                    {
                                        if (wasParent)
                                        {
                                            activeInterpreter.Dispose(); /* throw */
                                        }
                                        else if (childName != null)
                                        {
                                            parentInterpreter.RemoveChildInterpreterOrComplain(
                                                childName, null, true);
                                        }
                                        else
                                        {
                                            activeInterpreter.Dispose(); /* throw */
                                        }

                                        activeInterpreter = null;

                                        if (wasParent)
                                        {
                                            parentInterpreter = null;
                                            childInterpreter = null;
                                        }
                                        else
                                        {
                                            childInterpreter = null;
                                        }

                                        invalidInterpreter = false;
                                    }

                                    //
                                    // NOTE: If this command line option has
                                    //       been used before, the disposal
                                    //       flag will be set (i.e. because
                                    //       we created the interpreter that
                                    //       was just disposed).  Therefore,
                                    //       reset it now since the disposal
                                    //       of the interpreter is complete.
                                    //
                                    dispose = false;
                                }
                            }
                            catch (Exception e)
                            {
                                result = e;
                                code = ReturnCode.Error;
                            }
                        }

                        if (code == ReturnCode.Ok)
                        {
                            if (!whatIf)
                            {
                                if (create[2])
                                    interpreterSettings.MakeSafe();

                                if (create[3])
                                    interpreterSettings.MakeStandard();

                                if (create[1])
                                {
                                    if (parentInterpreter.CreateChildInterpreter(
                                            null, clientData, interpreterSettings,
                                            wasIsolated, wasSecurity,
                                            ref result) == ReturnCode.Ok)
                                    {
                                        childName = result;

                                        if (parentInterpreter.GetNestedChildInterpreter(
                                                childName, LookupFlags.Interpreter,
                                                false, ref activeInterpreter,
                                                ref result) != ReturnCode.Ok)
                                        {
                                            activeInterpreter = null; /* REDUNDANT? */
                                        }
                                    }
                                    else
                                    {
                                        activeInterpreter = null; /* REDUNDANT */
                                    }
                                }
                                else
                                {
                                    activeInterpreter = Create(
                                        interpreterSettings, true, ref result);
                                }
                            }

                            if (activeInterpreter != null)
                            {
                                //
                                // NOTE: This method has now re-created the
                                //       active interpreter; therefore, it
                                //       must be disposed by this method
                                //       before exiting.
                                //
                                dispose = true;

                                if (!whatIf)
                                {
                                    if (wasParent)
                                        parentInterpreter = activeInterpreter;
                                    else
                                        childInterpreter = activeInterpreter;
                                }

                                if (!whatIf && !quiet)
                                {
                                    ShellOps.WritePrompt(activeInterpreter,
                                        String.Format(_Constants.Prompt.Recreate,
                                        wasParent ? "Parent" : "Child",
                                        FormatOps.InterpreterNoThrow(activeInterpreter)));
                                }

                                if (popArgv)
                                {
                                    GenericOps<string>.PopFirstArgument(ref argv);
                                    popArgv = false;
                                }

                                goto retry;
                            }
                            else
                            {
                                code = ReturnCode.Error;
                            }
                        }

                        if (code != ReturnCode.Ok)
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0,
                            "cannot recreate parent interpreter " +
                            "with child interpreter", whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.RuntimeOption))
                {
                    if (arg1 != null)
                    {
                        if (whatIf || activeInterpreter.PrivateInitialized)
                        {
                            if (whatIf ||
                                activeInterpreter.ChangeRuntimeOption(arg1))
                            {
                                if (!whatIf && !quiet)
                                {
                                    ShellOps.WritePrompt(
                                        interactiveHost, String.Format(
                                        _Constants.Prompt.RuntimeOption,
                                        arg1));
                                }

                                if (popArgv)
                                {
                                    GenericOps<string>.PopFirstArgument(ref argv);
                                    GenericOps<string>.PopFirstArgument(ref argv);
                                    popArgv = false;
                                }

                                goto retry;
                            }
                            else
                            {
                                //
                                // BUGFIX: We may have evaluated some code and
                                //         the host may have been changed; grab
                                //         it again.
                                //
                                ShellOps.ShellMainCoreError(
                                    activeInterpreter, savedArg0, arg0,
                                    "failed to change runtime option", whatIf,
                                    ref argv, ref interactiveHost, ref quiet,
                                    ref result);
                            }

                            exitCode = ShellOps.FailureExitCode(activeInterpreter);
                        }
                        else
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0,
                                "script library is not initialized", whatIf,
                                ref argv, ref interactiveHost, ref quiet,
                                ref result);

                            exitCode = ShellOps.FailureExitCode(activeInterpreter);
                        }
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <optionName>\"",
                            CommandLineOption.RuntimeOption), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Safe))
                {
                    create[2] = true;

                    if (whatIf)
                    {
                        code = ReturnCode.Ok;
                    }
                    else
                    {
                        if (!quiet)
                        {
                            ShellOps.WritePrompt(
                                interactiveHost, String.Format(
                                _Constants.Prompt.Safe,
                                _Constants.Prompt.ViaCommandLine));
                        }

                        if (create[0])
                        {
                            arg0 = Characters.MinusSign + CommandLineOption.Recreate;

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto option;
                        }
                        else
                        {
                            code = activeInterpreter.InternalMakeSafe(
                                MakeFlags.SafeShell, true, ref result);
                        }
                    }

                    if (code == ReturnCode.Ok)
                    {
                        if (popArgv)
                        {
                            GenericOps<string>.PopFirstArgument(ref argv);
                            popArgv = false;
                        }

                        goto retry;
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, code, result,
                            whatIf, ref argv, ref interactiveHost,
                            ref quiet, ref result);
                    }

                    exitCode = ShellOps.ReturnCodeToExitCode(
                        activeInterpreter, code, true);
                }
#if TEST
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.ScriptTrace))
                {
                    if (arg1 != null)
                    {
                        if (whatIf)
                        {
                            code = ReturnCode.Ok;
                        }
                        else
                        {
                            code = DebugOps.AddScriptTraceListener(
                                activeInterpreter, arg1, activeInterpreter.Debug,
                                false, ref result);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            if (!whatIf && !quiet)
                            {
                                ShellOps.WritePrompt(
                                    interactiveHost, String.Format(
                                    _Constants.Prompt.ScriptTrace,
                                    _Constants.Prompt.ViaCommandLine));
                            }

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }

                        if (code != ReturnCode.Ok)
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <value>\"",
                            CommandLineOption.ScriptTrace), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
#endif
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Security))
                {
                    if (arg1 != null)
                    {
                        bool enable = false;

                        code = Value.GetBoolean2(
                            arg1, ValueFlags.AnyBoolean,
                            ShellOps.GetCultureInfo(activeInterpreter),
                            ref enable, ref result);

                        if ((code == ReturnCode.Ok) && !whatIf)
                        {
                            code = ScriptOps.EnableOrDisableSecurity(
                                activeInterpreter, enable,
                                activeInterpreter.PrivateIsNoVariables(),
                                ref result);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            if (!whatIf && !quiet)
                            {
                                ShellOps.WritePrompt(
                                    interactiveHost, String.Format(
                                    _Constants.Prompt.Security, enable ?
                                        "enabled" : "disabled"));
                            }

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }

                        if (code != ReturnCode.Ok)
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <enable>\"",
                            CommandLineOption.Security), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.SetCreate))
                {
                    if (arg1 != null)
                    {
                        code = Value.GetBoolean2(
                            arg1, ValueFlags.AnyBoolean,
                            ShellOps.GetCultureInfo(activeInterpreter),
                            ref create[0], ref result);

                        if (code == ReturnCode.Ok)
                        {
                            if (!whatIf && !quiet)
                            {
                                if (create[0])
                                {
                                    ShellOps.WritePrompt(interactiveHost,
                                        _Constants.Prompt.Create);
                                }
                                else
                                {
                                    ShellOps.WritePrompt(interactiveHost,
                                        _Constants.Prompt.NoCreate);
                                }
                            }

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }

                        if (code != ReturnCode.Ok)
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <enable>\"",
                            CommandLineOption.SetCreate), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.SetInitialize))
                {
                    if (arg1 != null)
                    {
                        code = Value.GetBoolean2(
                            arg1, ValueFlags.AnyBoolean,
                            ShellOps.GetCultureInfo(activeInterpreter),
                            ref initialize, ref result);

                        if (code == ReturnCode.Ok)
                        {
                            if (!whatIf && !quiet)
                            {
                                if (initialize)
                                {
                                    ShellOps.WritePrompt(interactiveHost,
                                        _Constants.Prompt.Initialize);
                                }
                                else
                                {
                                    ShellOps.WritePrompt(
                                        interactiveHost, String.Format(
                                        _Constants.Prompt.NoInitialize,
                                        _Constants.Prompt.ViaCommandLine));
                                }
                            }

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }

                        if (code != ReturnCode.Ok)
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <enable>\"",
                            CommandLineOption.SetInitialize), whatIf,
                            ref argv, ref interactiveHost, ref quiet,
                            ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.SetLoop))
                {
                    if (arg1 != null)
                    {
                        code = Value.GetBoolean2(
                            arg1, ValueFlags.AnyBoolean,
                            ShellOps.GetCultureInfo(activeInterpreter),
                            ref loop, ref result);

                        if (code == ReturnCode.Ok)
                        {
                            if (!whatIf && !quiet)
                            {
                                if (loop)
                                {
                                    ShellOps.WritePrompt(interactiveHost,
                                        _Constants.Prompt.Loop);
                                }
                                else
                                {
                                    ShellOps.WritePrompt(
                                        interactiveHost, String.Format(
                                        _Constants.Prompt.NoLoop,
                                        _Constants.Prompt.ViaCommandLine));
                                }
                            }

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto retry;
                        }

                        if (code != ReturnCode.Ok)
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);
                        }

                        exitCode = ShellOps.ReturnCodeToExitCode(
                            activeInterpreter, code, true);
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <enable>\"",
                            CommandLineOption.SetLoop), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.SetupTrace))
                {
                    if (whatIf)
                    {
                        code = ReturnCode.Ok;
                    }
                    else
                    {
                        code = DebugOps.SetupTraceListeners(
                            DebugOps.GetTraceListenerType(true),
                            clientData, true, activeInterpreter.Debug,
                            true, true, ref result);
                    }

                    if (code == ReturnCode.Ok)
                    {
                        if (popArgv)
                        {
                            GenericOps<string>.PopFirstArgument(ref argv);
                            popArgv = false;
                        }

                        goto retry;
                    }

                    ShellOps.ShellMainCoreError(
                        activeInterpreter, savedArg0, arg0, code, result,
                        whatIf, ref argv, ref interactiveHost,
                        ref quiet, ref result);

                    exitCode = ShellOps.ReturnCodeToExitCode(
                        activeInterpreter, code, true);
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Standard))
                {
                    create[3] = true;

                    if (whatIf)
                    {
                        code = ReturnCode.Ok;
                    }
                    else
                    {
                        if (!quiet)
                        {
                            ShellOps.WritePrompt(
                                interactiveHost, String.Format(
                                _Constants.Prompt.Standard,
                                _Constants.Prompt.ViaCommandLine));
                        }

                        if (create[0])
                        {
                            arg0 = Characters.MinusSign + CommandLineOption.Recreate;

                            if (popArgv)
                            {
                                GenericOps<string>.PopFirstArgument(ref argv);
                                popArgv = false;
                            }

                            goto option;
                        }
                        else
                        {
                            code = activeInterpreter.MakeStandard(
                                MakeFlags.StandardShell, true, ref result);
                        }
                    }

                    if (code == ReturnCode.Ok)
                    {
                        if (popArgv)
                        {
                            GenericOps<string>.PopFirstArgument(ref argv);
                            popArgv = false;
                        }

                        goto retry;
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, code, result,
                            whatIf, ref argv, ref interactiveHost,
                            ref quiet, ref result);
                    }

                    exitCode = ShellOps.ReturnCodeToExitCode(
                        activeInterpreter, code, true);
                }
#if TEST
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.StartupLogFile))
                {
                    //
                    // NOTE: Actually, this argument should have already been
                    //       processed by the GetStartupLogFileName() method;
                    //       therefore, just skip over it.  However, first
                    //       issue a warning to make sure that the user knows
                    //       about this.
                    //
                    if (!whatIf && !quiet)
                    {
                        ShellOps.WritePrompt(interactiveHost,
                            _Constants.Prompt.LogFile);
                    }

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
#endif
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.StartupLibrary))
                {
                    //
                    // NOTE: Actually, this argument should have already been
                    //       processed by the GetStartupLibraryPath() method;
                    //       therefore, just skip over it.  However, first
                    //       issue a warning to make sure that the user knows
                    //       about this.
                    //
                    if (!whatIf && !quiet)
                    {
                        ShellOps.WritePrompt(interactiveHost,
                            _Constants.Prompt.LibraryPath);
                    }

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
#if !ENTERPRISE_LOCKDOWN
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.StartupPreInitialize))
                {
                    //
                    // NOTE: Actually, this argument should have already been
                    //       processed by the GetStartupPreInitializeText()
                    //       method; therefore, just skip over it.  However,
                    //       first issue a warning to make sure that the user
                    //       knows about this.
                    //
                    if (!whatIf && !quiet)
                    {
                        ShellOps.WritePrompt(interactiveHost,
                            _Constants.Prompt.PreInitializeText);
                    }

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
#endif
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Step))
                {
#if DEBUGGER
                    if (!whatIf)
                    {
                        activeInterpreter.SingleStep = true;

                        if (!quiet)
                        {
                            ShellOps.WritePrompt(
                                interactiveHost, String.Format(
                                _Constants.Prompt.SingleStep,
                                _Constants.Prompt.ViaCommandLine));
                        }
                    }
#else
                    if (!whatIf && !quiet)
                    {
                        ShellOps.WritePrompt(
                            interactiveHost, String.Format(
                            _Constants.Prompt.NoDebugger,
                            _Constants.Prompt.ViaCommandLine));
                    }
#endif

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
                else if ((count > 0) &&
                    (StringOps.MatchSwitch(arg0, CommandLineOption.Test) ||
                    StringOps.MatchSwitch(arg0, CommandLineOption.PluginTest)))
                {
                    if (whatIf)
                    {
                        code = ReturnCode.Ok;
                    }
                    else
                    {
                        code = activeInterpreter.SetArguments(
                            new StringList(argv, 3, noTrim),
                            ref result);
                    }

                    if ((code == ReturnCode.Ok) && initialize && !whatIf)
                    {
                        code = activeInterpreter.PrivateInitialize(
                            forceInitialize, false, ref result);

                        activeInterpreter.MaybeIgnoreInitializeError(
                            ref code, ref result);
                    }

                    bool all = false;

                    if ((code == ReturnCode.Ok) && (arg2 != null))
                    {
                        code = Value.GetBoolean2(
                            arg2, ValueFlags.AnyBoolean,
                            ShellOps.GetCultureInfo(activeInterpreter),
                            ref all, ref result);
                    }

                    int errorLine = 0;

                    if ((code == ReturnCode.Ok) && !whatIf)
                    {
                        code = TestOps.ShellMain(
                            activeInterpreter, arg1, null,
                            activeInterpreter.EngineFlags,
                            activeInterpreter.SubstitutionFlags,
                            activeInterpreter.EngineEventFlags,
                            activeInterpreter.ExpressionFlags,
                            StringOps.MatchSwitch(arg0,
                                CommandLineOption.PluginTest) ?
                                TestPathType.Plugins :
                            TestPathType.Default, all,
                            ref result, ref errorLine);
                    }

                    if (code != ReturnCode.Ok)
                    {
                        //
                        // BUGFIX: We may have evaluated some code and
                        //         the host may have been changed; grab
                        //         it again.
                        //
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, code, result,
                            GetShellErrorLine(activeInterpreter, errorLine),
                            true, true, whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);
                    }

                    //
                    // NOTE: If the exit code for the interpreter is successful,
                    //       use the return code to figure out what this method
                    //       should return (i.e. just in case of a failure to
                    //       initialize, evaluate a script, etc).
                    //
                    ShellOps.GetExitCode(activeInterpreter, code, out exitCode);
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.TestDirectory))
                {
                    if (arg1 != null)
                    {
                        if (!whatIf)
                            activeInterpreter.TestPath = arg1;

                        if (popArgv)
                        {
                            GenericOps<string>.PopFirstArgument(ref argv);
                            GenericOps<string>.PopFirstArgument(ref argv);
                            popArgv = false;
                        }

                        goto retry;
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <directory>\"",
                            CommandLineOption.TestDirectory), whatIf,
                            ref argv, ref interactiveHost, ref quiet,
                            ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.TraceToHost))
                {
                    if (!whatIf)
                        activeInterpreter.InterpreterFlags |= InterpreterFlags.TraceToHost;

                    if (popArgv)
                    {
                        GenericOps<string>.PopFirstArgument(ref argv);
                        popArgv = false;
                    }

                    goto retry;
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.VendorPath))
                {
                    if (arg1 != null)
                    {
                        if (!whatIf)
                        {
                            GlobalConfiguration.SetValue(EnvVars.VendorPath,
                                arg1, ConfigurationFlags.Interpreter |
                                ConfigurationFlags.NativePathValue);
                        }

                        if (popArgv)
                        {
                            GenericOps<string>.PopFirstArgument(ref argv);
                            GenericOps<string>.PopFirstArgument(ref argv);
                            popArgv = false;
                        }

                        goto retry;
                    }
                    else
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, String.Format(
                            "wrong # args: should be \"-{0} <directory>\"",
                            CommandLineOption.VendorPath), whatIf, ref argv,
                            ref interactiveHost, ref quiet, ref result);

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }
                else if ((count > 0) &&
                    StringOps.MatchSwitch(arg0, CommandLineOption.Version))
                {
                    if (whatIf)
                    {
                        code = ReturnCode.Ok;
                    }
                    else
                    {
                        code = HelpOps.WriteVersion(
                            activeInterpreter, true, true, true,
                            true, true, true, true, true,
                            false, ref result);
                    }

                    if (code != ReturnCode.Ok)
                    {
                        ShellOps.ShellMainCoreError(
                            activeInterpreter, savedArg0, arg0, code, result,
                            whatIf, ref argv, ref interactiveHost,
                            ref quiet, ref result);
                    }

                    exitCode = ShellOps.ReturnCodeToExitCode(
                        activeInterpreter, code, true);
                }
                else
                {
                    //
                    // NOTE: This callback is (a bit) special as it is
                    //       optional -AND- it can impact the control
                    //       flow within this method (when specified).
                    //       Therefore, the helper method used to query
                    //       it is a bit different and requires an
                    //       output parameter.
                    //
                    bool wasHandled = false;

                    code = ShellOps.UnknownArgument(
                        activeInterpreter, interactiveHost, clientData,
                        localCallbackData, count, arg0, whatIf,
                        ref wasHandled, ref argv, ref result);

                    if (wasHandled)
                    {
                        if (code == ReturnCode.Ok)
                        {
                            goto retry;
                        }
                        else
                        {
                            //
                            // BUGFIX: We may have evaluated some code and
                            //         the host may have been changed; grab
                            //         it again.
                            //
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);

                            exitCode = ShellOps.FailureExitCode(activeInterpreter);
                        }
                    }
                    else
                    {
                        if (whatIf)
                        {
                            code = ReturnCode.Ok;
                        }
                        else
                        {
                            code = HelpOps.WriteUsage(
                                activeInterpreter, String.Format(
                                "invalid argument {0}, use \"-{1}\" for help",
                                FormatOps.WrapOrNull(savedArg0),
                                CommandLineOption.Help), false,
                                false, false, false, true,
                                ref result);
                        }

                        if (code != ReturnCode.Ok)
                        {
                            ShellOps.ShellMainCoreError(
                                activeInterpreter, savedArg0, arg0, code, result,
                                whatIf, ref argv, ref interactiveHost,
                                ref quiet, ref result);
                        }

                        exitCode = ShellOps.FailureExitCode(activeInterpreter);
                    }
                }

            doneArgs:

                //
                // NOTE: If requested, force entry into interactive loop,
                //       unless there is no interpreter available.
                //
                if (noExit && (activeInterpreter != null))
                {
                    //
                    // NOTE: It is necessary to invalidate the command line
                    //       arguments here; otherwise, the interactive loop
                    //       will not be entered.
                    //
                    argv = null;
                    goto retry;
                }
            }
            else if (loop)
            {
                if (initialize && !whatIf)
                {
                    code = activeInterpreter.PrivateInitialize(
                        forceInitialize, false, ref result);

                    activeInterpreter.MaybeIgnoreInitializeError(
                        ref code, ref result);
                }
                else
                {
                    code = ReturnCode.Ok;
                }

                if (code == ReturnCode.Ok)
                {
                    //
                    // HACK: Next, disable any flags that may be unsuitable
                    //       (for use in the interactive loop) -AND- enable
                    //       any flags that might be useful.
                    //
                    int flagCount = whatIf ? 0 :
                        activeInterpreter.MaybeChangeFlagsForInteractiveUse();

                    TraceOps.DebugTrace(String.Format(
                        "PrivateShellMainCore: interactive use detected, " +
                        "changed {0} flag {1}", flagCount, (flagCount != 1) ?
                        "sets" : "set"), typeof(Interpreter).Name,
                        TracePriority.StartupDebug3);

                    //
                    // HACK: Since populating the list of installed updates
                    //       is fairly expensive, only do it automatically
                    //       for an interpreter that is actually going to
                    //       enter the interactive loop.  For this, it does
                    //       not matter if the interactive loop callback is
                    //       being used (i.e. it has been customized).  Do
                    //       not do this for "safe" interpreters (e.g. via
                    //       the -safe command line option, etc).  Also, do
                    //       do not this for non-default AppDomains.  Note
                    //       that we cannot actually check the Interactive
                    //       property of the interpreter at this point, due
                    //       to it (generally) being initialized only from
                    //       within the interactive loop itself.
                    //
#if !NET_STANDARD_20
                    if (!whatIf &&
                        PlatformOps.ShouldPopulateOperatingSystemExtra(
                            activeInterpreter, false, true, false, false,
                            true))
                    {
                        /* ASYNCHRONOUS */
                        PlatformOps.PopulateOperatingSystemExtra(
                            activeInterpreter, false, true, true);
                    }
#endif

                kiosk:

                    //
                    // NOTE: At this point, if we are not in "what-if" mode,
                    //       we will entered the interactive loop below.
                    //
                    interactive = true;

                    if (!whatIf)
                    {
                        //
                        // NOTE: Always use the original command line arguments
                        //       (as passed by the caller) here; otherwise, we
                        //       should always end up with a null argument list
                        //       because we cannot get to this block of code
                        //       unless there are no arguments left to process
                        //       (or there never were any to begin with).
                        //
                        InteractiveLoopData interactiveLoopData =
                            new InteractiveLoopData(args);

#if DEBUGGER
                        //
                        // NOTE: This callback is (a bit) special as it is
                        //       optional -AND- it can impact the control
                        //       flow within this method (when specified).
                        //       Therefore, the helper method used to query
                        //       it is a bit different and requires an
                        //       output parameter.
                        //
                        InteractiveLoopCallback interactiveLoopCallback;

                        if (_ShellCallbackData.GetInteractiveLoopCallback(
                                localCallbackData, out interactiveLoopCallback))
                        {
                            //
                            // NOTE: Use the specified interactive loop callback
                            //       instead of the default interactive loop
                            //       implementation.  All the defaulted parameter
                            //       values here should match those used by the
                            //       InteractiveLoop method overload that accepts
                            //       three parameters (i.e. the one used by this
                            //       method).
                            //
                            try
                            {
                                code = interactiveLoopCallback( /* throw */
                                    activeInterpreter, interactiveLoopData,
                                    ref result);
                            }
                            catch (Exception e)
                            {
                                result = e;
                                code = ReturnCode.Error;

                                //
                                // NOTE: *SPECIAL* The custom interactive loop
                                //       threw an exception and may not have set
                                //       the exit code; therefore, use the error
                                //       return code instead.
                                //
                                exitCode = ShellOps.ReturnCodeToExitCode(
                                    activeInterpreter, code, true);
                            }
                        }
                        else
#endif
                        {
                            //
                            // NOTE: Use the built-in interactive loop.  This
                            //       is the default behavior when there are no
                            //       arguments -OR- the arguments do not specify
                            //       a script or file to evaluate.  Even if/when
                            //       the built-in interactive loop is used, there
                            //       are a variety of mechanisms (e.g. the IHost)
                            //       that can be used to customize its behavior.
                            //
                            code = InteractiveLoop(
                                activeInterpreter, interactiveLoopData,
                                ref result);
                        }

                        //
                        // NOTE: At this point, if the interpreter is still valid
                        //       and kiosk mode is enabled for the interpreter,
                        //       do the following things:
                        //
                        //       1. Emit the current result IF there was an error
                        //          in the interactive loop.  It should be noted
                        //          here that an error condition will NOT prevent
                        //          the interactive loop from being reentered.
                        //
                        //       2. Reset exit flag for the interpreter in use.
                        //
                        //       3. Jump back to the top of the interactive loop
                        //          and run it again.
                        //
                        //       None of the above actions will be performed when
                        //       operatring in "what-if" mode.  The net effect of
                        //       these actions is that "typical" ways of exiting
                        //       the interactive loop, e.g. [exit], et al, will
                        //       not work.
                        //
                        if (!whatIf && !activeInterpreter.PrivateDisposed &&
                            activeInterpreter.GetAndCheckInteractiveHost(
                                ref interactiveHost) &&
                            (kiosk || activeInterpreter.IsKioskLock()))
                        {
                            if (code != ReturnCode.Ok)
                            {
                                ShellOps.ShellMainCoreError(
                                    activeInterpreter, null, null, code, result,
                                    whatIf, ref argv, ref interactiveHost,
                                    ref quiet, ref result);
                            }

                            bool exit = activeInterpreter.PrivateExit;

                            if (exit) /* PERF */
                                activeInterpreter.PrivateExit = false;

                            if (!quiet)
                            {
                                ShellOps.WritePrompt(
                                    interactiveHost, String.Format(
                                    _Constants.Prompt.DeniedExit, exit ?
                                        " and reset interpreter flag" :
                                        String.Empty));
                            }

                            kioskLoops++;

                            if (activeInterpreter.IsKioskArgv())
                            {
                                StringList arguments = null;

                                if (activeInterpreter.GetArguments(
                                        ref arguments,
                                        ref result) == ReturnCode.Ok)
                                {
                                    argv = arguments;
                                    goto retry;
                                }
                            }

                            goto kiosk;
                        }
                    }
                }
                else
                {
                    //
                    // BUGFIX: We may have evaluated some code and
                    //         the host may have been changed; grab
                    //         it again.
                    //
                    ShellOps.ShellMainCoreError(
                        activeInterpreter, null, null, code, result,
                        Interpreter.GetErrorLine(activeInterpreter), true,
                        true, whatIf, ref argv, ref interactiveHost,
                        ref quiet, ref result);
                }

                //
                // NOTE: The return code is not used here to determine
                //       the exit code.  Instead, the exit code for the
                //       interpreter is used directly.
                //
                ShellOps.GetExitCode(activeInterpreter, out exitCode);
            }
            else
            {
                TraceOps.DebugTrace(
                    "PrivateShellMainCore: interactive loop skipped",
                    typeof(Interpreter).Name, TracePriority.StartupDebug);

                //
                // NOTE: The return code is not used here to determine
                //       the exit code.  Instead, the exit code for the
                //       interpreter is used directly.
                //
                ShellOps.GetExitCode(activeInterpreter, out exitCode);
            }

        done:

            //
            // NOTE: Do we need to dispose of the interpreter now?  This will
            //       only occur if the -reconfigure or -recreate command line
            //       options were used, which cause the interpreter to be
            //       re-created locally within this method.  Otherwise, the
            //       using statement in use by the caller, if any, would take
            //       care of any disposal.
            //
            if (!whatIf && dispose &&
                !invalidInterpreter && (parentInterpreter != null))
            {
                ReturnCode disposeCode;
                Result disposeError = null;
                bool localDispose = dispose;

                disposeCode = ObjectOps.TryDispose<Interpreter>(
                    ref parentInterpreter, ref localDispose, ref disposeError);

                if (!quiet)
                {
                    if (disposeCode == ReturnCode.Ok)
                    {
                        ShellOps.WritePrompt((Interpreter)null,
                            String.Format(_Constants.Prompt.Disposed,
                            FormatOps.InterpreterNoThrow(parentInterpreter),
                            localDispose ? String.Empty : "not "));
                    }
                    else
                    {
                        ShellOps.WritePrompt((Interpreter)null,
                            String.Format(_Constants.Prompt.DisposedError,
                            FormatOps.InterpreterNoThrow(parentInterpreter),
                            disposeError));
                    }
                }

                TraceOps.DebugTrace(String.Format(
                    "PrivateShellMainCore: dispose, parentInterpreter = {0}, " +
                    "disposeCode = {1}, localDispose = {2}, disposeError = {3}",
                    FormatOps.InterpreterNoThrow(parentInterpreter),
                    FormatOps.WrapOrNull(disposeCode), FormatOps.WrapOrNull(
                    dispose), FormatOps.WrapOrNull(true, false, disposeError)),
                    typeof(Interpreter).Name, (disposeCode == ReturnCode.Ok) ?
                        TracePriority.ShellDebug3 : TracePriority.ShellError);
            }

            TraceOps.DebugTrace(String.Format(
                "PrivateShellMainCore: exited, interpreter = {0}, " +
                "callbackData = {1}, clientData = {2}, argv = {3}, " +
                "whatIf = {4}, initialize = {5}, loop = {6}, " +
                "interactive = {7}, dispose = {8}, result = {9}, " +
                "exitCode = {10}",
                FormatOps.InterpreterNoThrow(interpreter),
                FormatOps.ShellCallbackData(callbackData),
                FormatOps.WrapOrNull(clientData),
                FormatOps.WrapOrNull(true, true, argv), whatIf,
                initialize, loop, interactive, dispose,
                FormatOps.WrapOrNull(true, true, result), exitCode),
                typeof(Interpreter).Name, TracePriority.StartupDebug);

            return exitCode;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TEST
        internal static ReturnCode MayEnterInteractiveLoop(
            Interpreter interpreter,  /* in */
            IEnumerable<string> args, /* in: OPTIONAL */
            ref bool result,          /* out */
            ref Result error          /* out */
            ) /* THREAD-SAFE, RE-ENTRANT */
        {
            Interlocked.Increment(ref globalShellMainCoreCount);

            try
            {
                bool initialize = false;
                bool loop = true;
                bool interactive = false;
                Result localResult = null;

                if (PrivateShellMainCore(interpreter,
                        null, null, args, true /* what-if */,
                        ref initialize, ref loop, ref interactive,
                        ref localResult) == ExitCode.Success)
                {
                    result = interactive;
                    return ReturnCode.Ok;
                }
                else
                {
                    error = localResult;
                    return ReturnCode.Error;
                }
            }
            finally
            {
                Interlocked.Decrement(ref globalShellMainCoreCount);
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method is [also] specifically for use by alternative shells
        //       (i.e. ones that have no console, etc).  This method assumes that
        //       the interpreter has already been created with the desired options
        //       and that the interpreter host has been set to something with
        //       suitable functionality (i.e. minimally, something that fully
        //       implements the IInteractiveHost interface).
        //
        public static ExitCode ShellMainCore(
            Interpreter interpreter,         /* in */
            IShellCallbackData callbackData, /* in: OPTIONAL */
            IClientData clientData,          /* in: OPTIONAL */
            IEnumerable<string> args,        /* in: OPTIONAL */
            bool initialize,                 /* in */
            bool loop,                       /* in */
            ref Result result                /* in, out */
            ) /* ENTRY-POINT, THREAD-SAFE, RE-ENTRANT */
        {
            Interlocked.Increment(ref globalShellMainCoreCount);

            try
            {
                bool interactive = false;

                return PrivateShellMainCore(
                    interpreter, callbackData, clientData,
                    args, false, ref initialize, ref loop,
                    ref interactive, ref result);
            }
            finally
            {
                Interlocked.Decrement(ref globalShellMainCoreCount);
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Standard Shell Entry Point
#if SHELL
        private static bool IsShellAssemblyActive()
        {
            AssemblyName assemblyName = GlobalState.GetEntryAssemblyName();

            if (assemblyName != null)
            {
                string simpleName = assemblyName.Name;

                if (SharedStringOps.SystemEquals(simpleName, _Assembly.Shell))
                    return true;

                if (SharedStringOps.SystemEquals(simpleName, _Assembly.Kit))
                    return true;
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool IsShellMainActive()
        {
            return Interlocked.CompareExchange(ref globalShellMainCount, 0, 0) > 0;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TEST
        private static ReturnCode MaybeSetupTraceLogFile(
            IEnumerable<string> args,
            ref Result error
            )
        {
            ReturnCode code;
            string fileName = null;

            code = GetStartupLogFileName(
                args, OptionOriginFlags.Shell, true, true,
                ref fileName, ref error);

            if ((code == ReturnCode.Ok) && (fileName != null))
            {
                TraceListener listener = null; /* NOT USED */

                code = DebugOps.SetupTraceLogFile(
                    ShellOps.GetTraceListenerName(null,
                        GlobalState.GetCurrentSystemThreadId()),
                    fileName, null, true, false, false, false,
                    false, ref listener, ref error);
            }

            return code;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ExitCode PrivateShellMain(
            IEnumerable<string> args
            )
        {
            ExitCode exitCode;

            try
            {
                //
                // NOTE: We need return code and a result variable very early on
                //       now for startup log file name, pre-initialize text, and
                //       library path processing.  Later, it is used to capture
                //       the result (or error message) of the shell interpreter
                //       creation operation.
                //
                ReturnCode code = ReturnCode.Ok;
                Result result = null;

#if TEST
                if (code == ReturnCode.Ok) /* REDUNDANT */
                    code = MaybeSetupTraceLogFile(args, ref result);
#endif

                //
                // NOTE: Start with no flags.
                //
                CreateFlags createFlags = CreateFlags.None;
                HostCreateFlags hostCreateFlags = HostCreateFlags.None;
                InitializeFlags initializeFlags = InitializeFlags.None;
                ScriptFlags scriptFlags = ScriptFlags.None;

                if (code == ReturnCode.Ok) /* REDUNDANT? */
                {
                    //
                    // NOTE: Setup the appropriate interpreter creation flags
                    //       for a shell.
                    //
                    createFlags = CreateFlags.CoreShellUse; /* EXEMPT */

                    //
                    // NOTE: Get the effective interpreter creation flags for
                    //       the shell from the environment, etc.
                    //
                    createFlags = GetStartupCreateFlags(
                        args, createFlags, OptionOriginFlags.Shell, true,
                        true);

                    //
                    // NOTE: Setup the appropriate interpreter host creation
                    //       flags for a shell.
                    //
                    hostCreateFlags = HostCreateFlags.CoreShellUse; /* EXEMPT */

                    //
                    // NOTE: Get the effective interpreter creation flags for
                    //       the shell from the environment, etc.
                    //
                    hostCreateFlags = GetStartupHostCreateFlags(
                        args, hostCreateFlags, OptionOriginFlags.Shell,
                        true, true);

                    //
                    // NOTE: Setup the appropriate interpreter initialization
                    //       flags for a shell.
                    //
                    initializeFlags = Defaults.InitializeFlags;

                    //
                    // NOTE: Get the effective interpreter initialization flags
                    //       for the shell from the environment, etc.
                    //
                    initializeFlags = GetStartupInitializeFlags(
                        args, initializeFlags, OptionOriginFlags.Shell,
                        true, true);

                    //
                    // NOTE: Setup the appropriate interpreter script flags
                    //       for a shell.
                    //
                    scriptFlags = Defaults.ScriptFlags;

                    //
                    // NOTE: Get the effective interpreter script flags for
                    //       the shell from the environment, etc.
                    //
                    scriptFlags = GetStartupScriptFlags(
                        args, scriptFlags, OptionOriginFlags.Shell,
                        true, true);
                }

                //
                // NOTE: Start with the default pre-initialize text (i.e.
                //       none).
                //
                string text = null;

                //
                // BUGFIX: If the "ShellPreInitialize" environment variable is
                //         present, pre-scan all the command line arguments for
                //         the pre-initialize script to evaluate.  Otherwise,
                //         this should be skipped to prevent the pre-initialize
                //         script from being evaluated more than once (COMPAT:
                //         Eagle Beta).
                //
                if ((code == ReturnCode.Ok) &&
                    GlobalConfiguration.DoesValueExist(
                        EnvVars.ShellPreInitialize,
                        ConfigurationFlags.InterpreterVerbose))
                {
                    code = GetStartupPreInitializeText(
                        args, createFlags, OptionOriginFlags.Shell, true, true,
                        ref text, ref result);
                }

                //
                // NOTE: Start with the default library path (i.e. automatic).
                //
                string libraryPath = null;

                if (code == ReturnCode.Ok)
                {
                    code = GetStartupLibraryPath(
                        args, createFlags, OptionOriginFlags.Shell, true, true,
                        ref libraryPath, ref result);
                }

                //
                // NOTE: Create an interpreter settings object based on the
                //       context we already have; then, check for a settings
                //       file and allow the settings to be overridden from
                //       it.
                //
                InterpreterSettings interpreterSettings = InterpreterSettings.Create(
                    null, args, createFlags, hostCreateFlags, initializeFlags, scriptFlags,
                    text, libraryPath);

#if XML && SERIALIZATION
                if (code == ReturnCode.Ok)
                {
                    code = InterpreterSettings.LoadFrom(
                        (CultureInfo)null, true, true, true, ref interpreterSettings,
                        ref result);
                }
#endif

                if (code == ReturnCode.Ok)
                {
                    //
                    // NOTE: Create an interpreter now inside of a using block
                    //       so that we can be relatively sure it will be
                    //       finalized on this thread.
                    //
                    using (Interpreter interpreter = Create(
                            interpreterSettings, true, ref result))
                    {
                        //
                        // NOTE: Make sure the interpreter was created.  This
                        //       can (in theory) be a problem if/when the
                        //       ThrowOnError flag ends up getting removed
                        //       somehow prior to the call to actually create
                        //       the interpreter.
                        //
                        if (interpreter != null)
                        {
                            //
                            // NOTE: By default, initialize the script library
                            //       and enter the interactive loop.
                            //
                            bool initialize = true;
                            bool loop = true;

                            //
                            // NOTE: Process all the remaining startup options
                            //       (i.e. the ones that do not modify the
                            //       interpreter creation flags or library path)
                            //       now.
                            //
                            code = ProcessStartupOptions(
                                interpreter, args, createFlags,
                                OptionOriginFlags.Shell, true, true,
                                ref initialize, ref loop, ref result);

                            if (code == ReturnCode.Ok)
                            {
                                exitCode = ShellMainCore(
                                    interpreter, null, null, args,
                                    initialize, loop, ref result);
                            }
                            else
                            {
                                ShellOps.ShellMainCoreError(
                                    interpreter, null, null, code, result);

                                exitCode = ShellOps.ReturnCodeToExitCode(
                                    interpreter, code, true);
                            }
                        }
                        else
                        {
                            //
                            // NOTE: Creation of the interpreter failed.
                            //
                            HostOps.WriteConsoleOrComplain(
                                ReturnCode.Error, result);

                            exitCode = ShellOps.FailureExitCode(interpreter);
                        }
                    }
                }
                else
                {
                    //
                    // NOTE: Library path processing failed.
                    //
                    HostOps.WriteConsoleOrComplain(ReturnCode.Error, result);

                    exitCode = ShellOps.ReturnCodeToExitCode(null, code, true);
                }
            }
            catch (Exception e)
            {
                //
                // WARNING: Top-level unhandled exception handler.
                //          We should never get here.  If we do then
                //          something has gone really wrong and should
                //          be complained about loudly.
                //
                string message = String.Format("UNHANDLED EXCEPTION: {0}", e);

                //
                // NOTE: We cannot rely on the Interpreter now (nor the
                //       IHost contained within it); therefore, output
                //       directly to the console.
                //
                HostOps.WriteConsoleOrComplain(ReturnCode.Error, message);

                //
                // NOTE: Output to trace listeners.
                //
                try
                {
                    DebugOps.TraceWriteLine(message,
                        typeof(Exception).Name); /* EXEMPT */ /* throw */
                }
                catch
                {
                    // do nothing.
                }

                //
                // NOTE: Break into the debugger, if one is attached.
                //
                DebugOps.MaybeBreak(message);

                //
                // NOTE: Re-throw the exception if we have been requested
                //       to do so.
                //
                if (GlobalConfiguration.DoesValueExist(
                        EnvVars.Throw, ConfigurationFlags.Interpreter))
                {
                    throw;
                }

                //
                // TODO: The ability to diagnostic send memory dumps here.
                //
                exitCode = ResultOps.ExceptionExitCode();
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

#if WINFORMS
            if (GlobalState.IsPrimaryThread())
                StatusFormOps.Exit();
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            try
            {
                long[] totalMemory = { 0, 0 };

                ObjectOps.GetTotalMemory(true,
                    ref totalMemory[0], ref totalMemory[1]);

                TraceOps.DebugTrace(String.Format(
                    "PrivateShellMain: exited, exitCode = {0}, " +
                    "totalMemory[0] = {1}, totalMemory[1] = {2}",
                    exitCode, totalMemory[0], totalMemory[1]),
                    typeof(Interpreter).Name, TracePriority.StartupDebug);
            }
            catch (Exception e)
            {
                TraceOps.DebugTrace(
                    e, typeof(Interpreter).Name,
                    TracePriority.StartupError);
            }



            return exitCode;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static ExitCode ShellMain(
            IEnumerable<string> args
            ) /* ENTRY-POINT, THREAD-SAFE, RE-ENTRANT */
        {
            Interlocked.Increment(ref globalShellMainCount);

            try
            {
                return PrivateShellMain(args);
            }
            finally
            {
                Interlocked.Decrement(ref globalShellMainCount);
            }
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interactive Loop Support
        #region Interactive Check-For-Update Support
        internal static void QueryFlagsNoThrow(
            Interpreter interpreter,
            bool debug,
            out EngineFlags engineFlags,
            out SubstitutionFlags substitutionFlags,
            out EventFlags eventFlags,
            out ExpressionFlags expressionFlags
            )
        {
            engineFlags = EngineFlags.None;
            substitutionFlags = SubstitutionFlags.Default;
            eventFlags = EventFlags.Default;
            expressionFlags = ExpressionFlags.Default;

            if (interpreter != null)
            {
                try
                {
                    engineFlags = interpreter.EngineFlags |
                        DebuggerOps.GetEngineFlags(debug);

                    substitutionFlags = interpreter.SubstitutionFlags;
                    eventFlags = interpreter.EngineEventFlags;
                    expressionFlags = interpreter.ExpressionFlags;
                }
                catch (Exception e)
                {
                    TraceOps.DebugTrace(
                        e, typeof(Interpreter).Name,
                        TracePriority.ShellError);
                }
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interactive Debugger Support
#if DEBUGGER
        private EngineFlags BeginDebuggerExecution()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                EngineFlags savedEngineFlags = engineFlags;

                engineFlags |= EngineFlags.DebuggerExecutionMask;

                return savedEngineFlags;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void EndDebuggerExecution(
            EngineFlags savedEngineFlags
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                engineFlags = savedEngineFlags;
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interactive Exit Support
#if SHELL
        private static void CheckExit(
            Interpreter interpreter,
            ref bool exit
            )
        {
            if (interpreter != null)
            {
                lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
                {
                    if (!interpreter.PrivateDisposed)
                    {
                        bool newExit = interpreter.PrivateExit;

                        if (newExit && !exit)
                            exit = newExit;
                    }
                }
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interactive Prompt Support
#if SHELL
        private static void Prompt(
            Interpreter interpreter,
            IInteractiveHost interactiveHost,
            HostFlags hostFlags,
            PromptType type,
            bool trace,
            bool debug,
            bool queue,
            ref bool done
            )
        {
            PromptFlags promptFlags = PromptFlags.None;

            //
            // NOTE: Set the prompt flags based on the parameters specified
            //       by our caller.
            //
            if (debug) promptFlags |= PromptFlags.Debug;
            if (queue) promptFlags |= PromptFlags.Queue;

            //
            // NOTE: We require an interactive host to display a custom prompt
            //       (or even to display a default prompt).
            //
            if (interactiveHost != null)
            {
                ReturnCode code;
                Result error = null;

                //
                // NOTE: Request the host to display some a prompt appropriate
                //       for the specified prompt type and flags.
                //
                try
                {
                    if (FlagOps.HasFlags(hostFlags, HostFlags.Prompt, true))
                    {
                        code = interactiveHost.Prompt(
                            type, ref promptFlags, ref error); /* throw */
                    }
                    else
                    {
                        error = String.Format(
                            HostOps.NoFeatureError, HostFlags.Prompt);

                        code = ReturnCode.Error;
                    }
                }
                catch (Exception e)
                {
                    error = e;
                    code = ReturnCode.Error;
                }

                //
                // NOTE: If tracing is enabled, emit key information about the
                //       success -OR- failure to display the prompt.
                //
                if (trace)
                {
                    TraceOps.DebugTrace(String.Format(
                        "Prompt: code = {0}, flags = {1}, error = {2}",
                        code, FormatOps.WrapOrNull(promptFlags),
                        FormatOps.WrapOrNull(true, true, error)),
                        typeof(Interpreter).Name,
                        TracePriority.HostDebug);
                }

                //
                // NOTE: If the host failed to display some type of prompt,
                //       fallback to an appropriate default prompt now.
                //
                if (!FlagOps.HasFlags(promptFlags, PromptFlags.Done, true))
                {
                    //
                    // NOTE: If available, grab the integer identifier for
                    //       the interpreter as this will help the end users
                    //       to identity which interpreter is emitting the
                    //       prompt.
                    //
                    long id = 0;

                    if (interpreter != null)
                    {
                        id = interpreter.IdNoThrow;

                        if (id > 1) /* HACK: Omit Id for primary. */
                            promptFlags |= PromptFlags.Interpreter;
                    }

                    //
                    // NOTE: Get the appropriate default prompt for this
                    //       situation.
                    //
                    string prompt = HostOps.GetDefaultPrompt(
                        type, promptFlags, id);

                    //
                    // NOTE: If there is a prompt configured and we cannot
                    //       write it, this is considered to be an error
                    //       fatal to the interactive loop.
                    //
                    if ((prompt != null) && !interactiveHost.Write(prompt))
                    {
                        //
                        // NOTE: If we cannot display prompts, there is not
                        //       much point in the interactive loop.
                        //
                        done = true;
                    }
                }
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interactive Input Support
#if SHELL
        private static bool ReadInteractiveInput(
            Interpreter interpreter,
            IInteractiveHost interactiveHost,
            bool trace,
            ref string value,
            ref bool done
            )
        {
            bool result = false;

            if (interactiveHost != null)
            {
                try
                {
                    if (IsReadLineDisabled(interpreter, true))
                    {
                        done = true; /* NOTE: Disabled, we are done. */

                        if (trace)
                        {
                            TraceOps.DebugTrace(
                                "ReadInteractiveInput: disabled",
                                typeof(Interpreter).Name,
                                TracePriority.ThreadError);
                        }
                    }
                    else
                    {
                        lock (staticSyncRoot) /* TRANSACTIONAL */
                        {
                            if ((readValue != null) &&
                                (readValue.Length >= 1))
                            {
                                value = readValue[0]; /* HOOK BEFORE */
                            }
                        }

                        result = interactiveHost.ReadLine(
                            ref value); /* throw */

                        lock (staticSyncRoot) /* TRANSACTIONAL */
                        {
                            if ((readValue != null) &&
                                (readValue.Length >= 2))
                            {
                                readValue[1] = value; /* SAVE AFTER */
                            }
                        }
                    }
                }
                catch (ThreadAbortException)
                {
                    Thread.ResetAbort();

                    done = true; /* NOTE: Aborted, we are done. */

                    if (trace)
                    {
                        TraceOps.DebugTrace(
                            "ReadInteractiveInput: caught thread abort",
                            typeof(Interpreter).Name,
                            TracePriority.ThreadError);
                    }
                }
                catch (ThreadInterruptedException)
                {
                    done = true; /* NOTE: Interrupted, we are done. */

                    if (trace)
                    {
                        TraceOps.DebugTrace(
                            "ReadInteractiveInput: caught thread interrupt",
                            typeof(Interpreter).Name,
                            TracePriority.ThreadError);
                    }
                }
                catch (ObjectDisposedException)
                {
                    done = true; /* NOTE: Host disposed, we are done. */

                    if (trace)
                    {
                        TraceOps.DebugTrace(
                            "ReadInteractiveInput: caught host disposed",
                            typeof(Interpreter).Name,
                            TracePriority.HostError);
                    }
                }
                catch
                {
                    // do nothing.
                }
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This method is private, very specialized, subject to change
        //          at any time, and is really only designed to be called from
        //          within the InteractiveLoop method.  Therefore, use this
        //          method at your own risk.
        //
        private static bool InteractiveIsComplete(
            Interpreter interpreter,             /* in */
            string text,                         /* in */
            int startIndex,                      /* in */
            EngineFlags engineFlags,             /* in */
            SubstitutionFlags substitutionFlags, /* in */
            ref bool notReady,                   /* in, out */
            ref Result error                     /* out */
            )
        {
            //
            // BUGFIX: To avoid recursively entering the interactive loop due
            //         to an active script cancellation flag, make sure that
            //         breakpoints are disabled while the parser is checking
            //         the interactive text.
            //
            EngineFlags localEngineFlags = engineFlags;

#if DEBUGGER
            localEngineFlags |= EngineFlags.NoBreakpoint;
#endif

            return Parser.IsComplete(
                interpreter, null, Parser.StartLine, text, startIndex,
                Length.Invalid, localEngineFlags, substitutionFlags,
                ref notReady, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void AnotherInteractiveInput(
            Interpreter interpreter
            )
        {
            if (interpreter == null)
                return;

            interpreter.TotalInteractiveInputs++; /* THREAD-SAFE */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This method is private, very specialized, subject to change
        //          at any time, and is really only designed to be called from
        //          within the InteractiveLoop method.  Therefore, use this
        //          method at your own risk.
        //
        internal static void GetInteractiveInput(
            Interpreter interpreter,              /* in */
            bool? refresh,                        /* in */
#if INTERACTIVE_COMMANDS
            bool noCommand,                       /* in */
#endif
            bool trace,                           /* in */
            bool debug,                           /* in */
            bool queue,                           /* in */
            EngineFlags engineFlags,              /* in */
            SubstitutionFlags substitutionFlags,  /* in */
            IClientData clientData,               /* in */
            bool forceCancel,                     /* in */
            bool forceHalt,                       /* in */
            ref IInteractiveHost interactiveHost, /* in, out */
            ref string savedText,                 /* in, out */
            ref bool exit,                        /* in, out */
            ref bool done,                        /* in, out */
            ref bool previous,                    /* out */
            out bool canceled,                    /* out */
            out string text,                      /* out */
            out bool notReady,                    /* out */
            out Result parseError                 /* out */
            )
        {
            //
            // NOTE: Keep track of the number of times, per thread, that an
            //       attempt was made to get some interactive input.
            //
            AnotherInteractiveInput(interpreter);

            //
            // NOTE: Grab the host flags now as we need them to determine if
            //       the prompt can and should [always] be displayed.
            //
            HostFlags hostFlags = HostOps.GetHostFlags(interactiveHost);

            //
            // NOTE: Re-fetch the interpreter host in case it has been
            //       externally modified or closed.  Also, make sure it is
            //       still open.  If either of these checks fail or return
            //       false, bail out now.
            //
            bool isOpen = HostOps.IsOpen(
                interpreter, refresh, ref hostFlags, ref interactiveHost);

            //
            // BUGFIX: Verify that the interactive host is still valid and
            //         open.  If not, the rest of this method is basically
            //         useless and we are done.
            //
            if (!isOpen)
            {
                done = true; /* NOTE: Invalid or closed host, we are done. */

                if (trace)
                {
                    TraceOps.DebugTrace(String.Format(
                        "GetInteractiveInput: leaving, host " +
                        "is already invalid or closed, exit = {0}, " +
                        "interactiveHost = {1}, isOpen = {2}",
                        exit, (interactiveHost != null), isOpen),
                        typeof(Interpreter).Name,
                        TracePriority.HostDebug);
                }

                //
                // NOTE: Reset the variables used by our caller (the main
                //       interactive loop).
                //
                canceled = false;
                text = null;
                notReady = false;
                parseError = null;

                return;
            }

            ReturnCode resetCode;
            Result resetError = null;

            //
            // NOTE: We must reset the script cancellation flags if we can
            //       (i.e. if no evals are pending), because the IsComplete
            //       method now relies upon the Ready method prior to the
            //       Engine.Evaluate* method having been called (which would
            //       normally cooperatively reset the script cancellation
            //       flags prior to checking them), which checks the script
            //       cancellation flags.
            //
            bool resetCancel = false;

            resetCode = Engine.ResetCancel(
                interpreter, ShellOps.GetResetCancelFlags(forceCancel),
                ref resetCancel, ref resetError);

            if (resetCode == ReturnCode.Ok)
            {
                if (trace)
                {
                    TraceOps.DebugTrace(String.Format(
                        "GetInteractiveInput: cancel flags {0}",
                        resetCancel ? "reset" : "not reset"),
                        typeof(Interpreter).Name,
                        TracePriority.HostDebug);
                }
            }
            else
            {
                if (trace)
                {
                    TraceOps.DebugTrace(
                        "GetInteractiveInput: failed to reset cancel flags",
                        typeof(Interpreter).Name,
                        TracePriority.EngineError);
                }

                DebugOps.Complain(interpreter, resetCode, resetError);
            }

            //
            // NOTE: We must reset the debugger halt flags if we can (i.e.
            //       if no evals are pending and no other interactive loops
            //       are active), because Parser.IsComplete now relies upon
            //       Interpreter.Ready prior to Engine.Evaluate* having been
            //       called (which would normally cooperatively reset the
            //       debugger halt flags prior to checking them), which checks
            //       the debugger halt flags.
            //
            bool resetHalt = false;

            resetCode = Engine.ResetHalt(
                interpreter, ShellOps.GetResetCancelFlags(forceHalt),
                ref resetHalt, ref resetError);

            if (resetCode == ReturnCode.Ok)
            {
                if (trace)
                {
                    TraceOps.DebugTrace(String.Format(
                        "GetInteractiveInput: halt flags {0}.",
                        resetHalt ? "reset" : "not reset"),
                        typeof(Interpreter).Name,
                        TracePriority.HostDebug);
                }
            }
            else
            {
                if (trace)
                {
                    TraceOps.DebugTrace(
                        "GetInteractiveInput: failed to reset halt flags",
                        typeof(Interpreter).Name,
                        TracePriority.EngineError);
                }

                DebugOps.Complain(interpreter, resetCode, resetError);
            }

            //
            // NOTE: Does the host want to force the prompt to be displayed
            //       even if input has been redirected?  If so, just do it.
            //       Otherwise, check if the host input is NOT currently being
            //       redirected (i.e. we currently have an interactive user)
            //       and then display the prompt prior to requesting any input
            //       from the host.
            //
            if (FlagOps.HasFlags(hostFlags, HostFlags.ForcePrompt, true) ||
                !HostOps.IsInputRedirected(interactiveHost))
            {
                //
                // WARNING: This may end up evaluating a script, if one or
                //          more of the "prompt script" variables are set.
                //          For the duration of the evaluated script, the
                //          script cancellation flags will be ignored.
                //
                Prompt(interpreter, interactiveHost,
                    hostFlags, PromptType.Start, trace, debug, queue,
                    ref done);

                if (done)
                {
                    if (trace)
                    {
                        TraceOps.DebugTrace(
                            "GetInteractiveInput: leaving, done flag was " +
                            "set by start prompt",
                            typeof(Interpreter).Name,
                            TracePriority.HostDebug);
                    }

                    //
                    // NOTE: Reset the variables used by our caller (the main
                    //       interactive loop).
                    //
                    canceled = false;
                    text = null;
                    notReady = false;
                    parseError = null;

                    return;
                }
            }

            //
            // NOTE: Check if the debugger is set to enter the interactive loop
            //       upon script cancellation.
            //
            bool breakOnCancel =
                DebuggerOps.GetBreakOnCancel(interpreter, false);

            //
            // NOTE: Reset the variables used by our caller (the main
            //       interactive loop).
            //
            canceled = false;
            text = String.Empty; // NOTE: Cannot be null.
            notReady = breakOnCancel; // NOTE: Bypass readiness?
            parseError = null;

            //
            // NOTE: This is the starting index used for the call to the parser
            //       to check if the input is complete.  This value should be
            //       just past the interactive command indicator, if present;
            //       otherwise, it should be zero.
            //
            int startIndex;

            do
            {
                //
                // NOTE: Re-grab the host flags now as they may have changed
                //       (?) and we need them to determine if the prompt can
                //       and should [always] be displayed.
                //
                hostFlags = HostOps.GetHostFlags(interactiveHost);

                //
                // NOTE: Was there a parser error just now when we checked if
                //       the input text was a complete command?
                //
                if (parseError != null)
                {
                    if (trace)
                    {
                        TraceOps.DebugTrace(String.Format(
                            "GetInteractiveInput: incomplete input, " +
                            "parseError = {0}",
                            FormatOps.WrapOrNull(parseError)),
                            typeof(Interpreter).Name,
                            TracePriority.HostDebug);
                    }

                    //
                    // NOTE: Does this host support multiple-line input?
                    //
                    if (FlagOps.HasFlags(
                            hostFlags, HostFlags.MultipleLineInput, true))
                    {
                        if (trace)
                        {
                            TraceOps.DebugTrace(
                                "GetInteractiveInput: multiple-line " +
                                "input is supported, setting canceled " +
                                "flag...", typeof(Interpreter).Name,
                                TracePriority.HostDebug);
                        }

                        //
                        // NOTE: For hosts that support multiple-line input,
                        //       we will not accept any incomplete input.
                        //       Therefore, bail out now with an "error" (i.e.
                        //       or at least our closest approximation of one).
                        //
                        canceled = true;

                        break;
                    }

                    //
                    // NOTE: In the event of a parser error (i.e. if the line
                    //       entered does not represent a complete command)
                    //       display the error in the host title.
                    //
                    /* IGNORED */
                    HostOps.SetTitle(interactiveHost, String.Format(
                        "incomplete: {0}", parseError));

                    /* IGNORED */
                    // HostOps.WriteLine(interactiveHost,
                    //     String.Format("incomplete: {0}", parseError));

                    parseError = null;
                }

                //
                // NOTE: Re-check if the host input is being redirected (i.e.
                //       we do not have an interactive user) then display the
                //       input continuation prompt if necessary prior to
                //       requesting more input from the host.
                //
                bool redirected = HostOps.IsInputRedirected(interactiveHost);

                if (!String.IsNullOrEmpty(text) && (!redirected ||
                    FlagOps.HasFlags(hostFlags, HostFlags.ForcePrompt, true)))
                {
                    //
                    // WARNING: This may end up evaluating a script, if one or
                    //          more of the "prompt script" variables are set.
                    //          For the duration of the evaluated script, the
                    //          script cancellation flags will be ignored.
                    //
                    Prompt(interpreter, interactiveHost,
                        hostFlags, PromptType.Continue, trace, debug, queue,
                        ref done);

                    if (done)
                    {
                        if (trace)
                        {
                            TraceOps.DebugTrace(
                                "GetInteractiveInput: leaving, done flag " +
                                "was set by continue prompt",
                                typeof(Interpreter).Name,
                                TracePriority.HostDebug);
                        }

                        //
                        // NOTE: Reset the variables used by our caller (the
                        //       main interactive loop).
                        //
                        canceled = false;
                        text = null;
                        notReady = false;
                        parseError = null;

                        return;
                    }
                }

                string line = null; // NOTE: Current input line.
                int length; // NOTE: Length of the current input line.

                //
                // NOTE: Check and see if the previous iteration of the primary
                //       loop saved some input for us to use.  If so, use it
                //       and set the saved input to null.
                //
                if (!String.IsNullOrEmpty(savedText))
                {
                    line = savedText;
                    savedText = null;

                    length = line.Length;

                    if (trace)
                    {
                        TraceOps.DebugTrace(String.Format(
                            "GetInteractiveInput: using saved input " +
                            "containing {0} characters...",
                            length), typeof(Interpreter).Name,
                            TracePriority.HostDebug);
                    }
                }

                //
                // NOTE: Is the current line of input still null (i.e. there
                //       was no saved input to use)?
                //
                if (line == null)
                {
                    //
                    // NOTE: Check and see if the debugger has command input
                    //       injected via the [debug icommand] sub-command for
                    //       us to use.
                    //
                    line = DebuggerOps.GetCommand(interpreter, false);

                    if (line != null)
                    {
                        length = line.Length;

                        if (trace)
                        {
                            TraceOps.DebugTrace(String.Format(
                                "GetInteractiveInput: injecting line " +
                                "of input from debugger containing {0} " +
                                "characters...",
                                length), typeof(Interpreter).Name,
                                TracePriority.HostDebug);
                        }
                    }
                }

                //
                // NOTE: Are we processing input injected via saved input text
                //       or the debugger?
                //
                if (!String.IsNullOrEmpty(line))
                {
                    //
                    // NOTE: Prevent this command from being used [again?] as
                    //       the previous interactive input and disable the
                    //       ability to use the "again" command.
                    //
                    previous = false;

                    //
                    // NOTE: Simulate the command having been entered via the
                    //       host.
                    //
                    /* IGNORED */
                    HostOps.WriteLine(interactiveHost, line);
                }

                //
                // NOTE: Has the request for input been canceled by the host
                //       (i.e. either a null line was returned and no input
                //       redirection is in use OR the ReadLine method returned
                //       false).
                //
                bool cancel = false;

                //
                // NOTE: Get a line of input from the host, if necessary (i.e.
                //       we do not already have a command injected via the
                //       debugger, etc).
                //
                if (!String.IsNullOrEmpty(line) || ReadInteractiveInput(
                        interpreter, interactiveHost, trace, ref line,
                        ref done))
                {
                    if (line != null) /* more input? */
                    {
                        length = line.Length;

                        if (trace)
                        {
                            TraceOps.DebugTrace(String.Format(
                                "GetInteractiveInput: read line of " +
                                "input containing {0} characters",
                                length), typeof(Interpreter).Name,
                                TracePriority.HostDebug);
                        }

                        if (length > 0)
                            text += line + Characters.NewLine;
                        else
                            text += Characters.NewLine;

                        SetInteractiveInput(interpreter, text);
                    }
                    else if (redirected)
                    {
                        if (trace)
                        {
                            TraceOps.DebugTrace(
                                "GetInteractiveInput: read null " +
                                "line of redirected input, setting exit " +
                                "flag...",
                                typeof(Interpreter).Name,
                                TracePriority.HostDebug);
                        }

                        //
                        // NOTE: It looks like console input is being
                        //       redirected and we have run out of it;
                        //       therefore, bail out of the interactive
                        //       loop now.
                        //
                        exit = true;
                    }
                    else
                    {
                        if (FlagOps.HasFlags(
                                hostFlags, HostFlags.TreatMissingLineAsEof, true))
                        {
                            if (trace)
                            {
                                TraceOps.DebugTrace(
                                    "GetInteractiveInput: read null " +
                                    "line of input, setting exit " +
                                    "flag...",
                                    typeof(Interpreter).Name,
                                    TracePriority.HostDebug);
                            }

                            exit = true;
                        }
                        else
                        {
                            if (trace)
                            {
                                TraceOps.DebugTrace(
                                    "GetInteractiveInput: read null " +
                                    "line of input, setting cancel " +
                                    "flag...",
                                    typeof(Interpreter).Name,
                                    TracePriority.HostDebug);
                            }

                            //
                            // NOTE: The ReadLine method returned true;
                            //       however, the actual input line is
                            //       null and input is (probably?) not
                            //       being redirected.  Therefore, just
                            //       assume the user has canceled the
                            //       input request.
                            //
                            cancel = true;
                        }
                    }
                }
                else if (done)
                {
                    if (trace)
                    {
                        TraceOps.DebugTrace(
                            "GetInteractiveInput: leaving, aborted " +
                            "while reading line of input...",
                            typeof(Interpreter).Name,
                            TracePriority.HostDebug);
                    }

                    //
                    // NOTE: The ReadLine method has returned false
                    //       and the done flag is set; therefore, we
                    //       were aborted by another thread while
                    //       reading input.
                    //
                    break;
                }
                else if (redirected)
                {
                    if (trace)
                    {
                        TraceOps.DebugTrace(
                            "GetInteractiveInput: failed to read line " +
                            "of redirected input, setting exit flag...",
                            typeof(Interpreter).Name,
                            TracePriority.HostDebug);
                    }

                    exit = true;
                }
                else
                {
                    if (FlagOps.HasFlags(
                            hostFlags, HostFlags.TreatMissingLineAsEof, true))
                    {
                        if (trace)
                        {
                            TraceOps.DebugTrace(
                                "GetInteractiveInput: failed to read line " +
                                "of input, setting exit flag...",
                                typeof(Interpreter).Name,
                                TracePriority.HostDebug);
                        }

                        exit = true;
                    }
                    else
                    {
                        if (trace)
                        {
                            TraceOps.DebugTrace(
                                "GetInteractiveInput: failed to read line " +
                                "of input, setting cancel flag...",
                                typeof(Interpreter).Name,
                                TracePriority.HostDebug);
                        }

                        //
                        // NOTE: The ReadLine method has returned false;
                        //       therefore, assume the input request was
                        //       canceled by the user.
                        //
                        cancel = true;
                    }
                }

                //
                // NOTE: Re-grab the host flags now as they may have changed
                //       during a host read (?) and we need them to determine
                //       if the host is still open.
                //
                hostFlags = HostOps.GetHostFlags(interactiveHost);

                //
                // NOTE: Re-fetch the interpreter host in case it has been
                //       externally modified or closed.  Also, make sure it is
                //       still open.  If either of these checks fail or return
                //       false, bail out now.
                //
                isOpen = HostOps.IsOpen(
                    interpreter, refresh, ref hostFlags, ref interactiveHost);

                //
                // NOTE: Make sure that we exit if the [exit] command was used.
                //       This is needed because another thread may have set the
                //       exit flag for the interpreter while we were waiting
                //       for input.
                //
                CheckExit(interpreter, ref exit);

                //
                // NOTE: Did the interpreter exit while we were reading (or was
                //       the host invalidated, perhaps by Dispose)?
                //
                if (exit || !isOpen)
                {
                    done = true; /* NOTE: Async exit, we are done. */

                    if (trace)
                    {
                        TraceOps.DebugTrace(String.Format(
                            "GetInteractiveInput: leaving, exit = {0}, " +
                            "interactiveHost = {1}, isOpen = {2}",
                            exit, (interactiveHost != null), isOpen),
                            typeof(Interpreter).Name,
                            TracePriority.HostDebug);
                    }

                    break;
                }
                //
                // NOTE: Was input canceled while we were reading?
                //
                else if (cancel)
                {
                    if (trace)
                    {
                        TraceOps.DebugTrace(
                            "GetInteractiveInput: leaving, input was " +
                            "canceled...", typeof(Interpreter).Name,
                            TracePriority.HostDebug);
                    }

                    /* IGNORED */
                    HostOps.WriteLine(interactiveHost, null);
                    canceled = true; /* skip command processing */

                    break;
                }
                else if (StringOps.IsLogicallyEmpty(text))
                {
                    if (trace)
                    {
                        TraceOps.DebugTrace(
                            "GetInteractiveInput: leaving, null or empty " +
                            "input...", typeof(Interpreter).Name,
                            TracePriority.HostDebug);
                    }

                    break;
                }

                //
                // NOTE: Figure out if this looks like an interactive command;
                //       if so, start checking if the input is complete at the
                //       character just after the interactive command prefix;
                //       otherwise, start at index zero.
                //
                startIndex = 0;

                /* IGNORED */
                ShellOps.LooksLikeAnyInteractiveCommand(text, ref startIndex);

                //
                // NOTE: Finally, see if the input is complete enough to return
                //       to the caller -OR- if we are done processing for some
                //       other reason (i.e. user canceled).
                //
            } while (StringOps.IsLogicallyEmpty(text) ||
                     !InteractiveIsComplete(interpreter, text, startIndex,
                            engineFlags, substitutionFlags, ref notReady,
                            ref parseError) &&
                     !notReady);

            //
            // NOTE: Make sure that we have not exited and that the host is
            //       still valid and open.
            //
            if (!done)
            {
                /* IGNORED */
                HostOps.SetTitle(interactiveHost, null);

                if (notReady)
                {
#if INTERACTIVE_COMMANDS
                    //
                    // NOTE: If this is an interactive debugger command, fake
                    //       the interpreter being "ready" (at least as far as
                    //       input validation goes) because we need to give the
                    //       user the opportunity to reset the script
                    //       cancellation flag, etc.
                    //
                    if (!noCommand && InteractiveOps.CheckCommand(
                            interpreter, text, null, clientData, true, false,
                            false))
                    {
                        if (trace)
                        {
                            TraceOps.DebugTrace(
                                "GetInteractiveInput: input looks like an " +
                                "interactive command, interpreter readiness " +
                                "faked", typeof(Interpreter).Name,
                                TracePriority.HostDebug);
                        }

                        notReady = false;
                    }
                    else // NOTE: Dangling else (see "if" statement below).
#endif
                    if (!breakOnCancel)
                    {
                        //
                        // NOTE: Show the user why the interpreter is not ready.
                        //
                        /* IGNORED */
                        HostOps.WriteResultLine(interactiveHost,
                            ReturnCode.Error, String.Format(
                                "interpreter not ready: {0}", parseError));
                    }
                }
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interactive Command Support
#if SHELL
        private void QueryInteractiveLoopFlags(
            out EngineFlags localEngineFlags,
            out SubstitutionFlags localSubstitutionFlags,
            out EventFlags localEventFlags,
            out ExpressionFlags localExpressionFlags
            )
        {
            bool locked = false;

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    localEngineFlags = this.EngineFlagsNoLock; /* PROPERTY */

                    localSubstitutionFlags = this.substitutionFlags;
                    localEventFlags = this.engineEventFlags;
                    localExpressionFlags = this.expressionFlags;
                }
                else
                {
                    localEngineFlags = EngineFlags.None;
                    localSubstitutionFlags = SubstitutionFlags.Default;
                    localEventFlags = EventFlags.Default;
                    localExpressionFlags = ExpressionFlags.Default;

                    TraceOps.DebugTrace(
                        "QueryInteractiveLoopFlags: unable to acquire lock",
                        typeof(Interpreter).Name, TracePriority.LockWarning);
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL && INTERACTIVE_COMMANDS
        #region GC Test Thread Support
        private bool HasTestGcThread(
            bool mustBeAlive
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                Thread localThread = testGcThread;

                return (localThread != null) &&
                    (!mustBeAlive || localThread.IsAlive);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void TestGcThreadStart( /* THREAD-SAFE */
            object obj /* NOT USED */
            ) /* System.Threading.ParameterizedThreadStart */
        {
            bool verbose = false;

            try
            {
                IAnyPair<Interpreter, bool> anyPair =
                    obj as IAnyPair<Interpreter, bool>;

                if (anyPair != null)
                    verbose = anyPair.Y;

                while (true)
                {
                    //
                    // NOTE: Force a full garbage collection now.
                    //
                    ObjectOps.CollectGarbage(); /* throw */

                    //
                    // NOTE: Wait a while before trying again.
                    //
                    if (HostOps.ThreadSleepOrMaybeComplain(
                            testGcSleepTime, false) != ReturnCode.Ok)
                    {
                        break;
                    }
                }
            }
            catch (ThreadAbortException e)
            {
                Thread.ResetAbort();

                if (verbose)
                {
                    TraceOps.DebugTrace(
                        e, typeof(Interpreter).Name,
                        TracePriority.ThreadError);
                }
            }
            catch (ThreadInterruptedException e)
            {
                if (verbose)
                {
                    TraceOps.DebugTrace(
                        e, typeof(Interpreter).Name,
                        TracePriority.ThreadError);
                }
            }
            catch (Exception e)
            {
                if (verbose)
                {
                    TraceOps.DebugTrace(
                        e, typeof(Interpreter).Name,
                        TracePriority.ThreadError);
                }

                throw;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode StartTestGcThread(
            bool mustBeAlive,
            bool verbose,
            bool strictStart,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                Thread localThread = testGcThread;

                if ((localThread == null) ||
                    (mustBeAlive && !localThread.IsAlive))
                {
                    bool success = false;

                    try
                    {
                        localThread = Engine.CreateThread(
                            this, TestGcThreadStart,
                            0, false, false, true);

                        if (localThread != null)
                        {
                            localThread.Name = String.Format(
                                "testGcThread: {0}",
                                FormatOps.InterpreterNoThrow(
                                    this)); /* throw */

                            localThread.Start(
                                new AnyPair<Interpreter, bool>(
                                    this, verbose)); /* throw */

                            testGcThread = localThread;
                            success = true;

                            result = "created and started garbage collection test thread";
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            result = "could not create garbage collection test thread";
                        }
                    }
                    catch (Exception e)
                    {
                        result = String.Format(
                            "failed to start garbage collection test thread, " +
                            "caught exception \"{0}\"",
                            e);
                    }
                    finally
                    {
                        if (!success && (localThread != null))
                        {
                            try
                            {
                                localThread.Interrupt(); /* throw */
                                localThread = null;
                            }
                            catch (Exception e)
                            {
                                TraceOps.DebugTrace(
                                    e, typeof(Interpreter).Name,
                                    TracePriority.ThreadError);
                            }
                        }
                    }
                }
                else
                {
                    result = "garbage collection test thread already started";

                    //
                    // NOTE: This is not really always an error due to nested
                    //       interactive loops.
                    //
                    if (!strictStart)
                        return ReturnCode.Ok;
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode InterruptTestGcThread(
            int? timeout,
            bool noAbort,
            bool strictStop,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                Thread localThread = testGcThread;

                if (localThread != null)
                {
                    try
                    {
                        if (localThread.IsAlive)
                        {
                            localThread.Interrupt();

                            int localTimeout;

                            if (timeout != null)
                                localTimeout = (int)timeout;
                            else
                                localTimeout = ThreadOps.DefaultJoinTimeout;

                            if (!localThread.Join(localTimeout))
                            {
                                if (noAbort)
                                {
                                    result = String.Format(
                                        "failed to join garbage collection " +
                                        "test thread after {0} milliseconds",
                                        localTimeout);

                                    return ReturnCode.Error;
                                }
                                else
                                {
                                    /* BUGBUG: Leaks? */
                                    localThread.Abort(); /* throw */

                                    result = "aborted garbage collection test thread";
                                }
                            }
                            else
                            {
                                result = "interrupted garbage collection test thread";
                            }

                            testGcThread = null; /* NOTE: Joined (?) */
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            testGcThread = null; /* NOTE: Dead. */
                            result = "garbage collection test thread is not alive";

                            //
                            // NOTE: This is not really always an error
                            //       due to subtle timing issues.
                            //
                            if (!strictStop)
                                return ReturnCode.Ok;
                        }
                    }
                    catch (Exception e)
                    {
                        result = String.Format(
                            "failed to interrupt garbage collection test thread, " +
                            "caught exception \"{0}\"",
                            e);
                    }
                }
                else
                {
                    result = "garbage collection test thread already stopped";

                    //
                    // NOTE: This is not really always an error due to nested
                    //       interactive loops.
                    //
                    if (!strictStop)
                        return ReturnCode.Ok;
                }

                return ReturnCode.Error;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void QueryInteractiveFlagsAndLimits(
            out EngineFlags engineFlags,
            out bool interactiveCommandsEnabled,
            out EngineFlags interactiveEngineFlags,
            out SubstitutionFlags interactiveSubstitutionFlags,
            out EventFlags interactiveEventFlags,
            out ExpressionFlags interactiveExpressionFlags
#if RESULT_LIMITS
            , out int interactiveExecuteResultLimit
            , out int interactiveNestedResultLimit
#endif
            )
        {
            bool locked = false;

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    engineFlags = this.EngineFlagsNoLock; /* PROPERTY */

                    interactiveCommandsEnabled = this.interactiveCommandsEnabled;

                    interactiveEngineFlags = this.interactiveEngineFlags;
                    interactiveSubstitutionFlags = this.interactiveSubstitutionFlags;
                    interactiveEventFlags = this.interactiveEventFlags;
                    interactiveExpressionFlags = this.interactiveExpressionFlags;

#if RESULT_LIMITS
                    interactiveExecuteResultLimit = this.executeResultLimit;
                    interactiveNestedResultLimit = this.nestedResultLimit;
#endif
                }
                else
                {
                    InteractiveOps.ResetFlagsAndLimits(
                        this, out engineFlags, out interactiveCommandsEnabled,
                        out interactiveEngineFlags, out interactiveSubstitutionFlags,
                        out interactiveEventFlags, out interactiveExpressionFlags
#if RESULT_LIMITS
                        , out interactiveExecuteResultLimit
                        , out interactiveNestedResultLimit
#endif
                    );

                    TraceOps.DebugTrace(
                        "QueryInteractiveFlags: unable to acquire lock",
                        typeof(Interpreter).Name,
                        TracePriority.LockWarning);
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interactive Script Cancellation Support
#if CONSOLE
        private static bool ShouldHandleConsoleCancelEvent(
            object sender, /* NOT USED */
            ConsoleCancelEventArgs e
            )
        {
            return (e == null) || !e.Cancel;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void MaybeSetConsoleEventArgsCancelFlag(
            object sender, /* NOT USED */
            ConsoleCancelEventArgs e
            )
        {
            //
            // NOTE: Prevent default event handling (which would terminate
            //       the process); however, we cannot prevent Ctrl-Break
            //       from terminating the process (only Ctrl-C).
            //
            if ((e != null) && !e.Cancel &&
                (e.SpecialKey == ConsoleSpecialKey.ControlC))
            {
                e.Cancel = true;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void BeginNoConsoleCancelEventHandler(
            ref int savedCancelViaConsole
            )
        {
            savedCancelViaConsole = Interlocked.Exchange(
                ref cancelViaConsole[0], 1 /* IGNORE */);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void EndNoConsoleCancelEventHandler(
            ref int savedCancelViaConsole
            )
        {
            /* IGNORED */
            Interlocked.Exchange(
                ref cancelViaConsole[0], savedCancelViaConsole);

            savedCancelViaConsole = 0;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void ConsoleCancelEventHandler(
            object sender,
            ConsoleCancelEventArgs e
            ) /* THREAD-SAFE */
        {
            //
            // NOTE: Is script cancellation via the console Ctrl-C handler
            //       actually enabled right now?
            //
            int localCancelViaConsoleSetting = Interlocked.CompareExchange(
                ref cancelViaConsole[0], 0, 0);

            //
            // NOTE: Increment the number of times this static event handler
            //       has been triggered.
            //
            int localCancelViaConsoleCount = Interlocked.Increment(
                ref cancelViaConsole[1]);

            //
            // NOTE: Is the event handler totally disabled?
            //
            if (localCancelViaConsoleSetting <= 0)
            {
                TraceOps.DebugTrace(String.Format(
                    "ConsoleCancelEventHandler: disabled, sender = {0}, " +
                    "e = {1}, cancelCount = {2}, cancelSetting = {3}, " +
                    "dateTime = {4}", FormatOps.WrapOrNull(sender),
                    FormatOps.WrapOrNull(e), localCancelViaConsoleCount,
                    localCancelViaConsoleSetting, FormatOps.Iso8601DateTime(
                    TimeOps.GetNow())), typeof(Interpreter).Name,
                    TracePriority.HostDebug);

                //
                // HACK: *SPECIAL* Just let the process die, in order to
                //       cooperate better with shells and other software
                //       that uses the shell in batch mode.
                //
                // MaybeSetConsoleEventArgsCancelFlag(sender, e);
                //
                return;
            }

            //
            // NOTE: Is script cancellation via the console disabled?
            //
            if (localCancelViaConsoleSetting == 1)
            {
                TraceOps.DebugTrace(String.Format(
                    "ConsoleCancelEventHandler: ignored, sender = {0}, " +
                    "e = {1}, cancelCount = {2}, cancelSetting = {3}, " +
                    "dateTime = {4}", FormatOps.WrapOrNull(sender),
                    FormatOps.WrapOrNull(e), localCancelViaConsoleCount,
                    localCancelViaConsoleSetting, FormatOps.Iso8601DateTime(
                    TimeOps.GetNow())), typeof(Interpreter).Name,
                    TracePriority.HostDebug);

                MaybeSetConsoleEventArgsCancelFlag(sender, e);
                return;
            }

            //
            // NOTE: If we get to this point, that means script cancellation
            //       via the console is enabled.
            //
            TraceOps.DebugTrace(String.Format(
                "ConsoleCancelEventHandler: entered, sender = {0}, " +
                "e = {1}, cancelCount = {2}, cancelSetting = {3}, " +
                "dateTime = {4}", FormatOps.WrapOrNull(sender),
                FormatOps.WrapOrNull(e), localCancelViaConsoleCount,
                localCancelViaConsoleSetting, FormatOps.Iso8601DateTime(
                TimeOps.GetNow())), typeof(Interpreter).Name,
                TracePriority.HostDebug);

            //
            // NOTE: Cancel all currently running scripts in all threads.  Only
            //       handle the first event generated by the Ctrl-C.
            //
            int count = Count.Invalid - 1; /* -2 */

            if (ShouldHandleConsoleCancelEvent(sender, e))
            {
                count = AllCancelAnyEvaluate(true);
                MaybeSetConsoleEventArgsCancelFlag(sender, e);
            }

            TraceOps.DebugTrace(String.Format(
                "ConsoleCancelEventHandler: exited, sender = {0}, " +
                "e = {1}, cancelCount = {2}, cancelSetting = {3}, " +
                "dateTime = {4}, interpCount = {5}",
                FormatOps.WrapOrNull(sender), FormatOps.WrapOrNull(e),
                localCancelViaConsoleCount, localCancelViaConsoleSetting,
                FormatOps.Iso8601DateTime(TimeOps.GetNow()), count),
                typeof(Interpreter).Name, TracePriority.HostDebug);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void CancelAnyEvaluate(
            Interpreter interpreter,
            CancelFlags cancelFlags
            )
        {
            if (interpreter == null)
                return;

            try
            {
                ReturnCode code;
                Result error = null;

                code = interpreter.InternalCancelAnyEvaluateNoContext(
                    demandCancelResultFormat, cancelFlags, ref error);

                if ((code != ReturnCode.Ok) && !FlagOps.HasFlags(
                        cancelFlags, CancelFlags.NoComplain, true))
                {
                    DebugOps.Complain(interpreter, code, error);
                }
            }
            catch (InterpreterDisposedException)
            {
                //
                // NOTE: The interpreter is disposed, do nothing.
                //
                TraceOps.DebugTrace(String.Format(
                    "CancelAnyEvaluate: interpreter = {0}, caught " +
                    "InterpreterDisposedException",
                    FormatOps.InterpreterNoThrow(interpreter)),
                    typeof(Interpreter).Name,
                    TracePriority.EngineError);
            }
            finally
            {
                //
                // BUGFIX: Cleanup any stray contexts that were created
                //         on this [random thread-pool] thread?
                //
                /* IGNORED */
                interpreter.MaybeDisposeThread();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void CancelAnyEvaluate(
            InterpreterDictionary interpreters,
            CancelFlags cancelFlags
            )
        {
            if (interpreters == null)
                return;

            foreach (KeyValuePair<string, Interpreter> pair in interpreters)
            {
                Interpreter interpreter = pair.Value;

                if (interpreter == null)
                    continue;

                CancelAnyEvaluate(interpreter, cancelFlags);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static int AllCancelAnyEvaluate(
            bool global
            )
        {
            InterpreterDictionary interpreters = GlobalState.GetInterpreters();

            if (interpreters == null)
                return Count.Invalid;

            CancelFlags cancelFlags = RuntimeOps.GetCancelEvaluateFlags(
                global, true, true, false, true, false);

            cancelFlags |= CancelFlags.InteractiveCancelEvent;

#if CONSOLE
            bool cancelThread = Interlocked.CompareExchange(
                ref cancelThreadViaConsole, 0, 0) > 0;

            if (cancelThread)
                cancelFlags |= CancelFlags.InteractiveCancelThread;
#endif

            int count = 0;

            foreach (KeyValuePair<string, Interpreter> pair
                    in interpreters)
            {
                Interpreter interpreter = pair.Value;

                if (interpreter == null)
                    continue;

                CancelAnyEvaluate(interpreter, cancelFlags);

                count++;

                InterpreterDictionary childInterpreters =
                    interpreter.TryCopyChildInterpreters();

                if (childInterpreters == null)
                    continue;

                CancelAnyEvaluate(childInterpreters, cancelFlags);

                count += childInterpreters.Count;
            }

            return count;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Health Thread Support
        private bool HasHealthThread(
            bool mustBeAlive
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                Thread localThread = healthThread;

                return (localThread != null) &&
                    (!mustBeAlive || localThread.IsAlive);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private EventWaitHandle InitializeHealthEvent()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (healthEvent == null)
                    healthEvent = new ManualResetEvent(false);

                return healthEvent;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void CloseHealthEvent()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (healthEvent != null)
                {
                    healthEvent.Close();
                    healthEvent = null;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private double? SecondsSinceLastHealthCheck()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (lastHealthCheck == null)
                    return null;

                return TimeOps.GetUtcNow().Subtract(
                    (DateTime)lastHealthCheck).TotalSeconds;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void TouchLastHealthCheck()
        {
            lock (syncRoot)
            {
                lastHealthCheck = TimeOps.GetUtcNow();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void HealthThreadStart( /* THREAD-SAFE */
            object obj
            ) /* System.Threading.ParameterizedThreadStart */
        {
            DateTime now = TimeOps.GetUtcNow();

            try
            {
                IAnyTriplet<Interpreter, int, EventWaitHandle> anyTriplet =
                    obj as IAnyTriplet<Interpreter, int, EventWaitHandle>;

                if (anyTriplet != null)
                {
                    Interpreter interpreter = anyTriplet.X;
                    int timeout = anyTriplet.Y;
                    EventWaitHandle @event = anyTriplet.Z;

                    if (interpreter != null)
                    {
                        if (timeout < 0)
                        {
                            //
                            // HACK: Use the default event timeout
                            //       since waiting forever in this
                            //       method is somewhat useless.
                            //
                            timeout = ThreadOps.GetDefaultTimeout(
                                TimeoutType.Event);
                        }

                        int totalTimeout = 0;

                        while (true)
                        {
                            /* NO RESULT */
                            interpreter.RunHealthChecks(totalTimeout);

                            if (@event != null)
                            {
                                if (ThreadOps.WaitEventOrThrow(
                                        @event, timeout))
                                {
                                    //
                                    // NOTE: The event was signaled;
                                    //       this thread must exit.
                                    //
                                    TraceOps.DebugTrace(
                                        "HealthThreadStart: STOP SIGNAL",
                                        typeof(Interpreter).Name,
                                        TracePriority.ThreadDebug3);

                                    break;
                                }
                                else
                                {
                                    //
                                    // NOTE: Timeout was hit while
                                    //       waiting for the event.
                                    //
                                    totalTimeout += timeout;
                                    continue;
                                }
                            }

                            Exception exception = null;

                            if (HostOps.ThreadSleep(
                                    timeout, ref exception) == ReturnCode.Ok)
                            {
                                //
                                // NOTE: Ok, just keep track.
                                //
                                totalTimeout += timeout;
                            }
                            else if (exception is ThreadInterruptedException)
                            {
                                //
                                // NOTE: Attempted thread interrupt,
                                //       bail now.
                                //
                                break;
                            }
                            else
                            {
                                TraceOps.DebugTrace(
                                    exception, typeof(Interpreter).Name,
                                    TracePriority.ThreadError);
                            }
                        }
                    }
                    else
                    {
                        TraceOps.DebugTrace(
                            "HealthThreadStart: INVALID INTERPRETER",
                            typeof(Interpreter).Name,
                            TracePriority.ThreadDebug3);
                    }
                }
                else
                {
                    TraceOps.DebugTrace(
                        "HealthThreadStart: INVALID THREAD ARGUMENT",
                        typeof(Interpreter).Name,
                        TracePriority.ThreadDebug3);
                }
            }
            catch (ThreadAbortException)
            {
                Thread.ResetAbort();
            }
            catch (ThreadInterruptedException)
            {
                // do nothing.
            }
            finally
            {
                TraceOps.DebugTrace(String.Format(
                    "HealthThreadStart: TIME {0}",
                    TimeOps.GetUtcNow().Subtract(now)),
                    typeof(Interpreter).Name,
                    TracePriority.ThreadDebug);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode StartHealthThread(
            int? timeout,
            bool forceStart,
            bool mustBeAlive,
            bool strictStart,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // NOTE: If there is not health we do not bother starting the
                //       dedicated script cancellation thread unless we are
                //       forced to by the caller.
                //
                int localTimeout;

                if (timeout != null)
                    localTimeout = (int)timeout;
                else
                    localTimeout = InternalTimeout; /* PROPERTY */

                if (forceStart ||
                    (localTimeout != _Timeout.Infinite))
                {
                    EventWaitHandle localEvent = InitializeHealthEvent();

                    if (localEvent != null)
                        ThreadOps.ResetEvent(localEvent);

                    Thread localThread = healthThread;

                    if ((localThread == null) ||
                        (mustBeAlive && !localThread.IsAlive))
                    {
                        bool success = false;

                        try
                        {
                            localThread = Engine.CreateThread(
                                this, HealthThreadStart,
                                0, false, false, true);

                            if (localThread != null)
                            {
                                localThread.Name = String.Format(
                                    "healthThread: {0}",
                                    FormatOps.InterpreterNoThrow(
                                        this)); /* throw */

                                localThread.Start(
                                    new AnyTriplet<Interpreter, int, EventWaitHandle>(
                                        this, localTimeout, localEvent)); /* throw */

                                healthThread = localThread;
                                success = true;

                                result = "created and started health thread";
                                return ReturnCode.Ok;
                            }
                            else
                            {
                                result = "could not create health thread";
                            }
                        }
                        catch (Exception e)
                        {
                            result = String.Format(
                                "failed to start health thread, caught exception: {0}",
                                e);
                        }
                        finally
                        {
                            if (!success && (localThread != null))
                            {
                                try
                                {
                                    localThread.Interrupt(); /* throw */
                                    localThread = null;
                                }
                                catch (Exception e)
                                {
                                    TraceOps.DebugTrace(
                                        e, typeof(Interpreter).Name,
                                        TracePriority.ThreadError);
                                }
                            }
                        }
                    }
                    else
                    {
                        result = "health thread already started";

                        //
                        // NOTE: This is not really always an error
                        //       due to nested interactive loops.
                        //
                        if (!strictStart)
                            return ReturnCode.Ok;
                    }
                }
                else
                {
                    //
                    // NOTE: Skipped, we were not forced to start the
                    //       health thread and there is no health set.
                    //
                    result = "skipped checking health thread";

                    return ReturnCode.Ok;
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode InterruptHealthThread(
            int? timeout,
            bool noAbort,
            bool strictStop,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                bool signaled = false;
                EventWaitHandle localEvent = InitializeHealthEvent();

                if (localEvent != null)
                    signaled = ThreadOps.SetEvent(localEvent);

                Thread localThread = healthThread;

                if (localThread != null)
                {
                    try
                    {
                        if (localThread.IsAlive)
                        {
                            int localTimeout;

                            if (timeout != null)
                                localTimeout = (int)timeout;
                            else
                                localTimeout = ThreadOps.DefaultJoinTimeout;

                            if (!localThread.Join(localTimeout))
                            {
                                localThread.Interrupt(); /* throw */

                                if (!localThread.Join(localTimeout))
                                {
                                    if (noAbort)
                                    {
                                        result = String.Format(
                                            "failed to join health " +
                                            "thread after {0} milliseconds",
                                            localTimeout);

                                        return ReturnCode.Error;
                                    }
                                    else
                                    {
                                        /* BUGBUG: Leaks? */
                                        localThread.Abort(); /* throw */

                                        result = "aborted health thread";
                                    }
                                }
                                else
                                {
                                    result = "interrupted health thread";
                                }
                            }
                            else if (signaled)
                            {
                                result = "signaled health thread";
                            }
                            else
                            {
                                result = "health thread has died";
                            }

                            healthThread = null; /* NOTE: Joined (?) */
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            healthThread = null; /* NOTE: Dead. */
                            result = "health thread is not alive";

                            //
                            // NOTE: This is not really always an error
                            //       due to subtle timing issues.
                            //
                            if (!strictStop)
                                return ReturnCode.Ok;
                        }
                    }
                    catch (Exception e)
                    {
                        result = String.Format(
                            "failed to interrupt health thread, caught exception: {0}",
                            e);
                    }
                }
                else
                {
                    result = "health thread already stopped";

                    //
                    // NOTE: This is not really always an error due to
                    //       nested interactive loops.
                    //
                    if (!strictStop)
                        return ReturnCode.Ok;
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void RunHealthChecks(
            int totalTimeout
            )
        {
            ReturnCode code;
            Result result = null;
            ResultList errors = null;

            code = ScriptOps.TryLockForHealth(this, ref errors);

            if (code != ReturnCode.Ok)
                goto fail;

            code = ScriptOps.EvaluateForHealth(this, ref result);

            if (ScriptOps.VerifyForHealth(code, result, ref errors))
            {
                Interlocked.Increment(ref goodHealthCount);
                return;
            }

        fail:

            Interlocked.Increment(ref badHealthCount);

            TraceOps.DebugTrace(String.Format(
                "RunHealthChecks: interpreter = {0}, " +
                "totalTimeout = {1}, code = {2}, " +
                "result = {3}, errors = {4}",
                FormatOps.InterpreterNoThrow(this),
                totalTimeout, FormatOps.WrapOrNull(code),
                FormatOps.WrapOrNull(result),
                FormatOps.WrapOrNull(errors)),
                typeof(Interpreter).Name,
                TracePriority.HealthError);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Timeout Thread Support
        private bool HasTimeoutThread(
            bool mustBeAlive
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                Thread localThread = timeoutThread;

                return (localThread != null) &&
                    (!mustBeAlive || localThread.IsAlive);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void TimeoutThreadStart( /* THREAD-SAFE */
            object obj
            ) /* System.Threading.ParameterizedThreadStart */
        {
            try
            {
                ScriptTimeoutClientData clientData = obj as ScriptTimeoutClientData;

                if (clientData != null)
                {
                    Interpreter interpreter = clientData.Interpreter;

#if THREADING
                    IEngineContext engineContext = clientData.EngineContext;
#endif

                    TimeoutFlags timeoutFlags = clientData.TimeoutFlags;
                    CancelFlags cancelFlags;

                    if (clientData.CancelFlags != null)
                    {
                        cancelFlags = (CancelFlags)clientData.CancelFlags;
                    }
                    else
                    {
                        //
                        // HACK: Use a reasonable set of default cancel flags.
                        //
                        cancelFlags = CancelFlags.Timeout;
                    }

                    int timeout = clientData.Timeout;

                    if (interpreter != null)
                    {
                        if (timeout != _Timeout.Infinite) // never timeout?
                        {
                            bool interactive = FlagOps.HasFlags(
                                timeoutFlags, TimeoutFlags.Interactive, true);

                            bool interrupt = FlagOps.HasFlags(
                                timeoutFlags, TimeoutFlags.Interrupt, true);

                            IInteractiveHost interactiveHost = null;

                            if (interactive)
                            {
                                //
                                // HACK: Workaround for Mono disposal race condition.
                                //
                                interactiveHost = interpreter.GetInteractiveHost();
                            }

                            //
                            // NOTE: Keep going while the interactive host is actively
                            //       reading input from the user.  This allows commands
                            //       that enter the interactive loop recursively (like
                            //       [debug break]) to be used with the script timeout
                            //       feature.  This loop will terminate when the user
                            //       attempts to cancel the running script -OR- allows
                            //       it to continue running.
                            //
                            int totalTimeout = 0;

                            while (true)
                            {
                                //
                                // NOTE: Give the script some time to execute.  If this
                                //       thread is interrupted during the wait, do not
                                //       attempt to do anything else.
                                //
                                Exception exception = null;

                                if (HostOps.ThreadSleep(
                                        timeout, ref exception) == ReturnCode.Ok)
                                {
                                    //
                                    // NOTE: If the interactive host is actively reading
                                    //       from the user there is probably no need to
                                    //       cancel the running script (if there actually
                                    //       is a running script).
                                    //
                                    if (interactive && (interactiveHost != null) &&
                                        HostOps.GetReadLevels(interactiveHost) > 0)
                                    {
                                        continue;
                                    }

                                    //
                                    // BUGFIX: Do not attempt to prompt the user and/or
                                    //         to cancel any running scripts if none are
                                    //         currently running.
                                    //
                                    if (!interpreter.InternalIsGlobalBusy)
                                        continue;

                                    //
                                    // NOTE: Keep track of the total timeout milliseconds,
                                    //       which is used to generate the prompts and/or
                                    //       error messages.
                                    //
                                    totalTimeout += timeout;

                                    //
                                    // NOTE: Prompt the interactive user and check if they
                                    //       would like to cancel the running script.
                                    //
#if WINFORMS
                                    DialogResult dialogResult;

                                    if (interactive)
                                    {
                                        dialogResult = FormOps.YesOrNoOrCancel(
                                            String.Format(
                                                timeoutCancelPromptFormat, totalTimeout),
                                            GlobalState.GetPackageName(),
                                            DefaultTimeoutDialogResult);
                                    }
                                    else
                                    {
                                        dialogResult = DefaultTimeoutDialogResult;
                                    }

                                    if (dialogResult == DialogResult.Cancel)
                                        continue; /* NOTE: Wait, then prompt again. */

                                    if (dialogResult == DialogResult.Yes)
#else
                                    bool? dialogResult;

                                    if (interactive)
                                    {
                                        dialogResult = WindowOps.YesOrNoOrCancel(
                                            String.Format(
                                                timeoutCancelPromptFormat, totalTimeout),
                                            GlobalState.GetPackageName(),
                                            DefaultTimeoutDialogResult);
                                    }
                                    else
                                    {
                                        dialogResult = DefaultTimeoutDialogResult;
                                    }

                                    if (dialogResult == null)
                                        continue; /* NOTE: Wait, then prompt again. */

                                    if ((bool)dialogResult)
#endif
                                    {
                                        bool global = FlagOps.HasFlags(
                                            cancelFlags, CancelFlags.Global, true);

#if THREADING
                                        if (!global && (engineContext == null))
                                            global = true;
#endif

                                        ReturnCode code;
                                        Result error = null;

                                        code = interpreter.InternalCancelAnyEvaluate(
#if THREADING
                                            engineContext,
#endif
                                            String.Format(
                                                timeoutCancelResultFormat, totalTimeout),
                                            RuntimeOps.GetCancelEvaluateFlags(global,
                                            interactive, true, false, true, interrupt),
                                            ref error);

                                        if (code != ReturnCode.Ok)
                                        {
                                            TraceOps.DebugTrace(String.Format(
                                                "TimeoutThreadStart: code = {0}, error = {1}",
                                                code, FormatOps.WrapOrNull(error)),
                                                typeof(Interpreter).Name,
                                                TracePriority.ThreadError);
                                        }
                                    }
                                }
                                else if (exception is ThreadInterruptedException)
                                {
                                    // do nothing.
                                }
                                else
                                {
                                    TraceOps.DebugTrace(
                                        exception, typeof(Interpreter).Name,
                                        TracePriority.ThreadError);
                                }

                                //
                                // NOTE: Either the script in progress (if any) completed
                                //       successfully -OR- we managed to cancel it.
                                //
                                break;
                            }
                        }
                    }
                }
            }
            catch (ThreadAbortException)
            {
                Thread.ResetAbort();
            }
            catch (ThreadInterruptedException)
            {
                // do nothing.
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode StartTimeoutThread(
            int? timeout,
            TimeoutFlags timeoutFlags,
            bool forceStart,
            bool mustBeAlive,
            bool strictStart,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // NOTE: If there is not timeout we do not bother starting the
                //       dedicated script cancellation thread unless we are
                //       forced to by the caller.
                //
                int localTimeout;

                if (timeout != null)
                    localTimeout = (int)timeout;
                else
                    localTimeout = InternalTimeout; /* PROPERTY */

                if (forceStart ||
                    (localTimeout != _Timeout.Infinite))
                {
                    Thread localThread = timeoutThread;

                    if ((localThread == null) ||
                        (mustBeAlive && !localThread.IsAlive))
                    {
                        bool success = false;

                        try
                        {
                            localThread = Engine.CreateThread(
                                this, TimeoutThreadStart,
                                0, false, false, true);

                            if (localThread != null)
                            {
                                localThread.Name = String.Format(
                                    "timeoutThread: {0}",
                                    FormatOps.InterpreterNoThrow(
                                        this)); /* throw */

                                localThread.Start(CreateScriptTimeoutClientData(
                                    null, timeoutFlags, null, localTimeout)); /* throw */

                                timeoutThread = localThread;
                                success = true;

                                result = "created and started timeout thread";
                                return ReturnCode.Ok;
                            }
                            else
                            {
                                result = "could not create timeout thread";
                            }
                        }
                        catch (Exception e)
                        {
                            result = String.Format(
                                "failed to start timeout thread, caught exception: {0}",
                                e);
                        }
                        finally
                        {
                            if (!success && (localThread != null))
                            {
                                try
                                {
                                    localThread.Interrupt(); /* throw */
                                    localThread = null;
                                }
                                catch (Exception e)
                                {
                                    TraceOps.DebugTrace(
                                        e, typeof(Interpreter).Name,
                                        TracePriority.ThreadError);
                                }
                            }
                        }
                    }
                    else
                    {
                        result = "timeout thread already started";

                        //
                        // NOTE: This is not really always an error
                        //       due to nested interactive loops.
                        //
                        if (!strictStart)
                            return ReturnCode.Ok;
                    }
                }
                else
                {
                    //
                    // NOTE: Skipped, we were not forced to start the
                    //       timeout thread and there is no timeout set.
                    //
                    result = "skipped checking timeout thread";

                    return ReturnCode.Ok;
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode InterruptTimeoutThread(
            int? timeout,
            bool noAbort,
            bool strictStop,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                Thread localThread = timeoutThread;

                if (localThread != null)
                {
                    try
                    {
                        if (localThread.IsAlive)
                        {
                            localThread.Interrupt(); /* throw */

                            int localTimeout;

                            if (timeout != null)
                                localTimeout = (int)timeout;
                            else
                                localTimeout = ThreadOps.DefaultJoinTimeout;

                            if (!localThread.Join(localTimeout))
                            {
                                if (noAbort)
                                {
                                    result = String.Format(
                                        "failed to join timeout " +
                                        "thread after {0} milliseconds",
                                        localTimeout);

                                    return ReturnCode.Error;
                                }
                                else
                                {
                                    /* BUGBUG: Leaks? */
                                    localThread.Abort(); /* throw */

                                    result = "aborted timeout thread";
                                }
                            }
                            else
                            {
                                result = "interrupted timeout thread";
                            }

                            timeoutThread = null; /* NOTE: Joined (?) */
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            timeoutThread = null; /* NOTE: Dead. */
                            result = "timeout thread is not alive";

                            //
                            // NOTE: This is not really always an error
                            //       due to subtle timing issues.
                            //
                            if (!strictStop)
                                return ReturnCode.Ok;
                        }
                    }
                    catch (Exception e)
                    {
                        result = String.Format(
                            "failed to interrupt timeout thread, caught exception: {0}",
                            e);
                    }
                }
                else
                {
                    result = "timeout thread already stopped";

                    //
                    // NOTE: This is not really always an error due to
                    //       nested interactive loops.
                    //
                    if (!strictStop)
                        return ReturnCode.Ok;
                }

                return ReturnCode.Error;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Finally Timeout Thread Support
        private static void FinallyTimeoutThreadStart( /* THREAD-SAFE */
            object obj
            ) /* System.Threading.ParameterizedThreadStart */
        {
            try
            {
                ScriptTimeoutClientData clientData = obj as ScriptTimeoutClientData;

                if (clientData != null)
                {
                    Interpreter interpreter = clientData.Interpreter;

#if THREADING
                    IEngineContext engineContext = clientData.EngineContext;
#endif

                    TimeoutFlags timeoutFlags = clientData.TimeoutFlags;
                    CancelFlags cancelFlags;

                    if (clientData.CancelFlags != null)
                    {
                        cancelFlags = (CancelFlags)clientData.CancelFlags;
                    }
                    else
                    {
                        //
                        // HACK: Use a reasonable set of default cancel flags.
                        //
                        cancelFlags = CancelFlags.Timeout;
                    }

                    int timeout = clientData.Timeout;

                    if (interpreter != null)
                    {
                        if (timeout != _Timeout.Infinite) // never timeout?
                        {
                            bool interrupt = FlagOps.HasFlags(
                                timeoutFlags, TimeoutFlags.Interrupt, true);

                            //
                            // NOTE: Keep going while the interactive host is actively
                            //       reading input from the user.  This allows commands
                            //       that enter the interactive loop recursively (like
                            //       [debug break]) to be used with the script timeout
                            //       feature.  This loop will terminate when the user
                            //       attempts to cancel the running script -OR- allows
                            //       it to continue running.
                            //
                            while (true)
                            {
                                ReturnCode code;
                                Exception exception;
                                Result error; /* REUSED */

                                //
                                // NOTE: Give the script some time to execute.  If this
                                //       thread is interrupted during the wait, do not
                                //       attempt to do anything else.
                                //
                                exception = null;
                                error = null;

                                code = HostOps.ThreadSleep(
                                    timeout, ref exception, ref error);

                                if (code == ReturnCode.Ok)
                                {
                                    bool global = FlagOps.HasFlags(
                                        cancelFlags, CancelFlags.Global, true);

#if THREADING
                                    if (!global && (engineContext == null))
                                        global = true;
#endif

                                    error = null;

                                    code = interpreter.InternalCancelAnyEvaluate(
#if THREADING
                                        engineContext,
#endif
                                        String.Format(
                                            finallyTimeoutCancelResultFormat, timeout),
                                        RuntimeOps.GetCancelEvaluateFlags(global,
                                            false, true, false, true, interrupt),
                                            ref error);

                                    if (code != ReturnCode.Ok)
                                    {
                                        TraceOps.DebugTrace(String.Format(
                                            "FinallyTimeoutThreadStart: code = {0}, " +
                                            "error = {1}", code, FormatOps.WrapOrNull(
                                            error)), typeof(Interpreter).Name,
                                            TracePriority.ThreadError);
                                    }
                                }
                                else if (exception is ThreadInterruptedException)
                                {
                                    // do nothing.
                                }
                                else
                                {
                                    TraceOps.DebugTrace(
                                        exception, typeof(Interpreter).Name,
                                        TracePriority.ThreadError);
                                }

                                //
                                // NOTE: Either the script in progress (if any)
                                //       completed successfully -OR- we managed
                                //       to cancel it.
                                //
                                break;
                            }
                        }
                    }
                }
            }
            catch (ThreadAbortException)
            {
                Thread.ResetAbort();
            }
            catch (ThreadInterruptedException)
            {
                // do nothing.
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode StartFinallyTimeoutThread(
            int? timeout,
            TimeoutFlags timeoutFlags,
            bool forceStart,
            ref Thread thread,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // NOTE: If there is not timeout we do not bother starting the
                //       dedicated finally timeout thread unless we are forced
                //       to by the caller.
                //
                int localTimeout;

                if (timeout != null)
                    localTimeout = (int)timeout;
                else
                    localTimeout = PrivateFinallyTimeout; /* PROPERTY */

                if (forceStart ||
                    (localTimeout != _Timeout.Infinite))
                {
                    bool success = false;
                    Thread localThread = null;

                    try
                    {
                        localThread = Engine.CreateThread(
                            this, FinallyTimeoutThreadStart,
                            0, false, false, true);

                        if (localThread != null)
                        {
                            localThread.Name = String.Format(
                                "finallyTimeoutThread: {0}",
                                FormatOps.InterpreterNoThrow(
                                    this)); /* throw */

                            localThread.Start(CreateScriptTimeoutClientData(
                                null, timeoutFlags, null, localTimeout)); /* throw */

                            thread = localThread;
                            success = true;

                            result = "created and started finally timeout thread";
                            return ReturnCode.Ok;
                        }
                        else
                        {
                            result = "could not create finally timeout thread";
                        }
                    }
                    catch (Exception e)
                    {
                        result = String.Format(
                            "failed to start finally timeout thread, caught exception: {0}",
                            e);
                    }
                    finally
                    {
                        if (!success && (localThread != null))
                        {
                            try
                            {
                                localThread.Interrupt(); /* throw */
                                localThread = null;
                            }
                            catch (Exception e)
                            {
                                TraceOps.DebugTrace(
                                    e, typeof(Interpreter).Name,
                                    TracePriority.ThreadError);
                            }
                        }
                    }
                }
                else
                {
                    //
                    // NOTE: Skipped, we were not forced to start the
                    //       timeout thread and there is no timeout set.
                    //
                    result = "skipped checking finally timeout thread";

                    return ReturnCode.Ok;
                }

                return ReturnCode.Error;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode InterruptFinallyTimeoutThread(
            Thread thread,
            int? timeout,
            bool noAbort,
            bool strictStop,
            ref Result result
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (thread != null)
                {
                    try
                    {
                        if (thread.IsAlive)
                        {
                            thread.Interrupt(); /* throw */

                            int localTimeout;

                            if (timeout != null)
                                localTimeout = (int)timeout;
                            else
                                localTimeout = ThreadOps.DefaultJoinTimeout;

                            if (!thread.Join(localTimeout))
                            {
                                if (noAbort)
                                {
                                    result = String.Format(
                                        "failed to join finally timeout " +
                                        "thread after {0} milliseconds",
                                        localTimeout);

                                    return ReturnCode.Error;
                                }
                                else
                                {
                                    /* BUGBUG: Leaks? */
                                    thread.Abort(); /* throw */

                                    result = "aborted finally timeout thread";
                                }
                            }
                            else
                            {
                                result = "interrupted finally timeout thread";
                            }

                            return ReturnCode.Ok;
                        }
                        else
                        {
                            result = "finally timeout thread is not alive";

                            //
                            // NOTE: This is not really always an error
                            //       due to subtle timing issues.
                            //
                            if (!strictStop)
                                return ReturnCode.Ok;
                        }
                    }
                    catch (Exception e)
                    {
                        result = String.Format(
                            "failed to interrupt finally timeout thread, caught exception: {0}",
                            e);
                    }
                }
                else
                {
                    result = "finally timeout thread already stopped";

                    //
                    // NOTE: This is not really always an error
                    //       due to nested evaluations, etc.
                    //
                    if (!strictStop)
                        return ReturnCode.Ok;
                }

                return ReturnCode.Error;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interactive Loop
#if SHELL
#if NATIVE && TCL
        private static ReturnCode EvaluateInteractiveTclScript(
            Interpreter interpreter,
            string tclInterpName,
            string text,
            ref Result result,
            ref int errorLine
            )
        {
            if (interpreter == null)
            {
                result = "invalid interpreter";
                return ReturnCode.Error;
            }

            ///////////////////////////////////////////////////////////////

            string interpName = null;
            IntPtr interp = IntPtr.Zero;

            ///////////////////////////////////////////////////////////////

            #region Get Native Tcl Interpreter
            if (tclInterpName != null)
            {
                interpName = tclInterpName;

                if (interpreter.GetTclInterpreter(
                        interpName, LookupFlags.Default,
                        ref interp, ref result) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }
            }
            else
            {
                if (interpreter.GetAnyTclParentInterpreter(
                        LookupFlags.Default, ref interpName,
                        ref interp, ref result) != ReturnCode.Ok)
                {
                    return ReturnCode.Error;
                }
            }
            #endregion

            ///////////////////////////////////////////////////////////////

            #region Evaluate Tcl Script
            if (interpreter.RecordAndEvaluateTclScript(
                    interpName, text, ref result) != ReturnCode.Ok)
            {
                errorLine = TclWrapper.GetErrorLine(
                    interpreter.tclApi, interp);

                return ReturnCode.Error;
            }

            return ReturnCode.Ok;
            #endregion
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReturnCode EvaluateInteractiveScript(
            Interpreter interpreter,
            string text,
            EngineFlags engineFlags,
            SubstitutionFlags substitutionFlags,
            EventFlags eventFlags,
            ExpressionFlags expressionFlags,
            bool noTimeout,
            ref Result result,
            ref int errorLine
            )
        {
            if (interpreter == null)
            {
                result = "invalid interpreter";
                return ReturnCode.Error;
            }

            try
            {
                #region Start Script Timeout Thread
                if (!noTimeout)
                {
                    //
                    // NOTE: Start runaway script timeout thread.
                    //
                    ReturnCode startTimeoutCode;
                    Result startTimeoutResult = null;

                    startTimeoutCode = interpreter.StartTimeoutThread(
                        null, TimeoutFlags.InteractiveLoop, false, true,
                        false, ref startTimeoutResult);

                    if (startTimeoutCode != ReturnCode.Ok)
                    {
                        DebugOps.Complain(interpreter,
                            startTimeoutCode, startTimeoutResult);
                    }
                }
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Evaluate Eagle Script
                return Engine.EvaluateScript(interpreter,
                    text, engineFlags, substitutionFlags, eventFlags,
                    expressionFlags, ref result, ref errorLine);
                #endregion
            }
            finally
            {
                #region Stop Script Timeout Thread
                if (!noTimeout)
                {
                    //
                    // NOTE: Stop runaway script timeout thread.
                    //
                    ReturnCode stopTimeoutCode;
                    Result stopTimeoutResult = null;

                    stopTimeoutCode = interpreter.InterruptTimeoutThread(
                        null, false, false, ref stopTimeoutResult);

                    if (stopTimeoutCode != ReturnCode.Ok)
                    {
                        DebugOps.Complain(interpreter,
                            stopTimeoutCode, stopTimeoutResult);
                    }
                }
                #endregion
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static ReturnCode InteractiveLoop(
            Interpreter interpreter,
            IEnumerable<string> args,
            ref Result result
            )
        {
            return InteractiveLoop(
                interpreter, new InteractiveLoopData(args), ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static ReturnCode InteractiveLoop(
            Interpreter interpreter,
            IInteractiveLoopData loopData,
            ref Result result
            )
        {
            //
            // NOTE: Push interpreter onto the activation stack
            //       because it is considered "active" while the
            //       interactive loop is using it.
            //
            if (interpreter != null)
            {
                /* IGNORED */
                interpreter.PushGlobalInteractiveLoopLevel();
            }

            try
            {
                GlobalState.PushActiveInterpreter(interpreter);

                try
                {
                    return PrivateInteractiveLoop(
                        interpreter, loopData, ref result);
                }
                finally
                {
                    //
                    // NOTE: Pop interpreter from the activation
                    //       stack because the interactive loop
                    //       is now done using it.
                    //
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }
            finally
            {
                if (interpreter != null)
                {
                    /* IGNORED */
                    interpreter.PopGlobalInteractiveLoopLevel();
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReturnCode PrivateInteractiveLoop(
            Interpreter interpreter,
            IInteractiveLoopData loopData,
            ref Result result
            )
        {
            TraceOps.DebugTrace(String.Format(
                "PrivateInteractiveLoop: entered, " +
                "interpreter = {0}, loopData = {1}, result = {2}",
                FormatOps.InterpreterNoThrow(interpreter),
                FormatOps.InteractiveLoopData(loopData),
                FormatOps.WrapOrNull(true, true, result)),
                typeof(Interpreter).Name, TracePriority.ShellDebug);

            try
            {
                #region Parameter Check
                //
                // NOTE: An interpreter is required for the interactive loop.
                //
                if (interpreter == null)
                {
                    result = "invalid interpreter";
                    return ReturnCode.Error;
                }

                ///////////////////////////////////////////////////////////////

                //
                // NOTE: The interactive loop data is required to do anything
                //       useful in this method -AND- it must be of the right
                //       concrete type (i.e. InteractiveLoopData).
                //
                if (loopData == null)
                {
                    result = "invalid interactive loop data";
                    return ReturnCode.Error;
                }

                InteractiveLoopData localLoopData;

                localLoopData = loopData as InteractiveLoopData;

                if (localLoopData == null)
                {
                    result = String.Format(
                        "interactive loop data must derive from {0}",
                        typeof(InteractiveLoopData));

                    return ReturnCode.Error;
                }
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Exit Check
                //
                // NOTE: Make sure that we exit if the [exit] command was used.
                //
                CheckExit(interpreter, ref localLoopData.exit);

                if (loopData.Exit)
                    return loopData.Code;
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Cross-AppDomain Check
                //
                // NOTE: Check to see if the specified interpreter is running
                //       in the same AppDomain as this interactive loop.  This
                //       is potentially important for any operation that may
                //       require remoting.
                //
                bool sameAppDomain = AppDomainOps.IsSame(interpreter);
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Interactive Host Check
                //
                // NOTE: Grab the interactive host from the interpreter.  The
                //       methods of this interface represent the absolute bare
                //       minimum functionality we need for the interactive loop
                //       to function correctly.
                //
                IInteractiveHost interactiveHost;

                interactiveHost = interpreter.GetInteractiveHost();

                //
                // NOTE: Check for host after checking whether we are exiting
                //       because the host may have already been torn down and
                //       that is not an error.
                //
                if (interactiveHost == null)
                {
                    //
                    // NOTE: We absolutely require an interpreter hosting
                    //       environment (such as the provided Console Host)
                    //       for the interactive loop to function properly.
                    //
                    result = "interpreter host not available"; /* ERROR */
                    return ReturnCode.Error;
                }
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Native Stack Check
#if NATIVE
                //
                // NOTE: Make sure we have checked for native stack space at
                //       least once at this point.
                //
                if (RuntimeOps.CheckForStackSpace(interpreter) != ReturnCode.Ok)
                {
                    //
                    // NOTE: We are out of native stack space.  Perhaps there
                    //       are too many nested interactive loops?
                    //
                    result = "out of stack space (infinite loop?)";
                    return ReturnCode.Error;
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Save / Push Interactive Loop Level
                //
                // NOTE: Save the interactive loop level now.  This involves
                //       grabbing and changing several related thread-specific
                //       properties of our interactive interpreter instance.
                //
                Thread savedInteractiveThread;
                bool savedInteractive;
                IInteractiveLoopData savedLoopData;

                interpreter.PushLocalInteractiveLoopLevel(
                    loopData, sameAppDomain, out savedInteractiveThread,
                    out savedInteractive, out savedLoopData);

                ///////////////////////////////////////////////////////////////

#if DEBUG && VERBOSE
                //
                // HACK: This must be done here, after the number of active
                //       interactive loops has been adjusted; ideally, this
                //       should have been done as soon as the interactive
                //       host was known.
                //
                HostOps.EmitTrace(
                    "PrivateInteractiveLoop", interpreter, interactiveHost,
                    HostOps.TryGetInteractiveLoops(interpreter), null);
#endif
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Local Halt State Variables
                //
                // NOTE: These variables are used when halting the interpreter
                //       (i.e. cancel any scripts in progress and break out of
                //       any nested interactive loops).
                //
                ReturnCode haltCode;
                bool haltReset = false;
                Result haltResult = null;
                #endregion

                ///////////////////////////////////////////////////////////////

                #region [Maybe] Initialize Interactive Loop (Shell)
                //
                // NOTE: Have we initialized the interactive shell yet?  If
                //       not, do it now.  The interpreter must already have
                //       been initialized.  Also, this is only done "once",
                //       for the outermost interactive loop.
                //
                if (interpreter.PrivateInitialized &&
                    interpreter.ShouldInitializeShell &&
                    (interpreter.ActiveInteractiveLoops == 1))
                {
                    #region Enter Debugger Active Level
#if DEBUGGER
                    //
                    // NOTE: Get the active debugger from the interpreter
                    //       itself.
                    //
                    IDebugger debugger = interpreter.Debugger;

                    ///////////////////////////////////////////////////////////

                    //
                    // NOTE: If we are debugging and the debugger is available
                    //       for this interpreter, increase one level of nested
                    //       debugger evaluations.  This is critical because it
                    //       is used by the engine to determine if breakpoints
                    //       should occur in the evaluated script and if the
                    //       halt flag for the interpreter should be reset
                    //       after the script is evaluated (below).
                    //
                    if (loopData.Debug &&
                        (debugger != null) && !debugger.Disposed)
                    {
                        debugger.SetActive(true);
                    }
#endif
                    #endregion

                    ///////////////////////////////////////////////////////////

                    try
                    {
                        //
                        // NOTE: Evaluate the user-specific shell startup file
                        //       and the interactive shell startup file, if
                        //       they exist.
                        //
                        ReturnCode shellCode;
                        Result shellResult = null;

                        shellCode = interpreter.PrivateInitializeShell(
                            false, loopData.Debug, ref shellResult);

                        if (shellCode != ReturnCode.Ok)
                        {
                            DebugOps.Complain(interpreter, shellCode,
                                String.Format("shell: {0}", shellResult));
                        }

                        //
                        // BUGFIX: If the shell initialization script somehow
                        //         set the exit flag for the interpreter, bail
                        //         out before entering the actual interactive
                        //         loop and without displaying any debugging
                        //         related information.
                        //
                        CheckExit(interpreter, ref localLoopData.exit);

                        //
                        // NOTE: Did the shell initialization script somehow
                        //       mark the interpreter as exited?
                        //
                        if (loopData.Exit)
                        {
                            TraceOps.DebugTrace(
                                "PrivateInteractiveLoop: leaving, shell " +
                                "initialization script set the exit flag...",
                                typeof(Interpreter).Name,
                                TracePriority.ShellDebug);

                            goto skipLoop;
                        }

                        ///////////////////////////////////////////////////////

#if !NET_STANDARD_20
                        //
                        // NOTE: Should we check for an update to the core
                        //       library right now (i.e. during interactive
                        //       loop startup)?
                        //
                        bool setupMissing = false;

                        if (!interpreter.InternalIsSafeOrSdk() &&
                            RuntimeOps.ShouldCheckForUpdates() &&
                            (SetupOps.ShouldCheckCoreUpdates(
                                ref setupMissing) || setupMissing) &&
                            ScriptOps.IsDefaultShellFileName())
                        {
                            //
                            // HACK: Prior to evaluating the script that is
                            //       used to check for updates, make sure to
                            //       set the value (in the registry) to keep
                            //       track of last update check.  This must
                            //       be done before evaluating the script
                            //       because the script itself may [exit].
                            //
                            // HACK: This is not done if there is apparently
                            //       no setup information present.
                            //
                            if (!setupMissing)
                                SetupOps.MarkCheckCoreUpdatesNow();

                            //
                            // NOTE: Check for an update to the core library
                            //       now, specifically the appropriate setup
                            //       package.
                            //
                            ReturnCode updateCode;
                            int updateErrorLine = 0;
                            Result updateResult = null;

                            updateCode = ShellOps.CheckForUpdate(
                                interpreter, new UpdateData((string)null,
                                    ActionType.CheckForUpdate,
                                    _Shared.ReleaseType.Setup,
                                    _Shared.UpdateType.Engine,
                                    false, true, true, true),
                                loopData.Debug, ref updateErrorLine,
                                ref updateResult);

                            TraceOps.DebugTrace(String.Format(
                                "PrivateInteractiveLoop: setupMissing = {0}, " +
                                "updateCode = {1}, updateErrorLine = {2}, " +
                                "updateResult = {3}", setupMissing, updateCode,
                                updateErrorLine, FormatOps.WrapOrNull(
                                updateResult)), typeof(Interpreter).Name,
                                TracePriority.SetupDebug);

                            //
                            // BUGFIX: If the update checking script somehow
                            //         set the exit flag for the interpreter,
                            //         bail out before entering the actual
                            //         interactive loop and without displaying
                            //         any debugging related information.
                            //
                            CheckExit(interpreter, ref localLoopData.exit);

                            //
                            // NOTE: Did the update checking script somehow
                            //       mark the interpreter as exited?
                            //
                            if (loopData.Exit)
                            {
                                TraceOps.DebugTrace(
                                    "PrivateInteractiveLoop: leaving, " +
                                    "check-for-update script set the " +
                                    "exit flag...",
                                    typeof(Interpreter).Name,
                                    TracePriority.ShellDebug);

                                goto skipLoop;
                            }
                        }
#endif
                    }
                    finally
                    {
                        #region Exit Debugger Active Level
#if DEBUGGER
                        //
                        // NOTE: Exit one level of nested debugger evaluations.
                        //
                        debugger = interpreter.Debugger; /* NOTE: Refresh. */

                        if (loopData.Debug &&
                            (debugger != null) && !debugger.Disposed)
                        {
                            debugger.SetActive(false);
                        }
#endif
                        #endregion
                    }
                }
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Write Interactive Header
                //
                // BUGFIX: Skip writing anything if the interpreter host has
                //         been disposed.
                //
                if (loopData.Debug && (interactiveHost != null) &&
                    !HostOps.IsDisposed(interactiveHost))
                {
                    //
                    // NOTE: Attempt to cast the interactive host to an
                    //       informational host.  If this fails, we simply
                    //       ignore it because it is not strictly required
                    //       for proper functioning of the interactive loop.
                    //
                    IInformationHost informationHost =
                        interactiveHost as IInformationHost;

                    bool proxy = AppDomainOps.IsTransparentProxy(
                        informationHost);

                    if (informationHost != null)
                    {
                        informationHost.WriteHeader(
                            interpreter, new InteractiveLoopData(
                            loopData, !proxy ? loopData.Token : null,
                            !proxy ? loopData.TraceInfo : null,
                            DebuggerOps.GetHeaderFlags(
                                interactiveHost, loopData.HeaderFlags,
                                loopData.Debug, true, false,
                                loopData.Debug)
                            ), result);
                    }
                }
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Determine Local Header & Detail Flags
                //
                // NOTE: Get the header display flags for the interpreter and
                //       add the necessary flags for our debugging mode.
                //
                HeaderFlags localHeaderFlags = DebuggerOps.GetHeaderFlags(
                    interactiveHost, interpreter.HeaderFlags, loopData.Debug,
                    false, false, loopData.Debug);

                DetailFlags localDetailFlags = interpreter.DetailFlags;
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Save / Push Engine Flags
                //
                // NOTE: Initialize the saved engine flags (to nothing).
                //
                EngineFlags savedEngineFlags = EngineFlags.None;

                //
                // NOTE: Are we being called by the debugger?
                //
                if (loopData.Debug)
                {
                    //
                    // BUGFIX: Save the current engine flags for this
                    //         interpreter to be restored as this
                    //         [potentially nested] interactive loop is
                    //         exiting.
                    //
                    savedEngineFlags = interpreter.ContextEngineFlags;

                    //
                    // NOTE: For functions called from inside the interactive
                    //       loop that do not, directly or indirectly, receive
                    //       engine flags as a formal argument, we still need
                    //       to be sure that the engine flags received from
                    //       our caller are in effect for the entire duration
                    //       of this interactive loop; therefore, we combine
                    //       the engine flags received from our caller into
                    //       the engine flags for the interpreter.
                    //
                    interpreter.ContextEngineFlags |= loopData.EngineFlags;
                }
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Local Flag Variables
                //
                // NOTE: Get the local engine, substitution, and event flags
                //       for this interpreter.
                //
                EngineFlags localEngineFlags;
                SubstitutionFlags localSubstitutionFlags;
                EventFlags localEventFlags;
                ExpressionFlags localExpressionFlags;

                interpreter.QueryInteractiveLoopFlags(
                    out localEngineFlags, out localSubstitutionFlags,
                    out localEventFlags, out localExpressionFlags);

                ///////////////////////////////////////////////////////////////

                //
                // NOTE: Add the engine flags for our debugging mode to our
                //       local engine flags, if necessary.
                //
                localEngineFlags |= DebuggerOps.GetEngineFlags(loopData.Debug);
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Force Cancel / Halt Flags
                //
                // NOTE: The "forceCancel" and "forceHalt" variables are used
                //       as the "force" argument to the ResetCancel and
                //       ResetHalt methods, respectively.  These methods are
                //       used at the top of each loop iteration to reset the
                //       interpreter flags as necessary prior to doing anything
                //       with the interpreter.
                //
                bool forceCancel = false;
                bool forceHalt = false;
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Local Return Code / Result / Error Line
                //
                // NOTE: These result variables need to be preserved between
                //       loop iterations for possible modification of the
                //       REAL result(s) (primarily in debug mode).
                //
                ReturnCode localCode = ReturnCode.Ok;
                Result localResult = null;
                int localErrorLine = 0;
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Tcl Shell Emulation Mode Variables
                //
                // NOTE: This variable controls which script engine is used to
                //       evaluate all interactively entered scripts (i.e.
                //       using Eagle or using "tclsh emulation mode").  By
                //       default (zero), all interactively entered scripts will
                //       be evaluated using the interactive Eagle interpreter.
                //       When this variable is non-zero, all interactively
                //       entered scripts will be evaluated using the parent Tcl
                //       interpreter (or the selected Tcl interpreter), when
                //       available.
                //
                bool tclsh = false;

                ///////////////////////////////////////////////////////////////

#if INTERACTIVE_COMMANDS || (NATIVE && TCL)
                //
                // NOTE: This variable will contain the native Tcl interpreter
                //       name to use when in "tclsh emulation mode".
                //
                string tclInterpName = null;
#endif

                ///////////////////////////////////////////////////////////////

                //
                // NOTE: This variable will contain the saved setting for the
                //       current "tclsh emulation mode" setting if it needs to
                //       be restored by the current iteration of the primary
                //       loop -OR- null if the "tclsh emulation mode" setting
                //       has not [yet] been saved or has already been restored.
                //
                bool? savedTclsh = null;
                #endregion

                ///////////////////////////////////////////////////////////////

                #region GC Test Thread Variables
#if INTERACTIVE_COMMANDS
                //
                // NOTE: Does the GC test thread need to be shutdown upon
                //       exiting THIS interactive loop?
                //
                bool startedGcThread = false;
#endif
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Interactive Input Variables
                //
                // NOTE: This variable will contain interactive input saved
                //       from a previous iteration of the primary loop (below)
                //       or null if no such input has been saved since it was
                //       last reset.
                //
                string savedText = null;
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Interactive Loop Variables
                //
                // NOTE: This variable controls the primary loop (below).  When
                //       it is true, the loop will terminate (i.e. there is no
                //       more input available, the user has exited, etc).
                //
                bool done;

                ///////////////////////////////////////////////////////////////

#if INTERACTIVE_COMMANDS
                //
                // NOTE: This variable controls whether or not interactive
                //       extension commands must be an exact name match in
                //       order to resolve.
                //
                bool exact = true;
#endif
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Reset Interactive Loop Event
                //
                // NOTE: Before entering the interactive loop, reset the
                //       associated event (which is global, not per-thread).
                //       This does prevent somebody from skipping the
                //       interactive loop entirely (i.e. due to some kind of
                //       race condition); however, that is seen as an extremely
                //       remote possibility.  It is better that the interpreter
                //       loop event be put into a well-known state prior to
                //       actually entering the interactive loop.
                //
                if (!ResetInteractiveLoopDone(interpreter, out done))
                {
                    //
                    // NOTE: If we get to this point, the interactive loop
                    //       event cannot be trusted; therefore, be sure we
                    //       skip the interactive loop entirely.
                    //
                    done = true;

                    //
                    // NOTE: Attempt to notify the attached debugger, if any,
                    //       of the failure.
                    //
                    TraceOps.DebugTrace(
                        "PrivateInteractiveLoop: failed to reset " +
                        "interactive loop", typeof(Interpreter).Name,
                        TracePriority.EventError);
                }
                #endregion

                ///////////////////////////////////////////////////////////////

                #region The Interactive Loop
                //
                // NOTE: This is the start of the interactive input processing
                //       loop.  Exiting this loop will cause one level of the
                //       interactive loop to exit.  If the interactive loop
                //       being exited is the final one remaining, the Eagle
                //       Shell process will exit.  However, other applications
                //       may continue running if they no longer require an
                //       interactive loop or intend on restarting it at some
                //       point.
                //
                while (!IsInteractiveLoopDone(interpreter, done))
                {
                    #region Wait On Paused Interactive Loop
                    //
                    // NOTE: Before doing anything in the actual loop itself,
                    //       check to make sure this interactive loop has not
                    //       been paused -AND- if this interactive loop has
                    //       been paused, synchronously wait until it is no
                    //       longer paused before proceeding.
                    //
                    Result waitError = null;

                    if (ShellOps.WaitPausedInteractiveLoop(
                            interpreter, AppDomainOps.GetCurrentId(),
                            GlobalState.GetCurrentSystemThreadId(),
                            ShellOps.PauseMicroseconds,
                            ref waitError) != ReturnCode.Ok)
                    {
                        TraceOps.DebugTrace(String.Format(
                            "PrivateInteractiveLoop: wait error: {0}",
                            FormatOps.WrapOrNull(waitError)),
                            typeof(Interpreter).Name,
                            TracePriority.ShellError);
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Interactive Input / Result Processing Variables
                    //
                    // NOTE: Reset the interactive processing variables used
                    //       by input loop(s) and the output handling code.
                    //
                    bool previous = true; /* NOTE: Update previous input? */
                    bool show = true; /* NOTE: Show result by default. */
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Interactive Loop Input Processing
                    //
                    // NOTE: Re-grab the current interpreter flags.
                    //
                    InterpreterFlags interpreterFlags =
                        interpreter.PrivateInterpreterFlags;

                    //
                    // NOTE: Disable all timeout thread management?
                    //
                    /* EXEMPT */
                    bool noTimeout = FlagOps.HasFlags(interpreterFlags,
                        InterpreterFlags.NoInteractiveTimeout, true);

#if INTERACTIVE_COMMANDS
                    //
                    // NOTE: Disable all interactive commands?
                    //
                    /* EXEMPT */
                    bool noCommand = !interpreter.InteractiveCommandsEnabled;
#endif

                    //
                    // NOTE: Enable traces in interactive input processing?
                    //
                    /* EXEMPT */
                    bool trace = FlagOps.HasFlags(interpreterFlags,
                        InterpreterFlags.TraceInput, true);

                    //
                    // NOTE: Wait for the interactive loop semaphore instead
                    //       of bailing out if it is unavailable?
                    //
                    /* EXEMPT */
                    bool waitSemaphore = FlagOps.HasFlags(interpreterFlags,
                        InterpreterFlags.WaitInteractiveSemaphore, true);

                    //
                    // NOTE: Do not refresh the interactive host when reading
                    //       interactive input.
                    //
                    /* EXEMPT */
                    bool noRefresh = FlagOps.HasFlags(interpreterFlags,
                        InterpreterFlags.NoRefreshHost, true);

                    ///////////////////////////////////////////////////////////

                    //
                    // NOTE: Figure out if the local interactive host should
                    //       be refreshed before (-AND- during) the reading
                    //       interactive input.
                    //
                    bool? refresh = null;

                    if (noRefresh)
                        refresh = false;

                    ///////////////////////////////////////////////////////////

                    //
                    // NOTE: Declare the output variables used for processing
                    //       all interactive input, redirected or otherwise
                    //       (i.e. from the actual interactive user).
                    //
                    bool canceled;
                    string text;
                    bool notReady;
                    Result parseError;

                    //
                    // NOTE: Prevent other threads from attempting to obtain
                    //       interactive input, if applicable.  In order to
                    //       prevent additional complexity, primary threads
                    //       will always block waiting for the semaphore.
                    //
                    if (waitSemaphore || interpreter.IsPrimarySystemThread())
                    {
                        //
                        // NOTE: This thread may block (forever?) at this
                        //       point, if another thread is holding the
                        //       semaphore.
                        //
                        /* IGNORED */
                        EnterInteractiveLoopSemaphore(interpreter);
                    }
                    else if (!TryEnterInteractiveLoopSemaphore(interpreter))
                    {
                        //
                        // NOTE: We were unable to obtain the interactive
                        //       loop semaphore and the blocking wait flag
                        //       is not set; therefore, make sure input
                        //       processing is skipped.
                        //
                        TraceOps.DebugTrace(
                            "PrivateInteractiveLoop: could not acquire " +
                            "semaphore", typeof(Interpreter).Name,
                            TracePriority.LockError);

                        break;
                    }

                    try
                    {
                        //
                        // NOTE: Invoke the method directly responsible for
                        //       getting a complete [logical] line of
                        //       interactive input.  This method may return
                        //       input injected via the debugger interface
                        //       -OR- input, that may have been modified,
                        //       from a previous iteration of this loop (e.g.
                        //       from the interactive "#eval" command).
                        //
                        GetInteractiveInput(interpreter, refresh,
#if INTERACTIVE_COMMANDS
                            noCommand,
#endif
                            trace, loopData.Debug, false, localEngineFlags,
                            localSubstitutionFlags, loopData.ClientData,
                            forceCancel, forceHalt, ref interactiveHost,
                            ref savedText, ref localLoopData.exit,
                            ref done, ref previous, out canceled,
                            out text, out notReady, out parseError);
                    }
                    finally
                    {
                        /* IGNORED */
                        ExitInteractiveLoopSemaphore(interpreter);
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Interactive Host Begin-Processing Hook Callback
                    //
                    // NOTE: Give the interactive host the opportunity to
                    //       preview and possibly respond to the entered
                    //       command.
                    //
                    if (!done && (interactiveHost != null) &&
                        !HostOps.IsDisposed(interactiveHost))
                    {
                        ReturnCode beginCode;
                        Result beginError = null;

                        beginCode = interactiveHost.BeginProcessing(
                            interpreter.ActiveInteractiveLoops, ref text,
                            ref beginError);

                        if (beginCode != ReturnCode.Ok)
                        {
                            TraceOps.DebugTrace(String.Format(
                                "PrivateInteractiveLoop: host processing " +
                                "error, beginCode = {0}, beginError = {1}",
                                beginCode, FormatOps.WrapOrNull(true, true,
                                beginError)), typeof(Interpreter).Name,
                                TracePriority.HostError);

                            //
                            // NOTE: Processing has been halted by the
                            //       interactive host, bail out of the
                            //       interactive loop now.
                            //
                            done = true;
                        }
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Done & Input Flags Check
                    //
                    // NOTE: Now, evaluate the completed script entered by
                    //       the user (if they have not canceled).
                    //
                    if (done || canceled || notReady)
                    {
                        goto skipProcess;
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Interactive Command Hook Callback
                    //
                    // NOTE: If there is a registered interactive command
                    //       callback, call it now; optionally, this may
                    //       modify the interactive command.
                    //
                    if (ShouldInteractiveCommandCallback(ref text))
                    {
                        MaybeInteractiveCommandCallback(
                            interpreter, loopData.Debug, ref text);
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Empty Input Check (Outer)
                    if (StringOps.IsLogicallyEmpty(text))
                    {
                        goto skipProcess;
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Enter Debugger Active Level
#if DEBUGGER
                    //
                    // NOTE: Refresh the active debugger from the interpreter.
                    //
                    IDebugger debugger = interpreter.Debugger;

                    //
                    // NOTE: If we are debugging and the debugger is available
                    //       for this interpreter, increase one level of nested
                    //       debugger evaluations.  This is critical because it
                    //       is used by the engine to determine if breakpoints
                    //       should occur in the evaluated script and if the
                    //       halt flag for the interpreter should be reset
                    //       after the script is evaluated (below).
                    //
                    if (loopData.Debug &&
                        (debugger != null) && !debugger.Disposed)
                    {
                        debugger.SetActive(true);
                    }
#endif
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Reset Local Error Line Flag
                    //
                    // NOTE: In order to accurately preserve and display the
                    //       error line information, we need to know whether
                    //       the current command, interactive or otherwise,
                    //       actually set the error line.
                    //
                    bool haveErrorLine = false;
                    #endregion

                    ///////////////////////////////////////////////////////////

                    try
                    {
                        //
                        // NOTE: Check if an interactive command was entered
                        //       (e.g. one that starts with one or more "#"
                        //       characters); otherwise, evaluate the entered
                        //       input as a script.
                        //
                        // TODO: This code is still too messy.  Resolving and
                        //       executing interactive commands should be a
                        //       lot cleaner, simpler, and more efficient.
                        //
                        ///////////////////////////////////////////////////////

                        #region Interactive Command Dispatch
#if INTERACTIVE_COMMANDS
                        if (!noCommand && InteractiveOps.DispatchCommand(
                                interpreter, loopData, refresh, noCommand,
                                trace, ref interactiveHost, ref text,
                                ref savedText, ref tclsh, ref savedTclsh,
                                ref localEngineFlags,
                                ref localSubstitutionFlags,
                                ref localEventFlags, ref localExpressionFlags,
                                ref localHeaderFlags, ref localDetailFlags,
                                ref exact, ref canceled, ref notReady,
                                ref parseError, ref localErrorLine,
                                ref haveErrorLine, ref startedGcThread,
                                ref tclInterpName, ref done, ref previous,
                                ref show, ref forceCancel, ref forceHalt,
                                ref localCode, ref localResult, ref result))
                        {
                            //
                            // NOTE: The interactive command was processed;
                            //       there is nothing else to do.
                            //
                            goto skipCommand;
                        }
#endif
                        #endregion

                        ///////////////////////////////////////////////////////

                        #region Empty Input Check (Inner)
                        if (StringOps.IsLogicallyEmpty(text))
                        {
                            //
                            // NOTE: We did absolutely nothing, record no
                            //       previous interactive input and show no
                            //       result.
                            //
                            previous = false;
                            show = false;

                            goto skipCommand;
                        }
                        #endregion

                        ///////////////////////////////////////////////////////

                        #region Interactive Script Evaluation
                        try
                        {
#if NATIVE && TCL
                            #region Tcl Shell Emulation Mode
                            //
                            // NOTE: Are we operating in "tclsh emulation
                            //       mode"?  If so, try to get the active Tcl
                            //       parent interpreter and then use it to do
                            //       the script evaluation; otherwise, fallback
                            //       on the normal behavior of using the Eagle
                            //       interpreter.
                            //
                            if (tclsh)
                            {
                                localErrorLine = 0;

                                ///////////////////////////////////////////////

                                #region Evaluate Tcl Script
                                localCode = EvaluateInteractiveTclScript(
                                    interpreter, tclInterpName, text,
                                    ref localResult, ref localErrorLine);
                                #endregion

                                ///////////////////////////////////////////////

                                haveErrorLine = true;
                            }
                            #endregion
                            else
#endif
                            {
                                localErrorLine = 0;

                                ///////////////////////////////////////////////

                                #region Evaluate Eagle Script
                                //
                                // NOTE: Perform the script evaluation using
                                //       our local code and result variables
                                //       (i.e. do not change the primary
                                //       "interpreter result").  It should
                                //       also be noted that this evaluation
                                //       is not isolated in any other way and
                                //       will change the interpreter state.
                                //       This is somewhat tricky because of
                                //       various re-entrancy concerns.
                                //       Matters are further complicated by
                                //       script cancellation and timeouts.
                                //
                                localCode = EvaluateInteractiveScript(
                                    interpreter, text, localEngineFlags,
                                    localSubstitutionFlags, localEventFlags,
                                    localExpressionFlags, noTimeout,
                                    ref localResult, ref localErrorLine);
                                #endregion

                                ///////////////////////////////////////////////

                                haveErrorLine = true;

                                ///////////////////////////////////////////////

                                //
                                // NOTE: Make sure that the script just
                                //       evaluated did not dispose of the
                                //       interpreter before we try to access
                                //       it.
                                //
                                if (!interpreter.PrivateDisposed)
                                {
                                    #region [Maybe] Reset Halt Flag
                                    //
                                    // NOTE: Reset the interpreter halt flag if
                                    //       this is the outermost interactive
                                    //       loop and the interpreter evaluation
                                    //       nesting level is zero.
                                    //
                                    haltCode = Engine.InteractiveResetHalt(
                                        interpreter, ref haltReset,
                                        ref haltResult);

                                    if (haltCode != ReturnCode.Ok)
                                    {
                                        DebugOps.Complain(
                                            interpreter, haltCode,
                                            haltResult);
                                    }
#if PREVIOUS_RESULT
                                    else if (haltReset)
                                    {
                                        //
                                        // NOTE: Reset the previous result
                                        //       here; otherwise, the [debug
                                        //       break] command will pick up
                                        //       the now stale "INTERPRETER
                                        //       HALTED" result and run with
                                        //       it otherwise.
                                        //
                                        SetPreviousResult(interpreter, null);
                                    }
#endif
                                    #endregion

                                    ///////////////////////////////////////////

                                    #region Check Halt Flag
                                    //
                                    // NOTE: If debugging is still halted (i.e.
                                    //       the ResetHalt above had no effect
                                    //       because this is not the outermost
                                    //       interactive loop), then exit this
                                    //       interactive loop.
                                    //
                                    if (Engine.InteractiveIsHalted(interpreter,
                                            ref localResult) != ReturnCode.Ok)
                                    {
                                        result = localResult; /* TRANSFER */
                                        loopData.Code = ReturnCode.Error;

                                        //
                                        // NOTE: Set the "done" flag for this
                                        //       nested interactive loop now.
                                        //       This code used to simply use
                                        //       a C# "break" statement here;
                                        //       however, this is much cleaner
                                        //       because it permits the extra
                                        //       tasks performed at the bottom
                                        //       of this loop to be done.
                                        //
                                        done = true;
                                    }
                                    #endregion
                                }
                            }
                        }
                        finally
                        {
                            #region Restore Saved Tcl Shell Emulation Mode
                            //
                            // NOTE: If necessary, restore the saved setting
                            //       for "tclsh emulation mode".
                            //
                            if (savedTclsh != null)
                            {
                                tclsh = (bool)savedTclsh;
                                savedTclsh = null;
                            }
                            #endregion
                        }
                        #endregion

                        ///////////////////////////////////////////////////////

                        //
                        // NOTE: This point can be reached if there is no
                        //       command to process -OR- it was processed
                        //       and there was nothing else to do.
                        //
                    skipCommand:
                        ; // do nothing.

                    }
                    catch (Exception e)
                    {
                        TraceOps.DebugTrace(e, typeof(Interpreter).Name,
                            "PrivateInteractiveLoop: caught exception: ",
                            TracePriority.ShellError);
                    }
                    finally
                    {
                        #region Exit Debugger Active Level
#if DEBUGGER
                        //
                        // NOTE: Exit one level of nested debugger
                        //       evaluations.
                        //
                        debugger = interpreter.Debugger; /* REFRESH */

                        if (loopData.Debug &&
                            (debugger != null) && !debugger.Disposed)
                        {
                            debugger.SetActive(false);
                        }
#endif
                        #endregion
                    }

                    ///////////////////////////////////////////////////////////

                    #region Refresh Interpreter Host
                    //
                    // BUGFIX: We must reload the local interactive host
                    //         variable from the actual property because
                    //         it may have been changed by an interactive
                    //         command or script.
                    //
                    if (!noRefresh)
                        interactiveHost = interpreter.GetInteractiveHost();
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Set Debugger Result
                    //
                    // NOTE: If there is a debugger available, store a
                    //       copy of the local result in the debugger
                    //       result.
                    //
                    DebuggerOps.SetResult(
                        interpreter, localCode, localResult, false);
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Refresh Exit, Previous, and Show Flags
                    //
                    // NOTE: Make sure that we exit if the [exit] command was
                    //       used.
                    //
                    CheckExit(interpreter, ref localLoopData.exit);

                    //
                    // NOTE: Check if we are supposed to exit; if not, write
                    //       the result of the last operation.
                    //
                    if (loopData.Exit)
                    {
                        //
                        // NOTE: Exit from entire interactive loop [and
                        //       possibly the entire interpreter as well].
                        //       If the entire interpreter has been marked
                        //       as exited all nested interactive loops will
                        //       still exit cleanly.
                        //
                        done = true;
                    }
                    else
                    {
                        if (previous && !interpreter.PrivateDisposed)
                            interpreter.PreviousInteractiveInput = text;

                        if (show && (interactiveHost != null) &&
                            !HostOps.IsDisposed(interactiveHost))
                        {
                            interactiveHost.WriteResultLine(
                                localCode, localResult,
                                haveErrorLine ? localErrorLine : 0);
                        }
                    }
                    #endregion

                    ///////////////////////////////////////////////////////////

                    //
                    // NOTE: This point can be reached if there is no input
                    //       to process -OR- it cannot be processed due to
                    //       some error condition.
                    //
                skipProcess:

                    ///////////////////////////////////////////////////////////

                    #region Interactive Host End-Processing Hook Callback
                    if (!done && (interactiveHost != null) &&
                        !HostOps.IsDisposed(interactiveHost))
                    {
                        ReturnCode endCode;
                        Result endError = null;

                        endCode = interactiveHost.EndProcessing(
                            interpreter.ActiveInteractiveLoops, ref text,
                            ref endError);

                        if (endCode != ReturnCode.Ok)
                        {
                            TraceOps.DebugTrace(String.Format(
                                "PrivateInteractiveLoop: host processing " +
                                "error, endCode = {0}, endError = {1}",
                                endCode, FormatOps.WrapOrNull(true, true,
                                endError)), typeof(Interpreter).Name,
                                TracePriority.HostError);

                            //
                            // NOTE: Processing has been halted by the
                            //       interactive host, bail out of the
                            //       interactive loop now.
                            //
                            done = true;
                        }
                    }
                    #endregion
                } /* while (!IsInteractiveLoopDone(interpreter, done)) */
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Interactive Host Done-Processing Hook Callback
                if ((interactiveHost != null) &&
                    !HostOps.IsDisposed(interactiveHost))
                {
                    ReturnCode doneCode;
                    Result doneError = null;

                    doneCode = interactiveHost.DoneProcessing(
                        interpreter.ActiveInteractiveLoops, ref doneError);

                    if (doneCode != ReturnCode.Ok)
                    {
                        TraceOps.DebugTrace(String.Format(
                            "PrivateInteractiveLoop: host processing " +
                            "error, doneCode = {0}, doneError = {1}",
                            doneCode, FormatOps.WrapOrNull(true, true,
                            doneError)), typeof(Interpreter).Name,
                            TracePriority.HostError);
                    }
                }
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Restore / Pop Engine Flags
                if (loopData.Debug && !interpreter.PrivateDisposed)
                {
                    //
                    // BUGFIX: Restore engine flags to the state they were in
                    //         upon entry into this interactive loop.
                    //
                    interpreter.ContextEngineFlags = savedEngineFlags;

                    //
                    // NOTE: clear out the previously saved engine flags.
                    //       This statement serves as a reminder to re-think
                    //       the interpreter engine flag management, including
                    //       possibly adding a saved engine flags member to the
                    //       interpreter state.
                    //
                    savedEngineFlags = EngineFlags.None;
                }
                #endregion

                ///////////////////////////////////////////////////////////////

                #region GC Test Thread Cleanup
#if INTERACTIVE_COMMANDS
                //
                // BUGFIX: Always try to stop the garbage collection test
                //         thread if this interactive loop started it unless
                //         the current interpreter has already been disposed.
                //
                if (startedGcThread && !interpreter.PrivateDisposed)
                {
                    //
                    // NOTE: Acquire and hold the interpreter lock while
                    //       shutting down the garbage collection test
                    //       thread, if it is active.
                    //
                    lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
                    {
                        //
                        // NOTE: Does the interpreter have an active garbage
                        //       collection test thread?
                        //
                        if (interpreter.HasTestGcThread(true))
                        {
                            ReturnCode gcCode;
                            Result gcResult = null;

                            gcCode = interpreter.InterruptTestGcThread(
                                null, false, false, ref gcResult);

                            if (gcCode != ReturnCode.Ok)
                            {
                                DebugOps.Complain(
                                    interpreter, gcCode, gcResult);
                            }
                        }
                    }
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////

                #region Write Interactive Footer
                //
                // BUGFIX: Skip writing anything if the interpreter host has
                //         already been disposed.
                //
                if (loopData.Debug && !loopData.Exit &&
                    (interactiveHost != null) &&
                    !HostOps.IsDisposed(interactiveHost))
                {
                    //
                    // NOTE: Attempt to cast the interactive host to an
                    //       informational host.  If this fails, we simply
                    //       ignore it because it is not strictly required
                    //       for proper functioning of the interactive loop.
                    //
                    IInformationHost informationHost =
                        interactiveHost as IInformationHost;

                    bool proxy = AppDomainOps.IsTransparentProxy(
                        informationHost);

                    if (informationHost != null)
                    {
                        informationHost.WriteFooter(
                            interpreter, new InteractiveLoopData(
                            loopData, !proxy ? loopData.Token : null,
                            !proxy ? loopData.TraceInfo : null,
                            DebuggerOps.GetHeaderFlags(
                                interactiveHost, loopData.HeaderFlags,
                                loopData.Debug, true, false,
                                loopData.Debug)
                            ), result);
                    }
                }
                #endregion

                ///////////////////////////////////////////////////////////////

                //
                // NOTE: We can get to this label if the script evaluated in
                //       the script initialization code block (above) calls
                //       the [exit] command (or does something else that
                //       causes the interpreter to be marked as exited) for
                //       some (any?) reason.
                //
            skipLoop:

                ///////////////////////////////////////////////////////////////

                #region Restore / Pop Interactive Loop Level
                //
                // NOTE: Restore the saved interactive loop level now.  This
                //       involves changing several related thread-specific
                //       properties of our interactive interpreter instance.
                //
                // if (!interpreter.PrivateDisposed) /* REDUNDANT */
                {
                    interpreter.PopLocalInteractiveLoopLevel(
                        sameAppDomain, ref savedInteractiveThread,
                        ref savedInteractive, ref savedLoopData);
                }
                #endregion

                ///////////////////////////////////////////////////////////////

                #region [Maybe] Reset Halt Flag
                //
                // NOTE: This must be done _after_ the block (above) that
                //       reduces the number of active interactive loops;
                //       otherwise, the halt flag will not be reset when it
                //       really should be.
                //
                // BUGFIX: No need to reset the halt flag if the interpreter
                //         has been disposed.
                //
                if (!interpreter.PrivateDisposed)
                {
                    //
                    // NOTE: Possibly reset the "halt" state for the
                    //       interpreter (if there are no more nested
                    //       loops).
                    //
                    haltCode = Engine.InteractiveResetHalt(
                        interpreter, ref haltReset, ref haltResult);

                    if (haltCode != ReturnCode.Ok)
                    {
                        DebugOps.Complain(
                            interpreter, haltCode, haltResult);
                    }
#if PREVIOUS_RESULT
                    else if (haltReset)
                    {
                        //
                        // NOTE: Reset the previous result here; otherwise,
                        //       the [debug break] command will pick up the
                        //       now stale "INTERPRETER HALTED" result and
                        //       run with it otherwise.
                        //
                        SetPreviousResult(interpreter, null);
                    }
#endif
                }
                #endregion

                ///////////////////////////////////////////////////////////////

                return loopData.Code;
            }
            finally
            {
                TraceOps.DebugTrace(String.Format(
                    "PrivateInteractiveLoop: exited, interpreter = {0}, " +
                    "loopData = {1}, result = {2}",
                    FormatOps.InterpreterNoThrow(interpreter),
                    FormatOps.InteractiveLoopData(loopData),
                    FormatOps.WrapOrNull(true, true, result)),
                    typeof(Interpreter).Name, TracePriority.ShellDebug);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        //
        // WARNING: This property is intended for use by the ContextManager
        //          class only.  Please use the "InteractiveLoopSemaphore"
        //          property instead.  Assumes interpreter lock is held.
        //
        internal Semaphore InternalInteractiveLoopSemaphore
        {
            get { return interactiveLoopSemaphore; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void ResetInteractiveLoopSemaphore()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
#if !THREADING
                Semaphore semaphore = InteractiveLoopSemaphore; /* NOTE: Context only. */
                savedInteractiveLoopSemaphore = semaphore; /* NOTE: Field. */
#endif

                InteractiveLoopSemaphore = null; /* NOTE: Context only. */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void RestoreInteractiveLoopSemaphore()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                Semaphore semaphore;

#if THREADING
                semaphore = interactiveLoopSemaphore; /* NOTE: Field. */
#else
                semaphore = savedInteractiveLoopSemaphore; /* NOTE: Field. */
#endif

                InteractiveLoopSemaphore = semaphore; /* NOTE: Context only. */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool EnterInteractiveLoopSemaphore(
            Interpreter interpreter
            )
        {
#if DEBUG && VERBOSE
            TraceOps.DebugTrace(String.Format(
                "EnterInteractiveLoopSemaphore: interpreter = {0}",
                FormatOps.InterpreterNoThrow(interpreter)),
                typeof(Interpreter).Name, TracePriority.LoopDebug);
#endif

            if ((interpreter == null) || ScriptOps.HasFlags(interpreter,
                    InterpreterFlags.NoInteractiveSemaphore, true))
            {
                return false;
            }

            Semaphore semaphore;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return false;

                semaphore = interpreter.InteractiveLoopSemaphore;
            }

            if (semaphore == null)
                return false;

            return ThreadOps.WaitSemaphore(semaphore);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool TryEnterInteractiveLoopSemaphore(
            Interpreter interpreter
            )
        {
            return TryEnterInteractiveLoopSemaphore(
                interpreter, ThreadOps.GetDefaultTimeout(
                TimeoutType.Lock), true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static bool TryEnterInteractiveLoopSemaphore(
            Interpreter interpreter,
            int timeout,
            bool @default
            )
        {
#if DEBUG && VERBOSE
            TraceOps.DebugTrace(String.Format(
                "TryEnterInteractiveLoopSemaphore: interpreter = {0}, " +
                "timeout = {1}", FormatOps.InterpreterNoThrow(interpreter),
                timeout), typeof(Interpreter).Name, TracePriority.LoopDebug);
#endif

            if ((interpreter == null) || ScriptOps.HasFlags(interpreter,
                    InterpreterFlags.NoInteractiveSemaphore, true))
            {
                return @default;
            }

            Semaphore semaphore;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return false;

                semaphore = interpreter.InteractiveLoopSemaphore;
            }

            if (semaphore == null)
                return @default;

            return ThreadOps.WaitSemaphore(semaphore, timeout);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static bool ExitInteractiveLoopSemaphore(
            Interpreter interpreter
            )
        {
#if DEBUG && VERBOSE
            TraceOps.DebugTrace(String.Format(
                "ExitInteractiveLoopSemaphore: interpreter = {0}",
                FormatOps.InterpreterNoThrow(interpreter)),
                typeof(Interpreter).Name,
                TracePriority.LoopDebug);
#endif

            if ((interpreter == null) || ScriptOps.HasFlags(interpreter,
                    InterpreterFlags.NoInteractiveSemaphore, true))
            {
                return false;
            }

            Semaphore semaphore;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return false;

                semaphore = interpreter.InteractiveLoopSemaphore;
            }

            if (semaphore == null)
                return false;

            return (ThreadOps.ReleaseSemaphore(semaphore) == 0);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal EventWaitHandle InteractiveLoopDoneEvent
        {
            get
            {
                // CheckDisposed();

                lock (syncRoot)
                {
                    return interactiveLoopDoneEvent;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool ResetInteractiveLoopDone(
            Interpreter interpreter,
            out bool done
            )
        {
#if DEBUG && VERBOSE
            TraceOps.DebugTrace(String.Format(
                "ResetInteractiveLoopDone: interpreter = {0}",
                FormatOps.InterpreterNoThrow(interpreter)),
                typeof(Interpreter).Name,
                TracePriority.LoopDebug);
#endif

            done = false;

            if (interpreter == null)
                return false;

            EventWaitHandle @event;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return false;

                @event = interpreter.InteractiveLoopDoneEvent;
            }

            return ThreadOps.ResetEvent(@event);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This method is used by the test suite.
        //          Please do not modify or remove it.
        //
        private static bool SetInteractiveLoopDone(
            Interpreter interpreter,
            out bool done
            )
        {
#if DEBUG && VERBOSE
            TraceOps.DebugTrace(String.Format(
                "SetInteractiveLoopDone: interpreter = {0}",
                FormatOps.InterpreterNoThrow(interpreter)),
                typeof(Interpreter).Name,
                TracePriority.LoopDebug);
#endif

            done = true;

            if (interpreter == null)
                return false;

            EventWaitHandle @event;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return false;

                @event = interpreter.InteractiveLoopDoneEvent;
            }

            return ThreadOps.SetEvent(@event);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool IsInteractiveLoopDone(
            Interpreter interpreter,
            bool done
            )
        {
            if (done)
                return true;

            if (interpreter == null)
                return true;

            EventWaitHandle @event;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return true;

                @event = interpreter.InteractiveLoopDoneEvent;
            }

            return ThreadOps.WaitEvent(@event, 0);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeInteractiveLoopData()
        {
#if !THREADING
            ThreadOps.CloseSemaphore(ref savedInteractiveLoopSemaphore);
#endif

            ThreadOps.CloseSemaphore(ref interactiveLoopSemaphore);
            ThreadOps.CloseEvent(ref interactiveLoopDoneEvent);
        }
        #endregion
#endif
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Entity Manager Support
        #region Policy Support
        #region Engine Interface Methods
        internal ReturnCode CheckPluginPolicies( /* BEFORE */
            PolicyFlags flags,
            AssemblyName assemblyName,
            string typeName,
            string fileName,
            byte[] bytes,
            IClientData clientData,
            ref PolicyDecision decision,
            ref Result result
            )
        {
            return CheckPolicies(
                MethodFlags.PluginPolicy | MethodFlags.OtherPolicy, flags,
                assemblyName, typeName, null, null, null, fileName, bytes,
                null, null, null, null, clientData, ref decision, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode CheckCommandPolicies( /* BEFORE */
            PolicyFlags flags,
            IExecute execute,
            ArgumentList arguments,
            IClientData clientData,
            ref PolicyDecision decision,
            ref Result result
            )
        {
            return CheckPolicies(
                MethodFlags.CommandPolicy | MethodFlags.OtherPolicy, flags,
                null, null, execute, arguments, null, null, null, null,
                null, null, null, clientData, ref decision, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode CheckScriptPolicies( /* BEFORE */
            PolicyFlags flags,
            IScript script,
            Encoding encoding,
            IClientData clientData,
            ref PolicyDecision decision,
            ref Result result
            )
        {
            string hashAlgorithmName = null; /* NOTE: Means "use default". */
            byte[] hashValue = null;

            if (!FlagOps.HasFlags(flags, PolicyFlags.BeforeNoHash, true))
            {
                Result hashError = null;

                hashValue = RuntimeOps.HashScript(
                    hashAlgorithmName, script, encoding, ref hashError);

                if (hashValue == null)
                    DebugOps.Complain(this, ReturnCode.Error, hashError);
            }

            return CheckPolicies(
                MethodFlags.ScriptPolicy | MethodFlags.OtherPolicy, flags,
                null, null, null, null, script, null, null, null,
                (encoding != null) ? encoding : GetPolicyEncoding(false),
                hashValue, hashAlgorithmName, clientData, ref decision,
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode CheckBeforeFilePolicies(
            PolicyFlags flags,
            string fileName,
            Encoding encoding,
            IClientData clientData,
            ref PolicyDecision decision,
            ref Result result
            )
        {
            string hashAlgorithmName = null; /* NOTE: Means "use default". */
            byte[] hashValue = null;

            if (!FlagOps.HasFlags(flags, PolicyFlags.BeforeNoHash, true))
            {
                Result hashError = null;

                hashValue = RuntimeOps.HashFile(
                    hashAlgorithmName, fileName, encoding, ref hashError);

                if (hashValue == null)
                    DebugOps.Complain(this, ReturnCode.Error, hashError);
            }

            return CheckPolicies(
                MethodFlags.FilePolicy | MethodFlags.OtherPolicy, flags,
                null, null, null, null, null, fileName, null, null,
                (encoding != null) ? encoding : GetPolicyEncoding(true),
                hashValue, hashAlgorithmName, clientData, ref decision,
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode CheckAfterFilePolicies(
            PolicyFlags flags,
            string fileName,
            string text,
            Encoding encoding,
            IClientData clientData,
            ref PolicyDecision decision,
            ref Result result
            )
        {
            string hashAlgorithmName = null; /* NOTE: Means "use default". */
            byte[] hashValue = null;

            if (!FlagOps.HasFlags(flags, PolicyFlags.AfterNoHash, true))
            {
                Result hashError = null;

                hashValue = RuntimeOps.HashString(
                    hashAlgorithmName, text, encoding, ref hashError);

#if DEBUG && VERBOSE
                if (hashValue == null)
                    DebugOps.Complain(this, ReturnCode.Error, hashError);
#endif
            }

            return CheckPolicies(
                MethodFlags.FilePolicy | MethodFlags.OtherPolicy, flags,
                null, null, null, null, null, fileName, null, text,
                (encoding != null) ? encoding : GetPolicyEncoding(true),
                hashValue, hashAlgorithmName, clientData, ref decision,
                ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode CheckBeforeStreamPolicies(
            PolicyFlags flags,
            string name,
            Encoding encoding,
            IClientData clientData,
            ref PolicyDecision decision,
            ref Result result
            )
        {
            return CheckPolicies(
                MethodFlags.StreamPolicy | MethodFlags.OtherPolicy, flags,
                null, null, null, null, null, name, null, null,
                (encoding != null) ? encoding : GetPolicyEncoding(false),
                null, null, clientData, ref decision, ref result);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode CheckAfterStreamPolicies(
            PolicyFlags flags,
            string name,
            string text,
            Encoding encoding,
            IClientData clientData,
            ref PolicyDecision decision,
            ref Result result
            )
        {
            string hashAlgorithmName = null; /* NOTE: Means "use default". */
            byte[] hashValue = null;

            if (!FlagOps.HasFlags(flags, PolicyFlags.AfterNoHash, true))
            {
                Result hashError = null;

                hashValue = RuntimeOps.HashString(
                    hashAlgorithmName, text, encoding, ref hashError);

#if DEBUG && VERBOSE
                if (hashValue == null)
                    DebugOps.Complain(this, ReturnCode.Error, hashError);
#endif
            }

            return CheckPolicies(
                MethodFlags.StreamPolicy | MethodFlags.OtherPolicy, flags,
                null, null, null, null, null, name, null, text,
                (encoding != null) ? encoding : GetPolicyEncoding(false),
                hashValue, hashAlgorithmName, clientData, ref decision,
                ref result);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool HasSecurity()
        {
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.SecurityWasEnabled, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HasPendingPolicies()
        {
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.PendingPolicies, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void SetPendingPolicies(
            bool pending
            )
        {
            if (pending)
                interpreterStateFlags |= InterpreterStateFlags.PendingPolicies;
            else
                interpreterStateFlags &= ~InterpreterStateFlags.PendingPolicies;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static Encoding GetPolicyEncoding(
            bool rawBytes
            )
        {
            return rawBytes ? OneByteEncoding.OneByte :
                StringOps.GetEncoding(EncodingType.Default);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeEmitPolicyResults(
            PolicyWrapperDictionary allPolicies,
            PolicyWrapperDictionary failedPolicies,
            MethodFlags methodFlags,
            PolicyFlags policyFlags,
            string fileName,
            ReturnCode code,
            PolicyDecision decision,
            Result result
            )
        {
#if !DEBUG
            if (PolicyOps.IsSuccess(code, decision))
                return;
#endif

            string formatted = FormatOps.MaybeEmitPolicyResults(
                allPolicies, failedPolicies, methodFlags, policyFlags,
                fileName, code, decision, result);

            TraceOps.DebugTrace(
                formatted, typeof(Interpreter).Name,
                TracePriority.PolicyDebug2);

#if DEBUG && VERBOSE
            if (!PolicyOps.IsSuccess(code, decision))
                DebugOps.Complain(this, code, formatted);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode CheckPolicies(
            MethodFlags methodFlags,
            PolicyFlags policyFlags,
            AssemblyName assemblyName,
            string typeName,
            IExecute execute,
            ArgumentList arguments,
            IScript script,
            string fileName,
            byte[] bytes,
            string text,
            Encoding encoding,
            byte[] hashValue,
            string hashAlgorithmName,
            IClientData clientData,
            ref PolicyDecision decision,
            ref Result result
            )
        {
            ReturnCode code = ReturnCode.Ok;

            if (HasPendingPolicies() || (PolicyLevels != 0))
                return code;

            //
            // NOTE: Grab a copy of the policy collection.
            //
            PolicyWrapperDictionary allPolicies = CopyPolicies();

            //
            // NOTE: How many policies with good intentions have failed?
            //
            PolicyWrapperDictionary failedPolicies = null;

            //
            // NOTE: Does this interpreter support policies?
            //
            if (allPolicies == null)
                return code;

            //
            // NOTE: Prevent endless policy recursion.
            //
            SetPendingPolicies(true);

            try
            {
                //
                // NOTE: Create the policy data object with the current policy
                //       related information (including the original decision,
                //       which is typically "unknown").
                //
                IPolicyContext policyContext = PolicyContext.Create(
                    policyFlags, assemblyName, typeName, execute, arguments,
                    script, fileName, bytes, text, encoding, hashValue,
                    hashAlgorithmName, clientData, /* interpreter */ null,
                    /* plugin */ null, decision);

                //
                // NOTE: When going through the generic callback delegates, we
                //       need to wrap our object in a clientData.
                //
                IClientData policyClientData = new ClientData(policyContext);

                //
                // NOTE: Process each policy (as long as they all continue
                //       to succeed).
                //
                foreach (KeyValuePair<string, _Wrappers.Policy> pair in allPolicies)
                {
                    IPolicy policy = pair.Value;

                    //
                    // NOTE: Skip invalid policies.
                    //
                    if (policy == null)
                        continue;

                    //
                    // NOTE: Do not invoke the policy if it has been disabled.
                    //
                    if (EntityOps.IsDisabled(policy))
                        continue;

                    //
                    // NOTE: Only execute the policies which match the specified
                    //       flags (i.e. command or file policies).
                    //
                    // FIXME: *PERF* Make sure this does not impact policy
                    //        performance too seriously.
                    //
                    if (!EntityOps.HasFlags(policy, methodFlags, false))
                        continue;

                    //
                    // NOTE: Since policies can basically do anything they want,
                    //       we wrap them in a try block to prevent exceptions
                    //       from escaping.
                    //
                    EnterPolicyLevel();

                    try
                    {
                        //
                        // HACK: Since we need the plugin to vary with each
                        //       policy called, do that now (i.e. to provide
                        //       more context for isolated policy support).
                        //
                        // TODO: Improve the locking semantics here.
                        //
                        PolicyDecision beforeDecision = policyContext.Decision;
                        PolicyDecision afterDecision = beforeDecision;

                        try
                        {
                            policyContext.Interpreter = this;
                            policyContext.Plugin = policy.Plugin;

                            code = policy.Execute(
                                this, policyClientData, arguments, ref result);

                            afterDecision = policyContext.Decision;
                        }
                        finally
                        {
                            if ((code != ReturnCode.Ok) ||
                                (PolicyOps.IsSuccess(beforeDecision) &&
                                !PolicyOps.IsSuccess(afterDecision)))
                            {
                                if (failedPolicies == null)
                                    failedPolicies = new PolicyWrapperDictionary();

                                failedPolicies.Add(pair.Key, pair.Value);
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        //
                        // NOTE: Translate exceptions to a failure return.
                        //
                        result = String.Format(
                            "caught exception while checking policies: {0}",
                            e);

                        code = ReturnCode.Error;
                    }
                    finally
                    {
                        ExitPolicyLevel();
                    }

                    //
                    // NOTE: Check for exception results specially because we
                    //       treat "Break" different from other return codes.
                    //
                    if (code == ReturnCode.Break)
                    {
                        //
                        // NOTE: Success; however, skip processing further
                        //       traces for this policy operation.
                        //
                        code = ReturnCode.Ok;
                        break;
                    }
                    else if (code != ReturnCode.Ok)
                    {
                        //
                        // NOTE: Some type of failure (or exception), stop
                        //       processing for this policy operation.
                        //
                        break;
                    }
                }

                //
                // NOTE: If all the policies succeeded and our local "pass" status
                //       is valid, copy it to the variable provided by the caller.
                //
                if (code == ReturnCode.Ok)
                {
                    //
                    // NOTE: Each policy gets one "vote" about whether or not to
                    //       allow the execution of the command.  One or more of
                    //       the current policies must agree for the execution of
                    //       the command to be allowed.  There must always be at
                    //       least one policy that "votes" to allow execution of
                    //       the command before it will be allowed (i.e. the
                    //       default policy denies everything).
                    //
                    decision = policyContext.Decision;

                    //
                    // NOTE: If there is no result so far, use the reason given
                    //       for the policy decision, if any.  We do not care if
                    //       the reason is null at this point.
                    //
                    if (result == null)
                        result = policyContext.Reason;
                }

                bool maybeEmit = true;

#if POLICY_TRACE
                bool didEmit = false;

                TraceOps.MaybeEmitPolicyTrace(
                    "CheckPolicies", this, ref didEmit, "methodFlags",
                    methodFlags, "policyFlags", policyFlags, "assemblyName",
                    assemblyName, "typeName", typeName, "execute", execute,
                    "arguments", arguments, "script", script, "fileName",
                    fileName, "bytes", bytes, "text", text, "encoding",
                    encoding, "hashValue", hashValue, "hashAlgorithmName",
                    hashAlgorithmName, "clientData", clientData, "decision",
                    decision, "code", code, "result", result);

                if (didEmit && PolicyOps.IsSuccess(code, decision))
                    maybeEmit = false;
#endif

                if (maybeEmit)
                {
                    MaybeEmitPolicyResults(
                        allPolicies, failedPolicies, methodFlags,
                        policyFlags, fileName, code, decision,
                        result);
                }
            }
            finally
            {
                //
                // NOTE: Remove policy prevention flag.
                //
                SetPendingPolicies(false);
            }

            return code;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Trace Support
        private bool HasPendingTraces()
        {
            return FlagOps.HasFlags(interpreterStateFlags,
                InterpreterStateFlags.PendingTraces, true); /* EXEMPT */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private void SetPendingTraces(
            bool pending
            )
        {
            if (pending)
                interpreterStateFlags |= InterpreterStateFlags.PendingTraces;
            else
                interpreterStateFlags &= ~InterpreterStateFlags.PendingTraces;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal TraceList GetTraces(
            TraceList traces,
            string varName,
            string varIndex,
            object varValue,
            bool? array
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                TraceList result = null;

                TraceList globalTraces = MakeTraceList(
                    varName, varIndex, varValue, array, null);

                if ((globalTraces != null) || (traces != null))
                {
                    result = new TraceList();

                    if (traces != null)
                        result.AddRange(traces);

                    if (globalTraces != null)
                        result.AddRange(globalTraces);
                }

                return result;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool NeedNewTraceInfo(
            VariableFlags flags
            )
        {
            if (FlagOps.HasFlags(flags, VariableFlags.NewTraceInfo, true))
                return true;

            //
            // NOTE: Query the number of trace levels at this point.
            //       Normally, this should be exactly one.
            //
            int levels = TraceLevels;

#if DEBUGGER
            //
            // NOTE: When compiled with integrated debugger support,
            //       also count the number of watchpoint levels.
            //
            levels += WatchpointLevels;
#endif

            return (levels > 0);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode ClearVariableFlagsOrLink(
            ICallFrame frame,
            IVariable savedVariable,
            IVariable variable,
            ITraceInfo traceInfo,
            TraceList traces,
            ref bool wasUndefined,
            ref Result error
            )
        {
            //
            // BUGFIX: The variable may have been undefined or a link to a
            //         variable in an undefined call frame.
            //
            if (variable != null)
            {
                wasUndefined = EntityOps.IsUndefined(variable);
                bool isLink = EntityOps.IsLink(variable);

                if (wasUndefined || isLink)
                {
                    //
                    // NOTE: First, grab the variable flags from the trace, if
                    //       any.
                    //
                    VariableFlags flags = (traceInfo != null) ?
                        traceInfo.Flags : VariableFlags.None;

                    //
                    // NOTE: Next, attempt to obtain the call frame that this
                    //       variable belongs to.
                    //
                    ICallFrame variableFrame = frame;

                    if (GetVariableFrameViaResolvers(
                            LookupFlags.Default, ref variableFrame, ref flags,
                            ref error) != ReturnCode.Ok)
                    {
                        return ReturnCode.Error;
                    }

                    //
                    // NOTE: Next, figure out which variable flags need to be
                    //       masked off.  If the variable is being recycled
                    //       (i.e. because it was previously undefined), there
                    //       are additional flags to mask off.
                    //
                    VariableFlags flagsMask = VariableFlags.NonSetMask;

                    if (wasUndefined)
                        flagsMask = VariableFlags.NonDefinedMask;

                    //
                    // NOTE: Next, reset the flags to the ones provided by the
                    //       caller, masking off any invalid ones.
                    //
                    variable.Flags = (flags & ~flagsMask);

                    //
                    // NOTE: If this variable was pointed to by a link, make
                    //       sure that link is "defined" now as well.
                    //
                    if ((savedVariable != null) &&
                        !Object.ReferenceEquals(savedVariable, variable))
                    {
                        EntityOps.SetUndefined(savedVariable, false);
                    }

                    //
                    // NOTE: Next, make sure the variable is no longer a link
                    //       to another variable, if necessary.
                    //
                    if (isLink)
                    {
                        EntityOps.SetLink(variable, false);

                        variable.Link = null;
                        variable.LinkIndex = null;
                    }

                    //
                    // NOTE: Next, flag the variable as either global or local,
                    //       depending on the call frame it resides in.
                    //
                    if (IsGlobalCallFrame(variableFrame))
                        EntityOps.SetGlobal(variable, true);
                    else
                        EntityOps.SetLocal(variable, true);

                    //
                    // NOTE: Next, reset the traces for this variable to the
                    //       same ones that would be assigned to brand new
                    //       variables.
                    //
                    variable.Traces = GetTraces(
                        traces, null, null, null, null);
                }
            }
            else
            {
                //
                // NOTE: There is no variable; therefore, it cannot be
                //       undefined.
                //
                wasUndefined = false;
            }

            return ReturnCode.Ok;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Alias Support
        internal ReturnCode GetAliasArguments(
            IAlias alias,
            ArgumentList arguments,
            ref string targetName
            )
        {
            ArgumentList targetArguments = null;

            return GetAliasArguments(
                alias, arguments, ref targetName, ref targetArguments);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetAliasArguments(
            IAlias alias,
            ArgumentList arguments,
            ref string targetName,
            ref ArgumentList targetArguments
            )
        {
            Result error = null;

            return GetAliasArguments(
                alias, arguments, ref targetName, ref targetArguments, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetAliasArguments(
            IAlias alias,
            ArgumentList arguments,
            ref string targetName,
            ref Result error
            )
        {
            ArgumentList targetArguments = null;

            return GetAliasArguments(
                alias, arguments, ref targetName, ref targetArguments, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetAliasArguments(
            IAlias alias,
            ArgumentList arguments,
            ref string targetName,
            ref ArgumentList targetArguments,
            ref Result error
            )
        {
            ReturnCode code;

            if (alias != null)
            {
                AliasFlags aliasFlags = alias.AliasFlags;

                bool mergeArguments = FlagOps.HasFlags(
                    aliasFlags, AliasFlags.MergeArguments, true);

                bool skipTargetName = FlagOps.HasFlags(
                    aliasFlags, AliasFlags.SkipTargetName, true);

                bool skipSourceName = FlagOps.HasFlags(
                    aliasFlags, AliasFlags.SkipSourceName, true);

                bool useTargetRemaining = FlagOps.HasFlags(
                    aliasFlags, AliasFlags.UseTargetRemaining, true);

                if (mergeArguments)
                {
                    //
                    // NOTE: Merged argument handling, carefully merge the
                    //       option and non-option arguments from the first
                    //       and second lists.  The start index for the second
                    //       list here is hard-coded to one because we know
                    //       that the command name itself is the first argument
                    //       in the second list.
                    //
                    code = PrivateMergeArguments(
                        alias.Options, alias.Arguments, arguments,
                        OptionBehaviorFlags.Default, alias.StartIndex, 1,
                        skipTargetName, skipSourceName, useTargetRemaining,
                        ref targetArguments, ref error);
                }
                else
                {
                    targetArguments = null;

                    //
                    // NOTE: Standard argument handling, simply append the
                    //       arguments from the first and second lists, in that
                    //       order, to the target argument list.
                    //
                    if ((alias.Arguments != null) || (arguments != null))
                        targetArguments = new ArgumentList();

                    if (alias.Arguments != null)
                    {
                        targetArguments.AddRange(ArgumentList.GetRange(
                            alias.Arguments, skipTargetName ? 1 : 0));
                    }

                    if (arguments != null)
                    {
                        targetArguments.AddRange(ArgumentList.GetRange(
                            arguments, skipSourceName ? 1 : 0));
                    }

                    code = ReturnCode.Ok;
                }

                //
                // NOTE: If necessary, modify the first argument to be the
                //       alias name.  Afterwards, always provide the value of
                //       the first argument to the caller.
                //
                targetName = null;

                if ((targetArguments != null) && (targetArguments.Count > 0))
                    targetName = targetArguments[0];
            }
            else
            {
                error = "invalid alias";
                code = ReturnCode.Error;
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetAliasTarget(
            IAlias alias,
            string targetName,
            ArgumentList targetArguments,
            LookupFlags lookupFlags,
            bool strict,
            ref IExecute target
            )
        {
            bool useUnknown = false;
            Result error = null;

            return GetAliasTarget(
                alias, targetName, targetArguments, lookupFlags, strict,
                ref target, ref useUnknown, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetAliasTarget(
            IAlias alias,
            string targetName,
            ArgumentList targetArguments,
            LookupFlags lookupFlags,
            bool strict,
            ref IExecute target,
            ref Result error
            )
        {
            bool useUnknown = false;

            return GetAliasTarget(
                alias, targetName, targetArguments, lookupFlags, strict,
                ref target, ref useUnknown, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetAliasTarget(
            IAlias alias,
            string targetName,
            ArgumentList targetArguments,
            LookupFlags lookupFlags,
            bool strict,
            ref IExecute target,
            ref bool useUnknown,
            ref Result error
            )
        {
            if (alias == null)
            {
                error = "invalid alias";
                return ReturnCode.Error;
            }

            //
            // NOTE: First, try for the pre-resolved target.
            //
            target = alias.Target;

            //
            // NOTE: Otherwise, is this a late-bound alias?
            //
            if (target != null)
            {
                //
                // NOTE: Success, just return it.
                //
                return ReturnCode.Ok;
            }
            else
            {
                //
                // NOTE: Query the necessary engine flags for use with the
                //       resolver subsystem.
                //
                EngineFlags engineFlags = GetResolveEngineFlagsNoLock(true);

                //
                // NOTE: If this alias has the global flag, make sure to use
                //       the global engine flag (to the resolver) as well.
                //
                if (FlagOps.HasFlags(
                        alias.AliasFlags, AliasFlags.GlobalNamespace, true))
                {
                    engineFlags |= EngineFlags.GlobalOnly;
                }

                ReturnCode code;
                Result localError = null;

                //
                // NOTE: Not found; lookup the target by name.
                //
                code = GetIExecuteViaResolvers(
                    engineFlags, targetName, targetArguments, lookupFlags,
                    ref target, ref localError);

                //
                // NOTE: During the alias creation process, the target
                //       does not have to be defined.  However, during
                //       the execution process, it does.  This can only
                //       work if there are target arguments since there
                //       is no other usable basis to use for looking up
                //       an executable entity.
                //
                if (code != ReturnCode.Ok)
                {
                    //
                    // NOTE: Attempt to use the unknown handler for
                    //       the interpreter when the target cannot
                    //       be resolved (COMPAT: Tcl).
                    //
                    code = AttemptToUseUnknown(
                        code, engineFlags | EngineFlags.GlobalOnly,
                        lookupFlags, ref targetArguments, ref target,
                        ref useUnknown);

                    if (code != ReturnCode.Ok)
                    {
                        if (!strict)
                            code = ReturnCode.Ok;
                        else
                            error = localError;
                    }
                }

                return code;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string GetAliasNameToken(string name)
        {
            //
            // NOTE: Initially, the name token is the same as the name;
            //       however, this may change later if the command is
            //       renamed.
            //
            string result = name;

            if (!String.IsNullOrEmpty(result))
            {
                while (DoesAliasExist(result) == ReturnCode.Ok)
                {
                    /*
                     * NOTE: This comment stolen from "generic/tclInterp.c".
                     *
                     * The alias name cannot be used as unique token, it is already taken.
                     * We can produce a unique token by prepending "::" repeatedly. This
                     * algorithm is a stop-gap to try to maintain the command name as
                     * token for most use cases, fearful of possible backwards compat
                     * problems. A better algorithm would produce unique tokens that need
                     * not be related to the command name.
                     *
                     * ATTENTION: the tests in interp.test and possibly safe.test depend
                     * on the precise definition of these tokens.
                     *
                     */
                    result = TclVars.Namespace.Separator + result;
                }
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void GetCommandNamesForRename(
            IIdentifierName identifierName, /* in */
            bool noNamespaces,              /* in */
            ref string oldCommandName,      /* out */
            ref string newCommandName       /* in, out */
            )
        {
            if (identifierName == null)
                return;

            oldCommandName = identifierName.Name;

            if (oldCommandName == null)
                return;

            bool useNamespaces = !noNamespaces && AreNamespacesEnabled();

            if (useNamespaces && !NamespaceOps.IsQualifiedName(newCommandName))
            {
                INamespace @namespace = NamespaceOps.LookupParent(
                    this, oldCommandName, false, true, false);

                if (@namespace != null)
                {
                    newCommandName = NamespaceOps.MakeQualifiedName(
                        this, @namespace, newCommandName);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IAlias FollowAlias(
            IAlias alias,
            IAlias nextAlias,
            string newName
            )
        {
            IAlias result = null;

            if (nextAlias.Target != null)
            {
                result = nextAlias.Target as IAlias;
            }
            else
            {
                Interpreter targetInterpreter = nextAlias.TargetInterpreter;

                if (targetInterpreter != null)
                {
                    string targetName = null;
                    ArgumentList targetArguments = null;

                    if (targetInterpreter.GetAliasArguments(
                            nextAlias, null, ref targetName,
                            ref targetArguments) == ReturnCode.Ok)
                    {
                        if (targetName != null)
                        {
                            if (targetInterpreter.GetAlias(
                                    targetName, LookupFlags.Default,
                                    ref result) != ReturnCode.Ok)
                            {
                                //
                                // NOTE: If the alias is being renamed, make
                                //       sure we are using the new name (i.e.
                                //       in that case the caller(s) is/are
                                //       responsible for passing it to us).
                                //
                                if (Object.ReferenceEquals(targetInterpreter, this) &&
                                    SharedStringOps.SystemEquals(targetName,
                                        (newName != null) ? newName : alias.Name))
                                {
                                    result = alias;
                                }
                            }
                        }
                    }
                }
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode PreventAliasLoop(
            IAlias alias,
            string newName,
            ref Result error
            )
        {
            IAlias nextAlias = alias;

            while (nextAlias != null)
            {
                //
                // NOTE: Proceed to the next alias in the chain.
                //
                nextAlias = FollowAlias(alias, nextAlias, newName);

                //
                // NOTE: Check to see if we have found a loop.
                //
                if (Object.ReferenceEquals(nextAlias, alias))
                {
                    error = String.Format(
                        "cannot define or rename alias {0}: would create a loop",
                        FormatOps.WrapOrNull(
                            (newName != null) ? newName : alias.Name));

                    return ReturnCode.Error;
                }
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddAliasAndCommand(
            IAlias alias,
            IClientData clientData,
            ref long token,
            ref Result result
            )
        {
            if (PreventAliasLoop(alias, null, ref result) == ReturnCode.Ok)
                //
                // NOTE: If the provided alias is not also a command, this cast will
                //       silently fail; however, that is fine because AddCommand will
                //       return an appropriate error message to the caller.
                //
                if (AddCommand(alias as ICommand, clientData, ref result) == ReturnCode.Ok)
                    if (AddAlias(alias, clientData, ref token, ref result) == ReturnCode.Ok)
                        return ReturnCode.Ok;

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveAliasAndCommand(
            string name,
            IClientData clientData,
            bool strict,
            ref Result result
            )
        {
            /* CheckDisposed(); */

            Result localResult = null;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (HasAliases(ref localResult))
                {
                    IAlias alias = null;

                    if (GetAlias(
                            name, LookupFlags.Default, ref alias,
                            ref localResult) == ReturnCode.Ok)
                    {
                        if (RemoveAlias(
                                alias.NameToken, clientData,
                                ref localResult) == ReturnCode.Ok)
                        {
                            if (HasCommands(ref localResult))
                            {
                                string commandName =
                                    ScriptOps.MakeCommandName(
                                        alias.Name);

                                if ((DoesCommandExist(
                                        commandName) != ReturnCode.Ok) ||
                                    (RemoveCommand(
                                        commandName, clientData,
                                        ref localResult) == ReturnCode.Ok))
                                {
                                    return ReturnCode.Ok;
                                }
                            }
                            else if (!strict)
                            {
                                return ReturnCode.Ok;
                            }
                        }
                    }
                }
                else if (!strict)
                {
                    return ReturnCode.Ok;
                }
            }

            result = localResult;
            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interpreter Alias Support
        private ReturnCode HasInterpreterAlias(
            string name
            )
        {
            IAlias alias = null;

            if (GetAlias(
                    name, LookupFlags.AliasNoVerbose,
                    ref alias) != ReturnCode.Ok)
            {
                return ReturnCode.Error;
            }

            if (!FlagOps.HasFlags(alias.AliasFlags,
                    AliasFlags.CrossInterpreter, true))
            {
                return ReturnCode.Error;
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetInterpreterAliasTarget(
            ref IExecute target,
            ref Result error
            )
        {
            ICommand command = null;

            if (GetCommand(
                    typeof(_Commands.Interp), LookupFlags.AliasDefault,
                    ref command, ref error) == ReturnCode.Ok)
            {
                target = command;

                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddInterpreterAlias(
            string name,
            OptionDictionary options,
            ObjectOptionType objectOptionType,
            ref Result error
            )
        {
            IAlias alias = null;

            return AddInterpreterAlias(
                name, options, objectOptionType, ref alias, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddInterpreterAlias(
            string name,
            OptionDictionary options,
            ObjectOptionType objectOptionType,
            ref IAlias alias,
            ref Result error
            )
        {
            IExecute target = null;

            if (GetInterpreterAliasTarget(ref target, ref error) == ReturnCode.Ok)
            {
                ArgumentList arguments = null;

                if (RuntimeOps.GetInterpreterAliasArguments(
                        null, objectOptionType, ref arguments,
                        ref error) == ReturnCode.Ok)
                {
                    AliasFlags aliasFlags = AliasFlags.MergeArguments |
                        AliasFlags.CrossInterpreterAlias;

                    int startIndex = 2; /* NOTE: For [interp eval]. */
                    Result result = null;

                    if (AddAlias(
                            name, CommandFlags.None, aliasFlags,
                            _ClientData.Empty, this, target, arguments,
                            options, startIndex /* interp eval */,
                            ref alias, ref result) == ReturnCode.Ok)
                    {
                        return ReturnCode.Ok;
                    }
                    else
                    {
                        //
                        // NOTE: Transfer error message to caller.
                        //
                        error = result;
                    }
                }
            }

            return ReturnCode.Error;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Library Alias Support
#if EMIT && NATIVE && LIBRARY
        private ReturnCode GetLibraryAliasTarget(
            ref IExecute target,
            ref Result error
            )
        {
            ICommand command = null;

            if (GetCommand(
                    typeof(_Commands.Library), LookupFlags.AliasDefault,
                    ref command, ref error) == ReturnCode.Ok)
            {
                target = command;

                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddLibraryAlias(
            string name,
            OptionDictionary options,
            ObjectOptionType objectOptionType,
            ref Result error
            )
        {
            IAlias alias = null;

            return AddLibraryAlias(
                name, options, objectOptionType, ref alias, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddLibraryAlias(
            string name,
            OptionDictionary options,
            ObjectOptionType objectOptionType,
            ref IAlias alias,
            ref Result error
            )
        {
            IExecute target = null;

            if (GetLibraryAliasTarget(ref target, ref error) == ReturnCode.Ok)
            {
                ArgumentList arguments = null;

                if (RuntimeOps.GetLibraryAliasArguments(
                        null, objectOptionType, ref arguments,
                        ref error) == ReturnCode.Ok)
                {
                    AliasFlags aliasFlags = AliasFlags.MergeArguments |
                        AliasFlags.Library;

                    int startIndex = 2; /* NOTE: For [library call]. */
                    Result result = null;

                    if (AddAlias(
                            name, CommandFlags.None, aliasFlags,
                            _ClientData.Empty, this, target, arguments,
                            options, startIndex /* [library call] */,
                            ref alias, ref result) == ReturnCode.Ok)
                    {
                        return ReturnCode.Ok;
                    }
                    else
                    {
                        //
                        // NOTE: Transfer error message to caller.
                        //
                        error = result;
                    }
                }
            }

            return ReturnCode.Error;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Object Alias Support
        private ReturnCode GetObjectAliasTarget(
            ref IExecute target,
            ref Result error
            )
        {
            ICommand command = null;

            if (GetCommand(
                    typeof(_Commands.Object), LookupFlags.AliasDefault,
                    ref command, ref error) == ReturnCode.Ok)
            {
                target = command;

                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool CanAddAliasName(
            string objectName,
            string aliasName
            )
        {
            if (!AreNamespacesEnabled())
                return true;

            return !String.IsNullOrEmpty(
                GetObjectAliasName(objectName, aliasName));
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeReplaceObjectNameWithIObject(
            ArgumentList arguments,
            IObject @object,
            int index
            )
        {
            if ((arguments == null) || (@object == null))
                return;

            if ((index < 0) || (index >= arguments.Count))
                return;

            arguments[index] = Argument.FromIObject(@object);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddObjectAlias(
            string objectName,
            string aliasName,
            OptionDictionary options,
            ObjectOptionType objectOptionType,
            bool reference,
            ref IAlias alias,
            ref Result error
            )
        {
            IExecute target = null;

            if (GetObjectAliasTarget(ref target, ref error) == ReturnCode.Ok)
            {
                ArgumentList arguments = null;

                if (RuntimeOps.GetObjectAliasArguments(
                        objectName, objectOptionType,
                        ref arguments, ref error) == ReturnCode.Ok)
                {
                    AliasFlags aliasFlags = AliasFlags.MergeArguments |
                        AliasFlags.Object;

                    int startIndex = 2; /* NOTE: For [object invoke]. */

                    if (aliasName != null)
                    {
                        //
                        // BUGFIX: For opaque object handles that have
                        //         an associated aliased command name,
                        //         the names used may not be the same
                        //         (e.g. the aliased command name may
                        //         have a namespace prefix).  To make
                        //         sure the opaque object handle is
                        //         used, avoid using the command name
                        //         from the source (second) argument
                        //         list and use remaining non-option
                        //         arguments from the target (first)
                        //         argument list instead.  Apparently,
                        //         this never quite worked right.
                        //
                        aliasFlags |= AliasFlags.SkipSourceName;
                        aliasFlags |= AliasFlags.UseTargetRemaining;
                    }

                    Result result = null;

                    if (AddAlias(
                            GetObjectAliasName(objectName, aliasName),
                            CommandFlags.None, aliasFlags, _ClientData.Empty,
                            this, target, arguments, options, startIndex
                            /* [object invoke ?name?] */, ref alias,
                            ref result) == ReturnCode.Ok)
                    {
                        ReturnCode code;
                        IObject @object = null;
                        Result localError = null;

                        if (reference)
                        {
                            code = AddObjectReference(
                                ReturnCode.Ok, objectName,
                                ObjectReferenceType.Command,
                                ref @object, ref localError);
                        }
                        else
                        {
                            code = GetObject(
                                objectName, LookupFlags.Default,
                                ref @object, ref localError);
                        }

                        if (code == ReturnCode.Ok)
                        {
                            if (reference && (alias != null))
                                alias.AliasFlags |= AliasFlags.Reference;

                            if (@object != null)
                            {
                                @object.Alias = alias;

                                //
                                // BUGFIX: Use the original object name
                                //         index (startIndex) here, not
                                //         insertion point for options.
                                //
                                MaybeReplaceObjectNameWithIObject(
                                    arguments, @object, startIndex);
                            }
                        }

                        return code;
                    }
                    else
                    {
                        //
                        // NOTE: Transfer error message to caller.
                        //
                        error = result;
                    }
                }
            }

            return ReturnCode.Error;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Tcl Alias Support
#if NATIVE && TCL
        private ReturnCode GetTclAliasTarget(
            ref IExecute target,
            ref Result error
            )
        {
            ICommand command = null;

            if (GetCommand(
                    typeof(_Commands.Tcl), LookupFlags.AliasDefault,
                    ref command, ref error) == ReturnCode.Ok)
            {
                target = command;

                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddTclAlias(
            string name,
            OptionDictionary options,
            ObjectOptionType objectOptionType,
            ref Result error
            )
        {
            IAlias alias = null;

            return AddTclAlias(
                name, options, objectOptionType, ref alias, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddTclAlias(
            string name,
            OptionDictionary options,
            ObjectOptionType objectOptionType,
            ref IAlias alias,
            ref Result error
            )
        {
            IExecute target = null;

            if (GetTclAliasTarget(ref target, ref error) == ReturnCode.Ok)
            {
                ArgumentList arguments = null;

                if (RuntimeOps.GetTclAliasArguments(
                        null, objectOptionType, ref arguments,
                        ref error) == ReturnCode.Ok)
                {
                    AliasFlags aliasFlags = AliasFlags.MergeArguments |
                        AliasFlags.TclWrapper;

                    int startIndex = 2; /* NOTE: For [tcl eval]. */
                    Result result = null;

                    if (AddAlias(
                            name, CommandFlags.None, aliasFlags,
                            _ClientData.Empty, this, target, arguments,
                            options, startIndex /* tcl eval */,
                            ref alias, ref result) == ReturnCode.Ok)
                    {
                        return ReturnCode.Ok;
                    }
                    else
                    {
                        //
                        // NOTE: Transfer error message to caller.
                        //
                        error = result;
                    }
                }
            }

            return ReturnCode.Error;
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Child Interpreter Support
        internal ReturnCode GetInterpreterPath(
            Interpreter interpreter,
            ref Result result
            )
        {
            if (interpreter == null)
            {
                result = "invalid interpreter";
                return ReturnCode.Error;
            }

            if (Object.ReferenceEquals(interpreter, this))
            {
                result = String.Empty;
                return ReturnCode.Ok;
            }

            Interpreter otherInterpreter = interpreter;
            StringList list = new StringList();

            while (!Object.ReferenceEquals(otherInterpreter, this))
            {
                string childName = otherInterpreter.ChildName;

                if (childName == null)
                    childName = otherInterpreter.InternalToString();

                //
                // NOTE: Keep track of the names going up the chain.
                //
                list.Add(childName);

                //
                // NOTE: Traverse to our parent interpreter.
                //
                otherInterpreter = otherInterpreter.ParentInterpreter;

                //
                // NOTE: Make sure the interpreter is still valid
                //       because we still haven't found this
                //       interpreter yet.
                //
                if (otherInterpreter == null)
                {
                    //
                    // NOTE: This should not really happen.  If so,
                    //       it is an error.
                    //
                    result = "invalid parent interpreter";
                    return ReturnCode.Error;
                }
            }

            list.Reverse();
            result = list;

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetNestedChildInterpreter(
            string path,
            LookupFlags lookupFlags,
            bool create,
            ref Interpreter interpreter, /* NOTE: Only set upon success. */
            ref Result error             /* NOTE: Only set upon failure. */
            )
        {
            string name = null;

            return GetNestedChildInterpreter(
                path, lookupFlags, create, ref interpreter, ref name,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetNestedChildInterpreter(
            string path,                 /* in */
            LookupFlags lookupFlags,     /* in */
            bool create,                 /* in */
            ref Interpreter interpreter, /* out */
            ref string name,             /* out */
            ref Result error             /* out */
            )
        {
            StringList list = null;

            if (ParserOps<string>.SplitList(
                    this, path, 0, Length.Invalid, true,
                    ref list, ref error) == ReturnCode.Ok)
            {
                Interpreter otherInterpreter = this;

                if (list.Count > 0)
                {
                    for (int index = 0; index < list.Count - 1; index++)
                    {
                        //
                        // BUGFIX: This loop should work correctly even when
                        //         the "Validate" lookup flag is disabled.
                        //
                        if (otherInterpreter == null)
                        {
                            error = "invalid interpreter";
                            return ReturnCode.Error;
                        }

                        if (otherInterpreter.GetChildInterpreter(
                                list[index], lookupFlags, ref otherInterpreter,
                                ref error) != ReturnCode.Ok)
                        {
                            return ReturnCode.Error;
                        }
                    }

                    //
                    // NOTE: This will be the name of the new interpreter
                    //       to be created in the target interpreter if the
                    //       "create" flag is true; otherwise, it will simply
                    //       be the name of the innertmost nested interpreter.
                    //
                    name = list[list.Count - 1];

                    if (!create)
                    {
                        //
                        // NOTE: Return the last interpreter in the "chain";
                        //       this one will be validated (i.e. checked for
                        //       null) only if the caller has requested it.
                        //
                        return otherInterpreter.GetChildInterpreter(
                            name, lookupFlags, ref interpreter, ref error);
                    }
                }

                interpreter = otherInterpreter;
                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode CreateChildInterpreter(
            string path,
            IClientData clientData,
            IRuleSet ruleSet,
            CreateFlags createFlags,
            HostCreateFlags hostCreateFlags,
            InitializeFlags initializeFlags,
            ScriptFlags scriptFlags,
            InterpreterFlags interpreterFlags,
            PluginFlags pluginFlags,
            bool isolated,
            bool security,
            bool alias,
            ref Result result
            )
        {
            ReturnCode code = ReturnCode.Ok;
            Interpreter interpreter = null;
            string name = null;
            Result localResult;

            if (path != null)
            {
                localResult = null;

                code = GetNestedChildInterpreter(
                    path, LookupFlags.Interpreter, true, ref interpreter,
                    ref name, ref localResult);

                if (code != ReturnCode.Ok)
                    result = localResult;
            }
            else
            {
                interpreter = this;
            }

            if (code == ReturnCode.Ok)
            {
#if APPDOMAINS && ISOLATED_INTERPRETERS
                string otherAppDomainName = null;
                AppDomain otherAppDomain = null;
                InterpreterHelper otherInterpreterHelper = null;
#endif
                Interpreter otherInterpreter = null;

                try
                {
                    if (isolated)
                    {
#if APPDOMAINS && ISOLATED_INTERPRETERS
                        otherAppDomainName = FormatOps.Id("childInterpreter", null, NextId());
                        localResult = null;

                        code = interpreter.AddAppDomain(otherAppDomainName, null, null,
#if CAS_POLICY
                            null,
#endif
                            clientData, true,
                            FlagOps.HasFlags(createFlags, CreateFlags.VerifyCoreAssembly, true),
                            !FlagOps.HasFlags(createFlags, CreateFlags.NoUseEntryAssembly, true),
                            FlagOps.HasFlags(createFlags, CreateFlags.OptionalEntryAssembly, true),
                            !FlagOps.HasFlags(createFlags, CreateFlags.NoConfiguration, true),
                            ref otherAppDomain, ref localResult);

                        if (code == ReturnCode.Ok)
                        {
                            localResult = null;

                            otherInterpreterHelper = InterpreterHelper.Create(otherAppDomain,
                                ruleSet, null, createFlags & ~CreateFlags.NoChildUseMask,
                                hostCreateFlags, initializeFlags, scriptFlags, interpreterFlags,
                                pluginFlags, null, null, null, ref localResult);

                            if (otherInterpreterHelper != null)
                            {
                                otherInterpreter = otherInterpreterHelper.Interpreter;

                                if (otherInterpreter == null)
                                {
                                    if (localResult != null)
                                        result = localResult;
                                    else
                                        result = "interpreter helper has no interpreter";

                                    code = ReturnCode.Error;
                                }
                            }
                            else
                            {
                                result = localResult;
                                code = ReturnCode.Error;
                            }
                        }
                        else
                        {
                            //
                            // NOTE: If the AddAppDomain method does not return
                            //       success, then an AppDomain was not added to
                            //       the target interpreter and the AppDomain was
                            //       already cleaned up; therefore, do not try to
                            //       remove it below (i.e. reset the name of the
                            //       new AppDomain to null here).
                            //
                            otherAppDomainName = null;
                            result = localResult;
                        }
#else
                        result = "not implemented";
                        code = ReturnCode.Error;
#endif
                    }
                    else
                    {
                        localResult = null;

                        otherInterpreter = Create(ruleSet, null,
                            createFlags & ~CreateFlags.NoChildUseMask,
                            hostCreateFlags, initializeFlags,
                            scriptFlags, interpreterFlags,
                            pluginFlags, ref localResult);

                        if (otherInterpreter == null)
                        {
                            result = localResult;
                            code = ReturnCode.Error;
                        }
                    }

                    if ((code == ReturnCode.Ok) && security)
                    {
                        localResult = null;

                        code = ScriptOps.EnableOrDisableSecurity(
                            otherInterpreter, true, FlagOps.HasFlags(
                            createFlags, CreateFlags.NoVariablesMask,
                            false), ref localResult);

                        if (code != ReturnCode.Ok)
                            result = localResult;
                    }
                }
                catch (Exception e)
                {
                    result = e;
                    code = ReturnCode.Error;
                }
                finally
                {
                    if (code == ReturnCode.Ok)
                    {
                        string otherId = isolated ?
                            GlobalState.NextInterpreterId().ToString() :
                            otherInterpreter.IdNoThrow.ToString();

                        if (name == null)
                            name = otherId;

                        if ((code == ReturnCode.Ok) && alias)
                        {
                            localResult = null;

                            code = AddInterpreterAlias(
                                name, null, ObjectOptionType.None,
                                ref localResult);

                            if (code != ReturnCode.Ok)
                                result = localResult;
                        }

                        if (code == ReturnCode.Ok)
                        {
                            localResult = null;

                            code = interpreter.AddChildInterpreter(
                                name, otherInterpreter, clientData,
                                ref localResult);

                            if (code != ReturnCode.Ok)
                                result = localResult;
                        }

                        if (code == ReturnCode.Ok)
                        {
                            //
                            // NOTE: Set the parent interpreter for the newly
                            //       created interpreter.
                            //
                            otherInterpreter.ParentInterpreter = interpreter;

                            //
                            // NOTE: We need a way to find this new interpreter
                            //       by the arbitrary name assigned to it by the
                            //       caller, not just the automatic Id; therefore,
                            //       store that now.
                            //
                            if (!SharedStringOps.SystemEquals(name, otherId))
                                otherInterpreter.ChildName = name;

#if APPDOMAINS && ISOLATED_INTERPRETERS
                            //
                            // NOTE: Set the application domain name for the newly
                            //       created interpreter (in isolated mode only).
                            //
                            if (otherAppDomainName != null)
                                otherInterpreter.ChildAppDomainName = otherAppDomainName;
#endif

                            //
                            // NOTE: Return the interpreter path if it is valid;
                            //       otherwise, return the generated interpreter
                            //       name.
                            //
                            result = (path != null) ? path : name;
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////

                    if (code != ReturnCode.Ok)
                    {
                        if (otherInterpreter != null)
                        {
                            ObjectOps.TryDisposeOrComplain<Interpreter>(
                                interpreter, ref otherInterpreter);
                        }

                        ///////////////////////////////////////////////////////////////////////////////

#if APPDOMAINS && ISOLATED_INTERPRETERS
                        if (otherInterpreterHelper != null)
                        {
                            ObjectOps.TryDisposeOrComplain<InterpreterHelper>(
                                interpreter, ref otherInterpreterHelper);
                        }

                        if (otherAppDomainName != null)
                        {
                            ReturnCode removeCode;
                            Result removeError = null;

                            removeCode = interpreter.RemoveAppDomain(
                                otherAppDomainName, clientData,
                                ref removeError);

                            if (removeCode != ReturnCode.Ok)
                            {
                                DebugOps.Complain(
                                    interpreter, removeCode,
                                    removeError);
                            }
                        }
#endif
                    }
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DeleteChildInterpreter(
            string path,
            IClientData clientData,
            bool synchronous,
            ref Result error
            )
        {
            Interpreter interpreter = null;
            string name = null;

            if (GetNestedChildInterpreter(
                    path, LookupFlags.Interpreter, true,
                    ref interpreter, ref name,
                    ref error) == ReturnCode.Ok)
            {
                return interpreter.RemoveChildInterpreter(
                    name, clientData, synchronous, ref error);
            }

            return ReturnCode.Error;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Context Manager Support
        private int CountThreadInterpreters()
        {
#if THREADING
            try
            {
                if (contextManager != null)
                    return contextManager.GetInterpreterContextCount();
            }
            catch
            {
                // do nothing.
            }
#else
            InterpreterDictionary interpreters = GlobalState.GetInterpreters();

            if (interpreters != null)
            {
                int count = 0;

                foreach (KeyValuePair<string, Interpreter> pair in interpreters)
                {
                    Interpreter interpreter = pair.Value;

                    if ((interpreter != null) && interpreter.IsPrimarySystemThread())
                        count++;
                }

                return count;
            }
#endif

            return 0;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if THREADING
        internal IContextManager InternalContextManager
        {
            get
            {
                // CheckDisposed();

                return contextManager;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void ResetDisposeContextCounts()
        {
            Interlocked.Exchange(
                ref preDisposeContextCount, 0);

            Interlocked.Exchange(
                ref postDisposeContextCount, 0);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void QueryDisposeContextCounts(
            ref int preDisposeContextCount,
            ref int postDisposeContextCount
            )
        {
            preDisposeContextCount = Interlocked.CompareExchange(
                ref this.preDisposeContextCount, 0, 0);

            postDisposeContextCount = Interlocked.CompareExchange(
                ref this.postDisposeContextCount, 0, 0);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Engine Context Members
        public bool IsBusy
        {
            get
            {
                CheckDisposed();

                return InternalIsBusy;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public bool IsGlobalBusy
        {
            get
            {
                CheckDisposed();

                return InternalIsGlobalBusy;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public int Levels /* WARNING: NOT GUARANTEED TO BE ACCURATE OR USEFUL. */
        {
            get
            {
                CheckDisposed();

                return InternalLevels;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
#if THREADING
        private IEngineContext GetEngineContext()
        {
            return (contextManager != null) ?
                contextManager.GetEngineContext(true) : null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IEngineContext GetEngineContextNoCreate()
        {
            return (contextManager != null) ?
                contextManager.GetEngineContext(false) : null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HaveEngineContext()
        {
            return GetEngineContextNoCreate() != null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool HaveAnyEngineContext(
            IEngineContext engineContext,
            CancelFlags cancelFlags
            )
        {
            if (engineContext != null)
                return true;

            if (HaveEngineContext())
                return true;

            if (FlagOps.HasFlags(
                    cancelFlags, CancelFlags.ForceContext, true) &&
                (GetEngineContext() /* CREATE */ != null))
            {
                return true;
            }

            return false;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ScriptTimeoutClientData CreateScriptTimeoutClientData(
            object data,
            TimeoutFlags timeoutFlags,
            CancelFlags? cancelFlags,
            int timeout
            )
        {
#if THREADING
            IEngineContext engineContext = GetEngineContextNoCreate();
#endif

            return new ScriptTimeoutClientData(
                data, this,
#if THREADING
                engineContext,
#endif
                timeoutFlags, cancelFlags, timeout);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalIsBusy
        {
            get
            {
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.Levels > 0;
                else
                    return false;
#else
                // lock (syncRoot)
                {
                    return levels > 0;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalIsGlobalBusy
        {
            get
            {
#if THREADING
                if ((Interlocked.CompareExchange(ref globalLevels, 0, 0) > 0) ||
                    (Interlocked.CompareExchange(ref globalScriptLevels, 0, 0) > 0))
                {
                    return true;
                }

                return false;
#else
                return InternalIsBusy;
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IClientData ContextClientData
        {
            get
            {
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ClientData;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return contextClientData;
                }
#endif
            }
            set
            {
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ClientData = value;
#else
                lock (syncRoot)
                {
                    contextClientData = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int InternalLevels
        {
            get
            {
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.Levels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return levels;
                }
#endif
            }
            private set
            {
                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.Levels = value;
#else
                // lock (syncRoot)
                {
                    levels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int MaximumLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.MaximumLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return maximumLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.MaximumLevels = value;
#else
                // lock (syncRoot)
                {
                    maximumLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ScriptLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ScriptLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return scriptLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ScriptLevels = value;
#else
                // lock (syncRoot)
                {
                    scriptLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int MaximumScriptLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.MaximumScriptLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return maximumScriptLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.MaximumScriptLevels = value;
#else
                // lock (syncRoot)
                {
                    maximumScriptLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int ParserLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ParserLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return parserLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ParserLevels = value;
#else
                // lock (syncRoot)
                {
                    parserLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int MaximumParserLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.MaximumParserLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return maximumParserLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.MaximumParserLevels = value;
#else
                // lock (syncRoot)
                {
                    maximumParserLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int ExpressionLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ExpressionLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return expressionLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ExpressionLevels = value;
#else
                // lock (syncRoot)
                {
                    expressionLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int EntryExpressionLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.EntryExpressionLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return entryExpressionLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.EntryExpressionLevels = value;
#else
                // lock (syncRoot)
                {
                    entryExpressionLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int MaximumExpressionLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.MaximumExpressionLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return maximumExpressionLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.MaximumExpressionLevels = value;
#else
                // lock (syncRoot)
                {
                    maximumExpressionLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int PreviousLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.PreviousLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return previousLevels;
                }
#endif
            }
            private set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.PreviousLevels = value;
#else
                // lock (syncRoot)
                {
                    previousLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int CatchLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.CatchLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return catchLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.CatchLevels = value;
#else
                // lock (syncRoot)
                {
                    catchLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int UnknownLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.UnknownLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return unknownLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.UnknownLevels = value;
#else
                // lock (syncRoot)
                {
                    unknownLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int TraceLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.TraceLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return traceLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.TraceLevels = value;
#else
                // lock (syncRoot)
                {
                    traceLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int SubCommandLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.SubCommandLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return subCommandLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.SubCommandLevels = value;
#else
                // lock (syncRoot)
                {
                    subCommandLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int SettingLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.SettingLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return settingLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.SettingLevels = value;
#else
                // lock (syncRoot)
                {
                    settingLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int PackageLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.PackageLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return packageLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.PackageLevels = value;
#else
                // lock (syncRoot)
                {
                    packageLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE
        internal Argument CacheArgument
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.CacheArgument;
                else
                    return 0;
#else
                lock (syncRoot)
                {
                    return cacheArgument;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.CacheArgument = value;
#else
                lock (syncRoot)
                {
                    cacheArgument = value;
                }
#endif
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if DEBUGGER
        private int WatchpointLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.WatchpointLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return watchpointLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.WatchpointLevels = value;
#else
                // lock (syncRoot)
                {
                    watchpointLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IDebugger Debugger
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.Debugger;
                else
                    return null;
#else
                // lock (syncRoot)
                {
                    return debugger;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.Debugger = value;
#else
                // lock (syncRoot)
                {
                    debugger = value;
                }
#endif
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY || NOTIFY_OBJECT
        private int NotifyLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.NotifyLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return notifyLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.NotifyLevels = value;
#else
                // lock (syncRoot)
                {
                    notifyLevels = value;
                }
#endif
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int SecurityLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.SecurityLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return securityLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.SecurityLevels = value;
#else
                // lock (syncRoot)
                {
                    securityLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int PolicyLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.PolicyLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return policyLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.PolicyLevels = value;
#else
                // lock (syncRoot)
                {
                    policyLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int TestLevels
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.TestLevels;
                else
                    return 0;
#else
                // lock (syncRoot)
                {
                    return testLevels;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.TestLevels = value;
#else
                // lock (syncRoot)
                {
                    testLevels = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if DEBUGGER
        internal bool IsDebuggerExiting
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.IsDebuggerExiting;
                else
                    return false;
#else
                lock (syncRoot)
                {
                    return isDebuggerExiting;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.IsDebuggerExiting = value;
#else
                lock (syncRoot)
                {
                    isDebuggerExiting = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void MaybeResetIsDebuggerExiting()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
            {
                bool isDebuggerExiting = context.IsDebuggerExiting;

                if (isDebuggerExiting)
                    context.IsDebuggerExiting = false;
            }
#else
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (isDebuggerExiting)
                    isDebuggerExiting = false;
            }
#endif
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool StackOverflow
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.StackOverflow;
                else
                    return false;
#else
                lock (syncRoot)
                {
                    return stackOverflow;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.StackOverflow = value;
#else
                lock (syncRoot)
                {
                    stackOverflow = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if PREVIOUS_RESULT
        private Result PreviousResult
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.PreviousResult;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return previousResult;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.PreviousResult = value;
#else
                lock (syncRoot)
                {
                    previousResult = value;
                }
#endif
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal EngineFlags EngineFlags
        {
            get
            {
                // CheckDisposed();

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    return EngineFlagsNoLock;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the EngineFlags property (just above) and
        //       the Engine.CreateThread method only.
        //
        internal EngineFlags EngineFlagsNoLock
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return engineFlags | context.EngineFlags;
                else
                    return engineFlags;
#else
                return engineFlags;
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal EngineFlags ContextEngineFlags
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.EngineFlags;
                else
                    return EngineFlags.None;
#else
                lock (syncRoot)
                {
                    return engineFlags;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.EngineFlags = value;
#else
                lock (syncRoot)
                {
                    engineFlags = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal EngineFlags SharedEngineFlags
        {
            get
            {
                // CheckDisposed();

                lock (syncRoot)
                {
                    return engineFlags;
                }
            }
            set
            {
                // CheckDisposed();

                lock (syncRoot)
                {
                    engineFlags = value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IParseState ParseState /* NOTE: For Engine use only. */
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ParseState;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return parseState;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ParseState = value;
#else
                lock (syncRoot)
                {
                    parseState = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ReturnCode
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ReturnCode;
                else
                    return ReturnCode.Ok;
#else
                lock (syncRoot)
                {
                    return returnCode;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ReturnCode = value;
#else
                lock (syncRoot)
                {
                    returnCode = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string ErrorCode
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ErrorCode;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return errorCode;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ErrorCode = value;
#else
                lock (syncRoot)
                {
                    errorCode = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string ErrorInfo
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ErrorInfo;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return errorInfo;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ErrorInfo = value;
#else
                lock (syncRoot)
                {
                    errorInfo = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ErrorFrames
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ErrorFrames;
                else
                    return 0;
#else
                lock (syncRoot)
                {
                    return errorFrames;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ErrorFrames = value;
#else
                lock (syncRoot)
                {
                    errorFrames = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal Exception Exception
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.Exception;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return exception;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.Exception = value;
#else
                lock (syncRoot)
                {
                    exception = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IScriptLocation ScriptLocation
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ScriptLocation;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return scriptLocation;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ScriptLocation = value;
#else
                lock (syncRoot)
                {
                    scriptLocation = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ScriptLocationList ScriptLocations
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ScriptLocations;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return scriptLocations;
                }
#endif
            }
            private set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ScriptLocations = value;
#else
                lock (syncRoot)
                {
                    scriptLocations = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SCRIPT_ARGUMENTS
        internal ArgumentListStack ScriptArguments
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ScriptArguments;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return scriptArguments;
                }
#endif
            }
            private set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ScriptArguments = value;
#else
                lock (syncRoot)
                {
                    scriptArguments = value;
                }
#endif
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal long PreviousProcessId
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.PreviousProcessId;
                else
                    return 0;
#else
                lock (syncRoot)
                {
                    return previousProcessId;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.PreviousProcessId = value;
#else
                lock (syncRoot)
                {
                    previousProcessId = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ArraySearchDictionary ArraySearches
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.ArraySearches;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return arraySearches;
                }
#endif
            }
            private set
            {
                // CheckDisposed();

                //
                // NOTE: This property "setter" is only supposed to be used during
                //       interpreter initialization.
                //
#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.ArraySearches = value;
#else
                lock (syncRoot)
                {
                    arraySearches = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if HISTORY
        private ClientDataList _History
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.History;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return _history;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.History = value;
#else
                lock (syncRoot)
                {
                    _history = value;
                }
#endif
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal EngineFlags BeginExternalExecution()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return context.BeginExternalExecution();
            else
                return EngineFlags.None;
#else
            EnterLevel();

            engineFlags |= EngineFlags.ExternalExecution;
            return Engine.AddStackCheckFlags(ref engineFlags);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EndExternalExecution(
            EngineFlags savedEngineFlags
            )
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return context.EndExternalExecution(savedEngineFlags);
            else
                return 0;
#else
            Engine.RemoveStackCheckFlags(savedEngineFlags, ref engineFlags);
            engineFlags &= ~EngineFlags.ExternalExecution;

            return ExitLevel();
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EndAndCleanupExternalExecution( /* EXIT POINT */
            EngineFlags savedEngineFlags
            )
        {
            int levels = EndExternalExecution(savedEngineFlags);

            if (levels == 0)
                Engine.CleanupNamespacesOrComplain(this);

            return levels;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int BeginNestedExecution()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return context.BeginNestedExecution();
            else
                return 0;
#else
            int savedPreviousLevels;

            lock (syncRoot)
            {
                savedPreviousLevels = previousLevels;
                previousLevels = levels;
            }

            return savedPreviousLevels;
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void EndNestedExecution(
            int savedPreviousLevels
            )
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                context.EndNestedExecution(savedPreviousLevels);
#else
            lock (syncRoot)
            {
                previousLevels = savedPreviousLevels;
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void MaybeBeginNestedExecution(
            Interpreter otherInterpreter, /* e.g. testInterpreter */
            out int? savedPreviousLevels
            )
        {
            if (Object.ReferenceEquals(otherInterpreter, this))
            {
                savedPreviousLevels = BeginNestedExecution();
            }
            else
            {
                savedPreviousLevels = null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void MaybeEndNestedExecution(
            int? savedPreviousLevels
            )
        {
            if (savedPreviousLevels != null)
            {
                EndNestedExecution((int)savedPreviousLevels);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void MaybePopulateResultErrorProperties(
            string type,
            ReturnCode code,
            Result result,
            int errorLine
            )
        {
            if (result == null)
                return;

            result.ErrorLine = 0;
            result.ErrorCode = null;
            result.ErrorInfo = null;

            if (code == ReturnCode.Error)
            {
                Result value; /* REUSED */

                result.ErrorLine = errorLine;

                value = null;

                if (GetVariableValue(
                        Engine.ErrorCodeVariableFlags,
                        TclVars.Core.ErrorCode,
                        ref value) == ReturnCode.Ok)
                {
                    result.ErrorCode = value;
                }

                value = null;

                if (GetVariableValue(
                        Engine.ErrorInfoVariableFlags,
                        TclVars.Core.ErrorInfo,
                        ref value) == ReturnCode.Ok)
                {
                    result.ErrorInfo = value;
                }
            }

            if (HasTraceResult(interpreterFlags))
            {
                TraceOps.DebugTrace(String.Format(
                    "MaybePopulateResultErrorProperties: type = {0}, result = [{1}]",
                    FormatOps.WrapOrNull(type), FormatOps.DisplayEngineResult(result)),
                    typeof(Interpreter).Name, TracePriority.EngineDebug);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if PREVIOUS_RESULT
        internal static Result GetPreviousResult(
            Interpreter interpreter
            )
        {
            if (interpreter == null)
                return null;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return null;

                return interpreter.PreviousResult;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void SetPreviousResult(
            Interpreter interpreter,
            Result previousResult
            )
        {
            if (interpreter == null)
                return;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return;

                interpreter.PreviousResult = previousResult;
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static void SetPreviousProcessId(
            Interpreter interpreter,
            long processId
            )
        {
            if (interpreter == null)
                return;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return;

                interpreter.PreviousProcessId = processId;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Support Methods
        #region Enter / Exit Global Levels
#if THREADING
        private int EnterGlobalLevel()
        {
            return Interlocked.Increment(ref globalLevels);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int ExitGlobalLevel()
        {
            return Interlocked.Decrement(ref globalLevels);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int EnterGlobalScriptLevel()
        {
            return Interlocked.Increment(ref globalScriptLevels);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int ExitGlobalScriptLevel()
        {
            return Interlocked.Decrement(ref globalScriptLevels);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Enter / Exit Context Levels
        private int EnterLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.Levels;
            else
                return 0;
#else
            return Interlocked.Increment(ref levels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int ExitLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.Levels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref levels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int EnterScriptLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.ScriptLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref scriptLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int ExitScriptLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.ScriptLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref scriptLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterParserLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.ParserLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref parserLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitParserLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.ParserLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref parserLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterExpressionLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.ExpressionLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref expressionLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitExpressionLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.ExpressionLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref expressionLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool PushSubExpression(
            ref int savedExpressionLevels /* out */
            )
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context == null)
                return false;

            savedExpressionLevels = context.EntryExpressionLevels;
            context.EntryExpressionLevels = context.ExpressionLevels;
#else
            savedExpressionLevels = entryExpressionLevels;
            entryExpressionLevels = expressionLevels;
#endif

            return true;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool PopSubExpression(
            ref int savedExpressionLevels /* in, out */
            )
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context == null)
                return false;

            context.EntryExpressionLevels = savedExpressionLevels;
            savedExpressionLevels = 0;
#else
            entryExpressionLevels = savedExpressionLevels;
            savedExpressionLevels = 0;
#endif

            return true;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsOuterSubExpression()
        {
            if (ExitExpressionLevel() == EntryExpressionLevels) /* SIDE-EFFECT */
                return true;
            else
                return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterCatchLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.CatchLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref catchLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitCatchLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.CatchLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref catchLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterUnknownLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.UnknownLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref unknownLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitUnknownLevel() /* EXIT POINT */
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.UnknownLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref unknownLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterTraceLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.TraceLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref traceLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitTraceLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.TraceLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref traceLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterSubCommandLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.SubCommandLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref subCommandLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitSubCommandLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.SubCommandLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref subCommandLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterSettingLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.SettingLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref settingLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitSettingLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.SettingLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref settingLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterPackageLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.PackageLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref packageLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitPackageLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.PackageLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref packageLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if DEBUGGER
        internal int EnterWatchpointLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.WatchpointLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref watchpointLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitWatchpointLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.WatchpointLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref watchpointLevels);
#endif
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY || NOTIFY_OBJECT
        internal int EnterNotifyLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.NotifyLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref notifyLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitNotifyLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.NotifyLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref notifyLevels);
#endif
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int EnterSecurityLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.SecurityLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref securityLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int ExitSecurityLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.SecurityLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref securityLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool HasSecurityLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context == null)
                return false;

            return (context.SecurityLevels > 0);
#else
            return Interlocked.CompareExchange(
                ref securityLevels, 0, 0) > 0;
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterPolicyLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.PolicyLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref policyLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitPolicyLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.PolicyLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref policyLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterTestLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return ++context.TestLevels;
            else
                return 0;
#else
            return Interlocked.Increment(ref testLevels);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitTestLevel()
        {
#if THREADING
            IEngineContext context = GetEngineContext();

            if (context != null)
                return --context.TestLevels;
            else
                return 0;
#else
            return Interlocked.Decrement(ref testLevels);
#endif
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Enter / Exit Engine Levels
        internal int EnterEngineLevel()
        {
#if THREADING
            /* IGNORED */
            EnterGlobalLevel();
#endif

            return EnterLevel();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitEngineLevel()
        {
#if THREADING
            /* IGNORED */
            ExitGlobalLevel();
#endif

            return ExitLevel();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterEngineScriptLevel()
        {
#if THREADING
            /* IGNORED */
            EnterGlobalScriptLevel();
#endif

            int levels = EnterScriptLevel();

            if (levels > MaximumScriptLevels)
                MaximumScriptLevels = levels;

            return levels;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitEngineScriptLevel()
        {
#if THREADING
            /* IGNORED */
            ExitGlobalScriptLevel();
#endif

            return ExitScriptLevel();
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interpreter Readiness
        internal bool HasReadyLevels()
        {
            if (InternalLevels > 0) /* EXEMPT */
                return true;

            if (ParserLevels > 0)
                return true;

            if (ExpressionLevels > 0)
                return true;

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is already held.
        //
        private ReturnCode GetReadyLevels(
            ref int levels,
            ref int maximumLevels,
            ref int parserLevels,
            ref int maximumParserLevels,
            ref int expressionLevels,
            ref int maximumExpressionLevels,
            ref Result error
            )
        {
#if THREADING
            IEngineContext context = (contextManager != null) ?
                contextManager.GetEngineContext(true, ref error) : null; /* EXEMPT */

            if (context != null)
            {
                levels = context.Levels;
                maximumLevels = context.MaximumLevels;

                if (levels > maximumLevels)
                    context.MaximumLevels = maximumLevels = levels;

                parserLevels = context.ParserLevels;
                maximumParserLevels = context.MaximumParserLevels;

                if (parserLevels > maximumParserLevels)
                    context.MaximumParserLevels = maximumParserLevels = parserLevels;

                expressionLevels = context.ExpressionLevels;
                maximumExpressionLevels = context.MaximumExpressionLevels;

                if (expressionLevels > maximumExpressionLevels)
                    context.MaximumExpressionLevels = maximumExpressionLevels = expressionLevels;

                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
#else
            levels = this.levels;
            maximumLevels = this.maximumLevels;

            if (levels > maximumLevels)
                this.MaximumLevels = maximumLevels = levels;

            parserLevels = this.parserLevels;
            maximumParserLevels = this.maximumParserLevels;

            if (parserLevels > maximumParserLevels)
                this.MaximumParserLevels = maximumParserLevels = parserLevels;

            expressionLevels = this.expressionLevels;
            maximumExpressionLevels = this.maximumExpressionLevels;

            if (expressionLevels > maximumExpressionLevels)
                this.MaximumExpressionLevels = maximumExpressionLevels = expressionLevels;

            return ReturnCode.Ok;
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static ReturnCode Ready( /* FOR EXTERNAL USE ONLY. */
            Interpreter interpreter,
            ref Result error
            ) /* THREAD-SAFE */
        {
            int timeout = DefaultReadyTimeout;
            ReadyFlags flags = ReadyFlags.ViaPublic;

            if (!FlagOps.HasFlags(flags, ReadyFlags.Disabled, true) &&
                !FlagOps.HasFlags(flags, ReadyFlags.NoFlags, true))
            {
                flags |= TryGetReadyFlags(interpreter, timeout, true);
            }

            bool timedOut;

            return Ready(
                interpreter, timeout, flags, out timedOut, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static ReturnCode EventReady( /* FOR EventOps CLASS USE ONLY. */
            Interpreter interpreter,
            int timeout,
            bool noCancel,
            bool noGlobalCancel,
            out bool timedOut,
            ref Result error
            ) /* THREAD-SAFE */
        {
            ReadyFlags flags = ReadyFlags.ViaEventManager;

            if (noCancel)
                flags |= ReadyFlags.NoCancel;

            if (noGlobalCancel)
                flags |= ReadyFlags.NoGlobalCancel;

            if (!FlagOps.HasFlags(flags, ReadyFlags.Disabled, true) &&
                !FlagOps.HasFlags(flags, ReadyFlags.NoFlags, true))
            {
                flags |= TryGetReadyFlags(interpreter, timeout, true);
            }

            EventOps.AdjustReadyFlags(noCancel, ref flags);

            return Ready(
                interpreter, timeout, flags, out timedOut, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NATIVE && TCL
        internal static ReturnCode TclReady( /* NOTE: FOR TclWrapper.DoOneEvent USE ONLY. */
            Interpreter interpreter,
            int timeout,
            ref Result error
            ) /* THREAD-SAFE */
        {
            ReadyFlags flags = ReadyFlags.ViaTclWrapper;

            if (!FlagOps.HasFlags(flags, ReadyFlags.Disabled, true) &&
                !FlagOps.HasFlags(flags, ReadyFlags.NoFlags, true))
            {
                flags |= TryGetReadyFlags(interpreter, timeout, true);
            }

            bool timedOut;

            return Ready(
                interpreter, timeout, flags, out timedOut, ref error);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static ReturnCode EventReady( /* FOR Interpreter/EventManager CLASS USE ONLY. */
            Interpreter interpreter,
            bool noCancel,
            bool noGlobalCancel,
            ref Result error
            ) /* THREAD-SAFE */
        {
            int timeout = DefaultReadyTimeout;
            ReadyFlags flags = ReadyFlags.ViaEventManager;

            if (noCancel)
                flags |= ReadyFlags.NoCancel;

            if (noGlobalCancel)
                flags |= ReadyFlags.NoGlobalCancel;

            if (!FlagOps.HasFlags(flags, ReadyFlags.Disabled, true) &&
                !FlagOps.HasFlags(flags, ReadyFlags.NoFlags, true))
            {
                flags |= TryGetReadyFlags(interpreter, timeout, true);
            }

            EventOps.AdjustReadyFlags(noCancel, ref flags);

            bool timedOut;

            return Ready(
                interpreter, timeout, flags, out timedOut, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static ReturnCode ParserReady( /* FOR Expression/Parser CLASS USE ONLY. */
            Interpreter interpreter,
            ReadyFlags flags,
            ref Result error
            ) /* THREAD-SAFE */
        {
            int timeout = DefaultReadyTimeout;

            flags |= ReadyFlags.ViaParser;

            if (!FlagOps.HasFlags(flags, ReadyFlags.Disabled, true) &&
                !FlagOps.HasFlags(flags, ReadyFlags.NoFlags, true))
            {
                flags |= TryGetReadyFlags(interpreter, timeout, false);
            }

            bool timedOut;

            return Ready(
                interpreter, timeout, flags, out timedOut, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static ReturnCode EngineReady( /* FOR Engine CLASS USE ONLY. */
            Interpreter interpreter,
            ReadyFlags flags,
            ref Result error
            ) /* THREAD-SAFE */
        {
            int timeout = DefaultReadyTimeout;

            flags |= ReadyFlags.ViaEngine;

            if (!FlagOps.HasFlags(flags, ReadyFlags.Disabled, true) &&
                !FlagOps.HasFlags(flags, ReadyFlags.NoFlags, true))
            {
                flags |= TryGetReadyFlags(interpreter, timeout, false);
            }

            bool timedOut;

            return Ready(
                interpreter, timeout, flags, out timedOut, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReturnCode Ready( /* FOR "*Ready" METHOD USE ONLY. */
            Interpreter interpreter,
            int timeout,
            ReadyFlags flags,
            out bool timedOut,
            ref Result error
            ) /* THREAD-SAFE */
        {
            //
            // NOTE: Reset the flag that will indicate whether we timed out
            //       while trying to obtain the interpreter lock.
            //
            timedOut = false;

            ///////////////////////////////////////////////////////////////////
            //
            // TODO: Insert any library-wide readiness checks here.
            //
            if (interpreter == null)
            {
                error = "invalid interpreter";
                return ReturnCode.Error;
            }

            ///////////////////////////////////////////////////////////////////
            //
            // NOTE: Is readiness checking completely disabled?
            //
            if (FlagOps.HasFlags(flags, ReadyFlags.Disabled, true))
                return ReturnCode.Ok;

            ///////////////////////////////////////////////////////////////////
            //
            // NOTE: Query and then increment the count that tracks how many
            //       times the interpreter readiness has been checked.
            //
            int readyCount = interpreter.BumpReadyCount();

            ///////////////////////////////////////////////////////////////////
            //
            // NOTE: Skip all checks except for native stack space?
            //
            bool stackOnly = FlagOps.HasFlags(
                flags, ReadyFlags.StackOnly, true);

            //
            // NOTE: The return code from various methods.  This variable is
            //       reused several times.
            //
            ReturnCode code;

            ///////////////////////////////////////////////////////////////////
            //
            // BUGFIX: Do not use the public SyncRoot property here (in case we
            //         have been disposed), use the internal property instead.
            //
            bool locked = false;
            object syncRoot = interpreter.InternalSyncRoot;

            if (syncRoot == null)
            {
                error = "invalid interpreter synchronization object";
                return ReturnCode.Error;
            }

            try
            {
                //
                // BUGFIX: *THREADING* Allow the callers to specify a timeout
                //         to avoid potential deadlocks here in some cases.
                //
                locked = Monitor.TryEnter(syncRoot, timeout);

                if (!locked)
                {
                    //
                    // NOTE: We cannot check if the interpreter is actually
                    //       ready; therefore, return failure.
                    //
                    timedOut = true;

                    error = String.Format(
                        "interpreter readiness timeout of {0} milliseconds",
                        timeout);

                    return ReturnCode.Error;
                }

                //
                // NOTE: We absoutely cannot continue if the interpreter has
                //       been disposed because that means there will be no
                //       engine context, which is required for checking the
                //       native stack space, among other things.  This is
                //       always checked because using a disposed interpreter
                //       is considered to be a serious programming error.
                //
                if (interpreter.PrivateDisposed)
                {
                    error = "attempt to call eval in disposed interpreter";
                    return ReturnCode.Error;
                }

                //
                // NOTE: Grab the user-defined callback.  When set, consult
                //       with it to determine if the interpreter is [still]
                //       considered to be ready.  This takes priority over
                //       all other checks exception interpreter disposal;
                //       however, if readiness checking is disabled via the
                //       "Disabled" flag, the user-defined callback will be
                //       skipped as well.
                //
                // WARNING: Unlike a lot of other user-defined callbacks in
                //          the core library, this one is called with the
                //          interpreter lock held; therefore, great care
                //          must be taken to avoid deadlocks (i.e. grabbing
                //          other locks, directly or indirectly, should be
                //          done with extreme caution).
                //
                if (!FlagOps.HasFlags(flags, ReadyFlags.NoCallback, true))
                {
                    ReadyCallback readyCallback =
                        interpreter.InternalReadyCallback;

                    if (readyCallback != null)
                    {
                        Result localError = null;

                        code = readyCallback(
                            interpreter, _ClientData.Empty, timeout, flags,
                            ref localError);

                        if (code != ReturnCode.Ok)
                        {
                            if (localError != null)
                                error = localError;
                            else
                                error = "interpreter not ready via callback";

                            return code;
                        }
                    }
                }

                ///////////////////////////////////////////////////////////////
                //
                // NOTE: Currently, the [exit] command (and the exit flag)
                //       in Eagle are more of a "suggestion" than anything
                //       else.  In fact, the exit flag may be unset via
                //       the IInterpreter property.
                //
                // FIXME: We may need to rethink this code.  If the exit
                //        flag has been set in the interpreter, does that
                //        mean cleanup code (e.g. finally blocks, etc)
                //        should also be skipped?
                //
                // NOTE: *COMPAT* This is one place where we do NOT follow
                //       (nor will we ever follow) native Tcl "standard"
                //       default behavior of unceremoniously exiting the
                //       entire process upon a script executing the [exit]
                //       command.
                //
                if (!stackOnly)
                {
                    //
                    // NOTE: Are we limiting the number of [full] readiness
                    //       checks?
                    //
                    if (FlagOps.HasFlags(flags, ReadyFlags.Limited, true))
                    {
                        //
                        // NOTE: In this context, the return code of Ok
                        //       means that we should continue checking
                        //       the readiness as normal [and not exit
                        //       prematurely].
                        //
                        code = ReturnCode.Ok;

                        //
                        // NOTE: Grab the ready limit for the interpreter.
                        //
                        int readyLimit = interpreter.PrivateReadyLimit;

                        //
                        // NOTE: If it is less than zero, assume that the
                        //       interpreter is always "ready".
                        //
                        if (readyLimit < 0)
                        {
                            //
                            // HACK: This return code assignment is somewhat
                            //       misleading because the label that will
                            //       be jumped to resets the return code to
                            //       Ok prior to returning.
                            //
                            code = ReturnCode.Error;
                            goto limitDone;
                        }

                        //
                        // NOTE: Otherwise, if it is greater than zero, check
                        //       to see if the readiness count is a multiple
                        //       of the readiness limit.  If so, it is time
                        //       for a periodic [full] readiness check.
                        //
                        if (readyLimit > 0)
                        {
                            if ((readyCount % readyLimit) != 0)
                            {
                                //
                                // HACK: This return code assignment is somewhat
                                //       misleading because the label that will
                                //       be jumped to resets the return code to
                                //       Ok prior to returning.
                                //
                                code = ReturnCode.Error;
                                goto limitDone;
                            }
                        }

                    limitDone:

                        //
                        // NOTE: If the return code is not Ok, we need
                        //       to exit prematurely now because we are
                        //       assuming that the interpreter is always
                        //       "ready".
                        //
                        if (code != ReturnCode.Ok)
                        {
                            //
                            // BUGBUG: Unfortunately, we must reset the script
                            //         cancellation flag here; otherwise, the
                            //         next readiness check may fail due to a
                            //         "stale" script cancellation request.
                            //         It should also be noted that the unwind
                            //         flag is purposely *NOT* being reset here
                            //         because it must be semantically "sticky"
                            //         until the evaluation stack for the
                            //         interpreter is completely unwound.
                            //
                            interpreter.ResetCancel(FlagOps.HasFlags(flags,
                                ReadyFlags.NoGlobalCancel, true), false);

                            //
                            // NOTE: Return success to the caller.  This is to
                            //       indicate that the interpreter is "ready".
                            //       Really, most of the checks were skipped;
                            //       however, our caller is not supposed to be
                            //       aware of that.
                            //
                            return ReturnCode.Ok;
                        }
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: If the interpreter is marked as "exited", it is
                    //       technically [from the perspective of resource
                    //       disposal] still in a usable state.
                    //
                    if (interpreter.PrivateExit &&
                        !FlagOps.HasFlags(flags, ReadyFlags.ExitedOk, true))
                    {
                        error = "attempt to call eval in exited interpreter";
                        return ReturnCode.Error;
                    }

                    ///////////////////////////////////////////////////////////
                    //
                    // NOTE: If the interpreter is marked as "deleted", it is
                    //       technically [from the perspective of resource
                    //       disposal] still in a usable state.  This flag is
                    //       currently only used while the interpreter is
                    //       actively being disposed.
                    //
                    if (interpreter.InternalDeleted &&
                        !FlagOps.HasFlags(flags, ReadyFlags.DeletedOk, true))
                    {
                        /* COMPAT: Tcl. */
                        error = "attempt to call eval in deleted interpreter";
                        return ReturnCode.Error;
                    }
                }

                ///////////////////////////////////////////////////////////////
                //
                // NOTE: Fetch the current script, parser, and expression
                //       nesting levels.  If this call fails, bail out now.
                //
                int levels = 0;
                int maximumLevels = 0;

                int parserLevels = 0;
                int maximumParserLevels = 0;

                int expressionLevels = 0;
                int maximumExpressionLevels = 0;

                code = interpreter.GetReadyLevels(
                    ref levels, ref maximumLevels, ref parserLevels,
                    ref maximumParserLevels, ref expressionLevels,
                    ref maximumExpressionLevels, ref error);

                if (code != ReturnCode.Ok)
                    return code;

#if NATIVE
                ///////////////////////////////////////////////////////////////
                //
                // NOTE: Checking native stack space is relatively "expensive";
                //       therefore, only perform this check if there are actual
                //       evaluations or expressions active AND it was requested
                //       by the caller.
                //
                if (RuntimeOps.ShouldCheckForStackSpace(
                        flags, levels, maximumLevels, parserLevels,
                        maximumParserLevels, expressionLevels,
                        maximumExpressionLevels))
                {
                    //
                    // NOTE: Ok, make sure that we are not running out
                    //       of native stack space.  If we cannot check
                    //       native stack space, this will simply return
                    //       "success".
                    //
                    code = RuntimeOps.CheckForStackSpace(interpreter);

                    if (code != ReturnCode.Ok)
                    {
                        //
                        // HACK: Set stack overflow flag so the engine
                        //       can unwind the evaluation stack in a
                        //       reasonable amount of time (i.e. skip
                        //       creating a complete error back trace).
                        //
                        interpreter.StackOverflow = true;

                        TraceOps.DebugTrace(String.Format(
                            "Ready: out of stack space, " +
                            "flags = {0}, levels = {1}, " +
                            "maximumLevels = {2}, " +
                            "parserLevels = {3}, " +
                            "maximumParserLevels = {4}, " +
                            "expressionLevels = {5}, " +
                            "maximumExpressionLevels = {6}", flags,
                            levels, maximumLevels, parserLevels,
                            maximumParserLevels, expressionLevels,
                            maximumExpressionLevels),
                            typeof(Interpreter).Name,
                            TracePriority.EngineError);

                        /* COMPAT: Tcl. */
                        error = "out of stack space (infinite loop?)";
                        return code;
                    }
                }
#endif

                ///////////////////////////////////////////////////////////////
                //
                // NOTE: If we only care about native stack checking, skip
                //       recursion limit checking.
                //
                if (!stackOnly)
                {
                    //
                    // NOTE: Make sure that we have not exceeded the
                    //       recursion limit.
                    //
                    int recursionLimit = interpreter.PrivateRecursionLimit;

                    if ((recursionLimit > 0) && (levels > recursionLimit))
                    {
                        //
                        // HACK: Set the stack overflow flag so that the
                        //       engine can "quickly" unwind the evaluation
                        //       stack.
                        //
                        interpreter.StackOverflow = true;

                        TraceOps.DebugTrace(String.Format(
                            "Ready: too many nested evaluations, flags = {0}, " +
                            "levels = {1}, maximumLevels = {2}, " +
                            "parserLevels = {3}, maximumParserLevels = {4}, " +
                            "expressionLevels = {5}, " +
                            "maximumExpressionLevels = {6}", flags, levels,
                            maximumLevels, parserLevels, maximumParserLevels,
                            expressionLevels, maximumExpressionLevels),
                            typeof(Interpreter).Name,
                            TracePriority.EngineError);

                        /* COMPAT: Tcl. */
                        error = "too many nested evaluations (infinite loop?)";
                        return ReturnCode.Error;
                    }
                }
            }
            catch (Exception e)
            {
                TraceOps.DebugTrace(
                    e, typeof(Interpreter).Name,
                    TracePriority.EngineError);

                error = e;
                return ReturnCode.Error;
            }
            finally
            {
                if (locked)
                    Monitor.Exit(syncRoot);
            }

            ///////////////////////////////////////////////////////////////////
            //
            // NOTE: If we only care about native stack checking, skip script
            //       cancellation checking.  Also skip it if requested to do
            //       so by our caller.
            //
            if (!stackOnly &&
                !FlagOps.HasFlags(flags, ReadyFlags.NoCancel, true))
            {
                //
                // NOTE: These may need to be treated as totally separate
                //       checks at some point, depending on where calls to
                //       ResetCancel and ResetHalt are present.
                //
                // BUGFIX: Do *NOT* do this while holding the interpreter
                //         synchronization lock.
                //
                CancelFlags cancelFlags = CancelFlags.Ready;

                if (FlagOps.HasFlags(flags, ReadyFlags.NoGlobalCancel, true))
                    cancelFlags &= ~CancelFlags.Global;

                if (FlagOps.HasFlags(flags, ReadyFlags.NoGlobalResetCancel, true))
                    cancelFlags &= ~CancelFlags.ResetGlobal;

#if DEBUGGER && DEBUGGER_ENGINE
                if (FlagOps.HasFlags(flags, ReadyFlags.NoBreakpoint, true))
                    cancelFlags |= CancelFlags.NoBreakpoint;
#endif

#if THREADING
                IEngineContext engineContext = null;

                if (interpreter != null)
                    engineContext = interpreter.GetEngineContextNoCreate();
#endif

                code = Engine.InternalIsCanceled(interpreter,
#if THREADING
                    engineContext,
#endif
                    cancelFlags, ref error);

                if (code != ReturnCode.Ok)
                    return code;

                if (!FlagOps.HasFlags(flags, ReadyFlags.NoHalt, true))
                {
                    code = Engine.InternalIsHalted(interpreter,
#if THREADING
                        engineContext,
#endif
                        cancelFlags, ref error);

                    if (code != ReturnCode.Ok)
                        return code;
                }
            }

            ///////////////////////////////////////////////////////////////////
            //
            // NOTE: If we get this far, everything we checked is considered
            //       to be "ready".
            //
            return ReturnCode.Ok;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Script Location Stack Support
        internal bool HasScriptLocation()
        {
            //
            // HACK: Accessed without locking, critical path.
            //
            // lock (syncRoot) /* TRANSACTIONAL */
            {
                return FlagOps.HasFlags( /* NO-LOCK */
                    interpreterStateFlags, InterpreterStateFlags.ScriptLocation,
                    true); /* EXEMPT */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void EnableScriptLocation(
            bool enable
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (enable)
                    interpreterStateFlags |= InterpreterStateFlags.ScriptLocation;
                else
                    interpreterStateFlags &= ~InterpreterStateFlags.ScriptLocation;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool ShouldPushScriptLocation(
            bool viaSource
            )
        {
            if (HasScriptLocation()) /* NOTE: Track all? */
                return true;

            return viaSource;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool ShouldPopScriptLocation(
            bool viaSource
            )
        {
            if (HasScriptLocation()) /* NOTE: Track all? */
                return true;

            return viaSource;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsScriptLocationStrict()
        {
            //
            // HACK: Accessed without locking, critical path.
            //
            // lock (syncRoot) /* TRANSACTIONAL */
            {
                return FlagOps.HasFlags( /* NO-LOCK */
                    interpreterStateFlags, InterpreterStateFlags.StrictScriptLocation,
                    true); /* EXEMPT */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void PushScriptLocation(
            string fileName,
            bool viaSource,
            ref bool pushed
            )
        {
            PushScriptLocation(fileName,
                Parser.StartLine, Parser.UnknownLine, viaSource,
                ref pushed);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void PushScriptLocation(
            string fileName,
            int startLine,
            int endLine,
            bool viaSource,
            ref bool pushed
            )
        {
            //
            // HACK: Avoid allocating a ScriptLocation object that we will just
            //       end up throwing away.
            //
            if (!ShouldPushScriptLocation(viaSource))
                return;

            PushScriptLocation(_Public.ScriptLocation.Create(
                this, fileName, startLine, endLine, viaSource),
                ref pushed);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void PushScriptLocation(
            IScriptLocation location, /* in */
            ref bool pushed           /* in, out */
            )
        {
            if (pushed)
                return;

            bool viaSource = EntityOps.IsViaSource(location);

            if (!ShouldPushScriptLocation(viaSource))
                return;

            //
            // NOTE: This lock is not necessary when we are compiled with
            //       the THREADING option enabled because ScriptLocation
            //       and ScriptLocations are per-thread values in that
            //       case.
            //
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                //
                // NOTE: Undo any previous manual override.
                //
                ScriptLocation = null;

                ScriptLocationList scriptLocations = ScriptLocations;

                if (scriptLocations != null)
                {
                    scriptLocations.Push(location);
                    pushed = true;
                }
                else if (IsScriptLocationStrict())
                {
                    throw new ScriptException("missing script locations");
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void PopScriptLocation(
            IScriptLocation location,
            ref bool pushed
            )
        {
            PopScriptLocation(
                EntityOps.IsViaSource(location), ref pushed);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void PopScriptLocation( /* EXIT POINT */
            bool viaSource,
            ref bool pushed
            )
        {
            //
            // BUGFIX: Skip popping the script location if the interpreter
            //         has been disposed (i.e. no more engine context).
            //
            if (disposed || !pushed || !ShouldPopScriptLocation(viaSource))
                return;

            //
            // NOTE: This lock is not necessary when we are compiled with
            //       the THREADING option enabled because ScriptLocations
            //       is a per-thread value in that case.
            //
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                ScriptLocationList scriptLocations = ScriptLocations;

                if (scriptLocations != null)
                {
                    scriptLocations.Pop();
                    pushed = false;
                }
                else if (IsScriptLocationStrict())
                {
                    throw new ScriptException("missing script locations");
                }
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Script Arguments Stack Support
#if SCRIPT_ARGUMENTS
        internal bool HasScriptArguments()
        {
            //
            // HACK: Accessed without locking, critical path.
            //
            // lock (syncRoot) /* TRANSACTIONAL */
            {
                return FlagOps.HasFlags( /* NO-LOCK */
                    interpreterStateFlags, InterpreterStateFlags.ScriptArguments,
                    true); /* EXEMPT */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void EnableScriptArguments(
            bool enable
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (enable)
                    interpreterStateFlags |= InterpreterStateFlags.ScriptArguments;
                else
                    interpreterStateFlags &= ~InterpreterStateFlags.ScriptArguments;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool AreScriptArgumentsStrict()
        {
            //
            // HACK: Accessed without locking, critical path.
            //
            // lock (syncRoot) /* TRANSACTIONAL */
            {
                return FlagOps.HasFlags( /* NO-LOCK */
                    interpreterStateFlags, InterpreterStateFlags.StrictScriptArguments,
                    true); /* EXEMPT */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void PushScriptArguments(
            ArgumentList arguments, /* in */
            ref bool pushed         /* out */
            )
        {
            if (pushed || !HasScriptArguments())
                return;

            //
            // NOTE: This lock is not necessary when we are compiled with
            //       the THREADING option enabled because ScriptLocation
            //       and ScriptLocations are per-thread values in that
            //       case.
            //
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                ArgumentListStack scriptArguments = ScriptArguments;

                if (scriptArguments != null)
                {
                    scriptArguments.Push(arguments);
                    pushed = true;
                }
                else if (AreScriptArgumentsStrict())
                {
                    throw new ScriptException("missing script arguments");
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void PopScriptArguments( /* EXIT POINT */
            ref bool pushed /* in, out */
            )
        {
            if (disposed || !pushed || !HasScriptArguments())
                return;

            //
            // NOTE: This lock is not necessary when we are compiled with
            //       the THREADING option enabled because ScriptArguments
            //       is a per-thread value in that case.
            //
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                ArgumentListStack scriptArguments = ScriptArguments;

                if (scriptArguments != null)
                {
                    scriptArguments.Pop();
                    pushed = false;
                }
                else if (AreScriptArgumentsStrict())
                {
                    throw new ScriptException("missing script arguments");
                }
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Engine Flags Support
        private bool HasErrorInProgress()
        {
            //
            // WARNING: Possibly per-thread engine flags used here,
            //          MUST use property, not field.
            //
            return EngineFlagOps.HasErrorInProgress(EngineFlags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool HasNoCacheArgument()
        {
#if ARGUMENT_CACHE
            //
            // WARNING: Possibly per-thread engine flags used here,
            //          MUST use property, not field.
            //
            return EngineFlagOps.HasNoCacheArgument(EngineFlags);
#else
            return false;
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE || PARSE_CACHE
        //
        // NOTE: This method is designed to disable all caching by the engine
        //       (i.e. not the parser) for the current thread only, saving the
        //       preexisting (per-thread) engine flags for later use with the
        //       EndProcedureBodyNoCaching method (below).
        //
        internal void BeginProcedureBodyNoCaching(
            ref EngineFlags savedEngineFlags
            )
        {
            EngineFlags enableEngineFlags = EngineFlags.None;

#if PARSE_CACHE
            enableEngineFlags |= EngineFlags.NoCacheParseState;
#endif

#if ARGUMENT_CACHE
            enableEngineFlags |= EngineFlags.NoCacheArgument;
#endif

            savedEngineFlags = ContextEngineFlags;
            ContextEngineFlags |= enableEngineFlags;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method is designed to restore all caching by the engine
        //       (i.e. not the parser) for the current thread only, restoring
        //       the previously saved (per-thread) engine flags.
        //
        internal void EndProcedureBodyNoCaching(
            ref EngineFlags savedEngineFlags
            )
        {
            ContextEngineFlags = savedEngineFlags;
            savedEngineFlags = EngineFlags.None;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Array Searches Support
        //
        // NOTE: The actual ArraySearches property is located with
        //       the engine context members, also within this file.
        //
        private bool CleanupArraySearches(IVariable variable)
        {
            int removed = 0;

            return CleanupArraySearches(variable, ref removed);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool CleanupArraySearches(
            IVariable variable,
            ref int removed
            )
        {
            if (variable != null)
            {
                ArraySearchDictionary arraySearches = ArraySearches;

                if (arraySearches != null)
                {
                    //
                    // NOTE: Cleanup, PASS #1, collect the list of keys we need to remove
                    //       from the objects collection in the containing interpreter.
                    //
                    StringList keys = new StringList();

                    foreach (KeyValuePair<string, ArraySearch> pair in arraySearches)
                    {
                        ArraySearch arraySearch = pair.Value;

                        if ((arraySearch != null) &&
                            Object.ReferenceEquals(arraySearch.Variable, variable))
                        {
                            keys.Add(pair.Key);
                        }
                    }

                    //
                    // NOTE: Cleanup, PASS #2, remove all the objects we found from PASS
                    //       #1 (above).
                    //
                    foreach (string key in keys)
                        LogicOps.Y(arraySearches.Remove(key), removed++);

                    return true;
                }
            }

            return false;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Previous Process Id Support
        internal void ResetPreviousProcessId()
        {
            PreviousProcessId = 0;
        }
        #endregion
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Interactive Context Members
#if SHELL
        private Semaphore InteractiveLoopSemaphore
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.InteractiveLoopSemaphore;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return interactiveLoopSemaphore;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.InteractiveLoopSemaphore = value;
#else
                lock (syncRoot)
                {
                    interactiveLoopSemaphore = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int GlobalInteractiveLoops
        {
            get { return globalInteractiveLoops; }
            set { globalInteractiveLoops = value; }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ActiveInteractiveLoops
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.ActiveInteractiveLoops;
                else
                    return 0;
#else
                lock (syncRoot)
                {
                    return activeInteractiveLoops;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.ActiveInteractiveLoops = value;
#else
                lock (syncRoot)
                {
                    activeInteractiveLoops = value;
                }
#endif

                if (IsPrimarySystemThread())
                {
                    VariableFlags flags = VariableFlags.ViaProperty;

                    //
                    // NOTE: Do not create the variable if we have been prohibited
                    //       from doing so.
                    //
                    if (InternalIsSafe() || PrivateIsNoVariables())
                        flags |= VariableFlags.NoCreate;

                    //
                    // NOTE: Update script-level informational variable.  This
                    //       variable is NOT allowed in "safe" interpreters.
                    //
                    SetLibraryVariableValue(
                        flags, TclVars.Core.InteractiveLoops, value.ToString());
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int TotalInteractiveLoops
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.TotalInteractiveLoops;
                else
                    return 0;
#else
                lock (syncRoot)
                {
                    return totalInteractiveLoops;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.TotalInteractiveLoops = value;
#else
                lock (syncRoot)
                {
                    totalInteractiveLoops = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int TotalInteractiveInputs
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.TotalInteractiveInputs;
                else
                    return 0;
#else
                lock (syncRoot)
                {
                    return totalInteractiveInputs;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.TotalInteractiveInputs = value;
#else
                lock (syncRoot)
                {
                    totalInteractiveInputs = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL
        internal IShellCallbackData ShellCallbackData
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.ShellCallbackData;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return shellCallbackData;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.ShellCallbackData = value;
#else
                lock (syncRoot)
                {
                    shellCallbackData = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IInteractiveLoopData InteractiveLoopData
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.InteractiveLoopData;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return interactiveLoopData;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.InteractiveLoopData = value;
#else
                lock (syncRoot)
                {
                    interactiveLoopData = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IUpdateData UpdateData
        {
            get
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    return context.UpdateData;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return updateData;
                }
#endif
            }
            set
            {
                // CheckDisposed();

#if THREADING
                IInteractiveContext context = GetInteractiveContext();

                if (context != null)
                    context.UpdateData = value;
#else
                lock (syncRoot)
                {
                    updateData = value;
                }
#endif
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
#if SHELL
        internal ReturnCode IsPausedInteractiveLoop(
            int appDomainId,
            long threadId,
            ref bool done,
            ref Result error
            )
        {
            bool locked = false;

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    if (pausedInteractiveLoops == null)
                    {
                        error = "paused interactive loops unavailable";
                        return ReturnCode.Error;
                    }

                    long localKey = ConversionOps.MakeLong(
                        appDomainId, threadId);

                    long localValue;

                    if (pausedInteractiveLoops.TryGetValue(
                            localKey, out localValue))
                    {
                        done = localValue <= 0;
                    }
                    else
                    {
                        done = true;
                    }

                    return ReturnCode.Ok;
                }
                else
                {
                    error = "unable to acquire lock";
                    return ReturnCode.Error;
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode ListPausedInteractiveLoops(
            ref StringList list,
            ref Result error
            )
        {
            bool locked = false;

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    if (pausedInteractiveLoops == null)
                    {
                        error = "paused interactive loops unavailable";
                        return ReturnCode.Error;
                    }

                    StringList localList = new StringList();

                    foreach (KeyValuePair<long, long> pair
                            in pausedInteractiveLoops)
                    {
                        long appDomainId; /* int */
                        long threadId;

                        ConversionOps.UnmakeLong(
                            pair.Key, out appDomainId, out threadId);

                        long value = pair.Value;

                        localList.Add(String.Format(
                            "{0}/{1}: {2} {3}", appDomainId, threadId,
                            value, (value > 0) ? "PAUSED" : "UNPAUSED"));
                    }

                    list = localList;
                    return ReturnCode.Ok;
                }
                else
                {
                    error = "unable to acquire lock";
                    return ReturnCode.Error;
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode PauseInteractiveLoop(
            int appDomainId,
            long threadId,
            ref Result result
            )
        {
            bool locked = false;

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    if (pausedInteractiveLoops == null)
                    {
                        result = "paused interactive loops unavailable";
                        return ReturnCode.Error;
                    }

                    long localKey = ConversionOps.MakeLong(
                        appDomainId, threadId);

                    long localValue;

                    if (!pausedInteractiveLoops.TryGetValue(
                            localKey, out localValue))
                    {
                        localValue = 0;
                    }

                    pausedInteractiveLoops[localKey] = ++localValue;

                    result = String.Format(
                        "interactive loop {0}/{1} paused: {2}",
                        appDomainId, threadId, localValue);

                    return ReturnCode.Ok;
                }
                else
                {
                    result = "unable to acquire lock";
                    return ReturnCode.Error;
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode UnpauseInteractiveLoop(
            int appDomainId,
            long threadId,
            bool errorOnNotFound,
            bool remove,
            bool force,
            bool sleep,
            ref Result result
            )
        {
            bool locked = false;

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    if (pausedInteractiveLoops == null)
                    {
                        result = "paused interactive loops unavailable";
                        return ReturnCode.Error;
                    }

                    long localKey = ConversionOps.MakeLong(
                        appDomainId, threadId);

                    long localValue;

                    if (!pausedInteractiveLoops.TryGetValue(
                            localKey, out localValue))
                    {
                        if (errorOnNotFound)
                        {
                            result = String.Format(
                                "interactive loop {0}/{1} already unpaused",
                                appDomainId, threadId);

                            return ReturnCode.Error;
                        }
                        else
                        {
                            return ReturnCode.Ok;
                        }
                    }

                    if (remove)
                    {
                        if ((force || (localValue <= 0)) &&
                            !pausedInteractiveLoops.Remove(localKey))
                        {
                            result = String.Format(
                                "interactive loop {0}/{1} not unpaused",
                                appDomainId, threadId);

                            return ReturnCode.Error;
                        }
                    }
                    else
                    {
                        pausedInteractiveLoops[localKey] = --localValue;
                    }

                    if (sleep)
                    {
                        if (EventOps.Wait(
                                this, null, ShellOps.PauseMicroseconds, null, true,
                                false, false, false, ref result) != ReturnCode.Ok)
                        {
                            return ReturnCode.Error;
                        }
                    }

                    result = String.Format(
                        "interactive loop {0}/{1} {2}: {3}",
                        appDomainId, threadId, remove ? "removed" :
                        "unpaused", localValue);

                    return ReturnCode.Ok;
                }
                else
                {
                    result = "unable to acquire lock";
                    return ReturnCode.Error;
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void PushUpdateData(
            IUpdateData newUpdateData,
            ref IUpdateData savedUpdateData
            )
        {
            //
            // NOTE: This lock is not necessary when we are compiled with
            //       the THREADING option enabled because UpdateData is a
            //       per-thread value in that case.
            //
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                savedUpdateData = UpdateData;
                UpdateData = newUpdateData;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void PopUpdateData(
            ref IUpdateData savedUpdateData
            )
        {
            //
            // NOTE: This lock is not necessary when we are compiled with
            //       the THREADING option enabled because UpdateData is a
            //       per-thread value in that case.
            //
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                UpdateData = savedUpdateData;
                savedUpdateData = null;
            }
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Test Context Members
        internal Interpreter TestTargetInterpreter
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.TargetInterpreter;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testTargetInterpreter;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.TargetInterpreter = value;
#else
                lock (syncRoot)
                {
                    testTargetInterpreter = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal long[] TestStatistics
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.Statistics;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testStatistics;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.Statistics = value;
#else
                lock (syncRoot)
                {
                    testStatistics = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal StringList TestConstraints
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.Constraints;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testConstraints;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.Constraints = value;
#else
                lock (syncRoot)
                {
                    testConstraints = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IntDictionary TestKnownBugs
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.KnownBugs;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testKnownBugs;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.KnownBugs = value;
#else
                lock (syncRoot)
                {
                    testKnownBugs = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal StringListDictionary TestSkipped
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.Skipped;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testSkipped;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.Skipped = value;
#else
                lock (syncRoot)
                {
                    testSkipped = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal StringList TestFailures
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.Failures;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testFailures;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.Failures = value;
#else
                lock (syncRoot)
                {
                    testFailures = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IntDictionary TestCounts
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.Counts;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testCounts;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.Counts = value;
#else
                lock (syncRoot)
                {
                    testCounts = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal StringList TestMatch
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.Match;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testMatch;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.Match = value;
#else
                lock (syncRoot)
                {
                    testMatch = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal StringList TestSkip
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.Skip;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testSkip;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.Skip = value;
#else
                lock (syncRoot)
                {
                    testSkip = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCodeDictionary TestReturnCodeMessages
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.ReturnCodeMessages;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testReturnCodeMessages;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.ReturnCodeMessages = value;
#else
                lock (syncRoot)
                {
                    testReturnCodeMessages = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if DEBUGGER
        internal StringDictionary TestBreakpoints
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.Breakpoints;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testBreakpoints;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.Breakpoints = value;
#else
                lock (syncRoot)
                {
                    testBreakpoints = value;
                }
#endif
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal IComparer<string> TestComparer
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.Comparer;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testComparer;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.Comparer = value;
#else
                lock (syncRoot)
                {
                    testComparer = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string TestPath
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.Path;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testPath;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.Path = value;
#else
                lock (syncRoot)
                {
                    testPath = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal TestOutputType TestVerbose
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.Verbose;
                else
                    return TestOutputType.None;
#else
                lock (syncRoot)
                {
                    return testVerbose;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.Verbose = value;
#else
                lock (syncRoot)
                {
                    testVerbose = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int TestRepeatCount
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.RepeatCount;
                else
                    return 0;
#else
                lock (syncRoot)
                {
                    return testRepeatCount;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.RepeatCount = value;
#else
                lock (syncRoot)
                {
                    testRepeatCount = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal string TestCurrent
        {
            get
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    return context.Current;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return testCurrent;
                }
#endif
            }
            set
            {
#if THREADING
                ITestContext context = GetTestContext();

                if (context != null)
                    context.Current = value;
#else
                lock (syncRoot)
                {
                    testCurrent = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
#if THREADING
        private ITestContext GetTestContext()
        {
            return (contextManager != null) ?
                contextManager.GetTestContext(true) : null;
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Variable Context Members
        internal CallStack CallStack /* THREAD-SAFE */
        {
            get
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    return context.CallStack;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return callStack;
                }
#endif
            }
            private set
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    context.CallStack = value;
#else
                lock (syncRoot)
                {
                    callStack = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
        internal ICallFrame GlobalFrame /* THREAD-SAFE */
        {
            get
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    return context.GlobalFrame;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return globalFrame;
                }
#endif
            }
            private set
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    context.GlobalFrame = value;
#else
                lock (syncRoot)
                {
                    globalFrame = value;
                }
#endif
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame GlobalScopeFrame /* THREAD-SAFE */
        {
            get
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    return context.GlobalScopeFrame;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return globalScopeFrame;
                }
#endif
            }
            /* internal */
            set
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    context.GlobalScopeFrame = value;
#else
                lock (syncRoot)
                {
                    globalScopeFrame = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: If the GlobalScopeFrame is currently set to non-null,
        //       this property will return that value; otherwise, it
        //       will return the GlobalFrame property.
        //
        internal ICallFrame CurrentGlobalFrame /* THREAD-SAFE, READ-ONLY */
        {
            get
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    return context.CurrentGlobalFrame;
                else
                    return null;
#else
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    if (globalScopeFrame != null)
                        return globalScopeFrame;

                    return globalFrame;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame CurrentFrame /* THREAD-SAFE */
        {
            get
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    return context.CurrentFrame;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return currentFrame;
                }
#endif
            }
            private set
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    context.CurrentFrame = value;
#else
                lock (syncRoot)
                {
                    currentFrame = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame ProcedureFrame /* THREAD-SAFE */
        {
            get
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    return context.ProcedureFrame;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return procedureFrame;
                }
#endif
            }
            /* internal */
            set
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    context.ProcedureFrame = value;
#else
                lock (syncRoot)
                {
                    procedureFrame = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame UplevelFrame /* THREAD-SAFE */
        {
            get
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    return context.UplevelFrame;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return uplevelFrame;
                }
#endif
            }
            /* internal */
            set
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    context.UplevelFrame = value;
#else
                lock (syncRoot)
                {
                    uplevelFrame = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ITraceInfo TraceInfo /* THREAD-SAFE */
        {
            get
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    return context.TraceInfo;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return traceInfo;
                }
#endif
            }
            set
            {
#if THREADING
                IVariableContext context = GetVariableContext();

                if (context != null)
                    context.TraceInfo = value;
#else
                lock (syncRoot)
                {
                    traceInfo = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
#if THREADING
        private IVariableContext GetVariableContext()
        {
            return (contextManager != null) ?
                contextManager.GetVariableContext(true) : null;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private IClientData CurrentResolveData
        {
            get
            {
#if !THREADING
                lock (syncRoot) /* TRANSACTIONAL */
#endif
                {
                    ICallFrame frame = CurrentFrame;

                    return (frame != null) ? frame.ResolveData : null;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This property is always the global call frame; however,
        //          it is intended for use by the ContextManager class only.
        //          Please use the "GlobalFrame" property instead.  Assumes
        //          interpreter lock is held.
        //
        internal ICallFrame InternalGlobalFrame
        {
            get { return globalFrame; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This method is allowed to access the global call frame
        //          variable directly because it is called directly by the
        //          ContextManager class.  Nobody else should access the
        //          global frame variable directly.  Please use the
        //          "CurrentGlobalFrame" property instead.  This assumes
        //          the interpreter lock is held.
        //
        internal bool CreateGlobalFrame(
            CallStack callStack
            )
        {
            if (globalFrame == null)
            {
                globalFrame = NewGlobalCallFrame(callStack);
                return false; /* NOTE: It was not already there. */
            }

            return true; /* NOTE: It was already there. */
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ICallFrame Management
        internal bool IsCallFrameInCallStack(ICallFrame frame)
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                if (CallStack != null)
                    return CallStack.Contains(frame);
                else
                    return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsVariableCallFrame(ICallFrame frame)
        {
            if (!CallFrameOps.IsVariable(frame))
                return false;

            ICallFrame variableFrame = frame;

            if (GetVariableFrameViaResolvers( /* NO-LOCK */
                    LookupFlags.NoVerbose,
                    ref variableFrame) != ReturnCode.Ok)
            {
                return false;
            }

            return CallFrameOps.IsSame(frame, variableFrame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsGlobalCallFrame(ICallFrame frame)
        {
            return CallFrameOps.IsSame(frame, CurrentGlobalFrame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsGlobalScopeCallFrame(ICallFrame frame)
        {
            return CallFrameOps.IsSame(frame, GlobalScopeFrame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsCurrentCallFrame(ICallFrame frame)
        {
            return CallFrameOps.IsSame(frame, CurrentFrame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsProcedureCallFrame(ICallFrame frame)
        {
            return CallFrameOps.IsSame(frame, ProcedureFrame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsUplevelCallFrame(ICallFrame frame)
        {
            return CallFrameOps.IsSame(frame, UplevelFrame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static bool IsNamespaceCallFrame(ICallFrame frame)
        {
            return CallFrameOps.IsNamespace(frame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsScopeCallFrame(
            ICallFrame frame,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!CallFrameOps.IsScope(frame))
                {
                    error = "call frame not of the scope type";
                    return false;
                }

                if (!HasScopes(ref error))
                    return false;

                foreach (KeyValuePair<string, ICallFrame> pair in scopes)
                {
                    ICallFrame localFrame = pair.Value;

                    if (localFrame == null)
                        continue;

                    if (CallFrameOps.IsSame(frame, localFrame))
                        return true;
                }

                error = "scope call frame not found";
                return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame GetProcedureFrame() /* CANNOT RETURN NULL */
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                ICallFrame frame = ProcedureFrame;

                return (frame != null) ? frame : CurrentGlobalFrame;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame GetUplevelFrame() /* CANNOT RETURN NULL */
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                ICallFrame frame = UplevelFrame;

                return (frame != null) ? frame : CurrentFrame;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame GetVariableFrame(
            ICallFrame frame,
            ref string varName,
            ref VariableFlags flags
            ) /* CANNOT RETURN NULL */
        {
            EntityOps.GetFlags(ref varName, ref flags);

            return GetVariableFrame(frame, flags);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame GetVariableFrame( // TODO: Replace uses of me.
            ICallFrame frame,
            VariableFlags flags
            ) /* CANNOT RETURN NULL */
        {
            ICallFrame variableFrame;

#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                if (FlagOps.HasFlags(flags, VariableFlags.GlobalOnly, true))
                {
                    variableFrame = CurrentGlobalFrame;
                }
                else
                {
                    if (frame != null)
                        variableFrame = CallFrameOps.FollowNext(frame);
                    else
                        variableFrame = CallFrameOps.FollowNext(CurrentFrame);

                    if (variableFrame == null)
                        variableFrame = CurrentGlobalFrame;
                }
            }

            return variableFrame;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void GetInfoLevelFlagsAndFrame(
            string subCommand,
            ref CallFrameFlags flags,
            ref ICallFrame frame
            ) /* HACK */
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                flags |= CallFrameFlags.Invisible;
                frame = CurrentFrame;

                //
                // NOTE: If we are not performing work for the generic
                //       "level" sub-command then always allow invisible
                //       call frames to be seen; otherwise, only allow
                //       invisible call frames to be seen if we are within
                //       a call frame that has the appropriate flag set.
                //
                if ((subCommand != null) && !SharedStringOps.SystemEquals(
                        subCommand, CallFrameOps.InfoLevelSubCommand) ||
                    CallFrameOps.Find(CallStack, frame, false, 0,
                        CallFrameFlags.NoInvisible, CallFrameFlags.None,
                        false, false) == ReturnCode.Ok)
                {
                    flags &= ~CallFrameFlags.Invisible;
                    frame = CallFrameOps.FollowNext(frame);
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal CallFrameFlags GetInfoLevelCallFrameFlags()
        {
            CallFrameFlags result = CallFrameFlags.InfoLevel;

            if (!AreNamespacesEnabled())
                result &= ~CallFrameFlags.Namespace;

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetInfoLevel(
            string subCommand,
            ref int level,
            ref Result error
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                //
                // HACK: Allow, through the usage of "##<integer>" notation,
                //       traversal of all call frames, including invisible
                //       ones.  This feature is not supported by Tcl.
                //
                CallFrameFlags notHasFlags = CallFrameFlags.None;
                ICallFrame currentFrame = null;

                GetInfoLevelFlagsAndFrame(
                    subCommand, ref notHasFlags, ref currentFrame);

                if ((currentFrame != null) &&
                    currentFrame.HasFlags(CallFrameFlags.Downlevel, true))
                {
                    level = (int)currentFrame.FrameLevel;
                    return ReturnCode.Ok;
                }

                return CallFrameOps.Count(CallStack, currentFrame,
                    GetInfoLevelCallFrameFlags(), notHasFlags, false,
                    false, ref level, ref error);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetInfoLevelArguments(
            string subCommand,
            string text,
            int level,
            bool fullName,
            ref Result result
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                //
                // HACK: Allow, through the usage of "##<integer>" notation,
                //       traversal of all call frames, including invisible
                //       ones.  This feature is not supported by Tcl.
                //
                CallFrameFlags notHasFlags = CallFrameFlags.NoVariables;
                ICallFrame currentFrame = null;

                GetInfoLevelFlagsAndFrame(
                    subCommand, ref notHasFlags, ref currentFrame);

                ArgumentList arguments;
                string executeName = null;

                if ((currentFrame != null) &&
                    currentFrame.HasFlags(CallFrameFlags.Downlevel, true))
                {
                    ICallFrame uplevelFrame = GetUplevelFrame();

                    arguments = (uplevelFrame != null) ?
                        uplevelFrame.Arguments : null;

                    if (arguments != null)
                    {
                        if (fullName && !CallFrameOps.GetIExecuteName(
                                uplevelFrame, ref executeName))
                        {
                            //
                            // TODO: Should this fail?  Caller requested
                            //       the "exact" name and for some reason
                            //       we cannot provide it.  Alternatively,
                            //       we could fallback to the normal case
                            //       and use the first argument.
                            //
                            result = "uplevel frame missing command name";
                            return ReturnCode.Error;
                        }

                        if (executeName != null)
                        {
                            arguments = arguments.CloneWithNewFirstValue(
                                executeName);
                        }

                        result = arguments.ToString();
                        return ReturnCode.Ok;
                    }
                }

                ReturnCode code;
                ICallFrame frame = null;

                code = CallFrameOps.GetOrFind(
                    CallStack, GlobalFrame /* EXEMPT */, CurrentGlobalFrame,
                    currentFrame, (level > 0), false, Math.Abs(level),
                    CallFrameFlags.Variables, notHasFlags, false, false,
                    ref frame, ref result);

                arguments = (frame != null) ? frame.Arguments : null;

                if ((code == ReturnCode.Ok) && (arguments != null))
                {
                    if (fullName && !CallFrameOps.GetIExecuteName(
                            frame, ref executeName))
                    {
                        //
                        // TODO: Should this fail?  Caller requested
                        //       the "exact" name and for some reason
                        //       we cannot provide it.  Alternatively,
                        //       we could fallback to the normal case
                        //       and use the first argument.
                        //
                        result = "specified frame missing command name";
                        return ReturnCode.Error;
                    }

                    if (executeName != null)
                    {
                        arguments = arguments.CloneWithNewFirstValue(
                            executeName);
                    }

                    result = arguments.ToString();
                }
                else
                {
                    result = String.Format(
                        "bad level {0}",
                        FormatOps.WrapOrNull(text));

                    code = ReturnCode.Error;
                }

                return code;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Peek / Push / Pop
        #region Shared
#if DEBUG
        private bool IsCallStackStrict()
        {
            //
            // HACK: Accessed without locking, critical path.
            //
            // lock (syncRoot) /* TRANSACTIONAL */
            {
                return FlagOps.HasFlags( /* NO-LOCK */
                    interpreterStateFlags, InterpreterStateFlags.StrictCallStack,
                    true); /* EXEMPT */
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void ThrowInvalidCallStack(
            ReturnCode code,
            Result error
            )
        {
            Result result = (error != null) ?
                String.Format("{0}: {1}", InvalidCallStackError, error) :
                InvalidCallStackError;

#if DEBUG && VERBOSE
            DebugOps.Complain(this, code, result);
#endif

            throw new ScriptException(code, result);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Peek
        internal bool CanPeekCallFrame()
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                return CallFrameOps.CanPeekOrPop(CallStack);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame PeekCallFrame()
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                ICallFrame peekFrame = null;
                CallStack callStack = CallStack;

#if DEBUG
                if (CallFrameOps.CanPeekOrPop(callStack))
#endif
                {
                    peekFrame = CallFrameOps.Peek(callStack);
                }
#if DEBUG
                else if (IsCallStackStrict())
                {
                    //
                    // NOTE: If there are no call frames on the stack, this
                    //       is an error.
                    //
                    ThrowInvalidCallStack(ReturnCode.Error,
                        "missing global call frame before peek");
                }
#endif

                return peekFrame;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ICallFrame FindCallFrame(
            ICallFrame notFrame,
            CallFrameFlags hasFlags,
            CallFrameFlags notHasFlags,
            bool hasAll,
            bool notHasAll
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                CallStack callStack = CallStack; /* PROPERTY */

                if (callStack != null)
                {
                    int count = callStack.Count;

                    for (int index = 0; index < count; index++)
                    {
                        ICallFrame frame = null;

                        if (!CallFrameOps.CanPeekOrPop(
                                callStack, index, ref frame))
                        {
                            continue;
                        }

                        if (frame == null)
                            continue;

                        if ((notFrame != null) &&
                            CallFrameOps.IsSame(frame, notFrame))
                        {
                            continue;
                        }

                        if (CallFrameOps.MatchFlags(
                                CallFrameOps.GetFlagsNoThrow(
                                frame), hasFlags, notHasFlags,
                                hasAll, notHasAll))
                        {
                            return frame;
                        }
                    }
                }

                return null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by the CallFrameOps.CloneToExisting
        //          method only.
        //
        internal ICallFrame GetVariableCallFrame(
            ICallFrame notFrame
            )
        {
            return FindCallFrame(
                notFrame, CallFrameFlags.Variables,
                CallFrameFlags.None, false, false);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Push
        internal void PushCallFrame(
            ICallFrame newFrame
            )
        {
            PushCallFrame(newFrame, false);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void PushAutomaticCallFrame(
            ICallFrame newFrame
            )
        {
            PushCallFrame(newFrame, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void PushCallFrame(
            ICallFrame newFrame,
            bool automatic
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                CallStack callStack = CallStack;

#if DEBUG
                if (CallFrameOps.CanPush(callStack))
#endif
                {
                    ICallFrame frame = null;

                    //
                    // NOTE: Push the call frame.
                    //
                    CallFrameOps.Push(callStack, newFrame, ref frame);

                    //
                    // NOTE: Flag the call frame as 'automatic', if necessary.
                    //
                    if (automatic && (frame != null))
                        frame.Flags |= CallFrameFlags.Automatic;

                    //
                    // NOTE: Set the current call frame to the one we just pushed.
                    //
                    CurrentFrame = frame;
                }
#if DEBUG
                else if (IsCallStackStrict())
                {
                    //
                    // NOTE: If the call stack is unusable, this is an error.
                    //
                    ThrowInvalidCallStack(
                        ReturnCode.Error, "missing before push");
                }
#endif
            }

#if NOTIFY
            /* IGNORED */
            CheckNotification(
                NotifyType.CallFrame, NotifyFlags.Pushed,
                newFrame, this,
                null, null, null);
#endif
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Pop
        private ICallFrame PopCallFrame()
        {
            ICallFrame popFrame = null;
            ICallFrame frame = null;

#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                //
                // NOTE: Grab the thread call stack into a local variable.
                //
                CallStack callStack = CallStack;

                //
                // NOTE: Pop the call frame now.  In the debug build, make
                //       sure there are actually some call frames available;
                //       otherwise, complain.
                //
#if DEBUG
                if (CallFrameOps.CanPeekOrPop(callStack))
#endif
                {
                    popFrame = CallFrameOps.Pop(callStack, ref frame);
                }
#if DEBUG
                else if (IsCallStackStrict())
                {
                    //
                    // NOTE: If there are no call frames on the stack, this
                    //       is an error.
                    //
                    ThrowInvalidCallStack(ReturnCode.Error,
                        "missing global call frame before pop");
                }
#endif

                //
                // NOTE: Set the current call frame to the one we just popped.
                //
                CurrentFrame = frame;

#if DEBUG
                //
                // NOTE: If there are no call frames left on the stack, this
                //       is an error.
                //
                if (IsCallStackStrict() &&
                    !CallFrameOps.CanPeekOrPop(callStack))
                {
                    ThrowInvalidCallStack(ReturnCode.Error,
                        "missing global call frame after pop");
                }
#endif
            }

#if NOTIFY || NOTIFY_OBJECT
            /* IGNORED */
            CheckNotification(
                NotifyType.CallFrame, NotifyFlags.Popped,
                popFrame, this,
                null, null, null);
#endif

            return popFrame;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ICallFrame PopCallFrameNoThrow(
            bool notify
            )
        {
            ICallFrame popFrame = null;

#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                //
                // NOTE: Grab the thread call stack into a local variable.
                //
                CallStack callStack = CallStack;

                //
                // NOTE: Pop the call frame now.  In the debug build, make
                //       sure there are actually some call frames available;
                //       otherwise, complain.
                //
                if (CallFrameOps.CanPeekOrPop(callStack))
                {
                    ICallFrame frame = null;

                    //
                    // NOTE: Attempt to pop one call frame now.  This may be
                    //       the global call frame and that is fine.  It is
                    //       up to the caller to make sure the call stack is
                    //       in a consistent state after this method returns.
                    //
                    popFrame = CallFrameOps.Pop(callStack, ref frame);

                    //
                    // NOTE: Set the current call frame to the one we just
                    //       popped.
                    //
                    CurrentFrame = frame;
                }
            }

#if NOTIFY || NOTIFY_OBJECT
            if (notify)
            {
                /* IGNORED */
                CheckNotification(
                    NotifyType.CallFrame, NotifyFlags.Popped,
                    popFrame, this,
                    null, null, null);
            }
#endif

            return popFrame;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ICallFrame PopCallFramesAndOneMore(
            CallFrameFlags hasFlags,
            bool all
            )
        {
            ICallFrame newFrame = PopCallFrames(hasFlags, 0, all);

            if (newFrame != null)
                newFrame = PopCallFrame();

            return newFrame;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ICallFrame PopCallFrames(
            CallFrameFlags hasFlags,
            int limit,
            bool all
            )
        {
            ICallFrame frame = null;

            return PopCallFrames(hasFlags, limit, all, ref frame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ICallFrame PopCallFrames(
            CallFrameFlags hasFlags,
            int limit,
            bool all,
            ref ICallFrame frame
            )
        {
            ICallFrame newFrame = null;

#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                int count = 0;
                bool done = false;

                do
                {
                    //
                    // NOTE: Examine the current call frame without popping it.
                    //       Upon returning from this method, returning a valid
                    //       call frame will cause that call frame to be popped.
                    //
                    newFrame = PeekCallFrame();

                    //
                    // HACK: Prevent an exception from being thrown here if the
                    //       call frame has been disposed (i.e. via the context
                    //       manager) at a point after the last disposal check.
                    //
                    if ((newFrame != null) && FlagOps.HasFlags(
                            CallFrameOps.GetFlagsNoThrow(newFrame), hasFlags,
                            all))
                    {
                        //
                        // NOTE: The current call frame does match the flags
                        //       provided by the caller, attempt to pop it now.
                        //
#if DEBUG
                        ICallFrame popFrame = PopCallFrame();
#else
                        /* IGNORED */
                        PopCallFrame();
#endif

                        //
                        // NOTE: Keep track of how many call frames have been
                        //       popped so far.
                        //
                        count++;

#if DEBUG
                        //
                        // NOTE: Check that the popped call frame matches the one
                        //       that we were expecting to pop.
                        //
                        if (IsCallStackStrict() &&
                            !CallFrameOps.IsSame(popFrame, newFrame))
                        {
                            ThrowInvalidCallStack(ReturnCode.Error,
                                "popped call frame does not match expected");
                        }
#endif

                        //
                        // NOTE: Provide the caller with the most recent frame
                        //       that was popped.
                        //
                        frame = newFrame;

                        //
                        // NOTE: Have we reached the limit for the number of
                        //       matching call frames to pop?  If the limit is
                        //       zero or negative, there is no limit.
                        //
                        if ((limit > 0) && (count >= limit))
                            done = true;
                    }
                    else
                    {
                        done = true;
                    }
                }
                while (!done);
            }

            return newFrame;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Global (Engine)
        internal void PushGlobalCallFrame(
            bool mark
            )
        {
            PushGlobalCallFrame(mark, false);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void PushGlobalCallFrame(
            bool mark,
            bool automatic
            )
        {
            if (mark)
            {
                //
                // BUGFIX: When pushing the global call frame from the engine we
                //         must make sure this is treated just like [uplevel #0]
                //         (i.e. the other call frames must be marked as invisible
                //         for [info level], etc to work properly).
                //
                ReturnCode code;
                Result error = null;

                code = CallFrameOps.MarkMatching(
                    CallStack, CurrentFrame, true, 0, CallFrameFlags.Variables,
                    CallFrameFlags.Invisible | CallFrameFlags.NoVariables,
                    CallFrameFlags.Invisible, false, false, true, ref error);

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error); // BUGBUG: Panic!

                ICallFrame globalFrame = CurrentGlobalFrame;
                string frameName;

                if (CallFrameOps.IsGlobalScope(globalFrame))
                    frameName = "global scope (engine)";
                else
                    frameName = "global (engine)";

                ICallFrame frame = NewLinkedCallFrame(
                    frameName, 0, CallFrameFlags.Uplevel, CurrentResolveData,
                    null, null, globalFrame);

                PushCallFrame(frame, automatic);

                //
                // TODO: Figure out if this will work here when use instead
                //       of the previous two statements.
                //
                // PushCallFrame(CurrentGlobalFrame, automatic);
            }
            else
            {
                PushCallFrame(CurrentGlobalFrame, automatic);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame PopScopeCallFramesAndOneMore() /* EXIT POINT */
        {
            return PopCallFramesAndOneMore(CallFrameFlags.Scope, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame PopScopeCallFrames()
        {
            return PopCallFrames(CallFrameFlags.Scope, 0, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame PopScopeCallFrames(
            ref ICallFrame frame
            )
        {
            return PopCallFrames(CallFrameFlags.Scope, 0, true, ref frame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void PopGlobalCallFrame( /* EXIT POINT */
            bool mark
            )
        {
            /* IGNORED */
            PopScopeCallFramesAndOneMore();

            if (mark)
            {
                ReturnCode code;
                Result error = null;

                code = CallFrameOps.MarkMatching(
                    CallStack, CurrentFrame, true, 0, CallFrameFlags.Variables,
                    CallFrameFlags.NoVariables, CallFrameFlags.Invisible, false,
                    false, false, ref error);

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error); // BUGBUG: Panic!
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Namespace (Core)
        #region Dead Code
#if DEAD_CODE
        internal void PushCurrentNamespace(
            INamespace @namespace,
            ref INamespace savedNamespace
            )
        {
            savedNamespace = NamespaceOps.GetCurrent(this, null);
            NamespaceOps.SetCurrent(this, null, @namespace);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal INamespace PopCurrentNamespace(
            ref INamespace savedNamespace
            )
        {
            INamespace @namespace = NamespaceOps.GetCurrent(this, null);
            NamespaceOps.SetCurrent(this, null, savedNamespace);
            savedNamespace = null;
            return @namespace;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void EnterNamespaceCallFrame(
            ICallFrame newFrame
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                //
                // NOTE: Increase the reference count for the namespace that
                //       is associated with the call frame.
                //
                if (newFrame != null)
                {
                    INamespace @namespace = NamespaceOps.GetCurrent(
                        this, newFrame);

                    if (@namespace != null)
                    {
                        /* IGNORED */
                        @namespace.Enter(true);
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void ExitNamespaceCallFrame(
            ICallFrame newFrame
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                //
                // NOTE: Decrease the reference count for the namespace that
                //       is associated with the call frame.
                //
                if (newFrame != null)
                {
                    INamespace @namespace = NamespaceOps.GetCurrent(
                        this, newFrame);

                    if (@namespace != null)
                    {
                        /* IGNORED */
                        @namespace.Exit(true);

                        if (@namespace.Deleted &&
                            !IsGlobalNamespace(@namespace) &&
                            CanDeleteNamespace(@namespace))
                        {
                            ReturnCode deleteCode;
                            Result deleteResult = null;

                            deleteCode = DeleteNamespace(
                                VariableFlags.None, @namespace, false,
                                ref deleteResult);

                            if (deleteCode != ReturnCode.Ok)
                                DebugOps.Complain(this, deleteCode, deleteResult);
                        }
                    }
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void PushNamespaceCallFrame(
            ICallFrame newFrame
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                //
                // NOTE: For now, just push the call frame as 'automatic'.
                //
                PushAutomaticCallFrame(newFrame);

                //
                // NOTE: Increase the reference count for the namespace that
                //       is associated with the call frame.
                //
                EnterNamespaceCallFrame(newFrame);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame PopNamespaceCallFrame(
            ICallFrame newFrame
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                //
                // NOTE: Decrease the reference count for the namespace that
                //       is associated with the call frame.
                //
                ExitNamespaceCallFrame(newFrame);

                //
                // NOTE: Cleanup any leftover open scopes from the procedure.
                //       We MUST do this here because otherwise the pop below
                //       will fail to pop the procedure call frame from the
                //       stack, thereby permanently unbalancing it.
                //
                return PopScopeCallFramesAndOneMore();
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Procedure (Core)
        internal void EnterProcedureCallFrame(
            ICallFrame newFrame,
            ref ICallFrame savedFrame
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                savedFrame = ProcedureFrame; // save the current procedure call frame.
                ProcedureFrame = newFrame;   // set the new procedure call frame.
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void ExitProcedureCallFrame(
            ref ICallFrame savedFrame
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                ProcedureFrame = savedFrame; // restore the saved procedure call frame.
                savedFrame = null;           // reset the saved procedure call frame.
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void PushProcedureCallFrame(
            ICallFrame newFrame,
            bool automatic,
            ref ICallFrame savedFrame
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                //
                // NOTE: Push the new procedure call frame, thereby making it
                //       the current call frame.
                //
                PushCallFrame(newFrame, automatic);

                //
                // NOTE: If necessary, enter the namespace context.
                //
                if (AreNamespacesEnabled())
                    EnterNamespaceCallFrame(newFrame);

                //
                // NOTE: Save the current procedure call frame and enter the
                //       new procedure call frame.
                //
                EnterProcedureCallFrame(newFrame, ref savedFrame);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame PopProcedureCallFrame( /* EXIT POINT */
            ICallFrame newFrame,
            ref ICallFrame savedFrame
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                //
                // NOTE: Cleanup any leftover open scopes from the procedure.
                //       We MUST do this here because otherwise the pop below
                //       will fail to pop the procedure call frame from the
                //       stack, thereby permanently unbalancing it.
                //
                /* IGNORED */
                PopScopeCallFrames();

                //
                // NOTE: Exit the current procedure call frame and restore
                //       the procedure call frame saved earlier.
                //
                ExitProcedureCallFrame(ref savedFrame);

                //
                // NOTE: If necessary, exit the namespace context.
                //
                if (AreNamespacesEnabled())
                    ExitNamespaceCallFrame(newFrame);

                //
                // NOTE: Grab the current call frame so that we can clean it
                //       up (i.e. remove undefined variables).
                //
                ICallFrame currentFrame = CurrentFrame;

                //
                // NOTE: Cleanup the current call frame (i.e. the procedure
                //       call frame).
                //
                /* IGNORED */
                CallFrameOps.Cleanup(currentFrame, newFrame, false);

                //
                // NOTE: Now pop the top call frame, which should be the
                //       procedure call frame.
                //
                ICallFrame popFrame = PopCallFrame();

                //
                // NOTE: Cleanup the call frame and mark it as undefined.
                //
                /* IGNORED */
                CallFrameOps.Cleanup(currentFrame, popFrame, true);

                //
                // NOTE: Return the call frame we just popped.
                //
                return popFrame;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Uplevel (Core)
        internal void EnterUplevelCallFrame(
            ICallFrame newFrame,
            ref ICallFrame savedFrame
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                savedFrame = UplevelFrame; // save the current uplevel call frame.
                UplevelFrame = newFrame;   // set the new uplevel call frame.
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void ExitUplevelCallFrame(
            ref ICallFrame savedFrame
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                UplevelFrame = savedFrame; // restore the saved uplevel call frame.
                savedFrame = null;           // reset the saved uplevel call frame.
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void PushUplevelCallFrame(
            ICallFrame oldFrame,
            ICallFrame newFrame,
            bool automatic,
            ref ICallFrame savedFrame
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                //
                // NOTE: Push the new uplevel call frame, thereby making it
                //       the current call frame.
                //
                PushCallFrame(newFrame, automatic);

                //
                // NOTE: Link the newly created [uplevel] call frame to the
                //       current frame provided by the caller.  This will help
                //       later when the [info level] sub-command is used from
                //       a [downlevel] call frame.
                //
                if (oldFrame != null)
                    oldFrame.Other = newFrame;

                //
                // NOTE: Save the current uplevel call frame and enter the
                //       new uplevel call frame.
                //
                EnterUplevelCallFrame(oldFrame, ref savedFrame);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame PopUplevelCallFrame(
            ICallFrame oldFrame,
            ICallFrame newFrame,
            ref ICallFrame savedFrame
            )
        {
#if !THREADING
            lock (syncRoot) /* TRANSACTIONAL */
#endif
            {
                //
                // NOTE: Cleanup any leftover open scopes from the uplevel.
                //       We MUST do this here because otherwise the pop below
                //       will fail to pop the uplevel call frame from the
                //       stack, thereby permanently unbalancing it.
                //
                /* IGNORED */
                PopScopeCallFrames();

                //
                // NOTE: Exit the current uplevel call frame and restore
                //       the uplevel call frame saved earlier.
                //
                ExitUplevelCallFrame(ref savedFrame);

                //
                // NOTE: Now unlink the [uplevel] call frame from the old call
                //       frame (i.e. the one that was the current call frame
                //       prior to the [uplevel] call frame being pushed).
                //
                if (oldFrame != null)
                    oldFrame.Other = null;

                //
                // NOTE: Now pop the top call frame, which should be the
                //       uplevel call frame.
                //
                ICallFrame popFrame = PopCallFrame();

                //
                // NOTE: Return the call frame we just popped.
                //
                return popFrame;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Automatic (Engine)
        internal static bool ShouldPopAutomaticCallFrame( /* EXIT POINT */
            Interpreter interpreter,
            ICallFrame oldFrame
            )
        {
            if (interpreter == null)
                return false;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return false;

                if (oldFrame == null)
                    return false;

                if (!interpreter.CanPeekCallFrame())
                    return false;

                return !CallFrameOps.IsSame(
                    oldFrame, interpreter.PeekCallFrame());
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static ICallFrame PopAutomaticCallFrame( /* EXIT POINT */
            Interpreter interpreter
            )
        {
            if (interpreter == null)
                return null;

            lock (interpreter.InternalSyncRoot) /* TRANSACTIONAL */
            {
                if (interpreter.PrivateDisposed)
                    return null;

                //
                // NOTE: Cleanup any leftover open scopes from the procedure.  We
                //       MUST do this here because otherwise the pop below will
                //       fail to pop the procedure call frame from the stack,
                //       thereby permanently unbalancing it.
                //
                /* IGNORED */
                interpreter.PopScopeCallFrames();

                //
                // NOTE: If the top of the call stack is an automatic call frame,
                //       that means it was not cleaned up by the code associated
                //       with originally pushing it.  In that case, pop it now;
                //       however, make sure that a maximum of one such call frame
                //       is popped.
                //
                ICallFrame popFrame = interpreter.PopCallFrames(
                    CallFrameFlags.Automatic, 1, true);

                //
                // NOTE: If the current procedure call frame was just popped, then
                //       it must be reset it as well.
                //
                if (CallFrameOps.IsSame(popFrame, interpreter.ProcedureFrame))
                    interpreter.ProcedureFrame = null;

                //
                // NOTE: If the current uplevel call frame was just popped, then
                //       it must be reset it as well.
                //
                if (CallFrameOps.IsSame(popFrame, interpreter.UplevelFrame))
                    interpreter.UplevelFrame = null;

                //
                // NOTE: Always return the call frame that was just popped, if any.
                //
                return popFrame;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Reset (Emergency Use Only)
        //
        // HACK: *WARNING* This method is a very lightly tested way of forcing
        //       the call stack for the interpreter to be completely reset to
        //       its initial state (i.e. with only the global frame present).
        //       It must not be called while a script is being evaluated using
        //       the interpreter (from any thread); otherwise, the results are
        //       undefined.  Since this method is private, it can only be used
        //       via reflection.  If this method fails, the interpreter may be
        //       in an inconsistent state (e.g. its call stack may be unusable
        //       for script evaluation).
        //
        private ReturnCode ResetCallStackAndFrames(
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                {
                    error = "attempt to call eval in disposed interpreter";
                    return ReturnCode.Error;
                }

                CallStack callStack = CallStack;
                ICallFrame peekFrame = null;

                while (true)
                {
                    if (!CallFrameOps.CanPeekOrPop(callStack, ref peekFrame))
                        break;

                    if (IsGlobalCallFrame(peekFrame))
                        break;

                    /* IGNORED */
                    PopCallFrame();
                }

                if (!IsGlobalCallFrame(peekFrame))
                {
                    error = "final peeked call frame is not global";
                    return ReturnCode.Error;
                }

                if (!IsGlobalCallFrame(PopCallFrameNoThrow(false)))
                {
                    error = "final popped call frame is not global";
                    return ReturnCode.Error;
                }

                if (!CallFrameOps.IsEmpty(callStack, true))
                {
                    error = "call stack is not empty";
                    return ReturnCode.Error;
                }

                PreSetupCallFramesPhase2();
                return ReturnCode.Ok;
            }
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ICallFrame (Scope)
        private ReturnCode GetScopeCallFrame(
            string name,
            LookupFlags lookupFlags,
            bool pop,
            bool remove,
            ref ICallFrame frame
            )
        {
            Result error = null;

            return GetScopeCallFrame(name, lookupFlags, pop, remove, ref frame, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetScopeCallFrame(
            string name,
            LookupFlags lookupFlags,
            bool pop,
            bool remove,
            ref ICallFrame frame,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!HasScopes(ref error))
                    return ReturnCode.Error;

                //
                // NOTE: Grab the current call frame without popping it.
                //
                ICallFrame newFrame = PeekCallFrame();

                //
                // NOTE: We cannot follow linked call frames if we
                //       intend to pop the innermost scope call frame.
                //
                if (!pop)
                    newFrame = CallFrameOps.FollowNext(newFrame);

                //
                // NOTE: Is the current call frame valid?
                //
                if (newFrame == null)
                {
                    error = "invalid call frame";
                    return ReturnCode.Error;
                }

                if (!newFrame.IsUsable(ref error))
                    return ReturnCode.Error;

                //
                // NOTE: Is this a [scope] created persistent call frame (i.e.
                //       one that was created by [scope], but not by [scope
                //       eval]).
                //
                CallFrameFlags frameFlags = newFrame.Flags;

                if (!FlagOps.HasFlags(frameFlags, CallFrameFlags.Scope, true) ||
                    FlagOps.HasFlags(frameFlags, CallFrameFlags.Evaluate, true))
                {
                    error = "no scopes are open";
                    return ReturnCode.Error;
                }

                //
                // NOTE: Does the provided scope name, if any, match?
                //
                if ((name == null) ||
                    SharedStringOps.SystemEquals(newFrame.Name, name))
                {
                    //
                    // NOTE: Pop the call frame from the call stack?
                    //
                    if (pop)
                    {
                        //
                        // NOTE: We know the call stack has not changed here
                        //       because we are holding the interpreter lock.
                        //
                        frame = PopCallFrame(); // return and remove it.

#if DEBUG
                        //
                        // NOTE: Check that the popped call frame matches the one
                        //       that we were expecting to pop.
                        //
                        if (IsCallStackStrict() &&
                            !CallFrameOps.IsSame(frame, newFrame))
                        {
                            ThrowInvalidCallStack(ReturnCode.Error,
                                "popped call frame does not match expected");
                        }
#endif
                    }
                    else
                    {
                        frame = newFrame; // just return it.
                    }

                    //
                    // NOTE: Remove the call frame from the interpreter?
                    //
                    if (remove)
                        scopes.Remove(newFrame.Name);

                    return ReturnCode.Ok;
                }
                else
                {
                    error = FlagOps.HasFlags(
                        lookupFlags, LookupFlags.Verbose, true) ?
                        String.Format(
                            "scope {0} is not innermost",
                            FormatOps.WrapOrNull(name)) :
                        "scope is not innermost";

                    return ReturnCode.Error;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode CopyProcedureArgumentsToFrame(
            ICallFrame frame,
            bool merge,
            ref Result error
            )
        {
            ArgumentList frameArguments = null;
            bool useNamedArguments = false;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                ICallFrame procedureFrame = ProcedureFrame;

                //
                // NOTE: Steal the arguments from the containing procedure;
                //       otherwise, we cannot access them from the [scope].
                //
                if ((procedureFrame != null) &&
                    (procedureFrame.ProcedureArguments != null))
                {
                    frameArguments = new ArgumentList(
                        procedureFrame.ProcedureArguments);

                    IProcedure procedure =
                        procedureFrame.Execute as IProcedure;

                    if (EntityOps.IsNamedArguments(procedure))
                        useNamedArguments = true;
                }
            }

            ReturnCode code = ReturnCode.Ok;

            if ((frame != null) && (frameArguments != null))
            {
                //
                // NOTE: Create variables for each of the formal arguments
                //       to the enclosing procedure.  Start the counting at
                //       one to skip the procedure name itself.
                //
                VariableDictionary variables = frame.Variables;

                if (useNamedArguments)
                {
                    for (int argumentIndex = 1;
                            argumentIndex < frameArguments.Count; argumentIndex += 2)
                    {
                        Argument nameArgument = frameArguments[argumentIndex];

                        if (nameArgument == null)
                            continue;

                        string varName = StringOps.GetStringFromObject(nameArgument);

                        if (merge || !variables.ContainsKey(varName))
                        {
                            Argument valueArgument = frameArguments[argumentIndex + 1];
                            object varValue = null;

                            if (valueArgument != null)
                                varValue = valueArgument.Value;

                            IVariable frameVariable = null; /* NOT USED */

                            code = SetVariableValue2(
                                VariableFlags.Argument, frame, varName, null,
                                varValue, null, ref frameVariable, ref error);

                            if (code != ReturnCode.Ok)
                                break;
                        }
                    }
                }
                else
                {
                    for (int argumentIndex = 1;
                            argumentIndex < frameArguments.Count; argumentIndex++)
                    {
                        Argument frameArgument = frameArguments[argumentIndex];

                        if (frameArgument == null)
                            continue;

                        string varName = frameArgument.Name;

                        if (merge || !variables.ContainsKey(varName))
                        {
                            object varValue = frameArgument.Value;
                            IVariable frameVariable = null; /* NOT USED */

                            code = SetVariableValue2(
                                VariableFlags.Argument, frame, varName, null,
                                varValue, null, ref frameVariable, ref error);

                            if (code != ReturnCode.Ok)
                                break;
                        }
                    }
                }

                //
                // NOTE: Finally, update the arguments for the call frame so
                //       that things like [info level] will work properly.
                //
                if (code == ReturnCode.Ok)
                    frame.Arguments = frameArguments;
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes that the interpreter lock is held.
        //
        internal ReturnCode SetGlobalScopeCallFrame(
            string name,
            ref Result error
            )
        {
            ICallFrame frame = null;

            if (GetScope(
                    name, LookupFlags.Default, ref frame,
                    ref error) == ReturnCode.Ok)
            {
                if (CallFrameOps.MarkGlobalScope(frame, ref error))
                {
                    //
                    // NOTE: First, set the global scope call frame
                    //       to the named scope call frame specified
                    //       by the caller.  Then, since it will now
                    //       be considered the current global frame,
                    //       push it onto the call stack, all while
                    //       leaving the existing global frame on
                    //       the call stack as well.
                    //
                    GlobalScopeFrame = frame;
                    PushGlobalCallFrame(false);

                    //
                    // NOTE: Finally, temporarily mark the global
                    //       frame as invisible so it will not work
                    //       for [uplevel 1], etc.
                    //
                    ICallFrame globalFrame = GlobalFrame; /* EXEMPT */

                    if (globalFrame != null)
                        globalFrame.Flags |= CallFrameFlags.Invisible;

                    return ReturnCode.Ok;
                }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes that the interpreter lock is held.
        //
        internal ReturnCode UnsetGlobalScopeCallFrame(
            bool strict,
            ref Result error
            )
        {
            ICallFrame globalScopeFrame = GlobalScopeFrame;

            if (globalScopeFrame != null)
            {
                CallFrameFlags newFlags = CallFrameFlags.None;

                if (CallFrameOps.GetNonGlobalScopeFlags(
                        globalScopeFrame, ref newFlags, ref error))
                {
                    //
                    // NOTE: First, remove temporary mark of global
                    //       frame as invisible, to restore normal
                    //       functioning of [uplevel], etc.
                    //
                    ICallFrame globalFrame = GlobalFrame; /* EXEMPT */

                    if (globalFrame != null)
                        globalFrame.Flags &= ~CallFrameFlags.Invisible;

                    //
                    // NOTE: Next, pop the global scope call frame
                    //       from the call stack.  If the top call
                    //       frame is not really the global scope
                    //       call frame, the results are undefined.
                    //       Next, reset the global scope frame to
                    //       null, which allows the normal global
                    //       frame to be used again.
                    //
                    PopGlobalCallFrame(false);
                    GlobalScopeFrame = null;

                    //
                    // NOTE: Finally, reset the flags for the scope
                    //       call frame, leaving it intact for later
                    //       use with the [scope] command and then
                    //       return success to the caller.
                    //
                    globalScopeFrame.Flags = newFlags;
                    return ReturnCode.Ok;
                }
            }
            else if (!strict)
            {
                return ReturnCode.Ok;
            }
            else
            {
                error = "global scope call frame not set";
            }

            return ReturnCode.Error;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region ICallFrame (Factory)
        internal ICallFrame NewProcedureCallFrame(
            string name,
            CallFrameFlags flags,
            IClientData auxiliaryData,
            IExecute execute,
            ArgumentList arguments
            ) /* CANNOT RETURN NULL */
        {
            INamespace @namespace = null;

            if (AreNamespacesEnabled())
                @namespace = NamespaceOps.LookupParent(this, name, false, true, false);

            return NewProcedureCallFrame(
                name, flags, auxiliaryData, execute, arguments, @namespace);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ICallFrame NewProcedureCallFrame(
            string name,
            CallFrameFlags flags,
            IClientData auxiliaryData,
            IExecute execute,
            ArgumentList arguments,
            INamespace @namespace
            ) /* CANNOT RETURN NULL */
        {
            CallStack callStack = CallStack;
            CallFrameFlags extraFlags = CallFrameFlags.None;
            IProcedure procedure = execute as IProcedure;

            if ((procedure != null) &&
                FlagOps.HasFlags(procedure.Flags, ProcedureFlags.Fast, true))
            {
                extraFlags |= CallFrameFlags.Fast;
            }

            return new CallFrame(
                NextId(), 0, name, null,
                (callStack != null) ? callStack.Count + 1 : 0, InternalLevels,
                flags | extraFlags, auxiliaryData, (@namespace != null) ?
                new ResolverClientData(@namespace) : CurrentResolveData,
                null, execute, arguments, false);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame NewNamespaceCallFrame(
            string name,
            CallFrameFlags flags,
            ArgumentList arguments
            )
        {
            return NewNamespaceCallFrame(name, flags, arguments, null, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame NewNamespaceCallFrame(
            string name,
            CallFrameFlags flags,
            ArgumentList arguments,
            INamespace @namespace,
            bool newVariables
            )
        {
            CallStack callStack = CallStack;

            return new CallFrame(
                NextId(), 0, name, null,
                (callStack != null) ? callStack.Count + 1 : 0, InternalLevels,
                flags | CallFrameFlags.Namespace, null, null, (@namespace != null) ?
                new ResolverClientData(@namespace) : CurrentResolveData,
                null, null, null, arguments, false, newVariables);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ICallFrame NewNamespaceCallFrame( /* NOT USED */
            string name,
            CallFrameFlags flags,
            IExecute execute,
            ArgumentList arguments
            )
        {
            CallStack callStack = CallStack;

            return new CallFrame(
                NextId(), 0, name, null,
                (callStack != null) ? callStack.Count + 1 : 0, InternalLevels,
                flags | CallFrameFlags.Namespace, null, null, (globalNamespace != null) ?
                new ResolverClientData(globalNamespace) : CurrentResolveData,
                null, null, execute, arguments, false, false);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame NewTrackingCallFrame(
            string name,
            CallFrameFlags flags
            )
        {
            return NewTrackingCallFrame(name, flags, CurrentResolveData);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ICallFrame NewTrackingCallFrame(
            string name,
            CallFrameFlags flags,
            IClientData resolveData
            )
        {
            return NewLinkedCallFrame(
                name, 0, flags | CallFrameFlags.Tracking, resolveData,
                null, null, CurrentFrame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame NewEngineCallFrame(
            string name,
            CallFrameFlags flags
            )
        {
            return NewEngineCallFrame(name, flags, CurrentResolveData);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ICallFrame NewEngineCallFrame(
            string name,
            CallFrameFlags flags,
            IClientData resolveData
            )
        {
            return NewLinkedCallFrame(
                name, 0, flags | CallFrameFlags.Engine, resolveData,
                null, null, CurrentFrame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame NewDownlevelCallFrame(
            string name
            )
        {
            long frameLevel = 0;
            ICallFrame nextFrame = GetUplevelFrame();

            if (nextFrame != null)
            {
                ICallFrame otherFrame = nextFrame.Other;

                if (otherFrame != null)
                    frameLevel = otherFrame.FrameLevel;
            }

            return NewLinkedCallFrame(
                name, frameLevel, CallFrameFlags.Downlevel,
                (nextFrame != null) ? nextFrame.ResolveData : null,
                null, CurrentFrame, nextFrame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame NewUplevelCallFrame(
            string name,
            long frameLevel,
            CallFrameFlags flags,
            bool mark,
            ICallFrame previousFrame,
            ICallFrame nextFrame
            )
        {
            //
            // HACK: If we are not marking call frames as "invisible" then
            //       we must be in "view everything" mode; therefore, set
            //       the NoInvisible flag on this call frame so that it
            //       will be found by [info level], etc.
            //
            return NewLinkedCallFrame(
                name, frameLevel, flags | CallFrameFlags.Uplevel |
                (mark ? CallFrameFlags.None : CallFrameFlags.NoInvisible),
                (nextFrame != null) ? nextFrame.ResolveData : null, null,
                previousFrame, nextFrame);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ICallFrame NewScopeCallFrame(
            string name,
            CallFrameFlags flags,
            VariableDictionary variables,
            ArgumentList arguments
            )
        {
            CallStack callStack = CallStack;

            return new CallFrame(
                NextId(), 0, name, null,
                (callStack != null) ? callStack.Count + 1 : 0, InternalLevels,
                flags, null, CurrentResolveData, null, variables, arguments,
                false);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: Assumes that the engine context is already available.
        //
        private ICallFrame NewGlobalCallFrame(
            CallStack callStack
            )
        {
            return new CallFrame(
                NextId(), 0, "global", null,
                (callStack != null) ? callStack.Count + 1 : 0,
                InternalLevels, CallFrameFlags.NoFree | CallFrameFlags.Global, null,
                null, null /* NOTE: DO NOT USE CurrentResolveData HERE. */,
                null, null, null, null, false, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ICallFrame NewLinkedCallFrame(
            string name,
            long frameLevel,
            CallFrameFlags flags,
            IClientData resolveData,
            ICallFrame otherFrame,
            ICallFrame previousFrame,
            ICallFrame nextFrame
            )
        {
            CallStack callStack = CallStack;

            return new CallFrame(
                NextId(), frameLevel, name, null,
                (callStack != null) ? callStack.Count + 1 : 0, InternalLevels,
                flags, null, resolveData, null, otherFrame, previousFrame,
                nextFrame);
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Flags Management
        internal EventFlags AfterEventFlags /* FOR [after] USE ONLY */
        {
            get { lock (syncRoot) { return afterEventFlags; } }
            set { lock (syncRoot) { afterEventFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal CreateFlags CreateFlags
        {
            get { lock (syncRoot) { return createFlags; } }
            set { lock (syncRoot) { createFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal CreateFlags DefaultCreateFlags
        {
            get { lock (syncRoot) { return defaultCreateFlags; } }
            set { lock (syncRoot) { defaultCreateFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal HostCreateFlags HostCreateFlags
        {
            get { lock (syncRoot) { return hostCreateFlags; } }
            set { lock (syncRoot) { hostCreateFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal HostCreateFlags DefaultHostCreateFlags
        {
            get { lock (syncRoot) { return defaultHostCreateFlags; } }
            set { lock (syncRoot) { defaultHostCreateFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal InitializeFlags InitializeFlags
        {
            get { lock (syncRoot) { return initializeFlags; } }
            set { lock (syncRoot) { initializeFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal InitializeFlags DefaultInitializeFlags
        {
            get { lock (syncRoot) { return defaultInitializeFlags; } }
            set { lock (syncRoot) { defaultInitializeFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ScriptFlags DefaultScriptFlags
        {
            get { lock (syncRoot) { return defaultScriptFlags; } }
            set { lock (syncRoot) { defaultScriptFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal InterpreterFlags InterpreterFlags
        {
            get { lock (syncRoot) { return interpreterFlags; } }
            set { lock (syncRoot) { interpreterFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal InterpreterFlags InterpreterFlagsNoLock
        {
            get { return interpreterFlags; }
            set { interpreterFlags = value; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal InterpreterFlags DefaultInterpreterFlags
        {
            get { lock (syncRoot) { return defaultInterpreterFlags; } }
            set { lock (syncRoot) { defaultInterpreterFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal InterpreterStateFlags InterpreterStateFlags
        {
            get { lock (syncRoot) { return interpreterStateFlags; } }
            set { lock (syncRoot) { interpreterStateFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal EventFlags EngineEventFlags
        {
            get { lock (syncRoot) { return engineEventFlags; } }

#if SHELL && INTERACTIVE_COMMANDS
            set { lock (syncRoot) { engineEventFlags = value; } }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if DEBUGGER || SHELL
        internal HeaderFlags HeaderFlags
        {
            get { lock (syncRoot) { return headerFlags; } }
            set { lock (syncRoot) { headerFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal DetailFlags DetailFlags
        {
            get { lock (syncRoot) { return detailFlags; } }
            set { lock (syncRoot) { detailFlags = value; } }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL && INTERACTIVE_COMMANDS
        internal bool InteractiveCommandsEnabled
        {
            get { lock (syncRoot) { return interactiveCommandsEnabled; } }
            set { lock (syncRoot) { interactiveCommandsEnabled = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal EngineFlags InteractiveEngineFlags
        {
            get { lock (syncRoot) { return interactiveEngineFlags; } }
            set { lock (syncRoot) { interactiveEngineFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal EventFlags InteractiveEventFlags
        {
            get { lock (syncRoot) { return interactiveEventFlags; } }
            set { lock (syncRoot) { interactiveEventFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ExpressionFlags InteractiveExpressionFlags
        {
            get { lock (syncRoot) { return interactiveExpressionFlags; } }
            set { lock (syncRoot) { interactiveExpressionFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal SubstitutionFlags InteractiveSubstitutionFlags
        {
            get { lock (syncRoot) { return interactiveSubstitutionFlags; } }
            set { lock (syncRoot) { interactiveSubstitutionFlags = value; } }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal PathComparisonType PathComparisonType
        {
            get { lock (syncRoot) { return pathComparisonType; } }
            set { lock (syncRoot) { pathComparisonType = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal PackageIndexFlags PackageIndexFlags
        {
            get { lock (syncRoot) { return packageIndexFlags; } }
            set { lock (syncRoot) { packageIndexFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal VariableFlags EventVariableFlags
        {
            get { lock (syncRoot) { return eventVariableFlags; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal EventWaitFlags EventWaitFlags
        {
            get { lock (syncRoot) { return eventWaitFlags; } }
            set { lock (syncRoot) { eventWaitFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal CreateFlags CreateFlagsNoLock
        {
            get { return createFlags; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private InterpreterFlags PrivateInterpreterFlags
        {
            get { /* NO-LOCK */ return interpreterFlags; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private PathComparisonType PrivatePathComparisonType
        {
            get { /* NO-LOCK */ return pathComparisonType; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private PackageIndexFlags PrivatePackageIndexFlags
        {
            get { /* NO-LOCK */ return packageIndexFlags; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReadyFlags PrivateReadyFlags
        {
            get { /* NO-LOCK */ return readyFlags; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal PackageFlags PackageFlags
        {
            get { lock (syncRoot) { return packageFlags; } }
            set { lock (syncRoot) { packageFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ProcedureFlags ProcedureFlags /* FOR [proc] USE ONLY */
        {
            get { lock (syncRoot) { return procedureFlags; } }
            set { lock (syncRoot) { procedureFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal PluginFlags PluginFlags
        {
            get { lock (syncRoot) { return pluginFlags; } }
            set { lock (syncRoot) { pluginFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal PluginFlags DefaultPluginFlags
        {
            get { lock (syncRoot) { return defaultPluginFlags; } }
            set { lock (syncRoot) { defaultPluginFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if ISOLATED_PLUGINS
        #region Dead Code
#if DEAD_CODE
        private void EnablePluginPreview()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                pluginFlags &= ~PluginFlags.NoPreview;
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisablePluginPreview()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                pluginFlags |= PluginFlags.NoPreview;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void EnablePluginIsolation()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                pluginFlags |= PluginFlags.Isolated;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void DisablePluginIsolation()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                pluginFlags &= ~PluginFlags.Isolated;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void BeginNoIsolatedPlugins(
            ref PluginFlags savedPluginFlags
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                savedPluginFlags = pluginFlags;
                pluginFlags |= PluginFlags.NoIsolated;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void EndNoIsolatedPlugins(
            ref PluginFlags savedPluginFlags
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                pluginFlags = savedPluginFlags;
                savedPluginFlags = PluginFlags.None;
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NATIVE && TCL
        internal FindFlags TclFindFlags
        {
            get { lock (syncRoot) { return tclFindFlags; } }
            set { lock (syncRoot) { tclFindFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal LoadFlags TclLoadFlags
        {
            get { lock (syncRoot) { return tclLoadFlags; } }
            set { lock (syncRoot) { tclLoadFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal UnloadFlags TclCommandUnloadFlags
        {
            get { lock (syncRoot) { return tclCommandUnloadFlags; } }
            set { lock (syncRoot) { tclCommandUnloadFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal UnloadFlags TclExitUnloadFlags
        {
            get { lock (syncRoot) { return tclExitUnloadFlags; } }
            set { lock (syncRoot) { tclExitUnloadFlags = value; } }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal EventFlags QueueEventFlags
        {
            get { lock (syncRoot) { return queueEventFlags; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal SubstitutionFlags SubstitutionFlags
        {
            get { lock (syncRoot) { return SubstitutionFlagsNoLock; } }

#if SHELL && INTERACTIVE_COMMANDS
            set { lock (syncRoot) { SubstitutionFlagsNoLock = value; } }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal SubstitutionFlags SubstitutionFlagsNoLock
        {
            get { return substitutionFlags; }

#if SHELL && INTERACTIVE_COMMANDS
            set { substitutionFlags = value; }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ExpressionFlags ExpressionFlags
        {
            get { lock (syncRoot) { return expressionFlags; } }
            set { lock (syncRoot) { expressionFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal EventFlags UpdateEventFlags
        {
            get { lock (syncRoot) { return updateEventFlags; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private EventFlags WaitEventFlags /* NOT USED */
        {
            get { lock (syncRoot) { return waitEventFlags; } }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal UpdateFlags UpdateFlags
        {
            get { lock (syncRoot) { return updateFlags; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        private VariableFlags NewGlobalVariableFlags
        {
            get { lock (syncRoot) { return newGlobalVariableFlags; } }
            set { lock (syncRoot) { newGlobalVariableFlags = value; } }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private VariableFlags NewLocalVariableFlags
        {
            get { lock (syncRoot) { return newLocalVariableFlags; } }
            set { lock (syncRoot) { newLocalVariableFlags = value; } }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL
        private int MaybeChangeFlagsForInteractiveUse()
        {
            //
            // NOTE: This method is only called right before entering
            //       the interactive loop.  Therefore, we know it is
            //       safe to remove the (various?) default flags that
            //       are disabled for non-interactive use.
            //
            int count = 0;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // NOTE: Since we are about to enter the interactive
                //       loop, enable plugin update checks; however,
                //       only do this if the plugin flags have not
                //       been (somehow?) modified via script library
                //       initialization.
                //
                if (pluginFlags == Defaults.PluginFlags)
                {
                    pluginFlags &= ~PluginFlags.NonInteractiveMask;
                    count++;
                }
            }

            return count;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Ready Flags
        private static ReadyFlags TryGetReadyFlags(
            Interpreter interpreter,
            int timeout,
            bool useEngine
            )
        {
            return TryGetReadyFlags(
                interpreter, timeout, ReadyFlags.Unknown, useEngine);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static ReadyFlags TryGetReadyFlags(
            Interpreter interpreter,
            int timeout,
            ReadyFlags @default,
            bool useEngine
            )
        {
            if (interpreter == null)
                return @default;

            ///////////////////////////////////////////////////////////////////
            //
            // BUGFIX: Do not use the public SyncRoot property here (in case we
            //         have been disposed), use the internal property instead.
            //
            bool locked = false;
            object syncRoot = interpreter.InternalSyncRoot;

            if (syncRoot == null)
                return @default;

            try
            {
                //
                // BUGFIX: *THREADING* Allow the callers to specify a timeout
                //         to avoid potential deadlocks here in some cases.
                //
                locked = Monitor.TryEnter(syncRoot, timeout);

                //
                // NOTE: We cannot check if the interpreter is actually ready;
                //       therefore, return failure.
                //
                if (!locked)
                    return @default;

                //
                // NOTE: We absoutely cannot continue if the interpreter has
                //       been disposed because that means there will be no
                //       engine context, which is required for checking the
                //       native stack space, among other things.  This is
                //       always checked because using a disposed interpreter
                //       is considered to be a serious programming error.
                //
                if (interpreter.PrivateDisposed)
                    return @default;

                //
                // NOTE: Start out with the ready flags for the interpreter.
                //       Then, optionally add the ready flags for the engine
                //       flags for the interpreter.
                //
                ReadyFlags result = interpreter.PrivateReadyFlags;

                if (useEngine)
                    result |= Engine.GetReadyFlags(interpreter.EngineFlags);

                //
                // NOTE: Return the ready flags for the interpreter.
                //
                return result;
            }
            catch (Exception e)
            {
                TraceOps.DebugTrace(
                    e, typeof(Interpreter).Name,
                    TracePriority.EngineError);
            }
            finally
            {
                if (locked)
                    Monitor.Exit(syncRoot);
            }

            return @default;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is
        //       already held.
        //
        internal VariableFlags GetNewVariableFlags(
            bool isGlobalCallFrame
            )
        {
            // lock (syncRoot) /* TRANSACTIONAL */
            // {
                return isGlobalCallFrame ?
                    newGlobalVariableFlags : newLocalVariableFlags;
            // }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Host Introspection (Default Host Only)
#if HISTORY
        private void GetHostHistoryInfo(
            ref StringPairList list, /* REMOTING */
            DetailFlags detailFlags
            )
        {
            if (list == null)
                return;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                    return;

                bool empty = HostOps.HasEmptyContent(detailFlags);
                ClientDataList _history = _History; /* NOTE: Context only. */

                if (empty || history)
                    list.Add("History", FormatOps.EnabledAndValue(history,
                        (_history != null) ? _history.Count.ToString() :
                        FormatOps.DisplayNull));

                IHistoryData historyLoadData = HistoryLoadData; /* NOTE: Context only. */

                if (empty || (historyLoadData != null))
                    list.Add("HistoryLoadData", (historyLoadData != null) ?
                        historyLoadData.ToString() : FormatOps.DisplayNull);

                IHistoryData historySaveData = HistorySaveData; /* NOTE: Context only. */

                if (empty || (historySaveData != null))
                    list.Add("HistorySaveData", (historySaveData != null) ?
                        historySaveData.ToString() : FormatOps.DisplayNull);

                IHistoryFilter historyEngineFilter = HistoryEngineFilter; /* NOTE: Context only. */

                if (empty || (historyEngineFilter != null))
                    list.Add("HistoryEngineFilter", (historyEngineFilter != null) ?
                        historyEngineFilter.ToString() : FormatOps.DisplayNull);

                IHistoryFilter historyInfoFilter = HistoryInfoFilter; /* NOTE: Context only. */

                if (empty || (historyInfoFilter != null))
                    list.Add("HistoryInfoFilter", (historyInfoFilter != null) ?
                        historyInfoFilter.ToString() : FormatOps.DisplayNull);

                IHistoryFilter historyLoadFilter = HistoryLoadFilter; /* NOTE: Context only. */

                if (empty || (historyLoadFilter != null))
                    list.Add("HistoryLoadFilter", (historyLoadFilter != null) ?
                        historyLoadFilter.ToString() : FormatOps.DisplayNull);

                IHistoryFilter historySaveFilter = HistorySaveFilter; /* NOTE: Context only. */

                if (empty || (historySaveFilter != null))
                    list.Add("HistorySaveFilter", (historySaveFilter != null) ?
                        historySaveFilter.ToString() : FormatOps.DisplayNull);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the _Hosts.Default class only.
        //
        internal void GetHostHistoryItemInfo(
            ref StringPairList list, /* REMOTING */
            IHistoryFilter historyFilter,
            int headerCount,
            DetailFlags detailFlags
            )
        {
            if (list == null)
                return;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                    return;

                if (HasHistory())
                {
                    ClientDataList history = _History;

                    if (history != null)
                    {
                        foreach (IClientData clientData in history)
                        {
                            if ((clientData != null) &&
                                HistoryOps.MatchData(clientData, historyFilter))
                            {
                                StringPair pair = FormatOps.HistoryItem(
                                    list.Count - headerCount + 1, clientData, false,
                                    false);

                                if (pair != null)
                                {
                                    list.Add(pair);

                                    if ((list.Count - headerCount) == historyLimit)
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void GetHostThreadInfo(
            ref StringPairList list, /* REMOTING */
            DetailFlags detailFlags
            )
        {
            if (list == null)
                return;

            bool empty = HostOps.HasEmptyContent(detailFlags);
            long localThreadId = Interlocked.CompareExchange(ref threadId, 0, 0);

            if (empty || (localThreadId != 0))
                list.Add("PrimaryThread", localThreadId.ToString());

            localThreadId = Interlocked.CompareExchange(ref managedThreadId, 0, 0);

            if (empty || (localThreadId != 0))
                list.Add("PrimaryManagedThread", localThreadId.ToString());

            localThreadId = Interlocked.CompareExchange(ref nativeThreadId, 0, 0);

            if (empty || (localThreadId != 0))
                list.Add("PrimaryNativeThread", localThreadId.ToString());
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the _Hosts.Default class only.
        //
        internal void GetHostControlInfo(
            ref StringPairList list, /* REMOTING */
            DetailFlags detailFlags
            )
        {
            if (list == null)
                return;

#if SHELL
            string[] localReadValue = null;

            lock (staticSyncRoot) /* TRANSACTIONAL */
            {
                if (readValue != null)
                {
                    localReadValue = new string[readValue.Length];
                    Array.Copy(readValue, localReadValue, readValue.Length);
                }
            }
#endif

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                    return;

                bool empty = HostOps.HasEmptyContent(detailFlags);

                HostOps.BuildInterpreterInfoList(
                    this, null, detailFlags, ref list);

                if (FlagOps.HasFlags(detailFlags, DetailFlags.ThreadInfo, true))
                    GetHostThreadInfo(ref list, detailFlags);

                int disableCreationCount = Interlocked.CompareExchange(
                    ref globalDisableCreationCount, 0, 0);

                if (empty || (disableCreationCount > 0))
                    list.Add("DisableCreationCount", disableCreationCount.ToString());

                int stubAssemblyCount = Interlocked.CompareExchange(
                    ref globalStubAssemblyCount, 0, 0);

                if (empty || (stubAssemblyCount > 0))
                    list.Add("StubAssemblyCount", stubAssemblyCount.ToString());

                IntPtr variableEventHandle = ThreadOps.GetHandle(variableEvent);

                if (empty || (variableEventHandle != IntPtr.Zero))
                    list.Add("VariableEvent", variableEventHandle.ToString());

#if SHELL
                IntPtr interactiveLoopSemaphoreHandle = ThreadOps.GetHandle(
                    interactiveLoopSemaphore);

                if (empty || (interactiveLoopSemaphoreHandle != IntPtr.Zero))
                    list.Add("InteractiveLoopSemaphore",
                        interactiveLoopSemaphoreHandle.ToString());

                IntPtr interactiveLoopDoneEventHandle = ThreadOps.GetHandle(
                    interactiveLoopDoneEvent);

                if (empty || (interactiveLoopDoneEventHandle != IntPtr.Zero))
                    list.Add("InteractiveLoopDoneEvent",
                        interactiveLoopDoneEventHandle.ToString());
#endif

                bool interactive = InternalInteractive; /* NOTE: Context only. */

                if (empty || interactive)
                    list.Add("Interactive", interactive.ToString());

                bool debug = Debug; /* NOTE: CreateFlags only. */

                if (empty || debug)
                    list.Add("Debug", debug.ToString());

                if (empty || quiet)
                    list.Add("Quiet", quiet.ToString());

                int initializeCount = Interlocked.CompareExchange(
                    ref globalInitializeCount, 0, 0);

                if (empty || (initializeCount > 0))
                    list.Add("GlobalInitializeCount", initializeCount.ToString());

                int breakCount = Interlocked.CompareExchange(
                    ref globalBreakCount, 0, 0);

                if (empty || (breakCount > 0))
                    list.Add("GlobalBreakCount", breakCount.ToString());

                int createCount = Interlocked.CompareExchange(
                    ref globalCreateCount, 0, 0);

                if (empty || (createCount > 0))
                    list.Add("GlobalCreateCount", createCount.ToString());

                int disposeCount = Interlocked.CompareExchange(
                    ref globalDisposeCount, 0, 0);

                if (empty || (disposeCount > 0))
                    list.Add("GlobalDisposeCount", disposeCount.ToString());

                int finalizeCount = Interlocked.CompareExchange(
                    ref globalFinalizeCount, 0, 0);

                if (empty || (finalizeCount > 0))
                    list.Add("GlobalFinalizeCount", finalizeCount.ToString());

#if SHELL
                int shellMainCount = Interlocked.CompareExchange(
                    ref globalShellMainCount, 0, 0);

                if (empty || (shellMainCount > 0))
                    list.Add("GlobalShellMainCount", shellMainCount.ToString());

                int shellMainCoreCount = Interlocked.CompareExchange(
                    ref globalShellMainCoreCount, 0, 0);

                if (empty || (shellMainCoreCount > 0))
                    list.Add("GlobalShellMainCoreCount", shellMainCoreCount.ToString());
#endif

                if (empty || useBuiltInCommands)
                    list.Add("UseBuiltInCommands", useBuiltInCommands.ToString());

                if (empty || useBuiltInFunctions)
                    list.Add("UseBuiltInFunctions", useBuiltInFunctions.ToString());

                if (empty || useBuiltInOperators)
                    list.Add("UseBuiltInOperators", useBuiltInOperators.ToString());

#if CONSOLE
                int localCancelViaConsoleSetting = Interlocked.CompareExchange(
                    ref cancelViaConsole[0], 0, 0);

                int localCancelViaConsoleCount = Interlocked.CompareExchange(
                    ref cancelViaConsole[1], 0, 0);

                if (empty || (localCancelViaConsoleSetting >= 0))
                    list.Add("CancelViaConsoleSetting", localCancelViaConsoleSetting.ToString());

                if (empty || (localCancelViaConsoleCount > 0))
                    list.Add("CancelViaConsoleCount", localCancelViaConsoleCount.ToString());
#endif

#if SHELL
                int length = (localReadValue != null) ? localReadValue.Length : 0;

                if (empty || (length > 0))
                {
                    if (localReadValue != null)
                    {
                        if (length > 0)
                        {
                            for (int index = 0; index < length; index++)
                            {
                                string value = localReadValue[index];

                                if (value == null)
                                    value = FormatOps.DisplayNull;

                                list.Add(String.Format(
                                    "ReadValue[{0}]", index), value);
                            }
                        }
                        else
                        {
                            list.Add("ReadValue", FormatOps.DisplayEmpty);
                        }
                    }
                    else
                    {
                        list.Add("ReadValue", FormatOps.DisplayNull);
                    }
                }
#endif

                bool defaultQuiet = DefaultQuiet;

                if (empty || defaultQuiet)
                    list.Add("DefaultQuiet", defaultQuiet.ToString());

                bool getDefaultQuiet = DebugOps.GetDefaultQuiet(defaultQuiet);

                if (empty || getDefaultQuiet)
                    list.Add("GetDefaultQuiet", getDefaultQuiet.ToString());

                bool shouldBeQuiet = ShouldBeQuiet(defaultQuiet);

                if (empty || shouldBeQuiet)
                    list.Add("ShouldBeQuiet", shouldBeQuiet.ToString());

                if (empty || readOnly)
                    list.Add("ReadOnly", readOnly.ToString());

                if (empty || immutable)
                    list.Add("Immutable", immutable.ToString());

                if (empty || (readyCount > 0))
                    list.Add("ReadyCount", readyCount.ToString());

                if (empty || (readyLimit > 0))
                    list.Add("ReadyLimit", readyLimit.ToString());

                if (empty || (recursionLimit > 0))
                    list.Add("RecursionLimit", recursionLimit.ToString());

                if (empty || (EventOps.ManagerIsOk(eventManager) && eventManager.Enabled))
                    list.Add("EventManager", EventOps.ManagerIsOk(eventManager) ?
                        eventManager.Enabled.ToString() : FormatOps.DisplayNull);

                if (empty || (eventCount > 0))
                    list.Add("EventCount", eventCount.ToString());

#if NATIVE && TCL
                if (empty || (tclEventCount > 0))
                    list.Add("TclEventCount", tclEventCount.ToString());

                if (empty || (tclSleepCount > 0))
                    list.Add("TclSleepCount", tclSleepCount.ToString());
#endif

                if (empty || (waitCount > 0))
                    list.Add("WaitCount", waitCount.ToString());

                if (empty || (waitSpinCount > 0))
                    list.Add("WaitSpinCount", waitSpinCount.ToString());

#if NETWORK
                if (empty || (serverSockets > 0))
                    list.Add("ServerSockets", serverSockets.ToString());
#endif

                if (empty || (timeout != _Timeout.Infinite))
                    list.Add("Timeout", timeout.ToString());

                if (empty || (finallyTimeout != _Timeout.Infinite))
                    list.Add("FinallyTimeout", finallyTimeout.ToString());

                if (empty || (networkTimeout != _Timeout.Infinite))
                    list.Add("NetworkTimeout", networkTimeout.ToString());

                if (empty || (sleepTime != 0))
                    list.Add("SleepTime", sleepTime.ToString());

#if SHELL && INTERACTIVE_COMMANDS
                if (empty || (testGcSleepTime != 0))
                    list.Add("TestGcSleepTime", testGcSleepTime.ToString());
#endif

                bool someFlag;
                Result someResult;

                someFlag = cancel; /* FIELD */

                if (empty || someFlag)
                    list.Add("GlobalCancel", someFlag.ToString());

                someFlag = unwind; /* FIELD */

                if (empty || someFlag)
                    list.Add("GlobalUnwind", someFlag.ToString());

                someFlag = halt; /* FIELD */

                if (empty || someFlag)
                    list.Add("GlobalHalt", someFlag.ToString());

                someResult = cancelResult; /* FIELD */

                if (empty || (someResult != null))
                    list.Add("GlobalCancelResult", (someResult != null) ?
                        FormatOps.DisplayString(someResult.String) :
                        FormatOps.DisplayNull);

                someResult = haltResult; /* FIELD */

                if (empty || (someResult != null))
                    list.Add("GlobalHaltResult", (someResult != null) ?
                        FormatOps.DisplayString(someResult.String) :
                        FormatOps.DisplayNull);

                someFlag = this.Cancel; /* PROPERTY */

                if (empty || someFlag)
                    list.Add("LocalCancel", someFlag.ToString());

                someFlag = this.Unwind; /* PROPERTY */

                if (empty || someFlag)
                    list.Add("LocalUnwind", someFlag.ToString());

                someFlag = this.Halt; /* PROPERTY */

                if (empty || someFlag)
                    list.Add("LocalHalt", someFlag.ToString());

                someResult = this.CancelResult; /* PROPERTY */

                if (empty || (someResult != null))
                    list.Add("LocalCancelResult", (someResult != null) ?
                        FormatOps.DisplayString(someResult.String) :
                        FormatOps.DisplayNull);

                someResult = this.HaltResult; /* PROPERTY */

                if (empty || (someResult != null))
                    list.Add("LocalHaltResult", (someResult != null) ?
                        FormatOps.DisplayString(someResult.String) :
                        FormatOps.DisplayNull);

#if HISTORY
                if (FlagOps.HasFlags(detailFlags, DetailFlags.HistoryInfo, true))
                    GetHostHistoryInfo(ref list, detailFlags);
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the _Hosts.Default class only.
        //
        internal void GetHostDebuggerInfo(
            ref StringPairList list, /* REMOTING */
            DetailFlags detailFlags
            )
        {
            if (list == null)
                return;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                    return;

                bool empty = HostOps.HasEmptyContent(detailFlags);

                if (empty || (host != null))
                    list.Add("Host", (host != null) ?
                        host.ToString() : FormatOps.DisplayNull);

                if (empty || (interactiveHost != null))
                    list.Add("InteractiveHost", (interactiveHost != null) ?
                        interactiveHost.ToString() : FormatOps.DisplayNull);

#if ISOLATED_PLUGINS
                if (empty || (isolatedHost != null))
                    list.Add("IsolatedHost", (isolatedHost != null) ?
                        isolatedHost.ToString() : FormatOps.DisplayNull);
#endif

                if (FlagOps.HasFlags(detailFlags, DetailFlags.ThreadInfo, true))
                    GetHostThreadInfo(ref list, detailFlags);

                IntPtr variableEventHandle = ThreadOps.GetHandle(variableEvent);

                if (empty || (variableEventHandle != IntPtr.Zero))
                    list.Add("VariableEvent", variableEventHandle.ToString());

#if HISTORY
                if (FlagOps.HasFlags(detailFlags, DetailFlags.HistoryInfo, true))
                    GetHostHistoryInfo(ref list, detailFlags);
#endif

                HostOps.BuildInterpreterInfoList(this, String.Empty, detailFlags, ref list);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the _Hosts.Default class only.
        //
        internal void GetHostEngineInfo(
            ref StringPairList list, /* REMOTING */
            DetailFlags detailFlags
            )
        {
            if (list == null)
                return;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                    return;

                bool empty = HostOps.HasEmptyContent(detailFlags);
                Thread localThread = Interlocked.CompareExchange(ref thread, null, null);

                if (empty || (localThread != null))
                    list.Add("Thread", (localThread != null) ?
                        localThread.ManagedThreadId.ToString() : FormatOps.DisplayNull);

#if SHELL
                localThread = Interlocked.CompareExchange(ref interactiveThread, null, null);

                if (empty || (localThread != null))
                    list.Add("InteractiveThread", (localThread != null) ?
                        localThread.ManagedThreadId.ToString() : FormatOps.DisplayNull);
#endif

                if (empty || (threadStackSize != 0))
                    list.Add("ThreadStackSize", threadStackSize.ToString());

                if (empty || (extraStackSpace != 0))
                    list.Add("ExtraStackSpace", extraStackSpace.ToString());

#if CALLBACK_QUEUE
                if (empty || (callbackLimit != 0))
                    list.Add("CallbackLimit", callbackLimit.ToString());
#endif

                if (empty || (eventLimit != 0))
                    list.Add("EventLimit", eventLimit.ToString());

                if (empty || (procedureLimit != 0))
                    list.Add("ProcedureLimit", procedureLimit.ToString());

                if (empty || (variableLimit != 0))
                    list.Add("VariableLimit", variableLimit.ToString());

                if (empty || (arrayElementLimit != 0))
                    list.Add("ArrayElementLimit", arrayElementLimit.ToString());

#if RESULT_LIMITS
                if (empty || (executeResultLimit != 0))
                    list.Add("ExecuteResultLimit", executeResultLimit.ToString());

                if (empty || (nestedResultLimit != 0))
                    list.Add("NestedResultLimit", nestedResultLimit.ToString());
#endif

#if SHELL
                if (empty || (globalInteractiveLoops > 0))
                    list.Add("GlobalInteractiveLoops", globalInteractiveLoops.ToString());
#endif

                int activeInteractiveLoops = ActiveInteractiveLoops; /* NOTE: Context only. */

                if (empty || (activeInteractiveLoops > 0))
                    list.Add("ActiveInteractiveLoops", activeInteractiveLoops.ToString());

                int totalInteractiveLoops = TotalInteractiveLoops; /* NOTE: Context only. */

                if (empty || (totalInteractiveLoops > 0))
                    list.Add("TotalInteractiveLoops", totalInteractiveLoops.ToString());

                int totalInteractiveInputs = TotalInteractiveInputs; /* NOTE: Context only. */

                if (empty || (totalInteractiveInputs > 0))
                    list.Add("TotalInteractiveInputs", totalInteractiveInputs.ToString());

#if SHELL
                IShellCallbackData shellCallbackData = ShellCallbackData; /* NOTE: Context only. */

                if (empty || (shellCallbackData != null))
                    list.Add("ShellCallbackData",
                        FormatOps.ShellCallbackData(shellCallbackData));

                IInteractiveLoopData interactiveLoopData = InteractiveLoopData; /* NOTE: Context only. */

                if (empty || (interactiveLoopData != null))
                    list.Add("InteractiveLoopData",
                        FormatOps.InteractiveLoopData(interactiveLoopData));

                IUpdateData updateData = UpdateData; /* NOTE: Context only. */

                if (empty || (updateData != null))
                    list.Add("UpdateData",
                        FormatOps.UpdateData(updateData));
#endif

                StringTransformCallback interactiveCommandCallback = InteractiveCommandCallback; /* NOTE: Context only. */

                if (empty || (interactiveCommandCallback != null))
                    list.Add("InteractiveCommandCallback",
                        (interactiveCommandCallback != null) ?
                            FormatOps.DelegateMethodName(
                                interactiveCommandCallback.Method, false, true) :
                            FormatOps.DisplayNull);

                if (empty || (profiler != null))
                {
                    IStringList localList = (profiler != null) ?
                        profiler.ToList() : null;

                    list.Add("Profiler", (localList != null) ?
                        localList.ToString() : FormatOps.DisplayNull);
                }

                if (empty || (unknownCount > 0))
                    list.Add("UnknownCount", unknownCount.ToString());

                if (empty || (operationCount > 0))
                    list.Add("OperationCount", operationCount.ToString());

                if (empty || (commandCount > 0))
                    list.Add("CommandCount", commandCount.ToString());

                if (empty || (commandDecision != PolicyDecision.None))
                    list.Add("CommandDecision", commandDecision.ToString());

                if (empty || (scriptDecision != PolicyDecision.None))
                    list.Add("ScriptDecision", scriptDecision.ToString());

                if (empty || (fileDecision != PolicyDecision.None))
                    list.Add("FileDecision", fileDecision.ToString());

                if (empty || (streamDecision != PolicyDecision.None))
                    list.Add("StreamDecision", streamDecision.ToString());

#if POLICY_TRACE
                bool policyTrace = InternalPolicyTrace;

                if (empty || policyTrace)
                    list.Add("PolicyTrace", policyTrace.ToString());
#endif

                if (empty || ((trustedPaths != null) && (trustedPaths.Count > 0)))
                    list.Add("TrustedPaths", FormatOps.DisplayList(trustedPaths));

                if (empty || ((trustedUris != null) && (trustedUris.Count > 0)))
                    list.Add("TrustedUris", FormatOps.DisplayKeys(trustedUris));

                if (empty || ((trustedTypes != null) && (trustedTypes.Count > 0)))
                    list.Add("TrustedTypes", FormatOps.DisplayKeys(trustedTypes));

                ReturnCode returnCode = ReturnCode; /* NOTE: Context only. */

                if (empty || (returnCode != ReturnCode.Ok))
                    list.Add("ReturnCode", returnCode.ToString());

                int errorLine = ErrorLine; /* NOTE: Context only. */ /* EXEMPT */

                if (empty || (errorLine != 0))
                    list.Add("ErrorLine", errorLine.ToString());

                string errorCode = ErrorCode; /* NOTE: Context only. */

                if (empty || (errorCode != null))
                    list.Add("ErrorCode", (errorCode != null) ?
                        errorCode : FormatOps.DisplayNull);

                string errorInfo = ErrorInfo; /* NOTE: Context only. */

                if (empty || (errorInfo != null))
                    list.Add("ErrorInfo", FormatOps.DisplayString(
                        FormatOps.ReplaceNewLines(FormatOps.NormalizeNewLines(
                            errorInfo))));

                int errorFrames = ErrorFrames; /* NOTE: Context only. */

                if (empty || (errorFrames != 0))
                    list.Add("ErrorFrames", errorFrames.ToString());

                Exception exception = Exception;

                if (empty || (exception != null))
                    list.Add("Exception", (exception != null) ?
                        exception.ToString() : FormatOps.DisplayNull);

#if DEBUGGER
                bool isDebuggerAvailable = IsDebuggerAvailable();

                if (empty || isDebuggerAvailable)
                    list.Add("IsDebuggerAvailable", isDebuggerAvailable.ToString());

                bool isDebuggerActive = IsDebuggerActive();

                if (empty || isDebuggerActive)
                    list.Add("IsDebuggerActive", isDebuggerActive.ToString());

                bool isDebuggerExiting = IsDebuggerExiting; /* NOTE: Context only. */

                if (empty || isDebuggerExiting)
                    list.Add("IsDebuggerExiting", isDebuggerExiting.ToString());
#endif

                bool stackOverflow = StackOverflow; /* NOTE: Context only. */

                if (empty || stackOverflow)
                    list.Add("StackOverflow", stackOverflow.ToString());

                bool isBusy = InternalIsBusy; /* NOTE: Context only. */

                if (empty || isBusy)
                    list.Add("IsBusy", isBusy.ToString());

                IClientData contextClientData = ContextClientData; /* NOTE: Context only. */

                if (empty || (contextClientData != null))
                    list.Add("ContextClientData", (contextClientData != null) ?
                        contextClientData.ToString() : FormatOps.DisplayNull);

                int levels = InternalLevels; /* NOTE: Context only. */

                if (empty || (levels > 0))
                    list.Add("Levels", levels.ToString());

                int maximumLevels = MaximumLevels; /* NOTE: Context only. */

                if (empty || (maximumLevels > 0))
                    list.Add("MaximumLevels", maximumLevels.ToString());

                int scriptLevels = ScriptLevels; /* NOTE: Context only. */

                if (empty || (scriptLevels > 0))
                    list.Add("ScriptLevels", scriptLevels.ToString());

                int maximumScriptLevels = MaximumScriptLevels; /* NOTE: Context only. */

                if (empty || (maximumScriptLevels > 0))
                    list.Add("MaximumScriptLevels", maximumScriptLevels.ToString());

                int parserLevels = ParserLevels; /* NOTE: Context only. */

                if (empty || (parserLevels > 0))
                    list.Add("ParserLevels", parserLevels.ToString());

                int maximumParserLevels = MaximumParserLevels; /* NOTE: Context only. */

                if (empty || (maximumParserLevels > 0))
                    list.Add("MaximumParserLevels", maximumParserLevels.ToString());

                int expressionLevels = ExpressionLevels; /* NOTE: Context only. */

                if (empty || (expressionLevels > 0))
                    list.Add("ExpressionLevels", expressionLevels.ToString());

                int entryExpressionLevels = EntryExpressionLevels; /* NOTE: Context only. */

                if (empty || (entryExpressionLevels > 0))
                    list.Add("EntryExpressionLevels", entryExpressionLevels.ToString());

                int maximumExpressionLevels = MaximumExpressionLevels; /* NOTE: Context only. */

                if (empty || (maximumExpressionLevels > 0))
                    list.Add("MaximumExpressionLevels", maximumExpressionLevels.ToString());

                int previousLevels = PreviousLevels; /* NOTE: Context only. */

                if (empty || (previousLevels > 0))
                    list.Add("PreviousLevels", previousLevels.ToString());

                int catchLevels = CatchLevels; /* NOTE: Context only. */

                if (empty || (catchLevels > 0))
                    list.Add("CatchLevels", catchLevels.ToString());

                int unknownLevels = UnknownLevels; /* NOTE: Context only. */

                if (empty || (unknownLevels > 0))
                    list.Add("UnknownLevels", unknownLevels.ToString());

                int securityLevels = SecurityLevels; /* NOTE: Context only. */

                if (empty || (securityLevels > 0))
                    list.Add("SecurityLevels", securityLevels.ToString());

                int policyLevels = PolicyLevels; /* NOTE: Context only. */

                if (empty || (policyLevels > 0))
                    list.Add("PolicyLevels", policyLevels.ToString());

                int traceLevels = TraceLevels; /* NOTE: Context only. */

                if (empty || (traceLevels > 0))
                    list.Add("TraceLevels", traceLevels.ToString());

                int subCommandLevels = SubCommandLevels; /* NOTE: Context only. */

                if (empty || (subCommandLevels > 0))
                    list.Add("SubCommandLevels", subCommandLevels.ToString());

                int settingLevels = SettingLevels; /* NOTE: Context only. */

                if (empty || (settingLevels > 0))
                    list.Add("SettingLevels", settingLevels.ToString());

                int packageLevels = PackageLevels; /* NOTE: Context only. */

                if (empty || (packageLevels > 0))
                    list.Add("PackageLevels", packageLevels.ToString());

#if ARGUMENT_CACHE
                Argument cacheArgument = CacheArgument;

                if (empty || (cacheArgument != null))
                    list.Add("CacheArgument", (cacheArgument != null) ?
                        cacheArgument.ToString() : FormatOps.DisplayNull);
#endif

#if DEBUGGER
                int watchpointLevels = WatchpointLevels; /* NOTE: Context only. */

                if (empty || (watchpointLevels > 0))
                    list.Add("WatchpointLevels", watchpointLevels.ToString());
#endif

#if NOTIFY || NOTIFY_OBJECT
                int notifyLevels = NotifyLevels; /* NOTE: Context only. */

                if (empty || (notifyLevels > 0))
                    list.Add("NotifyLevels", notifyLevels.ToString());
#endif

                if (empty || (precision != TclVars.Expression.DefaultPrecision))
                    list.Add("Precision", precision.ToString());

#if XML
                if (empty || (retryXml != XmlErrorTypes.None))
                    list.Add("RetryXml", retryXml.ToString());

                if (empty || validateXml)
                    list.Add("ValidateXml", validateXml.ToString());

                if (empty || relaxedXml)
                    list.Add("RelaxedXml", relaxedXml.ToString());

                if (empty || allXml)
                    list.Add("AllXml", allXml.ToString());
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the _Hosts.Default class only.
        //
        internal void GetHostEntityInfo(
            ref StringPairList list, /* REMOTING */
            DetailFlags detailFlags
            )
        {
            if (list == null)
                return;

            bool empty = HostOps.HasEmptyContent(detailFlags);
            IEventManager eventManager;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                    return;

                eventManager = this.eventManager;

                if (empty || ((childInterpreters != null) && (childInterpreters.Count > 0)))
                    list.Add("ChildInterpreters", (childInterpreters != null) ?
                        childInterpreters.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((packages != null) && (packages.Count > 0)))
                    list.Add("Packages", (packages != null) ?
                        packages.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((packageIndexes != null) && (packageIndexes.Count > 0)))
                    list.Add("PackageIndexes", (packageIndexes != null) ?
                        packageIndexes.Count.ToString() : FormatOps.DisplayNull);

#if APPDOMAINS
                if (empty || ((appDomains != null) && (appDomains.Count > 0)))
                    list.Add("AppDomains", (appDomains != null) ?
                        appDomains.Count.ToString() : FormatOps.DisplayNull);
#endif

                if (empty || ((pluginArguments != null) && (pluginArguments.Count > 0)))
                    list.Add("PluginArguments", (pluginArguments != null) ?
                        pluginArguments.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((plugins != null) && (plugins.Count > 0)))
                    list.Add("Plugins", (plugins != null) ?
                        plugins.Count.ToString() : FormatOps.DisplayNull);

#if NOTIFY || NOTIFY_OBJECT
                if (empty || ((notifyPlugins != null) && (notifyPlugins.Count > 0)))
                    list.Add("NotifyPlugins", (notifyPlugins != null) ?
                        notifyPlugins.Count.ToString() : FormatOps.DisplayNull);
#endif

                if (empty || (globalNamespace != null))
                    list.Add("GlobalNamespace", FormatOps.DisplayNamespace(globalNamespace));

                if (empty || ((pendingNamespaces != null) && (pendingNamespaces.Count > 0)))
                    list.Add("PendingNamespaces", (pendingNamespaces != null) ?
                        pendingNamespaces.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((namespaceMappings != null) && (namespaceMappings.Count > 0)))
                    list.Add("NamespaceMappings", (namespaceMappings != null) ?
                        namespaceMappings.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((commands != null) && (commands.Count > 0)))
                    list.Add("Commands", (commands != null) ?
                        commands.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((hiddenCommands != null) && (hiddenCommands.Count > 0)))
                    list.Add("HiddenCommands", (hiddenCommands != null) ?
                        hiddenCommands.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((aliases != null) && (aliases.Count > 0)))
                    list.Add("Aliases", (aliases != null) ?
                        aliases.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((procedures != null) && (procedures.Count > 0)))
                    list.Add("Procedures", (procedures != null) ?
                        procedures.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((hiddenProcedures != null) && (hiddenProcedures.Count > 0)))
                    list.Add("HiddenProcedures", (hiddenProcedures != null) ?
                        hiddenProcedures.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((executes != null) && (executes.Count > 0)))
                    list.Add("Executes", (executes != null) ?
                        executes.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((hiddenExecutes != null) && (hiddenExecutes.Count > 0)))
                    list.Add("HiddenExecutes", (hiddenExecutes != null) ?
                        hiddenExecutes.Count.ToString() : FormatOps.DisplayNull);

                #region Dead Code
#if DEAD_CODE
                if (empty || ((lambdas != null) && (lambdas.Count > 0)))
                    list.Add("Lambdas", (lambdas != null) ?
                        lambdas.Count.ToString() : FormatOps.DisplayNull);
#endif
                #endregion

                if (empty || ((functions != null) && (functions.Count > 0)))
                    list.Add("Functions", (functions != null) ?
                        functions.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((operators != null) && (operators.Count > 0)))
                    list.Add("Operators", (operators != null) ?
                        operators.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((operatorCache != null) && (operatorCache.Length > 0)))
                    list.Add("OperatorCache", (operatorCache != null) ?
                        operatorCache.Length.ToString() : FormatOps.DisplayNull);

                if (empty || ((policies != null) && (policies.Count > 0)))
                    list.Add("Policies", (policies != null) ?
                        policies.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((scopes != null) && (scopes.Count > 0)))
                    list.Add("Scopes", (scopes != null) ?
                        scopes.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((traces != null) && (traces.Count > 0)))
                    list.Add("Traces", (traces != null) ?
                        traces.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((channels != null) && (channels.Count > 0)))
                    list.Add("Channels", (channels != null) ?
                        channels.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((encodings != null) && (encodings.Count > 0)))
                    list.Add("Encodings", (encodings != null) ?
                        encodings.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((objects != null) && (objects.Count > 0)))
                    list.Add("Objects", (objects != null) ?
                        objects.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((objectTypes != null) && (objectTypes.Count > 0)))
                    list.Add("ObjectTypes", (objectTypes != null) ?
                        objectTypes.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((objectNamespaces != null) && (objectNamespaces.Count > 0)))
                    list.Add("ObjectNamespaces", (objectNamespaces != null) ?
                        objectNamespaces.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((objectInterfaces != null) && (objectInterfaces.Count > 0)))
                    list.Add("ObjectInterfaces", (objectInterfaces != null) ?
                        objectInterfaces.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((objectAliasNamespaces != null) && (objectAliasNamespaces.Count > 0)))
                    list.Add("ObjectAliasNamespaces", (objectAliasNamespaces != null) ?
                        objectAliasNamespaces.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((callbacks != null) && (callbacks.Count > 0)))
                    list.Add("Callbacks", (callbacks != null) ?
                        callbacks.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((resolvers != null) && (resolvers.Count > 0)))
                    list.Add("Resolvers", (resolvers != null) ?
                        resolvers.Count.ToString() : FormatOps.DisplayNull);

                ArraySearchDictionary arraySearches = ArraySearches; /* NOTE: Context only. */

                if (empty || ((arraySearches != null) && (arraySearches.Count > 0)))
                    list.Add("ArraySearches", (arraySearches != null) ?
                        arraySearches.Count.ToString() : FormatOps.DisplayNull);

#if CALLBACK_QUEUE
                if (empty || ((callbackQueue != null) && (callbackQueue.Count > 0)))
                    list.Add("CallbackQueue", (callbackQueue != null) ?
                        callbackQueue.Count.ToString() : FormatOps.DisplayNull);
#endif

#if DATA
                if (empty || ((connections != null) && (connections.Count > 0)))
                    list.Add("DbConnections", (connections != null) ?
                        connections.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((transactions != null) && (transactions.Count > 0)))
                    list.Add("DbTransactions", (transactions != null) ?
                        transactions.Count.ToString() : FormatOps.DisplayNull);
#endif

#if EMIT && NATIVE && LIBRARY
                if (empty || ((modules != null) && (modules.Count > 0)))
                    list.Add("Modules", (modules != null) ?
                        modules.Count.ToString() : FormatOps.DisplayNull);

                if (empty || ((delegates != null) && (delegates.Count > 0)))
                    list.Add("Delegates", (delegates != null) ?
                        delegates.Count.ToString() : FormatOps.DisplayNull);
#endif

                if (empty || ((cleanupPaths != null) && (cleanupPaths.Count > 0)))
                    list.Add("CleanupPaths", (cleanupPaths != null) ?
                        cleanupPaths.Count.ToString() : FormatOps.DisplayNull);
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            StringPairList list2 = new StringPairList();

            if (empty || (EventOps.ManagerIsOk(eventManager) && (Event.CreateCount > 0)))
                list2.Add("EventCreateCount", Event.CreateCount.ToString());

            if (empty || (EventOps.ManagerIsOk(eventManager) && (Event.DisposeCount > 0)))
                list2.Add("EventDisposeCount", Event.DisposeCount.ToString());

            if (empty || (EventOps.ManagerIsOk(eventManager) && (eventManager.QueueEventCount > 0)))
                list2.Add("QueueEventCount", EventOps.ManagerIsOk(eventManager) ?
                    eventManager.QueueEventCount.ToString() : FormatOps.DisplayNull);

            if (empty || (EventOps.ManagerIsOk(eventManager) && (eventManager.QueueIdleEventCount > 0)))
                list2.Add("QueueIdleEventCount", EventOps.ManagerIsOk(eventManager) ?
                    eventManager.QueueIdleEventCount.ToString() : FormatOps.DisplayNull);

            if (empty || (EventOps.ManagerIsOk(eventManager) && (eventManager.EventCount > 0)))
                list2.Add("EventCount", EventOps.ManagerIsOk(eventManager) ?
                    eventManager.EventCount.ToString() : FormatOps.DisplayNull);

            if (empty || (EventOps.ManagerIsOk(eventManager) && (eventManager.IdleEventCount > 0)))
                list2.Add("IdleEventCount", EventOps.ManagerIsOk(eventManager) ?
                    eventManager.IdleEventCount.ToString() : FormatOps.DisplayNull);

            if (empty || (EventOps.ManagerIsOk(eventManager) && (eventManager.TotalEventCount > 0)))
                list2.Add("TotalEventCount", EventOps.ManagerIsOk(eventManager) ?
                    eventManager.TotalEventCount.ToString() : FormatOps.DisplayNull);

            if (empty || (EventOps.ManagerIsOk(eventManager) && (eventManager.MaximumEventCount > 0)))
                list2.Add("MaximumEventCount", EventOps.ManagerIsOk(eventManager) ?
                    eventManager.MaximumEventCount.ToString() : FormatOps.DisplayNull);

            if (empty || (EventOps.ManagerIsOk(eventManager) && (eventManager.MaximumIdleEventCount > 0)))
                list2.Add("MaximumIdleEventCount", EventOps.ManagerIsOk(eventManager) ?
                    eventManager.MaximumIdleEventCount.ToString() : FormatOps.DisplayNull);

            if (empty || (EventOps.ManagerIsOk(eventManager) && (eventManager.MaybeDisposeEventCount > 0)))
                list2.Add("MaybeDisposeEventCount", EventOps.ManagerIsOk(eventManager) ?
                    eventManager.MaybeDisposeEventCount.ToString() : FormatOps.DisplayNull);

            if (empty || (EventOps.ManagerIsOk(eventManager) && (eventManager.ReallyDisposeEventCount > 0)))
                list2.Add("ReallyDisposeEventCount", EventOps.ManagerIsOk(eventManager) ?
                    eventManager.ReallyDisposeEventCount.ToString() : FormatOps.DisplayNull);

            if (empty || (EventOps.ManagerIsOk(eventManager) && (eventManager.WaitForEmptyQueueTotalCount > 0)))
                list2.Add("WaitForEmptyQueueTotalCount", EventOps.ManagerIsOk(eventManager) ?
                    eventManager.WaitForEmptyQueueTotalCount.ToString() : FormatOps.DisplayNull);

            if (empty || (EventOps.ManagerIsOk(eventManager) && (eventManager.WaitForEmptyQueueErrorCount > 0)))
                list2.Add("WaitForEmptyQueueErrorCount", EventOps.ManagerIsOk(eventManager) ?
                    eventManager.WaitForEmptyQueueErrorCount.ToString() : FormatOps.DisplayNull);

            if (empty || (EventOps.ManagerIsOk(eventManager) && (eventManager.WaitForEventEnqueuedTotalCount > 0)))
                list2.Add("WaitForEventEnqueuedTotalCount", EventOps.ManagerIsOk(eventManager) ?
                    eventManager.WaitForEventEnqueuedTotalCount.ToString() : FormatOps.DisplayNull);

            if (empty || (EventOps.ManagerIsOk(eventManager) && (eventManager.WaitForEventEnqueuedErrorCount > 0)))
                list2.Add("WaitForEventEnqueuedErrorCount", EventOps.ManagerIsOk(eventManager) ?
                    eventManager.WaitForEventEnqueuedErrorCount.ToString() : FormatOps.DisplayNull);

            if (list2.Count > 0)
            {
                list.Add((IPair<string>)null);
                list.Add("Event Manager");
                list.Add((IPair<string>)null);
                list.Add(list2);
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

#if NATIVE && TCL
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                StringPairList list3 = new StringPairList();
                bool needSeparator = false;
                bool needHeader = true;

                if (empty || (tclApi != null))
                {
                    if (tclApi != null)
                    {
                        list3.Add((IPair<string>)null);
                        list3.Add("Native Tcl API");
                        list3.Add((IPair<string>)null);
                        list3.Add(tclApi.ToList(false));

                        needHeader = false;

                        TclBuild tclBuild = tclApi.Build;

                        if (tclBuild != null)
                        {
                            list3.Add((IPair<string>)null);
                            list3.Add("Native Tcl Build");
                            list3.Add((IPair<string>)null);
                            list3.Add(tclBuild.ToList());
                        }

                        needSeparator = true;
                    }
                    else
                    {
                        list3.Add("TclApi", FormatOps.DisplayNull);
                    }
                }

                StringPairList entityHeader = new StringPairList();

                entityHeader.Add((IPair<string>)null);
                entityHeader.Add("Native Tcl Entities");
                entityHeader.Add((IPair<string>)null);

                if (empty || ((tclInterps != null) && (tclInterps.Count > 0)))
                {
                    if (needSeparator)
                    {
                        list3.Add(entityHeader);
                        needSeparator = false;
                    }

                    list3.Add("TclInterps", (tclInterps != null) ?
                        tclInterps.Count.ToString() : FormatOps.DisplayNull);
                }

#if TCL_THREADS
                if (empty || ((tclThreads != null) && (tclThreads.Count > 0)))
                {
                    if (needSeparator)
                    {
                        list3.Add(entityHeader);
                        needSeparator = false;
                    }

                    list3.Add("TclThreads", (tclThreads != null) ?
                        tclThreads.Count.ToString() : FormatOps.DisplayNull);
                }
#endif

                if (empty || ((tclBridges != null) && (tclBridges.Count > 0)))
                {
                    if (needSeparator)
                    {
                        list3.Add(entityHeader);
                        needSeparator = false;
                    }

                    list3.Add("TclBridges", (tclBridges != null) ?
                        tclBridges.Count.ToString() : FormatOps.DisplayNull);
                }

                if (empty || tclReadOnly)
                {
                    if (needSeparator)
                    {
                        list3.Add(entityHeader);
                        needSeparator = false;
                    }

                    list3.Add("TclReadOnly", tclReadOnly.ToString());
                }

                if (list3.Count > 0)
                {
                    if (needHeader)
                    {
                        list.Add((IPair<string>)null);
                        list.Add("Native Tcl Wrapper");
                        list.Add((IPair<string>)null);
                    }

                    list.Add(list3);
                }
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the _Hosts.Default class only.
        //
        internal void GetHostFlagInfo(
            ref StringPairList list, /* REMOTING */
            DetailFlags detailFlags
            )
        {
            if (list == null)
                return;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                    return;

                bool empty = HostOps.HasEmptyContent(detailFlags);

                if (empty || (createFlags != CreateFlags.None))
                    list.Add("iCreateFlags", createFlags.ToString());

                if (empty || (defaultCreateFlags != CreateFlags.None))
                    list.Add("iDefaultCreateFlags", defaultCreateFlags.ToString());

                if (empty || (hostCreateFlags != HostCreateFlags.None))
                    list.Add("iHostCreateFlags", hostCreateFlags.ToString());

                if (empty || (defaultHostCreateFlags != HostCreateFlags.None))
                    list.Add("iDefaultHostCreateFlags", defaultHostCreateFlags.ToString());

                if (empty || (initializeFlags != InitializeFlags.None))
                    list.Add("iInitializeFlags", initializeFlags.ToString());

                if (empty || (defaultInitializeFlags != InitializeFlags.None))
                    list.Add("iDefaultInitializeFlags", defaultInitializeFlags.ToString());

                if (empty || (scriptFlags != ScriptFlags.None))
                    list.Add("iScriptFlags", scriptFlags.ToString());

                if (empty || (defaultScriptFlags != ScriptFlags.None))
                    list.Add("iDefaultScriptFlags", defaultScriptFlags.ToString());

                if (empty || (interpreterFlags != InterpreterFlags.None))
                    list.Add("iInterpreterFlags", interpreterFlags.ToString());

                if (empty || (defaultInterpreterFlags != InterpreterFlags.None))
                    list.Add("iDefaultInterpreterFlags", defaultInterpreterFlags.ToString());

                if (empty || (interpreterStateFlags != InterpreterStateFlags.None))
                    list.Add("iInterpreterStateFlags", interpreterStateFlags.ToString());

                if (empty || (pluginFlags != PluginFlags.None))
                    list.Add("iPluginFlags", pluginFlags.ToString());

                if (empty || (defaultPluginFlags != PluginFlags.None))
                    list.Add("iDefaultPluginFlags", defaultPluginFlags.ToString());

                ///////////////////////////////////////////////////////////////////////////////////////

                if (empty || (existVariableFlags != VariableFlags.None))
                    list.Add("iExistVariableFlags", existVariableFlags.ToString());

                if (empty || (getVariableFlags != VariableFlags.None))
                    list.Add("iGetVariableFlags", getVariableFlags.ToString());

                if (empty || (setVariableFlags != VariableFlags.None))
                    list.Add("iSetVariableFlags", setVariableFlags.ToString());

                if (empty || (resetVariableFlags != VariableFlags.None))
                    list.Add("iResetVariableFlags", resetVariableFlags.ToString());

                if (empty || (unsetVariableFlags != VariableFlags.None))
                    list.Add("iUnsetVariableFlags", unsetVariableFlags.ToString());

                if (empty || (addVariableFlags != VariableFlags.None))
                    list.Add("iAddVariableFlags", addVariableFlags.ToString());

                if (empty || (systemArrayVariableFlags != VariableFlags.None))
                    list.Add("iSystemArrayVariableFlags", systemArrayVariableFlags.ToString());

                ///////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || EXECUTE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
                if (empty || (cacheFlags != CacheFlags.None))
                    list.Add("iCacheFlags", cacheFlags.ToString());
#endif

                if (empty || (pathComparisonType != PathComparisonType.None))
                    list.Add("iPathComparisonType", pathComparisonType.ToString());

                if (empty || (packageIndexFlags != PackageIndexFlags.None))
                    list.Add("iPackageIndexFlags", packageIndexFlags.ToString());

                if (empty || (eventVariableFlags != VariableFlags.None))
                    list.Add("iEventVariableFlags", eventVariableFlags.ToString());

                if (empty || (eventWaitFlags != EventWaitFlags.None))
                    list.Add("iEventWaitFlags", eventWaitFlags.ToString());

                if (empty || (readyFlags != ReadyFlags.None))
                    list.Add("iReadyFlags", readyFlags.ToString());

                if (empty || (engineFlags != EngineFlags.None))
                    list.Add("iEngineFlags", engineFlags.ToString());

                EngineFlags contextEngineFlags = ContextEngineFlags; /* NOTE: Context only. */

                if (empty || (contextEngineFlags != EngineFlags.None))
                    list.Add("iContextEngineFlags", contextEngineFlags.ToString());

                if (empty || (substitutionFlags != SubstitutionFlags.None))
                    list.Add("iSubstitutionFlags", substitutionFlags.ToString());

                if (empty || (expressionFlags != ExpressionFlags.None))
                    list.Add("iExpressionFlags", expressionFlags.ToString());

#if DEBUGGER || SHELL
                if (empty || (headerFlags != HeaderFlags.None))
                    list.Add("iHeaderFlags", headerFlags.ToString());

                if (empty || (detailFlags != DetailFlags.None))
                    list.Add("iDetailFlags", detailFlags.ToString());
#endif

                if (empty || (afterEventFlags != EventFlags.None))
                    list.Add("iAfterEventFlags", afterEventFlags.ToString());

                if (empty || (engineEventFlags != EventFlags.None))
                    list.Add("iEngineEventFlags", engineEventFlags.ToString());

                if (empty || (queueEventFlags != EventFlags.None))
                    list.Add("iQueueEventFlags", queueEventFlags.ToString());

                if (empty || (serviceEventFlags != EventFlags.None))
                    list.Add("iServiceEventFlags", serviceEventFlags.ToString());

                if (empty || (updateEventFlags != EventFlags.None))
                    list.Add("iUpdateEventFlags", updateEventFlags.ToString());

                if (empty || (waitEventFlags != EventFlags.None))
                    list.Add("iWaitEventFlags", waitEventFlags.ToString());

                if (empty || (updateFlags != UpdateFlags.None))
                    list.Add("iUpdateFlags", updateFlags.ToString());

                if (empty || (newGlobalVariableFlags != VariableFlags.None))
                    list.Add("iNewGlobalVariableFlags", newGlobalVariableFlags.ToString());

                if (empty || (newLocalVariableFlags != VariableFlags.None))
                    list.Add("iNewLocalVariableFlags", newLocalVariableFlags.ToString());

                if (empty || (packageFlags != PackageFlags.None))
                    list.Add("iPackageFlags", packageFlags.ToString());

                if (empty || (procedureFlags != ProcedureFlags.None))
                    list.Add("iProcedureFlags", procedureFlags.ToString());

#if SHELL && INTERACTIVE_COMMANDS
                if (empty || interactiveCommandsEnabled)
                    list.Add("idCommandsEnabled", interactiveCommandsEnabled.ToString());

                if (empty || (interactiveEngineFlags != EngineFlags.None))
                    list.Add("idEngineFlags", interactiveEngineFlags.ToString());

                if (empty || (interactiveSubstitutionFlags != SubstitutionFlags.None))
                    list.Add("idSubstitutionFlags", interactiveSubstitutionFlags.ToString());

                if (empty || (interactiveEventFlags != EventFlags.None))
                    list.Add("idEventFlags", interactiveEventFlags.ToString());

                if (empty || (interactiveExpressionFlags != ExpressionFlags.None))
                    list.Add("idExpressionFlags", interactiveExpressionFlags.ToString());
#endif

#if NOTIFY || NOTIFY_OBJECT
                if (empty || (notifyTypes != NotifyType.None))
                    list.Add("iNotifyTypes", notifyTypes.ToString());

                NotifyType threadNotifyTypes = NotifyTypes; /* NOTE: Context only. */

                if (empty || (threadNotifyTypes != NotifyType.None))
                    list.Add("iThreadNotifyTypes", threadNotifyTypes.ToString());

                if (empty || (notifyFlags != NotifyFlags.None))
                    list.Add("iNotifyFlags", notifyFlags.ToString());

                NotifyFlags threadNotifyFlags = NotifyFlags; /* NOTE: Context only. */

                if (empty || (threadNotifyFlags != NotifyFlags.None))
                    list.Add("iThreadNotifyFlags", threadNotifyFlags.ToString());
#endif

#if NATIVE && TCL
                if (empty || (tclFindFlags != FindFlags.None))
                    list.Add("iTclFindFlags", tclFindFlags.ToString());

                if (empty || (tclLoadFlags != LoadFlags.None))
                    list.Add("iTclLoadFlags", tclLoadFlags.ToString());

                if (empty || (tclCommandUnloadFlags != UnloadFlags.None))
                    list.Add("iTclCommandUnloadFlags", tclCommandUnloadFlags.ToString());

                if (empty || (tclExitUnloadFlags != UnloadFlags.None))
                    list.Add("iTclExitUnloadFlags", tclExitUnloadFlags.ToString());
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the _Hosts.Default class only.
        //
        internal void GetHostColorInfo(
            ref StringPairList list, /* REMOTING */
            DetailFlags detailFlags
            )
        {
            if (list == null)
                return;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                    return;

                bool empty = HostOps.HasEmptyContent(detailFlags);

                if (empty ||
                    (defaultForegroundColor != _ConsoleColor.None))
                {
                    list.Add("DefaultForegroundColor",
                        FormatOps.DisplayColor(defaultForegroundColor));
                }

                if (empty ||
                    (defaultBackgroundColor != _ConsoleColor.None))
                {
                    list.Add("DefaultBackgroundColor",
                        FormatOps.DisplayColor(defaultBackgroundColor));
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the _Hosts.Default class only.
        //
        internal void GetHostInterpreterInfo(
            ref StringPairList list, /* REMOTING */
            DetailFlags detailFlags
            )
        {
            if (list == null)
                return;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                    return;

                bool empty = HostOps.HasEmptyContent(detailFlags);

                list.Add("Id", InternalToString()); // NOTE: Also in engine info.
                list.Add("GroupId", groupId.ToString());
                list.Add("Created", FormatOps.Iso8601FullDateTime(created));

#if DEBUG
                ulong? token = Token; /* PROPERTY */

                if (empty || (token != null))
                {
                    list.Add("Token", (token != null) ?
                        token.ToString() : FormatOps.DisplayNull);
                }
#endif

                int localDisposalDisableCount = Interlocked.CompareExchange(
                    ref disposalDisableCount, 0, 0);

                if (empty || (localDisposalDisableCount > 0))
                    list.Add("DisposalDisableCount", localDisposalDisableCount.ToString());

                long localGoodHealthCount = Interlocked.CompareExchange(
                    ref goodHealthCount, 0, 0);

                if (empty || (localGoodHealthCount > 0))
                    list.Add("GoodHealthCount", localGoodHealthCount.ToString());

                long localBadHealthCount = Interlocked.CompareExchange(
                    ref badHealthCount, 0, 0);

                if (empty || (localBadHealthCount > 0))
                    list.Add("BadHealthCount", localBadHealthCount.ToString());

                DateTime? localLastHealthCheck = lastHealthCheck;

                if (empty || (localLastHealthCheck != null))
                    list.Add("LastHealthCheck", (localLastHealthCheck != null) ?
                        FormatOps.Iso8601FullDateTime((DateTime)localLastHealthCheck) :
                        FormatOps.DisplayNull);

                if (empty || !uniqueId.Equals(Guid.Empty))
                    list.Add("UniqueId", uniqueId.ToString());

                if (empty || !String.IsNullOrEmpty(group))
                    list.Add("Group",
                        FormatOps.DisplayString(group));

                if (empty || !String.IsNullOrEmpty(description))
                    list.Add("Description",
                        FormatOps.DisplayString(description));

                if (empty || (clientData != null))
                    list.Add("ClientData", (clientData != null) ?
                        clientData.ToString() : FormatOps.DisplayNull);

#if THREADING
                int preDisposeContextCount = 0;
                int postDisposeContextCount = 0;

                QueryDisposeContextCounts(
                    ref preDisposeContextCount,
                    ref postDisposeContextCount);

                if (empty || (preDisposeContextCount > 0))
                    list.Add("PreDisposeContextCount",
                        preDisposeContextCount.ToString());

                if (empty || (postDisposeContextCount > 0))
                    list.Add("PostDisposeContextCount",
                        postDisposeContextCount.ToString());

                int sum = SumOfAllContextCounts(); /* PER-THREAD */

                if (empty || (sum > 0))
                    list.Add("SumOfAllContextCounts", sum.ToString());
#endif

                int localActiveCount; /* REUSED */

                localActiveCount = GetActiveCount(false);

                if (empty || (localActiveCount > 0))
                    list.Add("ThreadActiveCount", localActiveCount.ToString());

                localActiveCount = GetActiveCount(true);

                if (empty || (localActiveCount > 0))
                    list.Add("GlobalActiveCount", localActiveCount.ToString());

                if (empty || throwOnFeatureNotSupported)
                    list.Add("ThrowOnFeatureNotSupported",
                        throwOnFeatureNotSupported.ToString());

                if (empty || AreNamespacesEnabled())
                    list.Add("AreNamespacesEnabled",
                        AreNamespacesEnabled().ToString());

                if (empty || (traceTextWriter != null))
                    list.Add("TraceTextWriter", (traceTextWriter != null) ?
                        traceTextWriter.ToString() : FormatOps.DisplayNull);

                if (empty || (debugTextWriter != null))
                    list.Add("DebugTextWriter", (debugTextWriter != null) ?
                        debugTextWriter.ToString() : FormatOps.DisplayNull);

                if (empty || (missingVariableValue != null))
                    list.Add("MissingVariableValue", (missingVariableValue != null) ?
                        missingVariableValue.ToString() : FormatOps.DisplayNull);

                if (empty || missingVariableDirty)
                    list.Add("MissingVariableDirty", missingVariableDirty.ToString());

                if (empty || (owner != null))
                    list.Add("Owner", (owner != null) ?
                        owner.ToString() : FormatOps.DisplayNull);

                if (empty || (applicationObject != null))
                    list.Add("ApplicationObject", (applicationObject != null) ?
                        applicationObject.ToString() : FormatOps.DisplayNull);

                if (empty || (policyObject != null))
                    list.Add("PolicyObject", (policyObject != null) ?
                        policyObject.ToString() : FormatOps.DisplayNull);

                if (empty || (resolverObject != null))
                    list.Add("ResolverObject", (resolverObject != null) ?
                        resolverObject.ToString() : FormatOps.DisplayNull);

                if (empty || (userObject != null))
                    list.Add("UserObject", (userObject != null) ?
                        userObject.ToString() : FormatOps.DisplayNull);

                if (empty || (runtimeOptions != null))
                    list.Add("RuntimeOptions", FormatOps.DisplayKeys(runtimeOptions));

#if WINFORMS
                if (empty || (statusThread != null))
                    list.Add("StatusThread", (statusThread != null) ?
                        statusThread.ManagedThreadId.ToString() : FormatOps.DisplayNull);

                if (empty || !String.IsNullOrEmpty(statusStartEventName))
                    list.Add("StatusStartEventName",
                        FormatOps.DisplayString(statusStartEventName));

                if (empty || !String.IsNullOrEmpty(statusDoneEventName))
                    list.Add("StatusDoneEventName",
                        FormatOps.DisplayString(statusDoneEventName));

                if (empty || (statusObject != null))
                    list.Add("StatusObject", (statusObject != null) ?
                        statusObject.ToString() : FormatOps.DisplayNull);

                StatusCallback statusCallback = Interlocked.CompareExchange(
                    ref this.statusCallback, null, null);;

                if (empty || (statusCallback != null))
                {
                    list.Add("StatusCallback",
                        (statusCallback != null) ?
                            FormatOps.DelegateMethodName(
                                statusCallback.Method, false, true) :
                            FormatOps.DisplayNull);
                }

                if (empty || (statusLevels != 0))
                    list.Add("StatusLevels", statusLevels.ToString());

                if (empty || (statusDisposed != 0))
                    list.Add("StatusDisposed", statusDisposed.ToString());

                if (empty || (statusIterations != 0))
                    list.Add("StatusIterations", statusIterations.ToString());

                if (empty || statusSynchronous)
                    list.Add("StatusSynchronous", statusSynchronous.ToString());
#endif

                if (empty || (random != null))
                    list.Add("Random", (random != null) ?
                        random.ToString() : FormatOps.DisplayNull);

                if (empty || (randomNumberGenerator != null))
                    list.Add("RandomNumberGenerator", (randomNumberGenerator != null) ?
                        randomNumberGenerator.ToString() : FormatOps.DisplayNull);

                if (empty || (entropy != null))
                    list.Add("Entropy", FormatOps.DisplayByteArray(entropy));

                if (empty || (safeEntropy != null))
                    list.Add("SafeEntropy", FormatOps.DisplayByteArray(safeEntropy));

#if SHELL
                PreviewArgumentCallback previewArgumentCallback = PreviewArgumentCallback;

                if (empty || (previewArgumentCallback != null))
                {
                    list.Add("PreviewArgumentCallback",
                        (previewArgumentCallback != null) ?
                            FormatOps.DelegateMethodName(
                                previewArgumentCallback.Method, false, true) :
                            FormatOps.DisplayNull);
                }

                UnknownArgumentCallback unknownArgumentCallback = UnknownArgumentCallback;

                if (empty || (unknownArgumentCallback != null))
                {
                    list.Add("UnknownArgumentCallback",
                        (unknownArgumentCallback != null) ?
                            FormatOps.DelegateMethodName(
                                unknownArgumentCallback.Method, false, true) :
                            FormatOps.DisplayNull);
                }

                EvaluateScriptCallback evaluateScriptCallback = EvaluateScriptCallback;

                if (empty || (evaluateScriptCallback != null))
                {
                    list.Add("EvaluateScriptCallback",
                        (evaluateScriptCallback != null) ?
                            FormatOps.DelegateMethodName(
                                evaluateScriptCallback.Method, false, true) :
                            FormatOps.DisplayNull);
                }

                EvaluateFileCallback evaluateFileCallback = EvaluateFileCallback;

                if (empty || (evaluateFileCallback != null))
                {
                    list.Add("EvaluateFileCallback",
                        (evaluateFileCallback != null) ?
                            FormatOps.DelegateMethodName(
                                evaluateFileCallback.Method, false, true) :
                            FormatOps.DisplayNull);
                }

                EvaluateEncodedFileCallback evaluateEncodedFileCallback = EvaluateEncodedFileCallback;

                if (empty || (evaluateEncodedFileCallback != null))
                {
                    list.Add("EvaluateEncodedFileCallback",
                        (evaluateEncodedFileCallback != null) ?
                            FormatOps.DelegateMethodName(
                                evaluateEncodedFileCallback.Method, false, true) :
                            FormatOps.DisplayNull);
                }
#endif

#if DEBUGGER
                InteractiveLoopCallback interactiveLoopCallback = InteractiveLoopCallback;

                if (empty || (interactiveLoopCallback != null))
                {
                    list.Add("InteractiveLoopCallback",
                        (interactiveLoopCallback != null) ?
                            FormatOps.DelegateMethodName(
                                interactiveLoopCallback.Method, false, true) :
                            FormatOps.DisplayNull);
                }
#endif

                if (empty || (parentInterpreter != null))
                    list.Add("ParentInterpreter", (parentInterpreter != null) ?
                        parentInterpreter.InternalToString() : FormatOps.DisplayNull);

                if (empty || !String.IsNullOrEmpty(childName))
                    list.Add("ChildName", FormatOps.DisplayString(childName));

#if APPDOMAINS && ISOLATED_INTERPRETERS
                if (empty || !String.IsNullOrEmpty(childAppDomainName))
                    list.Add("ChildAppDomainName",
                        FormatOps.DisplayString(childAppDomainName));
#endif

                if (empty || preSetup)
                    list.Add("PreSetup", preSetup.ToString());

                if (empty || setup)
                    list.Add("Setup", setup.ToString());

                if (empty || preInitialized)
                    list.Add("PreInitialized", preInitialized.ToString());

                if (empty || !String.IsNullOrEmpty(preInitializeText))
                    list.Add("PreInitializeText",
                        FormatOps.DisplayString(FormatOps.ReplaceNewLines(
                            FormatOps.NormalizeNewLines(preInitializeText))));

                if (empty || initialized)
                    list.Add("Initialized", initialized.ToString());

                if (empty || !String.IsNullOrEmpty(initializedPath))
                    list.Add("InitializedPath",
                        FormatOps.DisplayString(initializedPath));

#if SHELL
                if (empty || initializedShell)
                    list.Add("InitializedShell", initializedShell.ToString());

                if (empty || !String.IsNullOrEmpty(initializedShellPath))
                    list.Add("InitializedShellPath",
                        FormatOps.DisplayString(initializedShellPath));
#endif

                if (empty || !String.IsNullOrEmpty(libraryPath))
                    list.Add("LibraryPath", FormatOps.DisplayString(libraryPath));

                if (empty || ((autoPathList != null) && (autoPathList.Count > 0)))
                    list.Add("AutoPathList", FormatOps.DisplayList(autoPathList));

                if (empty || (unknownCallback != null))
                    list.Add("UnknownCallback", FormatOps.DelegateMethodName(
                        unknownCallback, false, true));

                if (empty || !String.IsNullOrEmpty(unknown))
                    list.Add("Unknown", FormatOps.DisplayString(unknown));

                string namespaceUnknown = NamespaceUnknown;

                if (empty || !String.IsNullOrEmpty(namespaceUnknown))
                    list.Add("NamespaceUnknown", FormatOps.DisplayString(namespaceUnknown));

                if (empty || (packageFallback != null))
                    list.Add("PackageFallback", FormatOps.DelegateMethodName(
                        packageFallback, false, true));

                if (empty || !String.IsNullOrEmpty(packageUnknown))
                    list.Add("PackageUnknown", FormatOps.DisplayString(packageUnknown));

                if (empty || !String.IsNullOrEmpty(backgroundError))
                    list.Add("BackgroundError", FormatOps.DisplayString(backgroundError));

                if (empty || (traceFilterCallback != null))
                    list.Add("TraceFilterCallback", FormatOps.DelegateMethodName(
                        traceFilterCallback, false, true));

                if (empty || (newCommandCallback != null))
                    list.Add("NewCommandCallback", FormatOps.DelegateMethodName(
                        newCommandCallback, false, true));

                if (empty || (newProcedureCallback != null))
                    list.Add("NewProcedureCallback", FormatOps.DelegateMethodName(
                        newProcedureCallback, false, true));

                if (empty || (matchCallback != null))
                    list.Add("MatchCallback", FormatOps.DelegateMethodName(
                        matchCallback, false, true));

                if (empty || (readyCallback != null))
                    list.Add("ReadyCallback", FormatOps.DelegateMethodName(
                        readyCallback, false, true));

                if (empty || (getTimeoutCallback != null))
                    list.Add("GetTimeoutCallback", FormatOps.DelegateMethodName(
                        getTimeoutCallback, false, true));

#if NETWORK
                if (empty || (preWebClientCallback != null))
                    list.Add("PreWebClientCallback", FormatOps.DelegateMethodName(
                        preWebClientCallback, false, true));

                if (empty || (newWebClientCallback != null))
                    list.Add("NewWebClientCallback", FormatOps.DelegateMethodName(
                        newWebClientCallback, false, true));
#endif

                string testPath = TestPath; /* NOTE: Context only. */

                if (empty || !String.IsNullOrEmpty(testPath))
                    list.Add("TestPath", FormatOps.DisplayString(testPath));

                TestOutputType testVerbose = TestVerbose;

                if (empty || (testVerbose != TestOutputType.None))
                    list.Add("TestVerbose", testVerbose.ToString());

                int testRepeatCount = TestRepeatCount;

                if (empty || (testRepeatCount != Count.Invalid))
                    list.Add("TestRepeatCount", testRepeatCount.ToString());

                string testCurrent = TestCurrent;

                if (empty || !String.IsNullOrEmpty(testCurrent))
                    list.Add("TestCurrent", FormatOps.DisplayString(testCurrent));

                if (empty || !String.IsNullOrEmpty(pluginBaseDirectory))
                    list.Add("PluginBaseDirectory", FormatOps.DisplayString(pluginBaseDirectory));

                if (empty || (binder != null))
                    list.Add("Binder", (binder != null) ?
                        binder.ToString() : FormatOps.DisplayNull);

                if (empty || (cultureInfo != null))
                    list.Add("CultureInfo", (cultureInfo != null) ?
                        FormatOps.CultureName(cultureInfo, true) : FormatOps.DisplayNull);

                string interactiveInput = InteractiveInput; /* NOTE: Context only. */

                if (empty || !String.IsNullOrEmpty(interactiveInput))
                    list.Add("InteractiveInput",
                        FormatOps.DisplayString(FormatOps.ReplaceNewLines(
                            FormatOps.NormalizeNewLines(interactiveInput))));

                string previousInteractiveInput = PreviousInteractiveInput; /* NOTE: Context only. */

                if (empty || !String.IsNullOrEmpty(previousInteractiveInput))
                    list.Add("PreviousInteractiveInput",
                        FormatOps.DisplayString(FormatOps.ReplaceNewLines(
                            FormatOps.NormalizeNewLines(previousInteractiveInput))));

                string interactiveMode = InteractiveMode; /* NOTE: Context only. */

                if (empty || !String.IsNullOrEmpty(interactiveMode))
                    list.Add("InteractiveMode", FormatOps.DisplayString(interactiveMode));

                IScriptLocation scriptLocation = ScriptLocation; /* NOTE: Context only. */

                if (empty || (scriptLocation != null))
                    list.Add("ScriptLocation (Override)", (scriptLocation != null) ?
                        scriptLocation.ToString() : FormatOps.DisplayNull);

                ScriptLocationList scriptLocations = ScriptLocations; /* NOTE: Context only. */

                if (empty || (scriptLocations != null))
                {
                    list.Add("ScriptLocation (Actual)",
                        FormatOps.DisplayScriptLocationList(scriptLocations));
                }

#if SCRIPT_ARGUMENTS
                ArgumentListStack scriptArguments = ScriptArguments; /* NOTE: Context only. */

                if (empty || (scriptArguments != null))
                {
                    list.Add("ScriptArguments (Actual)",
                        FormatOps.DisplayScriptArgumentsQueue(scriptArguments));
                }
#endif

                long previousProcessId = PreviousProcessId; /* NOTE: Context only. */

                if (empty || (previousProcessId != 0))
                    list.Add("PreviousProcessId", previousProcessId.ToString());

                ///////////////////////////////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(detailFlags, DetailFlags.InterpreterDisposedException, true))
                    InterpreterDisposedException.AddInfo(list, detailFlags);

                ///////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || EXECUTE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
                if (FlagOps.HasFlags(detailFlags, DetailFlags.ListCacheInfo, true))
                    GetHostOtherCacheInfo(ref list, detailFlags);
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

#if (CACHE_ARGUMENTLIST_TOSTRING || CACHE_STRINGLIST_TOSTRING) && CACHE_STATISTICS
                if (FlagOps.HasFlags(detailFlags, DetailFlags.StringCacheInfo, true))
                    GetHostStringCacheInfo(ref list, detailFlags);
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

                if (FlagOps.HasFlags(detailFlags, DetailFlags.ListOps, true))
                    ListOps.AddInfo(list, detailFlags);

                ///////////////////////////////////////////////////////////////////////////////////////

#if WINFORMS
                if (FlagOps.HasFlags(detailFlags, DetailFlags.StatusFormOps, true))
                    StatusFormOps.AddInfo(list, detailFlags);
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || EXECUTE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
        private void GetHostOtherCacheInfo(
            ref StringPairList list, /* REMOTING */
            DetailFlags detailFlags
            )
        {
            if (list == null)
                return;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                    return;

                bool empty = HostOps.HasEmptyContent(detailFlags);

                ///////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
                if (FlagOps.HasFlags(detailFlags, DetailFlags.CacheConfiguration, true))
                    CacheConfiguration.AddInfo(list, detailFlags);

#if NATIVE
                if (FlagOps.HasFlags(detailFlags, DetailFlags.CacheConfigurationMemoryLoad, true))
                    CacheConfiguration.AddMemoryLoadInfo(list, detailFlags);
#endif
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

                StringPairList localList = new StringPairList();

#if EXECUTE_CACHE
#if CACHE_STATISTICS
                if (empty || ((executeCache != null) && executeCache.HaveCacheCounts()))
#else
                if (empty || ((executeCache != null) && (executeCache.Count > 0)))
#endif
                {
                    localList.Add("ExecuteCache", (executeCache != null) ?
#if CACHE_STATISTICS
                        executeCache.CacheCountsToString(empty) : FormatOps.DisplayNull);
#else
                        executeCache.Count.ToString() : FormatOps.DisplayNull);
#endif
                }

                ///////////////////////////////////////////////////////////////////////////////////////

#if CACHE_STATISTICS
                if (empty || ((hiddenExecuteCache != null) && hiddenExecuteCache.HaveCacheCounts()))
#else
                if (empty || ((hiddenExecuteCache != null) && (hiddenExecuteCache.Count > 0)))
#endif
                {
                    localList.Add("HiddenExecuteCache", (hiddenExecuteCache != null) ?
#if CACHE_STATISTICS
                        hiddenExecuteCache.CacheCountsToString(empty) : FormatOps.DisplayNull);
#else
                        hiddenExecuteCache.Count.ToString() : FormatOps.DisplayNull);
#endif
                }
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE
#if CACHE_STATISTICS
                if (empty || ((argumentCache != null) && argumentCache.HaveCacheCounts()))
#else
                if (empty || ((argumentCache != null) && (argumentCache.Count > 0)))
#endif
                {
                    localList.Add("ArgumentCache", (argumentCache != null) ?
#if CACHE_STATISTICS
                        argumentCache.CacheCountsToString(empty) : FormatOps.DisplayNull);
#else
                        argumentCache.Count.ToString() : FormatOps.DisplayNull);
#endif
                }
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

#if LIST_CACHE
#if CACHE_STATISTICS
                if (empty || ((stringListCache != null) && stringListCache.HaveCacheCounts()))
#else
                if (empty || ((stringListCache != null) && (stringListCache.Count > 0)))
#endif
                {
                    localList.Add("StringListCache", (stringListCache != null) ?
#if CACHE_STATISTICS
                        stringListCache.CacheCountsToString(empty) : FormatOps.DisplayNull);
#else
                        stringListCache.Count.ToString() : FormatOps.DisplayNull);
#endif
                }
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

#if PARSE_CACHE
#if CACHE_STATISTICS
                if (empty || ((parseStateCache != null) && parseStateCache.HaveCacheCounts()))
#else
                if (empty || ((parseStateCache != null) && (parseStateCache.Count > 0)))
#endif
                {
                    localList.Add("ParseStateCache", (parseStateCache != null) ?
#if CACHE_STATISTICS
                        parseStateCache.CacheCountsToString(empty) : FormatOps.DisplayNull);
#else
                        parseStateCache.Count.ToString() : FormatOps.DisplayNull);
#endif
                }
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

#if TYPE_CACHE
#if CACHE_STATISTICS
                if (empty || ((typeCache != null) && typeCache.HaveCacheCounts()))
#else
                if (empty || ((typeCache != null) && (typeCache.Count > 0)))
#endif
                {
                    localList.Add("TypeCache", (typeCache != null) ?
#if CACHE_STATISTICS
                        typeCache.CacheCountsToString(empty) : FormatOps.DisplayNull);
#else
                        typeCache.Count.ToString() : FormatOps.DisplayNull);
#endif
                }
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

#if COM_TYPE_CACHE
#if CACHE_STATISTICS
                if (empty || ((comTypeListCache != null) && comTypeListCache.HaveCacheCounts()))
#else
                if (empty || ((comTypeListCache != null) && (comTypeListCache.Count > 0)))
#endif
                {
                    localList.Add("ComTypeListCache", (comTypeListCache != null) ?
#if CACHE_STATISTICS
                        comTypeListCache.CacheCountsToString(empty) : FormatOps.DisplayNull);
#else
                        comTypeListCache.Count.ToString() : FormatOps.DisplayNull);
#endif
                }
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

                if (localList.Count > 0)
                {
                    list.MaybeAddNull();

#if CACHE_STATISTICS
                    list.Add("Cache Statistics");
#else
                    list.Add("Cache Counts");
#endif

                    list.Add((IPair<string>)null);
                    list.Add(localList);
                }
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if (CACHE_ARGUMENTLIST_TOSTRING || CACHE_STRINGLIST_TOSTRING) && CACHE_STATISTICS
        private void GetHostStringCacheInfo(
            ref StringPairList list, /* REMOTING */
            DetailFlags detailFlags
            )
        {
            if (list == null)
                return;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                    return;

                bool empty = HostOps.HasEmptyContent(detailFlags);

#if CACHE_ARGUMENTLIST_TOSTRING
                if (empty || ArgumentList.HaveCacheCounts())
                    list.Add("ArgumentListToStringCache", ArgumentList.CacheCountsToString(empty));
#endif

                ///////////////////////////////////////////////////////////////////////////////////////

#if CACHE_STRINGLIST_TOSTRING
                if (empty || StringList.HaveCacheCounts())
                    list.Add("StringListToStringCache", StringList.CacheCountsToString(empty));
#endif
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For use by the _Hosts.Default class only.
        //
        internal void GetHostTestInfo(
            ref StringPairList list, /* REMOTING */
            DetailFlags detailFlags
            )
        {
            if (list == null)
                return;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (disposed)
                    return;

                bool empty = HostOps.HasEmptyContent(detailFlags);
                Interpreter testTargetInterpreter = TestTargetInterpreter; /* NOTE: Context only. */

                if (empty || (testTargetInterpreter != null))
                    list.Add("TargetInterpreter", FormatOps.InterpreterNoThrow(testTargetInterpreter));

                long[] testStatistics = TestStatistics; /* NOTE: Context only. */

                if ((testStatistics != null) &&
                    (testStatistics.Length >= (int)TestInformationType.SizeOf))
                {
                    if (empty || (testStatistics[(int)TestInformationType.Total] > 0))
                        list.Add("Total", testStatistics[(int)TestInformationType.Total].ToString());

                    if (empty || (testStatistics[(int)TestInformationType.Skipped] > 0))
                        list.Add("Skipped", testStatistics[(int)TestInformationType.Skipped].ToString());

                    if (empty || (testStatistics[(int)TestInformationType.Disabled] > 0))
                        list.Add("Disabled", testStatistics[(int)TestInformationType.Disabled].ToString());

                    if (empty || (testStatistics[(int)TestInformationType.Passed] > 0))
                        list.Add("Passed", testStatistics[(int)TestInformationType.Passed].ToString());

                    if (empty || (testStatistics[(int)TestInformationType.Failed] > 0))
                        list.Add("Failed", testStatistics[(int)TestInformationType.Failed].ToString());

                    if (empty || (testStatistics[(int)TestInformationType.SkippedBug] > 0))
                        list.Add("SkippedBug", testStatistics[(int)TestInformationType.SkippedBug].ToString());

                    if (empty || (testStatistics[(int)TestInformationType.DisabledBug] > 0))
                        list.Add("DisabledBug", testStatistics[(int)TestInformationType.DisabledBug].ToString());

                    if (empty || (testStatistics[(int)TestInformationType.PassedBug] > 0))
                        list.Add("PassedBug", testStatistics[(int)TestInformationType.PassedBug].ToString());

                    if (empty || (testStatistics[(int)TestInformationType.FailedBug] > 0))
                        list.Add("FailedBug", testStatistics[(int)TestInformationType.FailedBug].ToString());
                }

                StringList testMatch = TestMatch; /* NOTE: Context only. */

                if (empty || ((testMatch != null) && (testMatch.Count > 0)))
                    list.Add("Match", FormatOps.DisplayList(testMatch));

                StringList testSkip = TestSkip; /* NOTE: Context only. */

                if (empty || ((testSkip != null) && (testSkip.Count > 0)))
                    list.Add("Skip", FormatOps.DisplayList(testSkip));

#if DEBUGGER
                StringDictionary testBreakpoints = TestBreakpoints; /* NOTE: Context only. */

                if (empty || ((testBreakpoints != null) && (testBreakpoints.Count > 0)))
                    list.Add("Breakpoints", FormatOps.DisplayKeys(testBreakpoints));
#endif

                StringList testConstraints = TestConstraints; /* NOTE: Context only. */

                if (empty || ((testConstraints != null) && (testConstraints.Count > 0)))
                    list.Add("Constraints", FormatOps.DisplayList(testConstraints));

                IntDictionary testKnownBugs = TestKnownBugs; /* NOTE: Context only. */

                if (empty || ((testKnownBugs != null) && (testKnownBugs.Count > 0)))
                    list.Add("KnownBugs", FormatOps.DisplayKeys(testKnownBugs));

                StringList testFailures = TestFailures; /* NOTE: Context only. */

                if (empty || ((testFailures != null) && (testFailures.Count > 0)))
                    list.Add("Failures", FormatOps.DisplayList(testFailures));
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Cache Management
#if ARGUMENT_CACHE
        #region Argument Cache
        //
        // WARNING: For use by the Argument.Create methods only.
        //
        internal bool GetCachedArgument(
            ref Argument argument /* in, out */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!CacheConfiguration.CanRead())
                    return false;

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.Argument, true))
                {
                    if ((argument != null) && (argumentCache != null))
                    {
                        if (!CacheConfiguration.IsItemReadSizeOk(argument, false))
                        {
#if CACHE_STATISTICS
                            argumentCache.IncrementCacheCount(CacheCountType.Miss);
#endif

                            return false;
                        }

                        Argument localArgument;

                        if (argumentCache.TryGetValue(argument, out localArgument))
                        {
#if CACHE_STATISTICS
                            argumentCache.IncrementCacheCount(CacheCountType.Hit);
#endif

                            argument = localArgument;
                            return true;
                        }
#if CACHE_STATISTICS
                        else
                        {
                            argumentCache.IncrementCacheCount(CacheCountType.Miss);
                        }
#endif
                    }
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeTrimOrClearCachedArguments()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!CacheConfiguration.IsSizeOk(
                        argumentCache, CacheFlags.Argument, true, true, true))
                {
#if CACHE_DICTIONARY
                    int trimCount = 0;
                    bool? clear = null;

                    CacheConfiguration.TrimExcess<Argument, Argument>(
                        argumentCache, CacheFlags.Argument, cacheFlags,
                        FlagOps.HasFlags(
                            cacheFlags, CacheFlags.LockArgument, true),
                        ref trimCount, ref clear);

#if CACHE_STATISTICS
                    if (clear != null)
                    {
                        if ((bool)clear)
                        {
                            argumentCache.IncrementCacheCount(CacheCountType.Clear);
                        }
                        else
                        {
                            while (trimCount-- > 0)
                                argumentCache.IncrementCacheCount(CacheCountType.Trim);
                        }
                    }
#endif
#else
                    argumentCache.Clear();

#if CACHE_STATISTICS
                    argumentCache.IncrementCacheCount(CacheCountType.Clear);
#endif
#endif
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by the Argument.Create methods only.
        //
        internal bool AddCachedArgument(
            Argument argument /* in */
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
#if CACHE_DICTIONARY
                bool disabled = false;

                if (!FlagOps.HasFlags(cacheFlags, CacheFlags.LockArgument, true) &&
                    CacheConfiguration.MaybeEnableOrDisable<Argument, Argument>(
                        this, argumentCache, CacheFlags.Argument, cacheFlags,
                        ref disabled))
                {
                    if (argumentCache != null)
                        argumentCache.RestartChanges();

                    if (disabled)
                        return false;
                }
#endif

                bool full = false;

                if (!CacheConfiguration.CanWrite(CacheFlags.Argument, ref full))
                {
                    if (full)
                        MaybeTrimOrClearCachedArguments();

                    return false;
                }

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.Argument, true))
                {
                    if ((argument != null) && (argumentCache != null))
                    {
                        MaybeTrimOrClearCachedArguments();

                        if (!CacheConfiguration.IsItemWriteSizeOk(argument, false))
                        {
#if CACHE_STATISTICS
                            argumentCache.IncrementCacheCount(CacheCountType.Skip);
#endif

                            return false;
                        }

                        if (argumentCache.ContainsKey(argument))
                        {
#if CACHE_STATISTICS
                            argumentCache.IncrementCacheCount(CacheCountType.Collide);
#endif

                            return false;
                        }

                        argumentCache.Add(argument, argument);

#if CACHE_STATISTICS
                        argumentCache.IncrementCacheCount(CacheCountType.Add);
#endif

                        return true;
                    }
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Dead Code
#if DEAD_CODE
        //
        // WARNING: For use by the Argument.Create methods only.
        //
        internal bool RemoveCachedArgument(
            Argument argument
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
#if CACHE_DICTIONARY
                bool disabled = false;

                if (!FlagOps.HasFlags(cacheFlags, CacheFlags.LockArgument, true) &&
                    CacheConfiguration.MaybeEnableOrDisable<Argument, Argument>(
                        this, argumentCache, CacheFlags.Argument, cacheFlags,
                        ref disabled))
                {
                    if (argumentCache != null)
                        argumentCache.RestartChanges();

                    if (disabled)
                        return false;
                }
#endif

                if (!CacheConfiguration.CanDelete())
                    return false;

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.Argument, true))
                {
                    if ((argument != null) && (argumentCache != null))
                    {
                        bool result = argumentCache.Remove(argument);

#if CACHE_STATISTICS
                        if (result)
                            argumentCache.IncrementCacheCount(CacheCountType.Remove);
#endif

                        return result;
                    }
                }
            }

            return false;
        }
#endif
        #endregion
        #endregion
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if LIST_CACHE
        #region StringList Cache
        //
        // WARNING: For use by the ParserOps.(Managed?)SplitList method only.
        //
        internal bool GetCachedStringList(
            string text,
            ref StringList list
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!CacheConfiguration.CanRead())
                    return false;

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.StringList, true))
                {
                    if ((text != null) && (stringListCache != null))
                    {
                        if (!CacheConfiguration.IsItemReadSizeOk(text, false))
                        {
#if CACHE_STATISTICS
                            stringListCache.IncrementCacheCount(CacheCountType.Miss);
#endif

                            return false;
                        }

                        //
                        // NOTE: Check for an already parsed (cached) version
                        //       of this list.  However, if the list is going
                        //       to be modified by the caller, create a copy
                        //       to return to the caller.
                        //
                        StringList localList;

                        if (stringListCache.TryGetValue(text, out localList))
                        {
#if CACHE_STATISTICS
                            stringListCache.IncrementCacheCount(CacheCountType.Hit);
#endif

                            list = localList;
                            return true;
                        }
#if CACHE_STATISTICS
                        else
                        {
                            stringListCache.IncrementCacheCount(CacheCountType.Miss);
                        }
#endif
                    }
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeTrimOrClearCachedStringLists()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!CacheConfiguration.IsSizeOk(
                        stringListCache, CacheFlags.StringList, true, true, true))
                {
#if CACHE_DICTIONARY
                    int trimCount = 0;
                    bool? clear = null;

                    CacheConfiguration.TrimExcess<string, StringList>(
                        stringListCache, CacheFlags.StringList, cacheFlags,
                        FlagOps.HasFlags(
                            cacheFlags, CacheFlags.LockStringList, true),
                        ref trimCount, ref clear);

#if CACHE_STATISTICS
                    if (clear != null)
                    {
                        if ((bool)clear)
                        {
                            stringListCache.IncrementCacheCount(CacheCountType.Clear);
                        }
                        else
                        {
                            while (trimCount-- > 0)
                                stringListCache.IncrementCacheCount(CacheCountType.Trim);
                        }
                    }
#endif
#else
                    stringListCache.Clear();

#if CACHE_STATISTICS
                    stringListCache.IncrementCacheCount(CacheCountType.Clear);
#endif
#endif
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by the ParserOps.(Managed?)SplitList method only.
        //
        internal bool AddCachedStringList(
            string text,
            StringList list
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
#if CACHE_DICTIONARY
                bool disabled = false;

                if (!FlagOps.HasFlags(cacheFlags, CacheFlags.LockStringList, true) &&
                    CacheConfiguration.MaybeEnableOrDisable<string, StringList>(
                        this, stringListCache, CacheFlags.StringList, cacheFlags,
                        ref disabled))
                {
                    if (stringListCache != null)
                        stringListCache.RestartChanges();

                    if (disabled)
                        return false;
                }
#endif

                bool full = false;

                if (!CacheConfiguration.CanWrite(CacheFlags.StringList, ref full))
                {
                    if (full)
                        MaybeTrimOrClearCachedStringLists();

                    return false;
                }

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.StringList, true))
                {
                    if ((text != null) && (stringListCache != null))
                    {
                        MaybeTrimOrClearCachedStringLists();

                        if (!CacheConfiguration.IsItemWriteSizeOk(text, false))
                        {
#if CACHE_STATISTICS
                            stringListCache.IncrementCacheCount(CacheCountType.Skip);
#endif

                            return false;
                        }

                        if (!CacheConfiguration.IsItemWriteSizeOk((ICollection)list, false))
                        {
#if CACHE_STATISTICS
                            stringListCache.IncrementCacheCount(CacheCountType.Skip);
#endif

                            return false;
                        }

                        if (stringListCache.ContainsKey(text))
                        {
#if CACHE_STATISTICS
                            stringListCache.IncrementCacheCount(CacheCountType.Collide);
#endif

                            return false;
                        }

                        stringListCache.Add(text, list);

#if CACHE_STATISTICS
                        stringListCache.IncrementCacheCount(CacheCountType.Add);
#endif

                        return true;
                    }
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by the Parser.(Managed?)SplitList method only.
        //
        internal bool RemoveCachedStringList(
            string text
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
#if CACHE_DICTIONARY
                bool disabled = false;

                if (!FlagOps.HasFlags(cacheFlags, CacheFlags.LockStringList, true) &&
                    CacheConfiguration.MaybeEnableOrDisable<string, StringList>(
                        this, stringListCache, CacheFlags.StringList, cacheFlags,
                        ref disabled))
                {
                    if (stringListCache != null)
                        stringListCache.RestartChanges();

                    if (disabled)
                        return false;
                }
#endif

                if (!CacheConfiguration.CanDelete())
                    return false;

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.StringList, true))
                {
                    if ((text != null) && (stringListCache != null))
                    {
                        bool result = stringListCache.Remove(text);

#if CACHE_STATISTICS
                        if (result)
                            stringListCache.IncrementCacheCount(CacheCountType.Remove);
#endif

                        return result;
                    }
                }
            }

            return false;
        }
        #endregion
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if PARSE_CACHE
        #region ParseState Cache
        internal bool GetCachedParseState(
            string text,
            ref IParseState parseState
            )
        {
            //
            // NOTE: Part of the experimental parser caching mechanism.
            //
            //       No speed improvement was observed; however, further analysis
            //       and profiling may be warranted.
            //
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!CacheConfiguration.CanRead())
                    return false;

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.IParseState, true))
                {
                    if ((text != null) && (parseStateCache != null))
                    {
                        if (!CacheConfiguration.IsItemReadSizeOk(text, false))
                        {
#if CACHE_STATISTICS
                            parseStateCache.IncrementCacheCount(CacheCountType.Miss);
#endif

                            return false;
                        }

                        IParseState localParseState;

                        if (parseStateCache.TryGetValue(text, out localParseState))
                        {
#if CACHE_STATISTICS
                            parseStateCache.IncrementCacheCount(CacheCountType.Hit);
#endif

                            parseState = localParseState;
                            return true;
                        }
#if CACHE_STATISTICS
                        else
                        {
                            parseStateCache.IncrementCacheCount(CacheCountType.Miss);
                        }
#endif
                    }
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeTrimOrClearCachedParseStates()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!CacheConfiguration.IsSizeOk(
                        parseStateCache, CacheFlags.IParseState, true, true, true))
                {
#if CACHE_DICTIONARY
                    int trimCount = 0;
                    bool? clear = null;

                    CacheConfiguration.TrimExcess<string, IParseState>(
                        parseStateCache, CacheFlags.IParseState, cacheFlags,
                        FlagOps.HasFlags(
                            cacheFlags, CacheFlags.LockIParseState, true),
                        ref trimCount, ref clear);

#if CACHE_STATISTICS
                    if (clear != null)
                    {
                        if ((bool)clear)
                        {
                            parseStateCache.IncrementCacheCount(CacheCountType.Clear);
                        }
                        else
                        {
                            while (trimCount-- > 0)
                                parseStateCache.IncrementCacheCount(CacheCountType.Trim);
                        }
                    }
#endif
#else
                    parseStateCache.Clear();

#if CACHE_STATISTICS
                    parseStateCache.IncrementCacheCount(CacheCountType.Clear);
#endif
#endif
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool AddCachedParseState(
            IParseState parseState
            )
        {
            //
            // NOTE: Part of the experimental parser caching mechanism.
            //
            //       No speed improvement was observed; however, further analysis
            //       and profiling may be warranted.
            //
            lock (syncRoot) /* TRANSACTIONAL */
            {
#if CACHE_DICTIONARY
                bool disabled = false;

                if (!FlagOps.HasFlags(cacheFlags, CacheFlags.LockIParseState, true) &&
                    CacheConfiguration.MaybeEnableOrDisable<string, IParseState>(
                        this, parseStateCache, CacheFlags.IParseState, cacheFlags,
                        ref disabled))
                {
                    if (parseStateCache != null)
                        parseStateCache.RestartChanges();

                    if (disabled)
                        return false;
                }
#endif

                bool full = false;

                if (!CacheConfiguration.CanWrite(CacheFlags.IParseState, ref full))
                {
                    if (full)
                        MaybeTrimOrClearCachedParseStates();

                    return false;
                }

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.IParseState, true))
                {
                    if (parseState != null)
                    {
                        string text = parseState.Text;

                        if ((text != null) && (parseStateCache != null))
                        {
                            MaybeTrimOrClearCachedParseStates();

                            if (!CacheConfiguration.IsItemWriteSizeOk(text, false))
                            {
#if CACHE_STATISTICS
                                parseStateCache.IncrementCacheCount(CacheCountType.Skip);
#endif

                                return false;
                            }

                            TokenList tokens = parseState.Tokens;

                            if (!CacheConfiguration.IsItemWriteSizeOk(tokens, false))
                            {
#if CACHE_STATISTICS
                                parseStateCache.IncrementCacheCount(CacheCountType.Skip);
#endif

                                return false;
                            }

                            if (parseStateCache.ContainsKey(text))
                            {
#if CACHE_STATISTICS
                                parseStateCache.IncrementCacheCount(CacheCountType.Collide);
#endif

                                return false;
                            }

                            parseStateCache.Add(text, parseState);

#if CACHE_STATISTICS
                            parseStateCache.IncrementCacheCount(CacheCountType.Add);
#endif

                            return true;
                        }
                    }
                }
            }

            return false;
        }
        #endregion
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TYPE_CACHE
        #region Type Cache
        internal bool GetCachedType(
            string name,
            ref Type type
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!CacheConfiguration.CanRead())
                    return false;

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.Type, true))
                {
                    if ((name != null) && (typeCache != null))
                    {
                        if (!CacheConfiguration.IsItemReadSizeOk(name, false))
                        {
#if CACHE_STATISTICS
                            typeCache.IncrementCacheCount(CacheCountType.Miss);
#endif

                            return false;
                        }

                        if (typeCache.TryGetValue(name, out type))
                        {
#if CACHE_STATISTICS
                            typeCache.IncrementCacheCount(CacheCountType.Hit);
#endif

                            return true;
                        }
#if CACHE_STATISTICS
                        else
                        {
                            typeCache.IncrementCacheCount(CacheCountType.Miss);
                        }
#endif
                    }
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeTrimOrClearCachedTypes()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!CacheConfiguration.IsSizeOk(
                        typeCache, CacheFlags.Type, true, true, true))
                {
#if CACHE_DICTIONARY
                    int trimCount = 0;
                    bool? clear = null;

                    CacheConfiguration.TrimExcess<string, Type>(
                        typeCache, CacheFlags.Type, cacheFlags,
                        FlagOps.HasFlags(
                            cacheFlags, CacheFlags.LockType, true),
                        ref trimCount, ref clear);

#if CACHE_STATISTICS
                    if (clear != null)
                    {
                        if ((bool)clear)
                        {
                            typeCache.IncrementCacheCount(CacheCountType.Clear);
                        }
                        else
                        {
                            while (trimCount-- > 0)
                                typeCache.IncrementCacheCount(CacheCountType.Trim);
                        }
                    }
#endif
#else
                    typeCache.Clear();

#if CACHE_STATISTICS
                    typeCache.IncrementCacheCount(CacheCountType.Clear);
#endif
#endif
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool AddCachedType(
            string name,
            Type type
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
#if CACHE_DICTIONARY
                bool disabled = false;

                if (!FlagOps.HasFlags(cacheFlags, CacheFlags.LockType, true) &&
                    CacheConfiguration.MaybeEnableOrDisable<string, Type>(
                        this, typeCache, CacheFlags.Type, cacheFlags,
                        ref disabled))
                {
                    if (typeCache != null)
                        typeCache.RestartChanges();

                    if (disabled)
                        return false;
                }
#endif

                bool full = false;

                if (!CacheConfiguration.CanWrite(CacheFlags.Type, ref full))
                {
                    if (full)
                        MaybeTrimOrClearCachedTypes();

                    return false;
                }

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.Type, true))
                {
                    if ((name != null) && (typeCache != null))
                    {
                        MaybeTrimOrClearCachedTypes();

                        if (!CacheConfiguration.IsItemWriteSizeOk(name, false))
                        {
#if CACHE_STATISTICS
                            typeCache.IncrementCacheCount(CacheCountType.Skip);
#endif

                            return false;
                        }

                        if (typeCache.ContainsKey(name))
                        {
#if CACHE_STATISTICS
                            typeCache.IncrementCacheCount(CacheCountType.Collide);
#endif

                            return false;
                        }

                        typeCache.Add(name, type);

#if CACHE_STATISTICS
                        typeCache.IncrementCacheCount(CacheCountType.Add);
#endif

                        return true;
                    }
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool RemoveCachedType(
            string name
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
#if CACHE_DICTIONARY
                bool disabled = false;

                if (!FlagOps.HasFlags(cacheFlags, CacheFlags.LockType, true) &&
                    CacheConfiguration.MaybeEnableOrDisable<string, Type>(
                        this, typeCache, CacheFlags.Type, cacheFlags,
                        ref disabled))
                {
                    if (typeCache != null)
                        typeCache.RestartChanges();

                    if (disabled)
                        return false;
                }
#endif

                if (!CacheConfiguration.CanDelete())
                    return false;

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.Type, true))
                {
                    if ((name != null) && (typeCache != null))
                    {
                        bool result = typeCache.Remove(name);

#if CACHE_STATISTICS
                        if (result)
                            typeCache.IncrementCacheCount(CacheCountType.Remove);
#endif

                        return result;
                    }
                }
            }

            return false;
        }
        #endregion
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if COM_TYPE_CACHE
        #region ComTypeList Cache
        internal bool GetCachedComTypeList(
            IntPtr unknown,
            ref TypeList types
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!CacheConfiguration.CanRead())
                    return false;

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.ComTypeList, true))
                {
                    if ((unknown != IntPtr.Zero) && (comTypeListCache != null))
                    {
                        TypeList localTypes;

                        if (comTypeListCache.TryGetValue(unknown, out localTypes))
                        {
#if CACHE_STATISTICS
                            comTypeListCache.IncrementCacheCount(CacheCountType.Hit);
#endif

                            types = localTypes;
                            return true;
                        }
#if CACHE_STATISTICS
                        else
                        {
                            comTypeListCache.IncrementCacheCount(CacheCountType.Miss);
                        }
#endif
                    }
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeTrimOrClearCachedComTypeLists()
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!CacheConfiguration.IsSizeOk(
                        comTypeListCache, CacheFlags.ComTypeList, true, true, true))
                {
#if CACHE_DICTIONARY
                    int trimCount = 0;
                    bool? clear = null;

                    CacheConfiguration.TrimExcess<IntPtr, TypeList>(
                        comTypeListCache, CacheFlags.ComTypeList, cacheFlags,
                        FlagOps.HasFlags(
                            cacheFlags, CacheFlags.LockComTypeList, true),
                        ref trimCount, ref clear);

#if CACHE_STATISTICS
                    if (clear != null)
                    {
                        if ((bool)clear)
                        {
                            comTypeListCache.IncrementCacheCount(CacheCountType.Clear);
                        }
                        else
                        {
                            while (trimCount-- > 0)
                                comTypeListCache.IncrementCacheCount(CacheCountType.Trim);
                        }
                    }
#endif
#else
                    comTypeListCache.Clear();

#if CACHE_STATISTICS
                    comTypeListCache.IncrementCacheCount(CacheCountType.Clear);
#endif
#endif
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool AddCachedComTypeList(
            IntPtr unknown,
            TypeList types
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
#if CACHE_DICTIONARY
                bool disabled = false;

                if (!FlagOps.HasFlags(cacheFlags, CacheFlags.LockComTypeList, true) &&
                    CacheConfiguration.MaybeEnableOrDisable<IntPtr, TypeList>(
                        this, comTypeListCache, CacheFlags.ComTypeList, cacheFlags,
                        ref disabled))
                {
                    if (comTypeListCache != null)
                        comTypeListCache.RestartChanges();

                    if (disabled)
                        return false;
                }
#endif

                bool full = false;

                if (!CacheConfiguration.CanWrite(CacheFlags.ComTypeList, ref full))
                {
                    if (full)
                        MaybeTrimOrClearCachedComTypeLists();

                    return false;
                }

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.ComTypeList, true))
                {
                    if ((unknown != IntPtr.Zero) && (comTypeListCache != null))
                    {
                        MaybeTrimOrClearCachedComTypeLists();

                        if (!CacheConfiguration.IsItemWriteSizeOk(types, false))
                        {
#if CACHE_STATISTICS
                            comTypeListCache.IncrementCacheCount(CacheCountType.Skip);
#endif

                            return false;
                        }

                        if (comTypeListCache.ContainsKey(unknown))
                        {
#if CACHE_STATISTICS
                            comTypeListCache.IncrementCacheCount(CacheCountType.Collide);
#endif

                            return false;
                        }

                        comTypeListCache.Add(unknown, types);

#if CACHE_STATISTICS
                        comTypeListCache.IncrementCacheCount(CacheCountType.Add);
#endif

                        return true;
                    }
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool RemoveCachedComTypeList(
            IntPtr unknown
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
#if CACHE_DICTIONARY
                bool disabled = false;

                if (!FlagOps.HasFlags(cacheFlags, CacheFlags.LockComTypeList, true) &&
                    CacheConfiguration.MaybeEnableOrDisable<IntPtr, TypeList>(
                        this, comTypeListCache, CacheFlags.ComTypeList, cacheFlags,
                        ref disabled))
                {
                    if (comTypeListCache != null)
                        comTypeListCache.RestartChanges();

                    if (disabled)
                        return false;
                }
#endif

                if (!CacheConfiguration.CanDelete())
                    return false;

                if (FlagOps.HasFlags(cacheFlags, CacheFlags.ComTypeList, true))
                {
                    if ((unknown != IntPtr.Zero) && (comTypeListCache != null))
                    {
                        bool result = comTypeListCache.Remove(unknown);

#if CACHE_STATISTICS
                        if (result)
                            comTypeListCache.IncrementCacheCount(CacheCountType.Remove);
#endif

                        return result;
                    }
                }
            }

            return false;
        }
        #endregion
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Core Trace Callbacks
        #region Support Methods
        private static void SetTraceInfoForGetResult(
            ITraceInfo traceInfo,
            ReturnCode code,
            object oldValue
            )
        {
            if (traceInfo != null)
            {
                traceInfo.OldValue = oldValue;
                traceInfo.Cancel = true;
                traceInfo.ReturnCode = code;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void SetTraceInfoForGetResult(
            ITraceInfo traceInfo,
            ReturnCode code,
            Result result
            )
        {
            SetTraceInfoForGetResult(traceInfo, code,
                (object)StringOps.GetStringFromObject(result));
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static void SetTraceInfoForSetResult(
            ITraceInfo traceInfo,
            IVariable variable,
            object oldValue,
            object newValue,
            ReturnCode code,
            ref Result result
            )
        {
            //
            // HACK: This result is not 100% correct;
            //       however, we do not really care.
            //       Firstly, setting the overall
            //       result is entirely optional for
            //       trace callbacks that "succeed".
            //       Secondly, using FixupReturnValue
            //       (or similar) method here would
            //       potentially create opaque object
            //       handles which would then just be
            //       leaked because they would never
            //       actually even be seen by the
            //       calling script.  At some point,
            //       it might be worthwhile to use
            //       the FixupReturnValue method here
            //       with the value of the toString
            //       parameter hard-wired to true.
            //
            result = StringOps.GetResultFromObject(newValue);

            EntityOps.SetUndefined(variable, false);
            EntityOps.SetDirty(variable, true);

            if (traceInfo != null)
            {
                traceInfo.OldValue = oldValue;
                traceInfo.NewValue = newValue;
                traceInfo.Cancel = true;
                traceInfo.ReturnCode = code;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsForbiddenVariableForArrayCopy(
            IVariable variable
            )
        {
            // CheckDisposed();

            if (IsEnvironmentVariable(variable))
                return true;

            if (IsTestsVariable(variable))
                return true;

#if DATA
            if (IsDatabaseVariable(variable))
                return true;
#endif

#if NETWORK && WEB
            if (IsNetworkVariable(variable))
                return true;
#endif

#if !NET_STANDARD_20 && WINDOWS
            if (IsRegistryVariable(variable))
                return true;
#endif

            if (IsThreadVariable(variable))
                return true;

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsSpecialVariable(
            IVariable variable
            )
        {
            // CheckDisposed();

            if (IsEnvironmentVariable(variable))
                return true;

            if (IsTestsVariable(variable))
                return true;

            if (IsSystemArrayVariable(variable))
                return true;

#if DATA
            if (IsDatabaseVariable(variable))
                return true;
#endif

#if NETWORK && WEB
            if (IsNetworkVariable(variable))
                return true;
#endif

#if !NET_STANDARD_20 && WINDOWS
            if (IsRegistryVariable(variable))
                return true;
#endif

            if (IsThreadVariable(variable))
                return true;

            if (IsLinkedVariable(variable))
                return true;

            if (IsEnumerableVariable(variable))
                return true;

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: This method assumes the interpreter lock is already held.
        //
        private bool HasVariableTraces(
            TraceList traces, /* in */
            bool globalOnly   /* in */
            )
        {
            if (traces == null)
                return false;

            if (!globalOnly && (autoPathTraceList != null) &&
                !ScriptOps.HasTraceCallbacks(traces, autoPathTraceList))
            {
                return false;
            }

            if (!globalOnly && (environmentTraceList != null) &&
                !ScriptOps.HasTraceCallbacks(traces, environmentTraceList))
            {
                return false;
            }

            if (!globalOnly && (enumerableVariableTraceList != null) &&
                !ScriptOps.HasTraceCallbacks(traces, enumerableVariableTraceList))
            {
                return false;
            }

            if (!globalOnly && (linkedVariableTraceList != null) &&
                !ScriptOps.HasTraceCallbacks(traces, linkedVariableTraceList))
            {
                return false;
            }

            if (!globalOnly && (systemArrayTraceList != null) &&
                !ScriptOps.HasTraceCallbacks(traces, systemArrayTraceList))
            {
                return false;
            }

            if ((objectTraceList != null) &&
                !ScriptOps.HasTraceCallbacks(traces, objectTraceList))
            {
                return false;
            }

            if (!globalOnly && (precisionTraceList != null) &&
                !ScriptOps.HasTraceCallbacks(traces, precisionTraceList))
            {
                return false;
            }

            if (!globalOnly && (testsTraceList != null) &&
                !ScriptOps.HasTraceCallbacks(traces, testsTraceList))
            {
                return false;
            }

            return true;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static bool HasTraceCallbacks(
            TraceList traces, /* in */
            bool globalOnly   /* in */
            )
        {
            if (traces == null)
                return false;

            List<TraceCallback> callbacks = new List<TraceCallback>();

            callbacks.Add(ObjectTraceCallback);

            if (!globalOnly)
            {
                callbacks.Add(AutoPathTraceCallback);
                callbacks.Add(EnvironmentTraceCallback);
                callbacks.Add(EnumerableVariableTraceCallback);
                callbacks.Add(LinkedVariableTraceCallback);
                callbacks.Add(SystemArrayTraceCallback);
                callbacks.Add(PrecisionTraceCallback);
                callbacks.Add(TestsTraceCallback);
            }

            foreach (TraceCallback callback in callbacks) /* O(N) */
            {
                if (callback == null)
                    continue;

                bool found = false;

                foreach (ITrace trace in traces) /* O(M) */
                {
                    if (trace == null)
                        continue;

                    if (AppDomainOps.IsTransparentProxy(trace))
                        continue;

                    if (trace.Callback == callback)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                    return false;
            }

            return true;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region AutoPath Trace Callback
        #region Support Methods
        #region Dead Code
#if DEAD_CODE
        private static bool IsAutoPathTraceCallback(
            TraceCallback callback
            )
        {
            return callback == AutoPathTraceCallback;
        }
#endif
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        [MethodFlags(
            MethodFlags.VariableTrace | MethodFlags.System |
            MethodFlags.NoAdd)]
        private static ReturnCode AutoPathTraceCallback( /* SAFE */
            BreakpointType breakpointType,
            Interpreter interpreter,
            ITraceInfo traceInfo,
            ref Result result
            )
        {
            //
            // NOTE: Intercept writes to the variable "auto_path" and figure
            //       out if we need to rescan for package indexes.
            //
            if (interpreter == null)
            {
                result = "invalid interpreter";
                return ReturnCode.Error;
            }

            if (traceInfo == null)
            {
                result = "invalid trace";
                return ReturnCode.Error;
            }

            IVariable variable = traceInfo.Variable;

            if (variable == null)
            {
                result = "invalid variable";
                return ReturnCode.Error;
            }

            //
            // NOTE: Make sure that an array element index was not specified.
            //
            //       *WARNING* Empty array element names are allowed,
            //       please do not change this to "!String.IsNullOrEmpty".
            //
            if (traceInfo.Index == null)
            {
                switch (breakpointType)
                {
                    case BreakpointType.BeforeVariableSet:
                        {
                            PackageIndexDictionary packageIndexes = interpreter.CopyPackageIndexes();

                            //
                            // BUGFIX: Save and restore the current [shared] traceInfo object [for
                            //         this thread] because we may evaluate an arbitrary number of
                            //         scripts during our package index scan and any variable
                            //         accesses will cause the [shared] traceInfo object for this
                            //         thread to change out from under us.
                            //
                            ITraceInfo oldTraceInfo = traceInfo.Copy();

                            try
                            {
                                //
                                // NOTE: Figure out the package index flags needed to rescan for
                                //       "auto_path" changes.
                                //
                                PathComparisonType type = interpreter.PrivatePathComparisonType;
                                PackageIndexFlags flags = interpreter.PrivatePackageIndexFlags;

                                //
                                // NOTE: We do not really want to force a refresh here; however,
                                //       since we have no easy way of actually knowing which
                                //       package index file and by logical extension, which
                                //       directory, provided the "ifneeded" commands for a given
                                //       package, we must refresh all directories to be accurate.
                                //
                                // BUGFIX: Here, the null value should mean "just do nothing".
                                //
                                string newValue = StringOps.GetStringFromObject(
                                    traceInfo.NewValue);

                                if (newValue != null)
                                {
                                    StringList list = null;

                                    if (ParserOps<string>.SplitList(
                                            interpreter, newValue, 0, Length.Invalid, true,
                                            ref list, ref result) != ReturnCode.Ok)
                                    {
                                        return ReturnCode.Error;
                                    }

                                    if (interpreter.InternalIsSafe())
                                    {
                                        string basePath = GlobalState.GetBasePath();

                                        foreach (string element in list)
                                        {
                                            //
                                            // TODO: If "element" is null, should this
                                            //       handling still be the same?
                                            //
                                            if (!PathOps.IsUnderPath(
                                                    interpreter, element, basePath))
                                            {
                                                result = "permission denied: bad directory";
                                                return ReturnCode.Error;
                                            }
                                        }
                                    }

                                    if (PackageOps.FindAll(interpreter,
                                            list, flags, type, ref packageIndexes,
                                            ref result) != ReturnCode.Ok)
                                    {
                                        return ReturnCode.Error;
                                    }

                                    interpreter.PackageIndexes = packageIndexes;
                                }
                            }
                            finally
                            {
                                traceInfo.Update(oldTraceInfo);
                            }
                            break;
                        }
                    case BreakpointType.BeforeVariableUnset:
                        {
                            //
                            // NOTE: They want to unset the auto_path variable.  I guess
                            //       this should be allowed, it is in Tcl.  Also, make
                            //       sure it is purged from the call frame so that it
                            //       cannot be magically restored with this trace
                            //       callback in place.
                            //
                            traceInfo.Flags &= ~VariableFlags.NoRemove;

                            //
                            // BUGFIX: Yes, also make sure any waiters are cleared.
                            //
                            EntityOps.SetDirty(variable, true);

                            //
                            // NOTE: Ok, it appears that Tcl handles this by forgetting
                            //       all package index information; therefore, we will
                            //       emulate that behavior.
                            //
                            if (interpreter.ResetPkgIndexes(
                                    false, ref result) != ReturnCode.Ok)
                            {
                                return ReturnCode.Error;
                            }

                            break;
                        }
                }

                return ReturnCode.Ok;
            }
            else
            {
                //
                // NOTE: We expect "auto_path" to always be a scalar list variable.
                //
                result = String.Format("can't {0} {1}: variable isn't array",
                    FormatOps.Breakpoint(breakpointType),
                    FormatOps.ErrorVariableName(variable.Name, traceInfo.Index));
            }

            return ReturnCode.Error;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Environment Trace Callback
        #region Support Methods
        #region Dead Code
#if DEAD_CODE
        private static bool IsEnvironmentTraceCallback(
            TraceCallback callback
            )
        {
            return callback == EnvironmentTraceCallback;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool HasEnvironmentTraceCallback(
            IVariable variable
            )
        {
            return (variable != null) &&
                (variable.Traces != null) &&
                variable.Traces.Contains(EnvironmentTraceCallback);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsEnvironmentVariable(IVariable variable)
        {
            return (variable != null) &&
                IsGlobalCallFrame(variable.Frame) &&
                SharedStringOps.SystemEquals(
                    variable.Name, TclVars.Core.Environment) &&
                !HasPendingTraces() &&
                HasEnvironmentTraceCallback(variable);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        [MethodFlags(
            MethodFlags.VariableTrace | MethodFlags.System |
            MethodFlags.NoAdd)]
        private static ReturnCode EnvironmentTraceCallback(
            BreakpointType breakpointType,
            Interpreter interpreter,
            ITraceInfo traceInfo,
            ref Result result
            )
        {
            //
            // NOTE: Intercept reads and writes to the variable "env" and redirect
            //       them to get and set environment variables.
            //
            if (interpreter == null)
            {
                result = "invalid interpreter";
                return ReturnCode.Error;
            }

            if (traceInfo == null)
            {
                result = "invalid trace";
                return ReturnCode.Error;
            }

            IVariable variable = traceInfo.Variable;

            if (variable == null)
            {
                result = "invalid variable";
                return ReturnCode.Error;
            }

            //
            // NOTE: *SPECIAL* Ignore the index when we initially add the variable
            //       since we do not perform any trace actions during add anyhow.
            //
            //       *WARNING* Empty array element names are allowed,
            //       please do not change this to "!String.IsNullOrEmpty".
            //
            if ((breakpointType == BreakpointType.BeforeVariableAdd) ||
                (traceInfo.Index != null))
            {
                bool? exists = null;
                string oldValue = null;

                try
                {
                    if (traceInfo.Index != null)
                    {
                        exists = CommonOps.Environment.DoesVariableExistWithThrow(
                            traceInfo.Index, ref oldValue); /* throw */
                    }
                    else
                    {
                        exists = false;
                    }
                }
                catch (Exception e)
                {
                    result = e;
                    traceInfo.ReturnCode = ReturnCode.Error;
                }

                if (exists != null)
                {
                    switch (breakpointType)
                    {
                        case BreakpointType.BeforeVariableGet:
                            {
                                if ((bool)exists)
                                {
                                    try
                                    {
                                        result = oldValue;

                                        traceInfo.OldValue = oldValue;
                                        traceInfo.Cancel = true;
                                        traceInfo.ReturnCode = ReturnCode.Ok;
                                    }
                                    catch (Exception e)
                                    {
                                        result = e;
                                        traceInfo.ReturnCode = ReturnCode.Error;
                                    }
                                }
                                else
                                {
                                    result = String.Format(
                                        "can't read {0}: no such element in array",
                                        FormatOps.ErrorVariableName(variable.Name,
                                        traceInfo.Index));
                                }
                                break;
                            }
                        case BreakpointType.BeforeVariableSet:
                            {
                                try
                                {
                                    string newValue = StringOps.GetStringFromObject(
                                        traceInfo.NewValue);

                                    /* NO RESULT */
                                    CommonOps.Environment.SetVariableWithThrow(
                                        traceInfo.Index, newValue); /* throw */

                                    result = newValue;

                                    EntityOps.SetUndefined(variable, false);
                                    EntityOps.SetDirty(variable, true);

                                    //
                                    // BUGFIX: Must set the old and new values in case they
                                    //         are opaque object handles.
                                    //
                                    traceInfo.OldValue = oldValue;
                                    traceInfo.NewValue = newValue;
                                    traceInfo.Cancel = true;
                                    traceInfo.ReturnCode = ReturnCode.Ok;
                                }
                                catch (Exception e)
                                {
                                    result = e;
                                    traceInfo.ReturnCode = ReturnCode.Error;
                                }
                                break;
                            }
                        case BreakpointType.BeforeVariableUnset:
                            {
                                if ((bool)exists)
                                {
                                    try
                                    {
                                        CommonOps.Environment.UnsetVariableWithThrow(
                                            traceInfo.Index); /* throw */

                                        result = String.Empty;

                                        EntityOps.SetDirty(variable, true);

                                        //
                                        // BUGFIX: Must set the old value in case it was an
                                        //         opaque object handle.
                                        //
                                        traceInfo.OldValue = oldValue;
                                        traceInfo.Cancel = true;
                                        traceInfo.ReturnCode = ReturnCode.Ok;
                                    }
                                    catch (Exception e)
                                    {
                                        result = e;
                                        traceInfo.ReturnCode = ReturnCode.Error;
                                    }
                                }
                                else if (!FlagOps.HasFlags(
                                        traceInfo.Flags, VariableFlags.NoComplain, true))
                                {
                                    result = String.Format(
                                        "can't unset {0}: no such element in array",
                                        FormatOps.ErrorVariableName(variable.Name,
                                        traceInfo.Index));
                                }
                                else
                                {
                                    //
                                    // BUGFIX: Do not return an error if the "NoComplain"
                                    //         flag has been set by the caller.
                                    //
                                    // NOTE: The default handling sets an error message
                                    //       into the result for this case and we do not
                                    //       want that; therefore, cancel the default
                                    //       action.
                                    //
                                    traceInfo.Cancel = true;
                                    traceInfo.ReturnCode = ReturnCode.Ok;
                                }
                                break;
                            }
                    }
                }

                return traceInfo.ReturnCode;
            }
            else if (breakpointType == BreakpointType.BeforeVariableUnset)
            {
                //
                // NOTE: They want to unset the entire env array.  I guess
                //       this should be allowed, it is in Tcl.  Also, make
                //       sure it is purged from the call frame so that it
                //       cannot be magically restored with this trace
                //       callback in place.
                //
                traceInfo.Flags &= ~VariableFlags.NoRemove;

                //
                // BUGFIX: Must make the entire array "concrete" now just
                //         in case there are any opaque object handles
                //         that need to be picked up by later traces (e.g.
                //         ObjectTraceCallback).
                //
                if (EntityOps.IsArray2(variable))
                {
                    IDictionary environment =
                        Environment.GetEnvironmentVariables();

                    if (environment != null)
                    {
                        EventWaitHandle variableEvent;

                        variableEvent = interpreter.TryGetVariableEvent(
                            ref result);

                        if (variableEvent == null)
                            return ReturnCode.Error;

                        variable.ArrayValue = new ElementDictionary(
                            variableEvent, environment);
                    }
                    else
                    {
                        result = "environment variables unavailable";
                        return ReturnCode.Error;
                    }
                }

                return ReturnCode.Ok;
            }
            else
            {
                //
                // NOTE: We (this trace procedure) expect the "env" variable
                //       to always be an array.
                //
                result = String.Format(
                    "can't {0} {1}: variable is array",
                    FormatOps.Breakpoint(breakpointType),
                    FormatOps.ErrorVariableName(variable.Name));
            }

            return ReturnCode.Error;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Object Trace Callback
        #region Support Methods
        internal static bool IsObjectTraceCallback(
            TraceCallback callback
            )
        {
            return callback == ObjectTraceCallback;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddObjectReference(
            ReturnCode code,
            Result result,
            ObjectReferenceType type,
            ref Result error
            )
        {
            IObject @object = null;

            return AddObjectReference(
                code, result, type, ref @object, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode AddObjectReference(
            ReturnCode code,
            Result result,
            ObjectReferenceType type,
            ref IObject @object,
            ref Result error
            )
        {
            bool added = false;

            return AddObjectReference(
                code, result, type, ref @object, ref added, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode AddObjectReference(
            ReturnCode code,
            Result result,
            ObjectReferenceType type,
            ref IObject @object,
            ref bool added,
            ref Result error /* NOT USED */
            )
        {
            //
            // NOTE: Declare a variable for the formal interface for the
            //       objects that we track.
            //
            IObject localObject = null;

            //
            // NOTE: Check to see if the new variable value refers to a live
            //       object handle.
            //
            if ((result != null) && GetObject(
                    StringOps.GetStringFromObject(result),
                    LookupFlags.NoVerbose, ref localObject) == ReturnCode.Ok)
            {
                //
                // NOTE: Give the caller a reference to the object we found.
                //
                @object = localObject;

                //
                // NOTE: Attempt to cast the object to the proper wrapper
                //       type and then invalidate the object.
                //
                _Wrappers._Object newWrapper = localObject as _Wrappers._Object;
                localObject = null;

                //
                // NOTE: If the new wrapper object is valid, add a reference
                //       to it.
                //
                if (newWrapper != null)
                {
                    //
                    // NOTE: Do not attempt to manage reference counts for
                    //       locked objects.
                    //
                    ObjectFlags flags = newWrapper.ObjectFlags;

                    if (!FlagOps.HasFlags(
                            flags, ObjectFlags.Locked, true) &&
                        ((type != ObjectReferenceType.Return) ||
                        !FlagOps.HasFlags(
                            flags, ObjectFlags.NoReturnReference, true)))
                    {
                        //
                        // NOTE: Add a reference to the new wrapper object.
                        //
                        newWrapper.AddReference();

                        //
                        // NOTE: If flagged, also add a temporary reference
                        //       to the new wrapper object.
                        //
                        if ((type == ObjectReferenceType.Return) &&
                            FlagOps.HasFlags(
                                flags, ObjectFlags.TemporaryReturnReference,
                                true))
                        {
                            newWrapper.AddTemporaryReference();
                        }

                        //
                        // NOTE: We successfully added a reference to the
                        //       object.
                        //
                        added = true;
                    }

                    newWrapper = null;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveObjectReference(
            ReturnCode code,
            Result result,
            ObjectReferenceType type,
            bool alias,
            ref Result error
            )
        {
            IObject @object = null;

            return RemoveObjectReference(
                code, result, type, alias, ref @object, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode RemoveObjectReference(
            ReturnCode code,
            Result result,
            ObjectReferenceType type,
            bool alias,
            ref IObject @object,
            ref Result error
            )
        {
            bool removed = false;

            return RemoveObjectReference(
                code, result, type, alias, ref @object, ref removed,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode RemoveObjectReference(
            ReturnCode code,
            Result result,
            ObjectReferenceType type,
            bool alias,
            ref IObject @object,
            ref bool removed,
            ref Result error /* NOT USED */
            )
        {
            //
            // NOTE: Declare a variable for the formal interface for the
            //       objects that we track.
            //
            IObject localObject = null;

            //
            // NOTE: Check to see if the new variable value refers to a live
            //       object handle.
            //
            if ((result != null) && GetObject(
                    StringOps.GetStringFromObject(result),
                    LookupFlags.NoVerbose, ref localObject) == ReturnCode.Ok)
            {
                //
                // NOTE: Give the caller a reference to the object we found.
                //
                @object = localObject;

                //
                // NOTE: Attempt to cast the object to the proper wrapper type
                //       and then invalidate the object.
                //
                _Wrappers._Object oldWrapper = localObject as _Wrappers._Object;
                localObject = null;

                //
                // NOTE: If the old wrapper object is valid, remove a reference
                //       from it.
                //
                if (oldWrapper != null)
                {
                    //
                    // NOTE: Do not attempt to manage reference counts for
                    //       locked objects.
                    //
                    ObjectFlags flags = oldWrapper.ObjectFlags;

                    if (!FlagOps.HasFlags(
                            flags, ObjectFlags.Locked, true) &&
                        ((type != ObjectReferenceType.Return) ||
                        !FlagOps.HasFlags(
                            flags, ObjectFlags.NoReturnReference, true)))
                    {
                        //
                        // NOTE: Remove a reference from the old wrapper
                        //       object.  If there are no more outstanding
                        //       references to the underlying object, dipose
                        //       and remove it now.
                        //
                        if (oldWrapper.RemoveReference() <= 0)
                        {
                            ReturnCode removeCode;
                            Result removeResult = null;

                            removeCode = RemoveObject(
                                EntityOps.GetToken(oldWrapper), null,
                                ObjectOps.GetDefaultSynchronous(), alias,
                                ref removeResult);

                            if (removeCode == ReturnCode.Ok)
                            {
                                //
                                // NOTE: We successfully removed the object
                                //       from the interpreter.
                                //
                                removed = true;
                            }
                            else
                            {
                                //
                                // NOTE: Complain loudly if we could not remove
                                //       the object because this indicates an
                                //       error probably occurred during the
                                //       disposal of the object.
                                //
                                DebugOps.Complain(
                                    this, removeCode, removeResult);

                                //
                                // NOTE: If any of the objects cannot be
                                //       removed, the overall result will be an
                                //       error (even if some of the objects are
                                //       successfully removed).
                                //
                                result = removeResult;
                                code = removeCode;
                            }
                        }
                    }

                    oldWrapper = null;
                }
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode CleanupObjectReferences(
            bool force,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (!force && ScriptOps.HasFlags(this,
                        InterpreterFlags.NoCleanupObjectReferences, true))
                {
                    return ReturnCode.Ok;
                }

                if (!HasObjects(ref error))
                    return ReturnCode.Error;

                if (objects.Count == 0)
                    return ReturnCode.Ok;

                ObjectWrapperDictionary localObjects = new ObjectWrapperDictionary(
                    objects);

                foreach (KeyValuePair<string, _Wrappers._Object> pair in localObjects)
                {
                    _Wrappers._Object wrapper = pair.Value;

                    if (wrapper == null)
                        continue;

                    int finalCount = 0;

                    if (wrapper.RemoveTemporaryReferences(
                            this, pair.Key, ref finalCount) &&
                        (finalCount <= 0))
                    {
                        ReturnCode removeCode;
                        Result removeResult = null;

                        removeCode = MaybeRemoveObject(
                            EntityOps.GetToken(wrapper), null,
                            ObjectOps.GetDefaultSynchronous(),
                            true, ref removeResult);

                        if (removeCode != ReturnCode.Ok)
                        {
                            error = removeResult;
                            return ReturnCode.Error;
                        }
                    }
                }

                return ReturnCode.Ok;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        [MethodFlags(
            MethodFlags.VariableTrace | MethodFlags.System |
            MethodFlags.NoAdd)]
        internal static ReturnCode ObjectTraceCallback(
            BreakpointType breakpointType,
            Interpreter interpreter,
            ITraceInfo traceInfo,
            ref Result result
            )
        {
            //
            // NOTE: Only intercept attempted set and unset operations on
            //       variable values that could represent opaque object
            //       handles.
            //
            if (!ScriptOps.IsWriteValueTrace(breakpointType))
            {
                //
                // NOTE: We do not care about this type of variable trace;
                //       however, we cannot simply return the returnCode
                //       contained within the traceInfo object because the
                //       original result could have been an error (e.g. get
                //       access to the "env" array) and we do not want this
                //       trace to be considered a failure.  The traceInfo
                //       object itself is not being changed; therefore, the
                //       original returnCode within it is preserved for the
                //       caller(s) to use later.
                //
                return ReturnCode.Ok;
            }

            if (traceInfo == null)
            {
                result = "invalid trace";
                return ReturnCode.Error;
            }

            if (FlagOps.HasFlags(
                    traceInfo.Flags, VariableFlags.NoObject, true))
            {
                //
                // NOTE: Completely skip all processing of this variable
                //       trace.  The caller certifies that none of the
                //       values contained within the trace require object
                //       reference counting.
                //
                return ReturnCode.Ok;
            }

            if (interpreter == null)
            {
                result = "invalid interpreter";
                return ReturnCode.Error;
            }

            IVariable variable = traceInfo.Variable;

            if (variable == null)
            {
                result = "invalid variable";
                return ReturnCode.Error;
            }

            //
            // NOTE: This is the list of old variable values to check for
            //       opaque object handles (i.e. to decrease the reference
            //       counts on).
            //
            StringList oldValues = null;

            //
            // NOTE: For the purposes of processing this trace, do we need
            //       the old [array related] values?
            //
            bool needOldValueForTrace = ScriptOps.NeedValueForTrace(
                breakpointType, true);

            //
            // BUGFIX: *SPECIAL CASE* If the variable is [already] undefined,
            //         we must skip adding any old values from it; otherwise,
            //         once a variable with an opaque object handle has been
            //         unset, the variable can never be used for that same
            //         object handle again.  This bug can only be seen by
            //         using exactly the same opaque object handle name for
            //         both the old and new values.
            //
            if (!EntityOps.IsUndefined(variable))
            {
                //
                // NOTE: Handle resetting or unsetting an entire array, if
                //       necessary.
                //
                ElementDictionary arrayValue = null;

                if (needOldValueForTrace &&
                    (traceInfo.Index == null) &&
                    EntityOps.IsArray(variable, ref arrayValue))
                {
                    //
                    // HACK: Delve into the array dictionary directly and
                    //       extract all the keys and values that are about
                    //       to be reset or unset.
                    //
                    ScriptOps.GatherTraceValues(
                        null, null, null, arrayValue, ref oldValues);
                }
                else if (traceInfo.OldValue != null)
                {
                    //
                    // NOTE: Add the one and only old value to the list of
                    //       old values.
                    //
                    ScriptOps.GatherTraceValues(
                        null, null, traceInfo.OldValue, null, ref oldValues);
                }
            }

            //
            // NOTE: Add any extra old values provided with the trace.
            //       Currently, this is only used by [array set].  The
            //       variable name and element index should also be added
            //       (if non-null).
            //
            ScriptOps.GatherTraceValues(
                needOldValueForTrace ? traceInfo.Name : null,
                needOldValueForTrace ? traceInfo.Index : null,
                null, traceInfo.OldValues, ref oldValues);

            //
            // NOTE: This will be the final list of new variable values to
            //       check if they are opaque object handle references (i.e.
            //       to increase the reference counts on).
            //
            StringList newValues = null;

            //
            // NOTE: For the purposes of processing this trace, do we
            //       need the new [array related] values?
            //
            bool needNewValueForTrace = ScriptOps.NeedValueForTrace(
                breakpointType, false);

            //
            // NOTE: Add the new value to the list of new values.
            //       Also, add the extra new values (currently only
            //       used by [array set]) to the final list of new
            //       values.  Finally, the variable name and element
            //       index should also be added (if non-null).
            //
            ScriptOps.GatherTraceValues(
                needNewValueForTrace ? traceInfo.Name : null,
                needNewValueForTrace ? traceInfo.Index : null,
                traceInfo.NewValue, traceInfo.NewValues,
                ref newValues);

            //
            // NOTE: Are there any new variable values to process?
            //
            if (newValues != null)
            {
                //
                // NOTE: Grab all the new objects, based on their opaque
                //       object handles now, ignoring any failures.
                //
                IList<_Wrappers._Object> newObjects = null;

                interpreter.GetObjectsForTrace(newValues, ref newObjects);

                //
                // NOTE: Process all the new objects now (potentially
                //       adding to their reference counts).
                //
                ScriptOps.ProcessNewObjectsForTrace(newObjects);
            }

            //
            // NOTE: If there are no old values then we are done.
            //
            if (oldValues == null)
                return ReturnCode.Ok;

            //
            // NOTE: This return code is only used when removing
            //       objects (i.e. when they have no more outstanding
            //       references). If any of the objects to be removed
            //       return an error, this return code will reflect
            //       that.
            //
            ReturnCode code = ReturnCode.Ok;
            ResultList errors = null;

            //
            // NOTE: Grab all the old objects, based on their opaque
            //       object handles now, ignoring any failures.
            //
            IList<_Wrappers._Object> oldObjects = null;

            interpreter.GetObjectsForTrace(oldValues, ref oldObjects);

            //
            // NOTE: Process all the old objects now (potentially
            //       removing them from the interpreter).
            //
            ScriptOps.ProcessOldObjectsForTrace(
                interpreter, oldObjects, ref code, ref errors);

            if (code != ReturnCode.Ok)
                result = errors;

            return code;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Precision Trace Callback
        #region Support Methods
        #region Dead Code
#if DEAD_CODE
        private static bool IsPrecisionTraceCallback(
            TraceCallback callback
            )
        {
            return callback == PrecisionTraceCallback;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int PrivatePrecision
        {
            set { lock (syncRoot) { precision = value; } }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        [MethodFlags(
            MethodFlags.VariableTrace | MethodFlags.System |
            MethodFlags.NoAdd)]
        private static ReturnCode PrecisionTraceCallback( /* SAFE */
            BreakpointType breakpointType,
            Interpreter interpreter,
            ITraceInfo traceInfo,
            ref Result result
            )
        {
            //
            // NOTE: Sync up our copy of the integer value with what the
            //       script-level knows about.
            //
            if (interpreter == null)
            {
                result = "invalid interpreter";
                return ReturnCode.Error;
            }

            if (traceInfo == null)
            {
                result = "invalid trace";
                return ReturnCode.Error;
            }

            IVariable variable = traceInfo.Variable;

            if (variable == null)
            {
                result = "invalid variable";
                return ReturnCode.Error;
            }

            //
            // NOTE: Make sure that an array element index was not specified.
            //
            //       *WARNING* Empty array element names are allowed,
            //       please do not change this to "String.IsNullOrEmpty".
            //
            if (traceInfo.Index == null)
            {
                if (breakpointType == BreakpointType.BeforeVariableSet)
                {
                    int precision = 0;

                    traceInfo.ReturnCode = Value.GetInteger2(
                        StringOps.GetStringFromObject(traceInfo.NewValue),
                        ValueFlags.AnyInteger, interpreter.InternalCultureInfo,
                        ref precision, ref result);

                    if (traceInfo.ReturnCode == ReturnCode.Ok)
                        interpreter.PrivatePrecision = precision;
                }
                else if (breakpointType == BreakpointType.BeforeVariableUnset)
                {
                    //
                    // NOTE: They want to unset the tcl_precision variable.  I
                    //       guess this should be allowed, it is in Tcl.  Also,
                    //       make sure it is purged from the call frame so that
                    //       it cannot be magically restored with this trace
                    //       callback in place.  For this variable, this
                    //       behavior is not 100% compatible with Tcl; however,
                    //       it is internally consistent with other traced
                    //       Eagle variables.
                    //
                    traceInfo.Flags &= ~VariableFlags.NoRemove;

                    //
                    // BUGFIX: Yes, also make sure any waiters are cleared.
                    //
                    EntityOps.SetDirty(variable, true);
                }

                return traceInfo.ReturnCode;
            }
            else
            {
                //
                // NOTE: We expect "tcl_precision" to always be a
                //       scalar variable.
                //
                result = String.Format(
                    "can't {0} {1}: variable isn't array",
                    FormatOps.Breakpoint(breakpointType),
                    FormatOps.ErrorVariableName(variable.Name,
                    traceInfo.Index));
            }

            return ReturnCode.Error;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Tests Trace Callback
        #region Support Methods
        #region Dead Code
#if DEAD_CODE
        private static bool IsTestsTraceCallback(
            TraceCallback callback
            )
        {
            return callback == TestsTraceCallback;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool HasTestsTraceCallback(IVariable variable)
        {
            return (variable != null) &&
                (variable.Traces != null) &&
                variable.Traces.Contains(TestsTraceCallback);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsTestsVariable(IVariable variable)
        {
            return (variable != null) &&
                IsGlobalCallFrame(variable.Frame) &&
                SharedStringOps.SystemEquals(variable.Name, Vars.Core.Tests) &&
                !HasPendingTraces() && HasTestsTraceCallback(variable);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool DoesTestsVariableExist(string name)
        {
            object enumValue = EnumOps.TryParse(
                typeof(TestInformationType), name,
                true, true);

            if (enumValue is TestInformationType)
            {
                Result result = null;

                if (GetTestInformation(
                        (TestInformationType)enumValue,
                        ref result) == ReturnCode.Ok)
                {
                    return true;
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetTestInformation(
            TestInformationType type,
            ref Result result
            )
        {
            switch (type)
            {
                case TestInformationType.CurrentName:
                    {
                        result = TestCurrent;
                        return ReturnCode.Ok;
                    }
                case TestInformationType.Interpreter:
                    {
                        result = TestTargetInterpreter;
                        return ReturnCode.Ok;
                    }
                case TestInformationType.RepeatCount:
                    {
                        result = TestRepeatCount;
                        return ReturnCode.Ok;
                    }
                case TestInformationType.Verbose:
                    {
                        result = TestVerbose;
                        return ReturnCode.Ok;
                    }
                case TestInformationType.Constraints:
                    {
                        result = TestConstraints;
                        return ReturnCode.Ok;
                    }
                case TestInformationType.KnownBugs:
                    {
                        IntDictionary testKnownBugs = TestKnownBugs;

                        if (testKnownBugs != null)
                            result = testKnownBugs.KeysAndValuesToString(null, false);
                        else
                            result = null;

                        return ReturnCode.Ok;
                    }
#if DEBUGGER
                case TestInformationType.Breakpoints:
                    {
                        StringDictionary testBreakpoints = TestBreakpoints;

                        if (testBreakpoints != null)
                            result = testBreakpoints.KeysAndValuesToString(null, false);
                        else
                            result = null;

                        return ReturnCode.Ok;
                    }
#endif
                case TestInformationType.Counts:
                    {
                        IntDictionary testCounts = TestCounts;

                        if (testCounts != null)
                            result = testCounts.KeysAndValuesToString(null, false);
                        else
                            result = null;

                        return ReturnCode.Ok;
                    }
                case TestInformationType.SkippedNames:
                    {
                        StringListDictionary testSkipped = TestSkipped;

                        if (testSkipped != null)
                            result = testSkipped.ToString();
                        else
                            result = null;

                        return ReturnCode.Ok;
                    }
                case TestInformationType.FailedNames:
                    {
                        result = TestFailures;
                        return ReturnCode.Ok;
                    }
                case TestInformationType.SkipNames:
                    {
                        result = TestSkip;
                        return ReturnCode.Ok;
                    }
                case TestInformationType.MatchNames:
                    {
                        result = TestMatch;
                        return ReturnCode.Ok;
                    }
                case TestInformationType.Level:
                    {
                        result = TestLevels;
                        return ReturnCode.Ok;
                    }
                case TestInformationType.Total:
                case TestInformationType.Skipped:
                case TestInformationType.Disabled:
                case TestInformationType.Passed:
                case TestInformationType.Failed:
                case TestInformationType.SkippedBug:
                case TestInformationType.DisabledBug:
                case TestInformationType.PassedBug:
                case TestInformationType.FailedBug:
                    {
                        long[] testStatistics = TestStatistics;

                        if ((testStatistics != null) &&
                            ((int)type >= 0) && ((int)type < testStatistics.Length))
                        {
                            result = testStatistics[(int)type];
                        }
                        else
                        {
                            result = null;
                        }

                        return ReturnCode.Ok;
                    }
                default:
                    {
                        result = ScriptOps.BadValue(
                            null, "test information type", type.ToString(),
                            Enum.GetNames(typeof(TestInformationType)),
                            null, null);

                        break;
                    }
            }

            return ReturnCode.Error;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal StringDictionary GetAllTestInformation(
            bool values,
            ref Result error
            )
        {
            StringDictionary tests = null;

            foreach (TestInformationType type in new TestInformationType[] {
                    TestInformationType.CurrentName, TestInformationType.Interpreter,
                    TestInformationType.RepeatCount, TestInformationType.Verbose,
                    TestInformationType.KnownBugs, TestInformationType.Constraints,
#if DEBUGGER
                    TestInformationType.Breakpoints,
#endif
                    TestInformationType.Counts, TestInformationType.SkippedNames,
                    TestInformationType.FailedNames, TestInformationType.SkipNames,
                    TestInformationType.MatchNames, TestInformationType.Level,
                    TestInformationType.Total, TestInformationType.Skipped,
                    TestInformationType.Disabled, TestInformationType.Passed,
                    TestInformationType.Failed, TestInformationType.SkippedBug,
                    TestInformationType.DisabledBug, TestInformationType.PassedBug,
                    TestInformationType.FailedBug })
            {
                Result result = null;

                if (values &&
                    GetTestInformation(type, ref result) != ReturnCode.Ok)
                {
                    error = result;
                    return null;
                }

                if (tests == null)
                    tests = new StringDictionary();

                tests.Add(type.ToString(), result);
            }

            if (tests == null)
                error = "test information unavailable";

            return tests;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        [MethodFlags(
            MethodFlags.VariableTrace | MethodFlags.System |
            MethodFlags.NoAdd)]
        private static ReturnCode TestsTraceCallback(
            BreakpointType breakpointType,
            Interpreter interpreter,
            ITraceInfo traceInfo,
            ref Result result
            )
        {
            //
            // NOTE: Intercept reads and writes to the variable "tests" and redirect
            //       them to get and set interpreter state variables.
            //
            if (interpreter == null)
            {
                result = "invalid interpreter";
                return ReturnCode.Error;
            }

            if (traceInfo == null)
            {
                result = "invalid trace";
                return ReturnCode.Error;
            }

            IVariable variable = traceInfo.Variable;

            if (variable == null)
            {
                result = "invalid variable";
                return ReturnCode.Error;
            }

            //
            // NOTE: *SPECIAL* Ignore the index when we initially add the variable
            //       since we do not perform any trace actions during add anyhow.
            //
            //       *WARNING* Empty array element names are allowed,
            //       please do not change this to "!String.IsNullOrEmpty".
            //
            if (breakpointType != BreakpointType.BeforeVariableAdd)
            {
                string index = traceInfo.Index;

                if (index != null)
                {
                    object enumValue = EnumOps.TryParse(
                        typeof(TestInformationType), index, true, true,
                        ref result);

                    if (enumValue is TestInformationType)
                    {
                        TestInformationType informationType = (TestInformationType)enumValue;

                        switch (breakpointType)
                        {
                            case BreakpointType.BeforeVariableGet:
                                {
                                    traceInfo.ReturnCode = interpreter.GetTestInformation(
                                        informationType, ref result);

                                    traceInfo.Cancel = true;
                                    break;
                                }
                            case BreakpointType.BeforeVariableSet:
                                {
                                    if (informationType == TestInformationType.CurrentName)
                                    {
                                        interpreter.TestCurrent = StringOps.GetStringFromObject(
                                            traceInfo.NewValue);

                                        traceInfo.ReturnCode = ReturnCode.Ok;
                                    }
                                    else if (informationType == TestInformationType.Interpreter)
                                    {
                                        Interpreter localInterpreter = null;

                                        traceInfo.ReturnCode = Value.GetInterpreter(
                                            interpreter, StringOps.GetStringFromObject(
                                            traceInfo.NewValue), InterpreterType.Default,
                                            ref localInterpreter, ref result);

                                        if (traceInfo.ReturnCode == ReturnCode.Ok)
                                        {
                                            interpreter.TestTargetInterpreter = localInterpreter;
                                            result = localInterpreter;
                                        }
                                    }
                                    else if (informationType == TestInformationType.RepeatCount)
                                    {
                                        int newValue = 0;

                                        traceInfo.ReturnCode = Value.GetInteger2(
                                            StringOps.GetStringFromObject(traceInfo.NewValue),
                                            ValueFlags.AnyInteger, interpreter.InternalCultureInfo,
                                            ref newValue, ref result);

                                        if (traceInfo.ReturnCode == ReturnCode.Ok)
                                        {
                                            interpreter.TestRepeatCount = newValue;
                                            result = newValue;
                                        }
                                    }
                                    else if (informationType == TestInformationType.Verbose)
                                    {
                                        object enumValue2 = EnumOps.TryParseFlags(
                                            interpreter, typeof(TestOutputType),
                                            StringOps.GetStringFromObject(traceInfo.OldValue),
                                            StringOps.GetStringFromObject(traceInfo.NewValue),
                                            interpreter.InternalCultureInfo, true, true, true, ref result);

                                        if (enumValue2 is TestOutputType)
                                        {
                                            interpreter.TestVerbose = (TestOutputType)enumValue2;
                                            traceInfo.ReturnCode = ReturnCode.Ok;
                                        }
                                        else
                                        {
                                            traceInfo.ReturnCode = ReturnCode.Error;
                                        }
                                    }
                                    else if (informationType == TestInformationType.Constraints)
                                    {
                                        StringList list = null;

                                        //
                                        // WARNING: Cannot cache list representation here, the list
                                        //          may be modified via the public property in the
                                        //          future.
                                        //
                                        traceInfo.ReturnCode = ParserOps<string>.SplitList(
                                            interpreter, StringOps.GetStringFromObject(
                                            traceInfo.NewValue), 0, Length.Invalid, false,
                                            ref list, ref result);

                                        if (traceInfo.ReturnCode == ReturnCode.Ok)
                                            interpreter.TestConstraints = list;
                                    }
                                    else if (informationType == TestInformationType.KnownBugs)
                                    {
                                        StringList list = null;

                                        //
                                        // WARNING: Cannot cache list representation here, the list
                                        //          may be modified via the public property in the
                                        //          future.
                                        //
                                        traceInfo.ReturnCode = ParserOps<string>.SplitList(
                                            interpreter, StringOps.GetStringFromObject(
                                            traceInfo.NewValue), 0, Length.Invalid, false,
                                            ref list, ref result);

                                        if (traceInfo.ReturnCode == ReturnCode.Ok)
                                            interpreter.TestKnownBugs = new IntDictionary(
                                                list, interpreter.InternalCultureInfo);
                                    }
#if DEBUGGER
                                    else if (informationType == TestInformationType.Breakpoints)
                                    {
                                        StringList list = null;

                                        //
                                        // WARNING: Cannot cache list representation here, the list
                                        //          may be modified via the public property in the
                                        //          future.
                                        //
                                        traceInfo.ReturnCode = ParserOps<string>.SplitList(
                                            interpreter, StringOps.GetStringFromObject(
                                            traceInfo.NewValue), 0, Length.Invalid, false,
                                            ref list, ref result);

                                        if (traceInfo.ReturnCode == ReturnCode.Ok)
                                            interpreter.TestBreakpoints = new StringDictionary(list, true, false);
                                    }
#endif
                                    else if (informationType == TestInformationType.Counts)
                                    {
                                        StringList list = null;

                                        //
                                        // WARNING: Cannot cache list representation here, the list
                                        //          may be modified via the public property in the
                                        //          future.
                                        //
                                        traceInfo.ReturnCode = ParserOps<string>.SplitList(
                                            interpreter, StringOps.GetStringFromObject(
                                            traceInfo.NewValue), 0, Length.Invalid, false,
                                            ref list, ref result);

                                        if (traceInfo.ReturnCode == ReturnCode.Ok)
                                            interpreter.TestCounts = new IntDictionary(
                                                list, interpreter.InternalCultureInfo);
                                    }
                                    else if (informationType == TestInformationType.SkippedNames)
                                    {
                                        StringList list = null;

                                        //
                                        // WARNING: Cannot cache list representation here, the list
                                        //          may be modified via the public property in the
                                        //          future.
                                        //
                                        traceInfo.ReturnCode = ParserOps<string>.SplitList(
                                            interpreter, StringOps.GetStringFromObject(
                                            traceInfo.NewValue), 0, Length.Invalid, false,
                                            ref list, ref result);

                                        if (traceInfo.ReturnCode == ReturnCode.Ok)
                                        {
                                            //
                                            // NOTE: The test suite uses a zero element list
                                            //       value to clear out this test suite value.
                                            //
                                            if (list.Count == 0)
                                            {
                                                interpreter.TestSkipped = new StringListDictionary();
                                            }
                                            else if (list.Count == 2)
                                            {
                                                //
                                                // WARNING: This section of code is correct and has been
                                                //          tested; however, it is *NOT* actually used
                                                //          when running the library test suite.  Instead,
                                                //          the TestOps class calls the Merge method [on
                                                //          the StringListDictionary instance referenced
                                                //          via the TestSkipped property], as appropriate,
                                                //          while checking the constraints for a test.  In
                                                //          order to test this section of code, a command
                                                //          similar to the following may be used:
                                                //
                                                //            set eagle_tests(SkippedNames) \
                                                //                [list testName-1.1 [list \
                                                //                constraintName1 constraintName2]]
                                                //
                                                StringList list2 = null;

                                                //
                                                // WARNING: Cannot cache list representation here, the list
                                                //          may be modified via the public property in the
                                                //          future.
                                                //
                                                traceInfo.ReturnCode = ParserOps<string>.SplitList(
                                                    interpreter, list[1], 0, Length.Invalid, false,
                                                    ref list2, ref result);

                                                if (traceInfo.ReturnCode == ReturnCode.Ok)
                                                {
                                                    StringListDictionary testSkipped = interpreter.TestSkipped;

                                                    if (testSkipped != null)
                                                    {
                                                        testSkipped.Merge(list[0], list2);
                                                    }
                                                    else
                                                    {
                                                        result = String.Format(
                                                            "can't {0} {1}: skipped tests unavailable",
                                                            FormatOps.Breakpoint(breakpointType),
                                                            FormatOps.ErrorVariableName(variable.Name, index));

                                                        traceInfo.ReturnCode = ReturnCode.Error;
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                result = String.Format(
                                                    "can't {0} {1}: value must be zero or two element list",
                                                    FormatOps.Breakpoint(breakpointType),
                                                    FormatOps.ErrorVariableName(variable.Name, index));

                                                traceInfo.ReturnCode = ReturnCode.Error;
                                            }
                                        }
                                    }
                                    else if (informationType == TestInformationType.FailedNames)
                                    {
                                        StringList list = null;

                                        //
                                        // WARNING: Cannot cache list representation here, the list
                                        //          may be modified via the public property in the
                                        //          future.
                                        //
                                        traceInfo.ReturnCode = ParserOps<string>.SplitList(
                                            interpreter, StringOps.GetStringFromObject(
                                            traceInfo.NewValue), 0, Length.Invalid, false,
                                            ref list, ref result);

                                        if (traceInfo.ReturnCode == ReturnCode.Ok)
                                            interpreter.TestFailures = list;
                                    }
                                    else if (informationType == TestInformationType.SkipNames)
                                    {
                                        StringList list = null;

                                        //
                                        // WARNING: Cannot cache list representation here, the list
                                        //          may be modified via the public property in the
                                        //          future.
                                        //
                                        traceInfo.ReturnCode = ParserOps<string>.SplitList(
                                            interpreter, StringOps.GetStringFromObject(
                                            traceInfo.NewValue), 0, Length.Invalid, false,
                                            ref list, ref result);

                                        if (traceInfo.ReturnCode == ReturnCode.Ok)
                                            interpreter.TestSkip = list;
                                    }
                                    else if (informationType == TestInformationType.MatchNames)
                                    {
                                        StringList list = null;

                                        //
                                        // WARNING: Cannot cache list representation here, the list
                                        //          may be modified via the public property in the
                                        //          future.
                                        //
                                        traceInfo.ReturnCode = ParserOps<string>.SplitList(
                                            interpreter, StringOps.GetStringFromObject(
                                            traceInfo.NewValue), 0, Length.Invalid, false,
                                            ref list, ref result);

                                        if (traceInfo.ReturnCode == ReturnCode.Ok)
                                            interpreter.TestMatch = list;
                                    }
                                    else if (informationType == TestInformationType.Level)
                                    {
                                        int newValue = 0;

                                        traceInfo.ReturnCode = Value.GetInteger2(
                                            StringOps.GetStringFromObject(traceInfo.NewValue),
                                            ValueFlags.AnyInteger, interpreter.InternalCultureInfo,
                                            ref newValue, ref result);

                                        if (traceInfo.ReturnCode == ReturnCode.Ok)
                                        {
                                            interpreter.TestLevels = newValue;
                                            result = newValue;
                                        }
                                    }
                                    else
                                    {
                                        int newValue = 0;

                                        traceInfo.ReturnCode = Value.GetInteger2(
                                            StringOps.GetStringFromObject(traceInfo.NewValue),
                                            ValueFlags.AnyInteger, interpreter.InternalCultureInfo,
                                            ref newValue, ref result);

                                        if (traceInfo.ReturnCode == ReturnCode.Ok)
                                        {
                                            long[] testStatistics = interpreter.TestStatistics;

                                            if (testStatistics != null)
                                            {
                                                if ((informationType >= 0) &&
                                                    (informationType < TestInformationType.SizeOf))
                                                {
                                                    testStatistics[(int)informationType] = newValue;
                                                    result = newValue;
                                                }
                                                else
                                                {
                                                    result = String.Format(
                                                        "cannot set {0}, {1} is out-of-bounds",
                                                        FormatOps.ErrorVariableName(variable.Name, index),
                                                        informationType);

                                                    traceInfo.ReturnCode = ReturnCode.Error;
                                                }
                                            }
                                            else
                                            {
                                                result = "test statistics not available";
                                                traceInfo.ReturnCode = ReturnCode.Error;
                                            }
                                        }
                                    }

                                    if (traceInfo.ReturnCode == ReturnCode.Ok)
                                    {
                                        EntityOps.SetUndefined(variable, false);
                                        EntityOps.SetDirty(variable, true);
                                    }

                                    traceInfo.Cancel = true;
                                    break;
                                }
                            case BreakpointType.BeforeVariableUnset:
                                {
                                    result = String.Format(
                                        "cannot unset {0}, it is a linked variable",
                                        FormatOps.ErrorVariableName(variable.Name, index));

                                    traceInfo.Cancel = true;
                                    traceInfo.ReturnCode = ReturnCode.Error;
                                    break;
                                }
                        }

                        return traceInfo.ReturnCode;
                    }
                }
                else if (breakpointType == BreakpointType.BeforeVariableUnset)
                {
                    //
                    // NOTE: They want to unset the entire tests array.  I guess
                    //       this should be allowed.  Also, make sure it is purged
                    //       from the call frame so that it cannot be magically
                    //       restored with this trace callback in place.
                    //
                    traceInfo.Flags &= ~VariableFlags.NoRemove;

                    return ReturnCode.Ok;
                }
                else
                {
                    //
                    // NOTE: We (this trace procedure) expect the "tests" variable
                    //       to always be an array.
                    //
                    result = String.Format(
                        "can't {0} {1}: variable is array",
                        FormatOps.Breakpoint(breakpointType),
                        FormatOps.ErrorVariableName(variable.Name));
                }
            }
            else
            {
                //
                // NOTE: Skip add operations altogether.
                //
                return ReturnCode.Ok;
            }

            return ReturnCode.Error;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IEnumerable Variable Trace Callback
        #region Support Methods
        #region Dead Code
#if DEAD_CODE
        private static bool IsEnumerableVariableTraceCallback(
            TraceCallback callback
            )
        {
            return callback == EnumerableVariableTraceCallback;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool HasEnumerableVariableTraceCallback(
            IVariable variable
            )
        {
            return (variable != null) &&
                (variable.Traces != null) &&
                variable.Traces.Contains(EnumerableVariableTraceCallback);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsEnumerableVariable(
            IVariable variable
            )
        {
            return (variable != null) && !HasPendingTraces() &&
                HasEnumerableVariableTraceCallback(variable);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        [MethodFlags(
            MethodFlags.VariableTrace | MethodFlags.System |
            MethodFlags.NoAdd)]
        private static ReturnCode EnumerableVariableTraceCallback(
            BreakpointType breakpointType,
            Interpreter interpreter,
            ITraceInfo traceInfo,
            ref Result result
            )
        {
            if ((breakpointType != BreakpointType.BeforeVariableGet) &&
                (breakpointType != BreakpointType.BeforeVariableSet) &&
                (breakpointType != BreakpointType.BeforeVariableUnset))
            {
                return ReturnCode.Ok;
            }

            if (interpreter == null)
            {
                result = "invalid interpreter";
                return ReturnCode.Error;
            }

            if (traceInfo == null)
            {
                result = "invalid trace";
                return ReturnCode.Error;
            }

            IVariable variable = traceInfo.Variable;

            if (variable == null)
            {
                result = "invalid variable";
                return ReturnCode.Error;
            }

            //
            // NOTE: If the variable link is still being initially setup,
            //       skip all other handling.
            //
            if ((breakpointType == BreakpointType.BeforeVariableSet) &&
                EntityOps.IsUndefined(variable))
            {
                return ReturnCode.Ok;
            }

            //
            // NOTE: Grab the trace information we will need.
            //
            string name = traceInfo.Name;
            string index = traceInfo.Index;
            ElementDictionary arrayValue = null;

            //
            // NOTE: Is the variable an array?  If so, also get the
            //       actual backing storage for it.
            //
            bool isArray = EntityOps.IsArray(variable, ref arrayValue);

            //
            // NOTE: If applicable, does the array element exist?
            //
            bool exists = (isArray && (index != null)) ?
                arrayValue.ContainsKey(index) : false;

            if (breakpointType == BreakpointType.BeforeVariableUnset)
            {
                if (index != null)
                {
                    if (isArray)
                    {
                        //
                        // NOTE: Unset one array element.
                        //
                        if (exists)
                        {
                            //
                            // NOTE: Do nothing.  The element will be unset
                            //       by the caller.
                            //
                            traceInfo.ReturnCode = ReturnCode.Ok;
                        }
                        else if (!FlagOps.HasFlags(
                            traceInfo.Flags, VariableFlags.NoComplain, true))
                        {
                            result = String.Format(
                                "can't unset {0}: no such element in array",
                                FormatOps.ErrorVariableName(
                                    variable, null, variable.Name, index));

                            traceInfo.ReturnCode = ReturnCode.Error;
                        }
                        else
                        {
                            //
                            // NOTE: The default handling sets an error message
                            //       into the result for this case and we do not
                            //       want that; therefore, cancel the default
                            //       action.
                            //
                            traceInfo.Cancel = true;
                            traceInfo.ReturnCode = ReturnCode.Ok;
                        }
                    }
                    else
                    {
                        //
                        // NOTE: Error, unset index with non-array?
                        //
                        result = String.Format(
                            "can't unset {0}: variable isn't array",
                            FormatOps.ErrorVariableName(
                                variable, null, variable.Name, index));

                        traceInfo.ReturnCode = ReturnCode.Error;
                    }
                }
                else
                {
                    //
                    // NOTE: They want to unset the entire array.  Also, make
                    //       sure it is purged from the call frame so that it
                    //       cannot be magically restored with this trace
                    //       callback in place.
                    //
                    traceInfo.Flags &= ~VariableFlags.NoRemove;

                    //
                    // NOTE: If we get this far, everything went fine.
                    //
                    traceInfo.ReturnCode = ReturnCode.Ok;
                }
            }
            else if (breakpointType == BreakpointType.BeforeVariableSet)
            {
                if (isArray && !exists)
                {
                    //
                    // NOTE: Do nothing because the variable link, which is an
                    //       array element) is still being initially setup.
                    //
                    traceInfo.ReturnCode = ReturnCode.Ok;
                }
                else
                {
                    //
                    // NOTE: Variables backed by an IEnumerable must logically
                    //       be immutable; however, they can be removed.
                    //
                    result = String.Format(
                        "can't {0} {1}: variable is read-only",
                        FormatOps.Breakpoint(breakpointType),
                        FormatOps.ErrorVariableName(
                            variable, null, variable.Name, null));

                    traceInfo.ReturnCode = ReturnCode.Error;
                }
            }
            else if (isArray == (index != null))
            {
                if (!isArray || exists)
                {
                    ReturnCode code;
                    object itemValue = null;

                    code = ScriptOps.GetEnumerableVariableItemValue(
                        breakpointType, variable, name, index,
                        traceInfo.OldValue, ref itemValue, ref result);

                    if (code == ReturnCode.Ok)
                    {
                        code = MarshalOps.GetVariableValueAsString(
                            interpreter, itemValue, true, ref result);

                        if (code == ReturnCode.Ok)
                        {
                            SetTraceInfoForGetResult(
                                traceInfo, code, result);
                        }
                        else
                        {
                            traceInfo.ReturnCode = code;
                        }
                    }
                    else
                    {
                        traceInfo.ReturnCode = code;
                    }
                }
                else
                {
                    result = String.Format(
                        "can't read {0}: no such element in array",
                        FormatOps.ErrorVariableName(
                            variable, null, variable.Name, index));

                    traceInfo.ReturnCode = ReturnCode.Error;
                }
            }
            else
            {
                result = String.Format(
                    "can't {0} {1}: variable {2} array",
                    FormatOps.Breakpoint(breakpointType),
                    FormatOps.ErrorVariableName(
                        variable, null, variable.Name, index),
                    isArray ? "is" : "isn't");

                traceInfo.ReturnCode = ReturnCode.Error;
            }

            return traceInfo.ReturnCode;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Linked Variable Trace Callback
        #region Support Methods
        #region Dead Code
#if DEAD_CODE
        private static bool IsLinkedVariableTraceCallback(
            TraceCallback callback
            )
        {
            return callback == LinkedVariableTraceCallback;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool HasLinkedVariableTraceCallback(
            IVariable variable
            )
        {
            return (variable != null) &&
                (variable.Traces != null) &&
                variable.Traces.Contains(LinkedVariableTraceCallback);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsLinkedVariable(
            IVariable variable
            )
        {
            return (variable != null) && !HasPendingTraces() &&
                HasLinkedVariableTraceCallback(variable);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode ChangeType(
            string text,
            Type type,
            ref object value,
            ref Result error
            )
        {
            if (type == typeof(string))
            {
                value = text;
                return ReturnCode.Ok;
            }

            lock (syncRoot) /* TRANSACTIONAL */
            {
                if (binder == null)
                {
                    error = "invalid binder";
                    return ReturnCode.Error;
                }

                try
                {
                    value = binder.ChangeType(text, type, cultureInfo);

                    return ReturnCode.Ok;
                }
                catch (Exception e)
                {
                    error = e;
                }
            }

            return ReturnCode.Error;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        [MethodFlags(
            MethodFlags.VariableTrace | MethodFlags.System |
            MethodFlags.NoAdd)]
        private static ReturnCode LinkedVariableTraceCallback(
            BreakpointType breakpointType,
            Interpreter interpreter,
            ITraceInfo traceInfo,
            ref Result result
            )
        {
            if ((breakpointType != BreakpointType.BeforeVariableGet) &&
                (breakpointType != BreakpointType.BeforeVariableSet) &&
                (breakpointType != BreakpointType.BeforeVariableUnset))
            {
                return ReturnCode.Ok;
            }

            if (interpreter == null)
            {
                result = "invalid interpreter";
                return ReturnCode.Error;
            }

            if (traceInfo == null)
            {
                result = "invalid trace";
                return ReturnCode.Error;
            }

            IVariable variable = traceInfo.Variable;

            if (variable == null)
            {
                result = "invalid variable";
                return ReturnCode.Error;
            }

            //
            // NOTE: If the variable link is still being initially setup,
            //       skip all other handling.
            //
            if ((breakpointType == BreakpointType.BeforeVariableSet) &&
                EntityOps.IsUndefined(variable))
            {
                return ReturnCode.Ok;
            }

            //
            // NOTE: Grab the trace information we will need.
            //
            string name = traceInfo.Name;
            string index = traceInfo.Index;
            ElementDictionary arrayValue = null;

            //
            // NOTE: Is the variable an array?  If so, also get the
            //       actual backing storage for it.
            //
            bool isArray = EntityOps.IsArray(variable, ref arrayValue);

            //
            // NOTE: If applicable, does the array element exist?
            //
            bool exists = (isArray && (index != null)) ?
                arrayValue.ContainsKey(index) : false;

            if (breakpointType == BreakpointType.BeforeVariableUnset)
            {
                if (index != null)
                {
                    if (isArray)
                    {
                        //
                        // NOTE: Unset one array element.
                        //
                        if (exists)
                        {
                            //
                            // NOTE: Must grab the "real" old value in case we
                            //       need to adjust the reference count for it.
                            //
                            object oldValue = null;

                            ScriptOps.GetLinkedVariableMemberValue(
                                traceInfo.OldValue, ref oldValue);

                            if (oldValue != null)
                                traceInfo.OldValue = oldValue;

                            traceInfo.ReturnCode = ReturnCode.Ok;
                        }
                        else if (!FlagOps.HasFlags(
                            traceInfo.Flags, VariableFlags.NoComplain, true))
                        {
                            result = String.Format(
                                "can't unset {0}: no such element in array",
                                FormatOps.ErrorVariableName(
                                    variable, null, variable.Name, index));

                            traceInfo.ReturnCode = ReturnCode.Error;
                        }
                        else
                        {
                            //
                            // NOTE: The default handling sets an error message
                            //       into the result for this case and we do not
                            //       want that; therefore, cancel the default
                            //       action.
                            //
                            traceInfo.Cancel = true;
                            traceInfo.ReturnCode = ReturnCode.Ok;
                        }
                    }
                    else
                    {
                        //
                        // NOTE: Error, unset index with non-array?
                        //
                        result = String.Format(
                            "can't unset {0}: variable isn't array",
                            FormatOps.ErrorVariableName(
                                variable, null, variable.Name, index));

                        traceInfo.ReturnCode = ReturnCode.Error;
                    }
                }
                else
                {
                    //
                    // NOTE: They want to unset the entire array.  Also, make
                    //       sure it is purged from the call frame so that it
                    //       cannot be magically restored with this trace
                    //       callback in place.
                    //
                    traceInfo.Flags &= ~VariableFlags.NoRemove;

                    //
                    // NOTE: Must grab the "real" old value in case we need
                    //       to adjust the reference count for it.
                    //
                    object oldValue = traceInfo.OldValue;

                    if (oldValue != null)
                    {
                        ScriptOps.GetLinkedVariableMemberValue(
                            oldValue, ref oldValue);

                        if (oldValue != null)
                            traceInfo.OldValue = oldValue;
                    }

                    //
                    // BUGFIX: Must make the entire array "concrete" now just
                    //         in case there are any opaque object handles
                    //         that need to be picked up by later traces (e.g.
                    //         ObjectTraceCallback).
                    //
                    if (arrayValue != null)
                    {
                        EventWaitHandle variableEvent =
                            interpreter.TryGetVariableEvent(ref result);

                        if (variableEvent == null)
                            return ReturnCode.Error;

                        ElementDictionary oldValues = null;

                        ScriptOps.GetLinkedVariableArrayValues(
                            variableEvent, arrayValue, ref oldValues);

                        ScriptOps.AddOldValuesToTraceInfo(
                            variableEvent, traceInfo, oldValues);
                    }

                    //
                    // NOTE: If we get this far, everything went fine.
                    //
                    traceInfo.ReturnCode = ReturnCode.Ok;
                }
            }
            else if (isArray == (index != null))
            {
                ReturnCode code;
                MemberInfo memberInfo = null;
                Type type = null;
                object @object = null;
                object memberValue = null;

                code = ScriptOps.GetLinkedVariableMemberAndValue(
                    breakpointType, variable, name, index,
                    traceInfo.OldValue, ref memberInfo, ref type,
                    ref @object, ref memberValue, ref result);

                if (code == ReturnCode.Ok)
                {
                    switch (breakpointType)
                    {
                        case BreakpointType.BeforeVariableGet:
                            {
                                if (!isArray || exists)
                                {
                                    code = MarshalOps.GetVariableValueAsString(
                                        interpreter, memberValue, true, ref result);

                                    if (code == ReturnCode.Ok)
                                    {
                                        SetTraceInfoForGetResult(
                                            traceInfo, code, result);
                                    }
                                    else
                                    {
                                        traceInfo.ReturnCode = code;
                                    }
                                }
                                else
                                {
                                    result = String.Format(
                                        "can't read {0}: no such element in array",
                                        FormatOps.ErrorVariableName(
                                            variable, null, variable.Name, index));

                                    traceInfo.ReturnCode = ReturnCode.Error;
                                }
                                break;
                            }
                        case BreakpointType.BeforeVariableSet:
                            {
                                object newValue = traceInfo.NewValue;

                                if (newValue is string)
                                {
                                    //
                                    // HACK: We do not officially support
                                    //       any array types here (yet?);
                                    //       however, for one dimensional
                                    //       string arrays, just use a
                                    //       StringList.
                                    //
                                    if (type == typeof(string[]))
                                    {
                                        StringList list = null;

                                        code = ParserOps<string>.SplitList(
                                            interpreter, (string)newValue,
                                            0, Length.Invalid, true, ref list,
                                            ref result);

                                        if (code == ReturnCode.Ok)
                                            newValue = list.ToArray();
                                    }
                                    else
                                    {
                                        code = interpreter.ChangeType(
                                            (string)newValue, type,
                                            ref newValue, ref result);
                                    }
                                }

                                if (code == ReturnCode.Ok)
                                {
                                    code = ScriptOps.SetLinkedVariableMemberValue(
                                        breakpointType, variable, name,
                                        index, memberInfo, @object, newValue,
                                        ref result);
                                }

                                if (code == ReturnCode.Ok)
                                {
                                    SetTraceInfoForSetResult(
                                        traceInfo, variable, memberValue, newValue,
                                        code, ref result);
                                }
                                else
                                {
                                    traceInfo.ReturnCode = code;
                                }
                                break;
                            }
                    }
                }
                else
                {
                    traceInfo.ReturnCode = code;
                }
            }
            else
            {
                result = String.Format(
                    "can't {0} {1}: variable {2} array",
                    FormatOps.Breakpoint(breakpointType),
                    FormatOps.ErrorVariableName(
                        variable, null, variable.Name, index),
                    isArray ? "is" : "isn't");

                traceInfo.ReturnCode = ReturnCode.Error;
            }

            return traceInfo.ReturnCode;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region System.Array Variable Trace Callback
        #region Support Methods
        #region Dead Code
#if DEAD_CODE
        private static bool IsSystemArrayTraceCallback(
            TraceCallback callback
            )
        {
            return callback == SystemArrayTraceCallback;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private static bool HasSystemArrayTraceCallback(
            IVariable variable
            )
        {
            return (variable != null) &&
                (variable.Traces != null) &&
                variable.Traces.Contains(SystemArrayTraceCallback);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsSystemArrayVariable(
            IVariable variable
            )
        {
            return (variable != null) && !HasPendingTraces() &&
                HasSystemArrayTraceCallback(variable);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        [MethodFlags(
            MethodFlags.VariableTrace | MethodFlags.System |
            MethodFlags.NoAdd)]
        private static ReturnCode SystemArrayTraceCallback(
            BreakpointType breakpointType,
            Interpreter interpreter,
            ITraceInfo traceInfo,
            ref Result result
            )
        {
            if ((breakpointType != BreakpointType.BeforeVariableGet) &&
                (breakpointType != BreakpointType.BeforeVariableSet) &&
                (breakpointType != BreakpointType.BeforeVariableUnset))
            {
                return ReturnCode.Ok;
            }

            if (interpreter == null)
            {
                result = "invalid interpreter";
                return ReturnCode.Error;
            }

            if (traceInfo == null)
            {
                result = "invalid trace";
                return ReturnCode.Error;
            }

            IVariable variable = traceInfo.Variable;

            if (variable == null)
            {
                result = "invalid variable";
                return ReturnCode.Error;
            }

            //
            // NOTE: If the variable link is still being initially setup,
            //       skip all other handling.
            //
            if ((breakpointType == BreakpointType.BeforeVariableSet) &&
                EntityOps.IsUndefined(variable))
            {
                return ReturnCode.Ok;
            }

            //
            // NOTE: Grab the trace information we will need.
            //
            string name = traceInfo.Name;
            string index = traceInfo.Index;

            //
            // NOTE: For 'unset' operations, the index is not required;
            //       however, it is required for both 'get' and 'set'
            //       operations.
            //
            int[] indexes = null;

            if ((index != null) && MarshalOps.GetArrayIndexes(
                    interpreter.InternalCultureInfo, index, ref indexes,
                    ref result) != ReturnCode.Ok)
            {
                return ReturnCode.Error;
            }

            //
            // NOTE: The 'unset' operation has various special cases within
            //       it; therefore, check for it first.
            //
            if (breakpointType == BreakpointType.BeforeVariableUnset)
            {
                if (indexes != null)
                {
                    result = String.Format(
                        "can't {0} {1}: operation not supported for {2}",
                        FormatOps.Breakpoint(breakpointType),
                        FormatOps.ErrorVariableName(
                            variable, null, name, index),
                            FormatOps.TypeName(typeof(Array)));

                    traceInfo.ReturnCode = ReturnCode.Error;
                }
                else
                {
                    //
                    // NOTE: They want to unset the entire array.  Also, make
                    //       sure it is purged from the call frame so that it
                    //       cannot be magically restored with this trace
                    //       callback in place.
                    //
                    traceInfo.Flags &= ~VariableFlags.NoRemove;

                    //
                    // BUGFIX: Yes, also make sure any waiters are cleared.
                    //
                    EntityOps.SetDirty(variable, true);

                    //
                    // NOTE: If we get this far, everything went fine.
                    //
                    traceInfo.ReturnCode = ReturnCode.Ok;
                }
            }
            else if (indexes != null)
            {
                //
                // NOTE: See if the old value represents a System.Array
                //       instance.  If not, this is an invalid linkage.
                //
                Array array = EntityOps.GetSystemArray(variable);

                if (array == null)
                {
                    result = String.Format(
                        "can't {0} {1}: not {2}",
                        FormatOps.Breakpoint(breakpointType),
                        FormatOps.ErrorVariableName(
                            variable, null, name, index),
                            FormatOps.TypeName(typeof(Array)));

                    return ReturnCode.Error;
                }

                ReturnCode code;

                switch (breakpointType)
                {
                    case BreakpointType.BeforeVariableGet:
                        {
                            object oldValue = null;

                            code = MarshalOps.GetArrayElementValue(
                                interpreter.InternalBinder,
                                interpreter.InternalCultureInfo,
                                array, indexes, ref oldValue, ref result);

                            if (code == ReturnCode.Ok)
                            {
                                code = MarshalOps.GetVariableValueAsString(
                                    interpreter, oldValue, true, ref result);

                                if (code == ReturnCode.Ok)
                                {
                                    oldValue = StringOps.GetStringFromObject(
                                        result);
                                }
                            }

                            if (code == ReturnCode.Ok)
                            {
                                SetTraceInfoForGetResult(
                                    traceInfo, code, oldValue);
                            }
                            else
                            {
                                traceInfo.ReturnCode = code;
                            }
                            break;
                        }
                    case BreakpointType.BeforeVariableSet:
                        {
                            object newValue = traceInfo.NewValue;

                            code = MarshalOps.SetArrayElementValue(
                                interpreter.InternalBinder,
                                interpreter.InternalCultureInfo,
                                array, indexes, newValue, ref result);

                            if (code == ReturnCode.Ok)
                            {
                                object oldValue = traceInfo.OldValue;

                                SetTraceInfoForSetResult(
                                    traceInfo, variable, oldValue,
                                    newValue, code, ref result);
                            }
                            else
                            {
                                traceInfo.ReturnCode = code;
                            }
                            break;
                        }
                }
            }
            else
            {
                result = String.Format(
                    "can't {0} {1}: variable is array",
                    FormatOps.Breakpoint(breakpointType),
                    FormatOps.ErrorVariableName(
                        variable, null, variable.Name, index));

                traceInfo.ReturnCode = ReturnCode.Error;
            }

            return traceInfo.ReturnCode;
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Database Variable Support
#if DATA
        private static bool HasDatabaseTraceCallback(
            IVariable variable,
            ref DatabaseVariable databaseVariable
            )
        {
            if (variable == null)
                return false;

            TraceList traces = variable.Traces;

            if (traces == null)
                return false;

            foreach (ITrace trace in traces)
            {
                if (trace == null)
                    continue;

                if (AppDomainOps.IsTransparentProxy(trace))
                    continue;

                TraceCallback callback = trace.Callback;

                if (callback == null)
                    continue;

                MethodInfo methodInfo = callback.Method;

                if (methodInfo == null)
                    continue;

                if (methodInfo.DeclaringType == typeof(DatabaseVariable))
                {
                    databaseVariable = callback.Target as DatabaseVariable;
                    return (databaseVariable != null);
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsDatabaseVariable(
            IVariable variable
            )
        {
            DatabaseVariable databaseVariable = null;

            return IsDatabaseVariable(variable, ref databaseVariable);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsDatabaseVariable(
            IVariable variable,
            ref DatabaseVariable databaseVariable
            )
        {
            return (variable != null) && !HasPendingTraces() &&
                HasDatabaseTraceCallback(variable, ref databaseVariable);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Network Variable Support
#if NETWORK && WEB
        private static bool HasNetworkTraceCallback(
            IVariable variable,
            ref NetworkVariable networkVariable
            )
        {
            if (variable == null)
                return false;

            TraceList traces = variable.Traces;

            if (traces == null)
                return false;

            foreach (ITrace trace in traces)
            {
                if (trace == null)
                    continue;

                if (AppDomainOps.IsTransparentProxy(trace))
                    continue;

                TraceCallback callback = trace.Callback;

                if (callback == null)
                    continue;

                MethodInfo methodInfo = callback.Method;

                if (methodInfo == null)
                    continue;

                if (methodInfo.DeclaringType == typeof(NetworkVariable))
                {
                    networkVariable = callback.Target as NetworkVariable;
                    return (networkVariable != null);
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsNetworkVariable(
            IVariable variable
            )
        {
            NetworkVariable networkVariable = null;

            return IsNetworkVariable(variable, ref networkVariable);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsNetworkVariable(
            IVariable variable,
            ref NetworkVariable networkVariable
            )
        {
            return (variable != null) && !HasPendingTraces() &&
                HasNetworkTraceCallback(variable, ref networkVariable);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Registry Variable Support
#if !NET_STANDARD_20 && WINDOWS
        private static bool HasRegistryTraceCallback(
            IVariable variable,
            ref RegistryVariable registryVariable
            )
        {
            if (variable == null)
                return false;

            TraceList traces = variable.Traces;

            if (traces == null)
                return false;

            foreach (ITrace trace in traces)
            {
                if (trace == null)
                    continue;

                if (AppDomainOps.IsTransparentProxy(trace))
                    continue;

                TraceCallback callback = trace.Callback;

                if (callback == null)
                    continue;

                MethodInfo methodInfo = callback.Method;

                if (methodInfo == null)
                    continue;

                if (methodInfo.DeclaringType == typeof(RegistryVariable))
                {
                    registryVariable = callback.Target as RegistryVariable;
                    return (registryVariable != null);
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsRegistryVariable(
            IVariable variable
            )
        {
            RegistryVariable registryVariable = null;

            return IsRegistryVariable(variable, ref registryVariable);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsRegistryVariable(
            IVariable variable,
            ref RegistryVariable registryVariable
            )
        {
            return (variable != null) && !HasPendingTraces() &&
                HasRegistryTraceCallback(variable, ref registryVariable);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Thread Variable Support
        private static bool HasThreadTraceCallback(
            IVariable variable,
            ref ThreadVariable threadVariable
            )
        {
            if (variable == null)
                return false;

            TraceList traces = variable.Traces;

            if (traces == null)
                return false;

            foreach (ITrace trace in traces)
            {
                if (trace == null)
                    continue;

                if (AppDomainOps.IsTransparentProxy(trace))
                    continue;

                TraceCallback callback = trace.Callback;

                if (callback == null)
                    continue;

                MethodInfo methodInfo = callback.Method;

                if (methodInfo == null)
                    continue;

                if (methodInfo.DeclaringType == typeof(ThreadVariable))
                {
                    threadVariable = callback.Target as ThreadVariable;
                    return (threadVariable != null);
                }
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsThreadVariable(
            IVariable variable
            )
        {
            ThreadVariable threadVariable = null;

            return IsThreadVariable(variable, ref threadVariable);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool IsThreadVariable(
            IVariable variable,
            ref ThreadVariable threadVariable
            )
        {
            return (variable != null) && !HasPendingTraces() &&
                HasThreadTraceCallback(variable, ref threadVariable);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode ResetThreadVariable(
            VariableFlags flags,
            string name,
            ref Result error
            )
        {
            lock (syncRoot) /* TRANSACTIONAL */
            {
                IVariable variable = null;

                if (GetVariableViaResolversWithSplit(
                        name, ref flags, ref variable,
                        ref error) == ReturnCode.Ok)
                {
                    ThreadVariable threadVariable = null;

                    if (IsThreadVariable(
                            variable, ref threadVariable))
                    {
                        /* IGNORED */
                        threadVariable.CleanupForAll();

                        return ReturnCode.Ok;
                    }
                    else
                    {
                        error = "variable is not per-thread";
                    }
                }

                return ReturnCode.Error;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region "First" Interpreter Support
        public static Interpreter GetFirst()
        {
            return GlobalState.GetFirstInterpreter();
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region "Active" Interpreter Support
        public static Interpreter GetAny() /* THREAD-SAFE */
        {
            Interpreter interpreter = GetActive();

            if (interpreter == null)
            {
                ReturnCode code;
                Result error = null;

                code = GlobalState.GetInterpreter(
                    LookupFlags.Interpreter, null, ref interpreter,
                    ref error);

                if (code != ReturnCode.Ok)
                {
                    TraceOps.DebugTrace(String.Format(
                        "GetAny: code = {0}, error = {1}",
                        code, FormatOps.WrapOrNull(error)),
                        typeof(Interpreter).Name,
                        TracePriority.InterpreterError);
                }
            }

            return interpreter;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static Interpreter GetActive() /* THREAD-SAFE */
        {
            IAnyPair<Interpreter, IClientData> anyPair = GetActivePair();
            return (anyPair != null) ? anyPair.X : null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static IAnyPair<Interpreter, IClientData> GetActivePair()
        {
            return GetActivePair(null);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal static IAnyPair<Interpreter, IClientData> GetActivePair(
            Type type
            )
        {
            return GlobalState.GetActiveInterpreter(type);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private int GetActiveCount(
            bool global
            )
        {
            if (global)
            {
                return Interlocked.CompareExchange(ref activeCount, 0, 0);
            }
            else
            {
                return GlobalState.CountActiveInterpreters(this);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int IncreaseActiveCount()
        {
            return Interlocked.Increment(ref activeCount);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int DecreaseActiveCount()
        {
            return Interlocked.Decrement(ref activeCount);
        }

        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Server Socket Support
#if NETWORK
        internal int ServerSockets
        {
            get { return serverSockets; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int EnterSocketThread()
        {
            return Interlocked.Increment(ref serverSockets);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal int ExitSocketThread()
        {
            return Interlocked.Decrement(ref serverSockets);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode StartServerSocket(
            OptionDictionary options,
            int? timeout,
            string address,
            string port,
            AddressFamily addressFamily,
            StreamFlags streamFlags,
            int? availableTimeout,
            bool exclusive,
            string text, /* command */
            ref Result result
            )
        {
            bool success = false;
            EventWaitHandle localEvent = null;
            Thread localThread = null;

            try
            {
                //
                // TODO: Maybe make this into a named event and then
                //       have the server socket thread open its own
                //       instance of it?
                //
                localEvent = ThreadOps.CreateEvent(false);

                SocketClientData clientData = new SocketClientData(
                    null, localEvent, this, options, address, port,
                    addressFamily, streamFlags, availableTimeout,
                    exclusive, text);

                int localTimeout = ThreadOps.GetTimeout(
                    this, timeout, TimeoutType.Start);

                localThread = Engine.CreateThread(
                    this, SocketOps.ServerThreadStart, 0,
                    true, false, true);

                if (localThread != null)
                {
                    localThread.Name = FormatOps.Id(String.Format(
                        "serverSocketThread: {0}",
                            FormatOps.InterpreterNoThrow(
                                this)), port, 0); /* throw */

                    localThread.Start(clientData); /* throw */

                    //
                    // HACK: For now, avoid ever using new overload(s)
                    //       of this method; otherwise, Mono crashes.
                    //
                    if (ThreadOps.WaitEvent(localEvent, localTimeout))
                    {
                        //
                        // NOTE: Upon success from the newly created
                        //       server socket thread return the code
                        //       "Ok" and the name of its associated
                        //       TcpListener channel; otherwise, upon
                        //       failure, return the code "Error" and
                        //       the associated error message.
                        //
                        result = clientData.Result;

                        if (clientData.ReturnCode == ReturnCode.Ok)
                        {
                            //
                            // NOTE: If (and only if) this point is
                            //       reached, we know that the server
                            //       socket thread is fully setup and
                            //       working (i.e. no need to shut it
                            //       down via interrupting it).
                            //
                            success = true;

                            return ReturnCode.Ok;
                        }
                    }
                    else
                    {
                        result = "timed out starting server thread";
                    }
                }
                else
                {
                    result = "could not create server thread";
                }
            }
            catch (Exception e)
            {
                result = e;
            }
            finally
            {
                if (!success && (localThread != null))
                {
                    try
                    {
                        localThread.Interrupt(); /* throw */
                        localThread = null;
                    }
                    catch (Exception e)
                    {
                        TraceOps.DebugTrace(
                            e, typeof(Interpreter).Name,
                            TracePriority.ThreadError);
                    }
                }

                ThreadOps.CloseEvent(ref localEvent);
            }

            return ReturnCode.Error;
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Host Integration Support
        internal string Complaint
        {
            get
            {
                // CheckDisposed(); /* EXEMPT */

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    return context.Complaint;
                else
                    return null;
#else
                lock (syncRoot)
                {
                    return complaint;
                }
#endif
            }
            set
            {
                // CheckDisposed(); /* EXEMPT */

#if THREADING
                IEngineContext context = GetEngineContext();

                if (context != null)
                    context.Complaint = value;
#else
                lock (syncRoot)
                {
                    complaint = value;
                }
#endif
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode CanExit(
            ExitCode exitCode,
            bool force,
            bool fail,
            string message,
            ref Result error
            )
        {
            ReturnCode code = ReturnCode.Ok;
            IProcessHost processHost = InternalHost;

            if (processHost != null)
            {
                try
                {
                    if (FlagOps.HasFlags(
                            processHost.GetHostFlags(), HostFlags.Exit, true))
                    {
                        if (processHost.Exiting)
                        {
                            error = "interpreter host is already exiting";
                            code = ReturnCode.Error;
                        }
                        else if (!processHost.CanExit)
                        {
                            error = "exit denied by interpreter host";
                            code = ReturnCode.Error;
                        }
                        else if (force && !processHost.CanForceExit)
                        {
                            error = "force exit denied by interpreter host";
                            code = ReturnCode.Error;
                        }
                    }
                }
                catch (Exception e)
                {
                    //
                    // TODO: Should this simply allow the exit to take place?
                    //
                    error = e;
                    code = ReturnCode.Error;
                }
            }

            TraceOps.DebugTrace(String.Format(
                "CanExit: returning, exitCode = {0}, force = {1}, " +
                "fail = {2}, message = {3}, code = {4}, error = {5}",
                exitCode, force, fail, FormatOps.WrapOrNull(true, true,
                message), code, FormatOps.WrapOrNull(true, true, error)),
                typeof(Interpreter).Name, TracePriority.HostDebug);

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetStream( /* FOR USE BY Engine.OpenScriptStream METHOD */
            string path,
            FileMode mode,
            FileAccess access,
            ref HostStreamFlags hostStreamFlags,
            ref string fullPath,
            ref Stream stream,
            ref Result error
            )
        {
            return GetStream(
                path, mode, access, FileShare.Read,
                ChannelOps.DefaultBufferSize, FileOptions.None,
                true, ref hostStreamFlags, ref fullPath, ref stream,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode GetStream( /* FOR USE BY [open] COMMAND */
            string path,
            FileMode mode,
            FileAccess access,
            FileShare share,
            int bufferSize,
            FileOptions options,
            bool strict,
            ref HostStreamFlags hostStreamFlags,
            ref Stream stream,
            ref Result error
            )
        {
            string fullPath = null;

            return GetStream(
                path, mode, access, share, bufferSize, options,
                strict, ref hostStreamFlags, ref fullPath, ref stream,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode GetStream(
            string path,
            FileMode mode,
            FileAccess access,
            FileShare share,
            int bufferSize,
            FileOptions options,
            bool strict,
            ref HostStreamFlags hostStreamFlags,
            ref string fullPath,
            ref Stream stream,
            ref Result error
            )
        {
            IFileSystemHost fileSystemHost = InternalHost;

            return HostOps.GetStream(
                this, fileSystemHost, path, mode, access, share, bufferSize,
                options, strict, ref hostStreamFlags, ref fullPath, ref stream,
                ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void GetHostColors(
            IColorHost colorHost,
            string name,
            bool strict,
            ref ConsoleColor foregroundColor,
            ref ConsoleColor backgroundColor
            )
        {
            ReturnCode code;
            Result error = null;

            code = HostOps.GetColors(
                colorHost, name, true, true, strict, ref foregroundColor,
                ref backgroundColor, ref error);

            if (code != ReturnCode.Ok)
            {
#if DEBUG && VERBOSE
                DebugOps.Complain(this, code, error);
#endif

                foregroundColor = defaultForegroundColor;
                backgroundColor = defaultBackgroundColor;
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Disposal Helper Methods (Terminate/Dispose)
        #region Tcl Disposal
#if NATIVE && TCL
        private bool IsTransferFromTclAllowed()
        {
            if (InternalIsSafe())
                return false;

            if (FlagOps.HasFlags(
                    createFlags, CreateFlags.NoTclTransfer, true))
            {
                return false;
            }

            return true;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool DoesTclNeedDispose(
            ref ResultList errors
            )
        {
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (tclApi != null)
                {
                    if (errors == null)
                        errors = new ResultList();

                    errors.Add("may leak Tcl API object");
                }

                if ((tclInterps != null) && (tclInterps.Count > 0))
                {
                    if (errors == null)
                        errors = new ResultList();

                    errors.Add(String.Format(
                        "may leak {0} Tcl interpreters: {1}",
                        tclInterps.Count, tclInterps));
                }

#if TCL_THREADS
                if ((tclThreads != null) && (tclThreads.Count > 0))
                {
                    if (errors == null)
                        errors = new ResultList();

                    errors.Add(String.Format(
                        "may leak {0} Tcl threads: {1}",
                        tclThreads.Count, tclThreads));
                }
#endif

                if ((tclBridges != null) && (tclBridges.Count > 0))
                {
                    if (errors == null)
                        errors = new ResultList();

                    errors.Add(String.Format(
                        "may leak {0} Tcl bridges: {1}",
                        tclBridges.Count, tclBridges));
                }

                //
                // BUGFIX: Only generate this error message if the thread is
                //         actually wrong (i.e. not the primary thread for this
                //         interpreter).
                //
                if ((errors != null) && (errors.Count > 0) && !IsTclThread())
                {
                    errors.Insert(0, String.Format(
                        "interpreter {0} from thread {1} is being " +
                        "disposed on [the wrong] native thread {2}",
                        FormatOps.InterpreterNoThrow(this),
                        GetTclThreadId(),
                        GlobalState.GetCurrentNativeThreadId()));
                }
            }

            return ((errors != null) && (errors.Count > 0));
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeInitializeTclPurgatory()
        {
            #region Static Lock Held
            lock (staticSyncRoot) /* TRANSACTIONAL */
            {
                lock (tclSyncRoot) /* TRANSACTIONAL */
                {
                    if (deadTclInterps == null)
                        deadTclInterps = new IntPtrDictionary();

#if TCL_THREADS
                    if (deadTclThreads == null)
                        deadTclThreads = new TclThreadDictionary();
#endif

                    if (deadTclBridges == null)
                        deadTclBridges = new TclBridgeDictionary();
                }
            }
            #endregion
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeEmitTclPurgatoryResults(
            ResultList results /* in */
            )
        {
            if ((results != null) && (results.Count > 0))
            {
                results.Insert(0, String.Format(
                    "interpreter {0} from thread {1}",
                    FormatOps.InterpreterNoThrow(this),
                    threadId)); /* NO-LOCK */

                TraceOps.DebugTrace(
                    (Result)results, typeof(Interpreter).Name,
                    TracePriority.NativeDebug);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeTransferFromTclPurgatory(
            ref ResultList results /* in, out */
            )
        {
            #region Static Lock Held
            //
            // NOTE: If this thread (i.e. the primary thread for the interpreter
            //       being created) is the same as the thread for the dead Tcl
            //       objects in the global cache, transfer them to us now.  This
            //       is never done for nested interpreters (i.e. those created
            //       via the [interp create] sub-command) -OR- any interpreter
            //       created with the "safe" flag.
            //
            lock (staticSyncRoot) /* TRANSACTIONAL */
            {
                lock (tclSyncRoot) /* TRANSACTIONAL */
                {
                    if ((deadTclThreadId == 0) || IsTclThread(deadTclThreadId))
                    {
                        if (deadTclThreadId != 0)
                            deadTclThreadId = 0;

                        ///////////////////////////////////////////////////////

                        if (deadTclApi != null)
                        {
                            if (tclApi != null)
                            {
                                if (results == null)
                                    results = new ResultList();

                                results.Add(String.Format(
                                    "leaking Tcl API object from interpreter: {0}",
                                    tclApi));
                            }

                            tclApi = deadTclApi;
                            deadTclApi = null;

                            if (results == null)
                                results = new ResultList();

                            results.Add(
                                "recovered Tcl API object from purgatory");
                        }

                        ///////////////////////////////////////////////////////

                        if (deadTclInterps != null)
                        {
                            if (tclInterps != null)
                            {
                                IntPtrDictionary leakedTclInterps = null;

                                tclInterps.MaybeAdd(
                                    deadTclInterps, ref leakedTclInterps);

                                if (deadTclInterps.Count > 0)
                                {
                                    if (results == null)
                                        results = new ResultList();

                                    results.Add(String.Format(
                                        "recovered {0} Tcl interpreters from purgatory: {1}",
                                        deadTclInterps.Count, FormatOps.DisplayKeys(
                                        deadTclInterps)));
                                }

                                if (leakedTclInterps != null)
                                {
                                    if (results == null)
                                        results = new ResultList();

                                    results.Add(String.Format(
                                        "duplicate {0} Tcl interpreters from purgatory: {1}",
                                        leakedTclInterps.Count, FormatOps.DisplayKeys(
                                        leakedTclInterps)));
                                }
                            }
                            else
                            {
                                if (results == null)
                                    results = new ResultList();

                                results.Add(String.Format(
                                    "leaking {0} Tcl interpreters from purgatory: {1}",
                                    deadTclInterps.Count, FormatOps.DisplayKeys(
                                    deadTclInterps)));
                            }

                            deadTclInterps.Clear();
                            deadTclInterps = null;
                        }

                        ///////////////////////////////////////////////////////

#if TCL_THREADS
                        if (deadTclThreads != null)
                        {
                            if (tclThreads != null)
                            {
                                TclThreadDictionary leakedTclThreads = null;

                                tclThreads.MaybeAdd(
                                    deadTclThreads, ref leakedTclThreads);

                                if (deadTclThreads.Count > 0)
                                {
                                    if (results == null)
                                        results = new ResultList();

                                    results.Add(String.Format(
                                        "recovered {0} Tcl threads from purgatory: {1}",
                                        deadTclThreads.Count, FormatOps.DisplayKeys(
                                        deadTclThreads)));
                                }

                                if (leakedTclThreads != null)
                                {
                                    if (results == null)
                                        results = new ResultList();

                                    results.Add(String.Format(
                                        "duplicate {0} Tcl threads from purgatory: {1}",
                                        leakedTclThreads.Count, FormatOps.DisplayKeys(
                                        leakedTclThreads)));
                                }
                            }
                            else
                            {
                                if (results == null)
                                    results = new ResultList();

                                results.Add(String.Format(
                                    "leaking {0} Tcl threads from purgatory: {1}",
                                    deadTclThreads.Count, FormatOps.DisplayKeys(
                                    deadTclThreads)));
                            }

                            deadTclThreads.Clear();
                            deadTclThreads = null;
                        }
#endif

                        ///////////////////////////////////////////////////////

                        if (deadTclBridges != null)
                        {
                            if (tclBridges != null)
                            {
                                TclBridgeDictionary leakedTclBridges = null;

                                tclBridges.MaybeAdd(
                                    deadTclBridges, ref leakedTclBridges);

                                if (deadTclBridges.Count > 0)
                                {
                                    if (results == null)
                                        results = new ResultList();

                                    results.Add(String.Format(
                                        "recovered {0} Tcl bridges from purgatory: {1}",
                                        deadTclBridges.Count, FormatOps.DisplayKeys(
                                        deadTclBridges)));
                                }

                                if (leakedTclBridges != null)
                                {
                                    if (results == null)
                                        results = new ResultList();

                                    results.Add(String.Format(
                                        "duplicate {0} Tcl bridges from purgatory: {1}",
                                        leakedTclBridges.Count, FormatOps.DisplayKeys(
                                        leakedTclBridges)));
                                }
                            }
                            else
                            {
                                if (results == null)
                                    results = new ResultList();

                                results.Add(String.Format(
                                    "leaking {0} Tcl bridges from purgatory: {1}",
                                    deadTclBridges.Count, FormatOps.DisplayKeys(
                                    deadTclBridges)));
                            }

                            deadTclBridges.Clear();
                            deadTclBridges = null;
                        }
                    }
                }
            }
            #endregion
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeTransferFromTclPurgatory()
        {
            if (IsTransferFromTclAllowed())
            {
                ResultList tclTransferResults = null;

                MaybeTransferFromTclPurgatory(ref tclTransferResults);
                MaybeEmitTclPurgatoryResults(tclTransferResults);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeTransferToTclPurgatory(
            ref ResultList results /* in, out */
            )
        {
            //
            // NOTE: Check if we can add all the Tcl related objects that
            //       would otherwise leak to the global (static) cache for
            //       later disposal on the correct thread.
            //
            #region Static Lock Held
            lock (staticSyncRoot) /* TRANSACTIONAL */
            {
                lock (tclSyncRoot) /* TRANSACTIONAL */
                {
                    if ((deadTclThreadId == 0) || IsTclThread(deadTclThreadId))
                    {
                        if (deadTclThreadId == 0)
                            deadTclThreadId = GetTclThreadId();

                        ///////////////////////////////////////////////////////

                        if (tclApi != null)
                        {
                            if (deadTclApi == null)
                            {
                                deadTclApi = tclApi;

                                if (results == null)
                                    results = new ResultList();

                                results.Add(
                                    "sent Tcl API object to purgatory");
                            }
                            else
                            {
                                results.Add(String.Format(
                                    "leaking Tcl API object from interpreter: {0}",
                                    tclApi));
                            }

                            tclApi = null;
                        }

                        ///////////////////////////////////////////////////////

                        if (tclInterps != null)
                        {
                            if (deadTclInterps != null)
                            {
                                IntPtrDictionary leakedTclInterps = null;

                                deadTclInterps.MaybeAdd(
                                    tclInterps, ref leakedTclInterps);

                                if (tclInterps.Count > 0)
                                {
                                    if (results == null)
                                        results = new ResultList();

                                    results.Add(String.Format(
                                        "sent {0} Tcl interpreters to purgatory: {1}",
                                        tclInterps.Count, FormatOps.DisplayKeys(
                                        tclInterps)));
                                }

                                if (leakedTclInterps != null)
                                {
                                    if (results == null)
                                        results = new ResultList();

                                    results.Add(String.Format(
                                        "duplicate {0} Tcl interpreters from interpreter: {1}",
                                        leakedTclInterps.Count, FormatOps.DisplayKeys(
                                        leakedTclInterps)));
                                }
                            }
                            else
                            {
                                if (results == null)
                                    results = new ResultList();

                                results.Add(String.Format(
                                    "leaking {0} Tcl interpreters from interpreter: {1}",
                                    tclInterps.Count, FormatOps.DisplayKeys(
                                    tclInterps)));
                            }

                            tclInterps.Clear();
                            tclInterps = null;
                        }

                        ///////////////////////////////////////////////////////

#if TCL_THREADS
                        if (tclThreads != null)
                        {
                            if (deadTclThreads != null)
                            {
                                TclThreadDictionary leakedTclThreads = null;

                                deadTclThreads.MaybeAdd(
                                    tclThreads, ref leakedTclThreads);

                                if (tclThreads.Count > 0)
                                {
                                    if (results == null)
                                        results = new ResultList();

                                    results.Add(String.Format(
                                        "sent {0} Tcl threads to purgatory: {1}",
                                        tclThreads.Count, FormatOps.DisplayKeys(
                                        tclThreads)));
                                }

                                if (leakedTclThreads != null)
                                {
                                    if (results == null)
                                        results = new ResultList();

                                    results.Add(String.Format(
                                        "duplicate {0} Tcl threads from interpreter: {1}",
                                        leakedTclThreads.Count, FormatOps.DisplayKeys(
                                        leakedTclThreads)));
                                }
                            }
                            else
                            {
                                if (results == null)
                                    results = new ResultList();

                                results.Add(String.Format(
                                    "leaking {0} Tcl threads from interpreter: {1}",
                                    tclThreads.Count, FormatOps.DisplayKeys(
                                    tclThreads)));
                            }

                            tclThreads.Clear();
                            tclThreads = null;
                        }
#endif

                        ///////////////////////////////////////////////////////

                        if (tclBridges != null)
                        {
                            if (deadTclBridges != null)
                            {
                                TclBridgeDictionary leakedTclBridges = null;

                                deadTclBridges.MaybeAdd(
                                    tclBridges, ref leakedTclBridges);

                                if (tclBridges.Count > 0)
                                {
                                    if (results == null)
                                        results = new ResultList();

                                    results.Add(String.Format(
                                        "sent {0} Tcl bridges to purgatory: {1}",
                                        tclBridges.Count, FormatOps.DisplayKeys(
                                        tclBridges)));
                                }

                                if (leakedTclBridges != null)
                                {
                                    if (results == null)
                                        results = new ResultList();

                                    results.Add(String.Format(
                                        "duplicate {0} Tcl bridges from interpreter: {1}",
                                        leakedTclBridges.Count, FormatOps.DisplayKeys(
                                        leakedTclBridges)));
                                }
                            }
                            else
                            {
                                if (results == null)
                                    results = new ResultList();

                                results.Add(String.Format(
                                    "leaking {0} Tcl bridges from interpreter: {1}",
                                    tclBridges.Count, FormatOps.DisplayKeys(
                                    tclBridges)));
                            }

                            tclBridges.Clear();
                            tclBridges = null;
                        }
                    }
                }
            }
            #endregion
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void MaybeTransferToTclPurgatory()
        {
            ResultList tclTransferResults = null;

            MaybeTransferToTclPurgatory(ref tclTransferResults);
            MaybeEmitTclPurgatoryResults(tclTransferResults);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeTcl(
            bool dispose,
            bool disposing,
            bool disconnect
            ) /* WARNING: For use by Dispose(bool) only. */
        {
            //
            // HACK: Take this opportunity to see if we can dispose of any
            //       native Tcl resources that may have affinity to this
            //       thread, e.g. created within a different interpreter.
            //
            MaybeTransferFromTclPurgatory();

            ///////////////////////////////////////////////////////////////////

            ResultList errors = null;

            if (!DoesTclNeedDispose(ref errors))
                return;

            ReturnCode code;
            Result error = null;

            //
            // NOTE: Attempt to dispose our Tcl related stuff now.
            //
            code = DisposeTcl(dispose, disposing, disconnect, ref error);

            if (code == ReturnCode.Ok)
                return;

            //
            // NOTE: If we fail for any reason (including thread affinity)
            //       report the error message itself and the objects that
            //       may be leaked.  Also, see if we can transfer the now
            //       "dead" Tcl related objects that  require cleanup to
            //       the global (static) cache for later transfer to an
            //       interpreter created on the appropriate thread (which,
            //       at least in theory, has a greater than zero chance of
            //       properly calling Dispose on the correct thread?).
            //
            if (errors == null)
                errors = new ResultList();

            errors.Insert(0, error);
            error = errors;

            DebugOps.Complain(this, code, error);

            ///////////////////////////////////////////////////////////////////

            //
            // NOTE: If there is any leftover Tcl entities, e.g. interps,
            //       threads, bridges, etc, perhaps transfer them to the
            //       dedicated lists of "dead" Tcl entities for possible
            //       later cleanup on this thread.
            //
            MaybeTransferToTclPurgatory();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DisposeTcl(
            bool dispose,
            bool disposing, /* NOT USED */
            bool disconnect,
            ref Result error
            )
        {
            ReturnCode code;

            if (IsTclThread())
            {
                //
                // NOTE: Dispose of all TclBridge objects we own now.
                //
                code = DisposeTclBridges(
                    IntPtr.Zero, null, false, dispose, ref error);

                if (code != ReturnCode.Ok)
                {
                    if (dispose)
                    {
                        //
                        // NOTE: We are being called from dispose, not much we
                        //       can really do here.  Attempt to show the error
                        //       to the user.
                        //
                        DebugOps.Complain(this, code, error);

                        //
                        // NOTE: Next, reset the return code here so that we
                        //       can continue to dispose Tcl resources.
                        //
                        code = ReturnCode.Ok;
                    }
                    else
                    {
                        //
                        // NOTE: We are not being called from Dispose, bail out
                        //       now with the error.
                        //
                        return code;
                    }
                }

                ///////////////////////////////////////////////////////////////

#if TCL_THREADS
                code = DisposeTclThreads(
                    dispose, disposing, disconnect, ref error);

                if (code != ReturnCode.Ok)
                    return code;
#endif

                ///////////////////////////////////////////////////////////////

                code = DisposeTclInterpreters(dispose, disconnect, ref error);

                if (code != ReturnCode.Ok)
                    return code;

                ///////////////////////////////////////////////////////////////

                code = DisposeTclApi(dispose, disconnect, ref error);

                if (code != ReturnCode.Ok)
                    return code;
            }
            else
            {
                error = "cannot dispose Tcl, wrong thread";
                code = ReturnCode.Error;
            }

            return code;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private StringList FilterTclBridges(
            IntPtr interp,
            IExecute execute,
            bool? fromThread
            )
        {
            StringList keys = new StringList();

            //
            // NOTE: Cleanup, PASS #1, collect the list of keys we need to remove
            //       from the TclBridges collection in the containing interpreter.
            //
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (tclBridges != null)
                {
                    foreach (KeyValuePair<string, TclBridge> pair in tclBridges)
                    {
                        TclBridge value = pair.Value;

                        if (value == null)
                            continue;

                        if ((interp != IntPtr.Zero) && !value.InternalMatch(interp))
                            continue;

                        if ((execute != null) && !value.InternalMatch(execute))
                            continue;

                        if ((fromThread != null) && !value.InternalMatch(fromThread))
                            continue;

                        keys.Add(pair.Key);
                    }
                }
            }

            return keys;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal TclBridgeDictionary GetTclBridges(
            IntPtr interp,
            IExecute execute,
            bool? fromThread
            )
        {
            TclBridgeDictionary result = null;

            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                if (tclBridges != null)
                {
                    result = new TclBridgeDictionary();

                    foreach (string key in
                            FilterTclBridges(interp, execute, fromThread))
                    {
                        result.Add(key, tclBridges[key]);
                    }
                }
            }

            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: Assumes the "tclSyncRoot" lock is already held by the caller.
        //
        private ReturnCode PrivateDisposeTclBridges(
            StringList keys,
            bool dispose,
            ref Result error
            )
        {
            //
            // NOTE: Cleanup, PASS #2, dispose and remove all the TclBridge
            //       objects we found from PASS #1 (above).
            //
            if (tclBridges != null)
            {
                foreach (string key in keys)
                {
                    TclBridge tclBridge = tclBridges[key];

                    if (tclBridge != null)
                    {
                        try
                        {
                            tclBridge.Dispose(); /* throw */
                            tclBridge = null;
                        }
                        catch (Exception e)
                        {
                            error = String.Format(
                                "caught exception while disposing Tcl bridge: {0}",
                                e);

                            return ReturnCode.Error;
                        }
                    }

                    tclBridges.Remove(key);
                }

                //
                // NOTE: Upon dispose, destroy the collection itself so that it
                //       cannot be used again.
                //
                if (dispose && (tclBridges.Count == 0))
                    tclBridges = null;
            }

            return ReturnCode.Ok;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal ReturnCode DisposeTclBridges(
            IntPtr interp,
            IExecute execute,
            bool? fromThread,
            bool dispose,
            ref Result error
            )
        {
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                GlobalState.PushActiveInterpreter(this);

                try
                {
                    if (tclBridges == null)
                        return ReturnCode.Ok;

                    return PrivateDisposeTclBridges(
                        FilterTclBridges(interp, execute, fromThread),
                        dispose, ref error);
                }
                catch (Exception e)
                {
                    error = e;

                    return ReturnCode.Error;
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DisposeTclApi(
            bool dispose,
            bool disconnect,
            ref Result error
            )
        {
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                GlobalState.PushActiveInterpreter(this);

                try
                {
                    //
                    // NOTE: Only mess with the Tcl API object if we are being
                    //       called by our Dispose or the Dispose of the Tcl
                    //       API object itself; otherwise, the cleanup will be
                    //       handled externally.
                    //
                    if (disconnect || dispose)
                    {
                        //
                        // NOTE: Terminate the link with the Tcl API now.
                        //
                        // BUGBUG: This needs to be reworked at some point when
                        //         Dispose is modified to be capable of failing.
                        //
                        if (tclApi != null)
                        {
                            try
                            {
                                if (dispose
#if NATIVE_PACKAGE
                                    && !NativePackage.IsTclInterpreterActive()
#endif
                                    )
                                {
                                    //
                                    // BUGFIX: If we are being explicitly
                                    //         disposed, we need to make
                                    //         sure the actual Tcl library
                                    //         gets unloaded (or at least
                                    //         has its internal reference
                                    //         count decreased in the event
                                    //         it is being used by other
                                    //         Eagle interpreters or random
                                    //         external code).
                                    //
                                    return TclWrapper.Unload(
                                        this, UnloadFlags.Default, ref tclApi,
                                        ref error);
                                }
                                else
                                {
                                    //
                                    // NOTE: Just clear out our Tcl API
                                    //       object reference because we
                                    //       are [already] being called by
                                    //       its Dispose method.
                                    //
                                    tclApi = null;

                                    //
                                    // NOTE: Yes, indicate success to our
                                    //       caller, even though nothing
                                    //       much was actually done.
                                    //
                                    return ReturnCode.Ok;
                                }
                            }
                            catch (Exception e)
                            {
                                error = e;
                            }

                            return ReturnCode.Error;
                        }
                    }

                    return ReturnCode.Ok;
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private ReturnCode DisposeTclInterpreters(
            bool dispose,
            bool disconnect,
            ref Result error
            )
        {
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                GlobalState.PushActiveInterpreter(this);

                try
                {
                    //
                    // NOTE: Attempt to delete all the Tcl interps we own
                    //       now.
                    //
                    if (tclInterps != null)
                    {
                        StringList keys = new StringList(tclInterps.Keys);

                        foreach (string key in keys)
                        {
                            IntPtr interp = tclInterps[key];

                            if (interp == IntPtr.Zero)
                                continue;

                            //
                            // BUGFIX: If we are being called by the exit
                            //         handler, "force" the deletion of the
                            //         interpreter.  Tcl should not actually
                            //         free the underlying memory until the
                            //         stack is unwound.
                            //
                            ReturnCode code;

#if NATIVE_PACKAGE
                            if (NativePackage.ShouldDeleteTclInterpreter(
                                    key, interp))
#endif
                            {
                                code = TclWrapper.DeleteInterpreter(
                                    tclApi, disconnect, ref interp,
                                    ref error);
                            }
#if NATIVE_PACKAGE
                            else
                            {
                                code = ReturnCode.Ok;
                            }
#endif

                            if (code == ReturnCode.Ok)
                            {
                                //
                                // NOTE: The Tcl interpreter has been
                                //       deleted, remove it from our
                                //       collection.
                                //
                                tclInterps.Remove(key);
                            }
                            else
                            {
                                if (dispose)
                                {
                                    //
                                    // NOTE: We are being called from
                                    //       dispose, not much we can
                                    //       really do here.  Attempt to
                                    //       show the error to the user.
                                    //
                                    DebugOps.Complain(this, code, error);
                                }
                                else
                                {
                                    //
                                    // NOTE: We are not being called from
                                    //       Dispose, bail out now with the
                                    //       error.
                                    //
                                    return code;
                                }
                            }
                        }

                        //
                        // NOTE: Upon dispose, destroy the collection itself
                        //       so that it cannot be used again.
                        //
                        // BUGBUG: This needs to be reworked at some point
                        //         when Dispose is modified to be capable
                        //         of "failing".
                        //
                        if (dispose)
                        {
                            tclInterps.Clear();
                            tclInterps = null;
                        }
                    }

                    return ReturnCode.Ok;
                }
                finally
                {
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TCL_THREADS
        private ReturnCode DisposeTclThreads(
            bool dispose,
            bool disposing,
            bool disconnect,
            ref Result error
            )
        {
            //
            // NOTE: Attempt to shutdown all the Tcl threads we own now.
            //
            ITclApi tclApi;
            TclThreadDictionary localTclThreads = null;

            //
            // BUGFIX: Avoid holding the Tcl state lock while shutting
            //         down the Tcl threads.
            //
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                tclApi = this.tclApi;

                if (tclThreads != null)
                    localTclThreads = new TclThreadDictionary(tclThreads);
            }

            if (localTclThreads == null)
                return ReturnCode.Ok;

            GlobalState.PushActiveInterpreter(this);

            try
            {
                foreach (KeyValuePair<string, TclThread> pair
                        in localTclThreads)
                {
                    TclThread thread = pair.Value;

                    if (thread == null)
                        continue;

                    //
                    // NOTE: If we are being called by the exit handler,
                    //       "force" the shutdown of the thread.
                    //
                    ReturnCode code;

                    try
                    {
                        code = thread.Shutdown(
                            tclApi, GetTclBridges(thread.Interp, null, null),
                            true, disconnect, false, ref error);
                    }
                    catch (Exception e)
                    {
                        error = e;
                        code = ReturnCode.Error;
                    }

                    if (code != ReturnCode.Ok)
                    {
                        if (dispose)
                        {
                            //
                            // NOTE: We are being called from Dispose,
                            //       not much we can really do here.
                            //       Attempt to show the error to the
                            //       user.
                            //
                            DebugOps.Complain(this, code, error);
                        }
                        else
                        {
                            //
                            // NOTE: We are not being called from
                            //       Dispose, bail out now with the
                            //       error.
                            //
                            return code;
                        }
                    }
                }
            }
            finally
            {
                /* IGNORED */
                GlobalState.PopActiveInterpreter();
            }

            //
            // NOTE: Re-sync the collections of Tcl bridges and threads
            //       now.
            //
            lock (tclSyncRoot) /* TRANSACTIONAL */
            {
                //
                // NOTE: Remove all the Tcl bridges that have been
                //       cleaned up because due to being associated
                //       with the Tcl threads being disposed.
                //
                if (tclBridges != null)
                {
                    StringList keys = new StringList(tclBridges.Keys);

                    foreach (string key in keys)
                    {
                        TclBridge tclBridge = tclBridges[key];

                        if ((tclBridge != null) &&
                            tclBridge.InternalMatch(true))
                        {
                            tclBridges.Remove(key);
                        }
                    }
                }

                //
                // BUGBUG: This needs to be reworked at some point when
                //         Dispose is modified to be capable of failing.
                //
                if (dispose)
                {
                    //
                    // NOTE: Upon dispose, destroy the collection
                    //       itself so that it cannot be used again.
                    //
                    tclThreads.Clear();
                    tclThreads = null;
                }
                else
                {
                    //
                    // NOTE: Remove all the Tcl threads that should
                    //       have been disposed by the loop above.
                    //
                    foreach (string key in localTclThreads.Keys)
                        tclThreads.Remove(key);
                }
            }

            return ReturnCode.Ok;
        }
#endif
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Callback Disposal
        private void DisposeCallbacks()
        {
            if (callbacks == null)
                return;

            StringList keys = new StringList(callbacks.Keys);

            foreach (string key in keys)
            {
                ICallback callback = callbacks[key];

                if (callback == null)
                {
                    callbacks.Remove(key);
                    continue;
                }

                string callbackName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    callbackName = EntityOps.GetNameNoThrow(
                        callback);

                    code = ObjectOps.TryDispose<ICallback>(
                        ref callback, ref error);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Callback successfully disposed, remove it.
                        //
                        callbacks.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing callback {0}: {1}",
                        FormatOps.WrapOrNull(callbackName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Callback Queue Disposal
#if CALLBACK_QUEUE
        private void DisposeCallbackQueue()
        {
            if (callbackQueue == null)
                return;

            while (true)
            {
                if (callbackQueue.Count == 0)
                    break;

                ICallback callback = callbackQueue.Dequeue();

                if (callback == null)
                    continue;

                string callbackName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    callbackName = EntityOps.GetNameNoThrow(
                        callback);

                    code = ObjectOps.TryDispose<ICallback>(
                        ref callback, ref error);
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing queued callback {0}: {1}",
                        FormatOps.WrapOrNull(callbackName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Callstack Disposal
#if !THREADING
        private void DisposeCallStack(
            ref CallStack callStack
            )
        {
            if (callStack != null)
            {
                ReturnCode code;
                Result error = null;

                try
                {
                    code = ObjectOps.TryDispose<CallStack>(
                        ref callStack, ref error);
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing call stack: {0}",
                        e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);

                callStack = null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeCallFrame(
            ref ICallFrame frame
            )
        {
            if (frame != null)
            {
                ReturnCode code;
                Result error = null;

                try
                {
                    code = ObjectOps.TryDispose<ICallFrame>(
                        ref frame, ref error);
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing call frame: {0}",
                        e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);

                frame = null;
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Thread Data Disposal
#if THREADING
        private int SumOfAllContextCounts()
        {
            int count = 0;

            if (contextManager != null)
            {
                count += contextManager.GetEngineContextCount();
                count += contextManager.GetInteractiveContextCount();
                count += contextManager.GetTestContextCount();
                count += contextManager.GetVariableContextCount();
            }

            return count;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool MaybeDisposeThread()
        {
            bool nonPrimary = !IsPrimarySystemThread();
            bool isActive = GlobalState.IsActiveInterpreter(this);

#if THREADING
            Interlocked.Exchange(
                ref preDisposeContextCount, SumOfAllContextCounts());

            //
            // BUGBUG: This is not 100% failsafe.  It is possible that
            //         some contexts will be removed for a thread that
            //         is not actually being exited.  Generally, this
            //         will happen via the CommandCallback class when
            //         a [Parameterized]ThreadStart or generic delegate
            //         is used for something that is not really a new
            //         thread.  This should be relatively rare because
            //         of the IsPrimarySystemThread check (above).  The
            //         check is not entirely related; however, it is a
            //         relatively good indicator.
            //
            int count = ContextManager.Purge(this, nonPrimary, false);
#endif

            if (!isActive && nonPrimary)
                DisposeThread(false, false);

#if THREADING
            Interlocked.Exchange(
                ref postDisposeContextCount, SumOfAllContextCounts());

            return (!isActive && nonPrimary) || (count > 0);
#else
            return (!isActive && nonPrimary);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Context Information with Threading Disabled
#if !THREADING
        private void DisposeNonThreadedContexts(
            bool dispose,
            bool disposing, /* NOT USED */
            bool isStoppingSoon /* NOT USED */
            )
        {
            //
            // NOTE: Dispose all per-interpreter data (for all threads).
            //       We do this here, rather than in Dispose, in order
            //       to "centralize" the logic that handles data that
            //       is per-thread in "threading" enabled builds.
            //
            TraceOps.DebugTrace(String.Format(
                "DisposeNonThreadedContexts: interpreter = {0}, " +
                "dispose = {1}, disposing = {2}, isStoppingSoon = {3}",
                id, dispose, disposing, isStoppingSoon),
                typeof(Interpreter).Name, TracePriority.CleanupDebug);

            if (dispose)
            {
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    #region Engine Context
                    cancel = false;
                    unwind = false;
                    halt = false;

                    cancelResult = null;
                    haltResult = null;
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Engine Context (Non-Threaded Only)
                    contextClientData = null;

                    levels = 0;
                    maximumLevels = 0;

                    scriptLevels = 0;
                    maximumScriptLevels = 0;

                    parserLevels = 0;
                    maximumParserLevels = 0;

                    expressionLevels = 0;
                    entryExpressionLevels = 0;
                    maximumExpressionLevels = 0;

                    previousLevels = 0;
                    catchLevels = 0;
                    unknownLevels = 0;
                    traceLevels = 0;
                    subCommandLevels = 0;
                    settingLevels = 0;
                    packageLevels = 0;

                    ///////////////////////////////////////////////////////////

#if ARGUMENT_CACHE
                    cacheArgument = null;
#endif

                    ///////////////////////////////////////////////////////////

#if DEBUGGER
                    watchpointLevels = 0;
#endif

                    ///////////////////////////////////////////////////////////

#if SHELL
                    previewArgumentCallback = null;
                    unknownArgumentCallback = null;
                    evaluateScriptCallback = null;
                    evaluateFileCallback = null;
                    evaluateEncodedFileCallback = null;
#endif

                    ///////////////////////////////////////////////////////////

#if DEBUGGER
                    interactiveLoopCallback = null;
#endif

                    ///////////////////////////////////////////////////////////

#if NOTIFY || NOTIFY_OBJECT
                    notifyLevels = 0;
                    notifyTypes = NotifyType.None;
                    notifyFlags = NotifyFlags.None;
#endif

                    ///////////////////////////////////////////////////////////

                    securityLevels = 0;
                    policyLevels = 0;
                    testLevels = 0;

                    ///////////////////////////////////////////////////////////

#if DEBUGGER
                    isDebuggerExiting = false;
#endif

                    ///////////////////////////////////////////////////////////

                    stackOverflow = false;

                    ///////////////////////////////////////////////////////////

#if PREVIOUS_RESULT
                    previousResult = null;
#endif

                    ///////////////////////////////////////////////////////////

                    engineFlags = EngineFlags.None;
                    parseState = null;
                    returnCode = ReturnCode.Ok;
                    errorLine = 0;
                    errorCode = null;
                    errorInfo = null;
                    errorFrames = 0;
                    exception = null;
                    scriptLocation = null;

                    ///////////////////////////////////////////////////////////

                    if (scriptLocations != null)
                    {
                        scriptLocations.Clear();
                        scriptLocations = null;
                    }

                    ///////////////////////////////////////////////////////////

#if SCRIPT_ARGUMENTS
                    if (scriptArguments != null)
                    {
                        scriptArguments.Clear();
                        scriptArguments = null;
                    }
#endif

                    ///////////////////////////////////////////////////////////

                    previousProcessId = 0;

                    ///////////////////////////////////////////////////////////

                    if (arraySearches != null)
                    {
                        arraySearches.Clear();
                        arraySearches = null;
                    }

                    ///////////////////////////////////////////////////////////

#if HISTORY
                    historyEngineFilter = null;

                    ///////////////////////////////////////////////////////////

                    if (_history != null)
                    {
                        _history.Clear();
                        _history = null;
                    }
#endif
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Interactive Context (Non-Threaded Only)
                    interactive = false;
                    interactiveInput = null;
                    previousInteractiveInput = null;
                    interactiveMode = null;
                    activeInteractiveLoops = 0;
                    totalInteractiveLoops = 0;
                    totalInteractiveInputs = 0;

#if SHELL
                    shellCallbackData = null;
                    interactiveLoopData = null;
                    updateData = null;
#endif

                    interactiveCommandCallback = null;

                    ///////////////////////////////////////////////////////////

#if HISTORY
                    historyLoadData = null;
                    historySaveData = null;
                    historyInfoFilter = null;
                    historyLoadFilter = null;
                    historySaveFilter = null;
                    historyFileName = null;
#endif
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Test Context (Non-Threaded Only)
                    testTargetInterpreter = null;
                    testStatistics = null;

                    ///////////////////////////////////////////////////////////

                    if (testConstraints != null)
                    {
                        testConstraints.Clear();
                        testConstraints = null;
                    }

                    ///////////////////////////////////////////////////////////

                    if (testKnownBugs != null)
                    {
                        testKnownBugs.Clear();
                        testKnownBugs = null;
                    }

                    ///////////////////////////////////////////////////////////

                    if (testSkipped != null)
                    {
                        testSkipped.Clear();
                        testSkipped = null;
                    }

                    ///////////////////////////////////////////////////////////

                    if (testFailures != null)
                    {
                        testFailures.Clear();
                        testFailures = null;
                    }

                    ///////////////////////////////////////////////////////////

                    if (testCounts != null)
                    {
                        testCounts.Clear();
                        testCounts = null;
                    }

                    ///////////////////////////////////////////////////////////

                    if (testMatch != null)
                    {
                        testMatch.Clear();
                        testMatch = null;
                    }

                    ///////////////////////////////////////////////////////////

                    if (testSkip != null)
                    {
                        testSkip.Clear();
                        testSkip = null;
                    }

                    ///////////////////////////////////////////////////////////

                    if (testReturnCodeMessages != null)
                    {
                        testReturnCodeMessages.Clear();
                        testReturnCodeMessages = null;
                    }

                    ///////////////////////////////////////////////////////////

#if DEBUGGER
                    if (testBreakpoints != null)
                    {
                        testBreakpoints.Clear();
                        testBreakpoints = null;
                    }
#endif

                    ///////////////////////////////////////////////////////////

                    testComparer = null;
                    testPath = null;
                    testVerbose = TestOutputType.None;
                    testRepeatCount = 0;
                    testCurrent = null;
                    #endregion

                    ///////////////////////////////////////////////////////////

                    #region Variable Context (Non-Threaded Only)
                    //
                    // NOTE: Dispose of the call stack now.
                    //
                    DisposeCallStack(ref callStack);

                    //
                    // NOTE: Dispose of the current, procedure, and global call
                    //       frames now.
                    //
                    DisposeCallFrame(ref uplevelFrame);
                    DisposeCallFrame(ref procedureFrame);
                    DisposeCallFrame(ref currentFrame);
                    DisposeCallFrame(ref globalScopeFrame);
                    DisposeCallFrame(ref globalFrame);

                    ///////////////////////////////////////////////////////////

                    traceInfo = null;
                    #endregion
                }
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Context Information with Threading Enabled
#if THREADING
        private void DisposeThreadedContexts(
            bool dispose,
            bool disposing, /* NOT USED */
            bool isStoppingSoon
            )
        {
            //
            // NOTE: Dispose all per-interpreter data (for this thread only).
            //       Only "threading" enabled data is disposed here.  Normal
            //       per-interpreter data is disposed by Dispose (see below).
            //       This must be skipped if the entire application domain is
            //       being finalized because the thread-local storage may have
            //       already been freed in that case.
            //
            TraceOps.DebugTrace(String.Format(
                "DisposeThreadedContexts: interpreter = {0}, " +
                "contextManager = {1}, dispose = {2}, disposing = {3}, " +
                "isStoppingSoon = {4}", id, (contextManager != null) ?
                "<present>" : "<absent>", dispose, disposing, isStoppingSoon),
                typeof(Interpreter).Name, TracePriority.CleanupDebug);

            if (!isStoppingSoon && (contextManager != null))
                contextManager.Free(dispose);
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void DisposeThread(
            bool dispose,
            bool disposing /* NOT USED */
            )
        {
            bool isStoppingSoon = AppDomainOps.IsStoppingSoon();

            ///////////////////////////////////////////////////////////////////

#if NATIVE
            //
            // NOTE: Skip finalizing the native stack checking subsystem if
            //       the entire application domain is being finalized.  This
            //       is necessary because the thread-local storage may have
            //       already been freed in that case.
            //
            // NOTE: Try to verify that we are the last interpreter for this
            //       thread prior to getting rid of our native stack related
            //       informmation.
            //
            if (!isStoppingSoon &&
                (CountThreadInterpreters() <= 1)) // BUGBUG: Was == 1 here?
            {
                RuntimeOps.MaybeFinalizeStackChecking();
            }
#endif

            ///////////////////////////////////////////////////////////////////

#if THREADING
            //
            // NOTE: Dispose thread-specific context data for this interpreter
            //       for this thread [only].
            //
            DisposeThreadedContexts(dispose, disposing, isStoppingSoon);
#else
            //
            // NOTE: Dispose context data for this interpreter.  There is no
            //       built-in threading support, so this context data applies
            //       to all threads.
            //
            DisposeNonThreadedContexts(dispose, disposing, isStoppingSoon);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if THREADING
        private void ResetContextManagerAndPurge(
            bool purge
            )
        {
            ///////////////////////////////////////////////////////////////////
            //  *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*  //
            //                                                               //
            //   The interpreter cannot be used for anything that requires   //
            //   per-thread context information at this point because that   //
            //   subsystem is (probably?) disposed.  If any other threads    //
            //   subsequently attempt to use this interpreter, there is no   //
            //   way they will work correctly.                               //
            //                                                               //
            //  *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*  //
            ///////////////////////////////////////////////////////////////////

            TraceOps.DebugTrace(String.Format(
                "ResetContextManagerAndPurge: interpreter = {0}, " +
                "purge = {1}", id, purge), typeof(Interpreter).Name,
                TracePriority.CleanupDebug);

            ///////////////////////////////////////////////////////////////////

            #region Reset Context Manager Instance Data
            contextManager = null;

            ///////////////////////////////////////////////////////////////////

            //
            // NOTE: Reset the context counts used for testing.  There is no
            //       need for locking here because there is no non-test code
            //       that relies on them for correct operation.
            //
            ResetDisposeContextCounts();
            #endregion

            ///////////////////////////////////////////////////////////////////

            #region Purge Context Manager Static Data
            //
            // NOTE: Purge contexts for this thread from the context manager
            //       that may refer to [other] disposed interpreters.
            //
            if (purge)
                ContextManager.Purge(this, false, true);
            #endregion
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeThreadAndContextManager(
            bool disposing
            )
        {
            DisposeThread(true, disposing);

#if THREADING
            ResetContextManagerAndPurge(true);
#endif
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region "Other" Threads Disposal
        private void DisposeOtherThreads()
        {
            ReturnCode code;
            Result result; /* REUSED */

            ///////////////////////////////////////////////////////////////////

            //
            // BUGFIX: Does the interpreter have an active timeout thread?
            //         If so, stop it now.
            //
            result = null;
            code = InterruptTimeoutThread(null, false, false, ref result);

            if (code != ReturnCode.Ok)
                DebugOps.Complain(this, code, result);

            ///////////////////////////////////////////////////////////////////

            //
            // BUGFIX: Does the interpreter have an active health thread?
            //         If so, stop it now.
            //
            result = null;
            code = InterruptHealthThread(null, false, false, ref result);

            if (code != ReturnCode.Ok)
                DebugOps.Complain(this, code, result);

            /* NO RESULT */
            CloseHealthEvent();

            ///////////////////////////////////////////////////////////////////

#if SHELL && INTERACTIVE_COMMANDS
            //
            // BUGFIX: Does the interpreter have an active garbage collection
            //         test thread?  If so, stop it now.
            //
            result = null;
            code = InterruptTestGcThread(null, false, false, ref result);

            if (code != ReturnCode.Ok)
                DebugOps.Complain(this, code, result);
#endif
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Namespace Disposal
        private void DisposeNamespaces()
        {
            #region Global Namespace
            if (globalNamespace != null)
            {
                ReturnCode code;
                Result error = null;

                code = NamespaceOps.Dispose(this, ref globalNamespace, ref error);

                if (code != ReturnCode.Ok)
                {
                    error = String.Format(
                        "caught exception while disposing namespace {0}: {1}",
                        FormatOps.WrapOrNull(TclVars.Namespace.GlobalName),
                        error);

                    DebugOps.Complain(this, code, error);

                    //
                    // HACK: Reset the global namespace instance even if we
                    //       could not successfully dispose it.
                    //
                    globalNamespace = null;
                }
            }
            #endregion
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Resolver Disposal
        private void DisposeResolvers()
        {
            if (resolvers == null)
                return;

            if (resolvers.Count == 0)
                return;

            for (int index = resolvers.Count - 1; index >= 0; index--)
            {
                IResolve resolve = resolvers[index];

                if (resolve == null)
                {
                    resolvers.RemoveAt(index);
                    continue;
                }

                string resolveName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    resolveName = EntityOps.GetNameNoThrow(resolve);

                    IDisposable disposable = resolve as IDisposable;

                    if (disposable != null)
                        disposable.Dispose(); /* throw */

                    code = ReturnCode.Ok;

                    // if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: If we get to this point, we succeeded (i.e.
                        //       resolver was successfully disposed, remove
                        //       it).
                        //
                        resolvers.RemoveAt(index);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing resolver {0}: {1}",
                        FormatOps.WrapOrNull(resolveName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Scope Disposal
        private void DisposeScopes() /* EXEMPT */
        {
            if (scopes == null)
                return;

            StringList keys = new StringList(scopes.Keys);

            foreach (string key in keys)
            {
                ICallFrame frame = scopes[key];

                if (frame == null)
                {
                    scopes.Remove(key);
                    continue;
                }

                string frameName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    frameName = EntityOps.GetNameNoThrow(frame);

                    IDisposable disposable = frame as IDisposable;

                    if (disposable != null)
                        disposable.Dispose(); /* throw */

                    code = ReturnCode.Ok;

                    // if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: If we get to this point, we succeeded (i.e.
                        //       call frame was successfully disposed, remove
                        //       it).
                        //
                        scopes.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing scope {0}: {1}",
                        FormatOps.WrapOrNull(frameName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Alias Disposal
        private void DisposeAliases()
        {
            if (aliases == null)
                return;

            StringList keys = new StringList(aliases.Keys);

            foreach (string key in keys)
            {
                IAlias alias = aliases[key];

                if (alias == null)
                {
                    aliases.Remove(key);
                    continue;
                }

                string aliasName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    aliasName = EntityOps.GetNameNoThrow(alias);

                    IDisposable disposable = alias as IDisposable;

                    if (disposable != null)
                        disposable.Dispose(); /* throw */

                    code = ReturnCode.Ok;

                    // if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: If we get to this point, we succeeded (i.e.
                        //       alias was successfully disposed, remove it).
                        //
                        aliases.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing alias {0}: {1}",
                        FormatOps.WrapOrNull(aliasName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Policy Disposal
        private void DisposePolicies()
        {
            if (policies == null)
                return;

            StringList keys = new StringList(policies.Keys);

            foreach (string key in keys)
            {
                IPolicy policy = policies[key];

                if (policy == null)
                {
                    policies.Remove(key);
                    continue;
                }

                string policyName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    policyName = EntityOps.GetNameNoThrow(policy);

                    IDisposable disposable = policy as IDisposable;

                    if (disposable != null)
                        disposable.Dispose(); /* throw */

                    code = ReturnCode.Ok;

                    // if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: If we get to this point, we succeeded (i.e.
                        //       policy was successfully disposed, remove it).
                        //
                        policies.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing policy {0}: {1}",
                        FormatOps.WrapOrNull(policyName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Trace Disposal
        private void DisposeTraces()
        {
            if (traces == null)
                return;

            StringList keys = new StringList(traces.Keys);

            foreach (string key in keys)
            {
                ITrace trace = traces[key];

                if (trace == null)
                {
                    traces.Remove(key);
                    continue;
                }

                string traceName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    traceName = EntityOps.GetNameNoThrow(trace);

                    IDisposable disposable = trace as IDisposable;

                    if (disposable != null)
                        disposable.Dispose(); /* throw */

                    code = ReturnCode.Ok;

                    // if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: If we get to this point, we succeeded (i.e.
                        //       trace was successfully disposed, remove it).
                        //
                        traces.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing trace {0}: {1}",
                        FormatOps.WrapOrNull(traceName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Plugin Disposal
        private void DisposePlugins(
            DisposalPhase phase
            )
        {
            if (plugins == null)
                return;

            bool disposeNative = FlagOps.HasFlags(
                phase, DisposalPhase.Native, true);

            bool disposeSystem = FlagOps.HasFlags(
                phase, DisposalPhase.System, true);

            StringList keys = new StringList(plugins.Keys);

            foreach (string key in keys)
            {
                IPlugin plugin = plugins[key];

                if (plugin == null)
                {
                    plugins.Remove(key);

#if NOTIFY || NOTIFY_OBJECT
                    if (notifyPlugins != null)
                        notifyPlugins.Remove(key);
#endif

                    continue;
                }

                PluginFlags pluginFlags = EntityOps.GetFlagsNoThrow(
                    plugin);

                bool nativeCode = FlagOps.HasFlags(
                    pluginFlags, PluginFlags.NativeCode, true);

                if (nativeCode && !disposeNative)
                    continue;

                bool system = FlagOps.HasFlags(
                    pluginFlags, PluginFlags.System, true);

                if (system && !disposeSystem)
                    continue;

#if ISOLATED_PLUGINS
                //
                // HACK: Avoid calling the AppDomainOps.IsIsolated method
                //       here.  Instead, just check the [already] queried
                //       plugin flags directly.
                //
                bool isolated = FlagOps.HasFlags( /* EXEMPT */
                    pluginFlags, PluginFlags.Isolated, true);

                AppDomain appDomain = isolated ?
                    EntityOps.GetAppDomainNoThrow(plugin) : null;
#endif

                string pluginName = null;

                ReturnCode code;
                Result result = null;

                try
                {
                    pluginName = EntityOps.GetNameNoThrow(plugin);

                    code = TerminatePlugin(plugin, null, ref result);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Plugin successfully terminated, remove it.
                        //
                        plugins.Remove(key);

#if NOTIFY || NOTIFY_OBJECT
                        if (notifyPlugins != null)
                            notifyPlugins.Remove(key);
#endif

                        TraceOps.DebugTrace(String.Format(
                            "DisposePlugins: disposed {0} {1} plugin {2}",
                            nativeCode ? "native" : "managed", system ? "system" : "user",
                            FormatOps.WrapOrNull(pluginName)), typeof(Interpreter).Name,
                            TracePriority.CleanupDebug);
                    }
                }
                catch (Exception e)
                {
                    result = String.Format(
                        "caught exception while disposing {0} {1} plugin {2}: {3}",
                        nativeCode ? "native" : "managed", system ? "system" : "user",
                        FormatOps.WrapOrNull(pluginName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, result);

#if ISOLATED_PLUGINS
                if (isolated)
                {
                    UnloadAppDomainForPlugin(
                        plugin, null, null, appDomain);
                }
#endif
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Command Disposal
        private void DisposeCommands(
            DisposalPhase phase
            )
        {
            if (commands == null)
                return;

            bool disposeNative = FlagOps.HasFlags(
                phase, DisposalPhase.Native, true);

            bool disposeSystem = FlagOps.HasFlags(
                phase, DisposalPhase.System, true);

            StringList keys = new StringList(commands.Keys);

            foreach (string key in keys)
            {
                ICommand command = commands[key];

                if (command == null)
                {
                    commands.Remove(key);
                    continue;
                }

                CommandFlags commandFlags = EntityOps.GetFlagsNoThrow(
                    command);

                bool nativeCode = FlagOps.HasFlags(
                    commandFlags, CommandFlags.NativeCode, true);

                if (nativeCode && !disposeNative)
                    continue;

                bool system = FlagOps.HasFlags(
                    commandFlags, CommandFlags.Core, true);

                if (system && !disposeSystem)
                    continue;

                bool alias = FlagOps.HasFlags(
                    commandFlags, CommandFlags.Alias, true);

                string commandName = null;

                ReturnCode code;
                Result result = null;

                try
                {
                    commandName = EntityOps.GetNameNoThrow(command);

                    code = TerminateCommand(command, null, ref result);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Command successfully terminated, remove it.
                        //
                        commands.Remove(key);

                        TraceOps.DebugTrace(String.Format(
                            "DisposeCommands: disposed {0} {1} {2} {3}",
                            nativeCode ? "native" : "managed", system ? "system" : "user",
                            alias ? "alias" : "command", FormatOps.WrapOrNull(commandName)),
                            typeof(Interpreter).Name, TracePriority.CleanupDebug);
                    }
                }
                catch (Exception e)
                {
                    result = String.Format(
                        "caught exception while disposing {0} {1} {2} {3}: {4}",
                        nativeCode ? "native" : "managed", system ? "system" : "user",
                        alias ? "alias" : "command", FormatOps.WrapOrNull(commandName),
                        e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, result);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeHiddenCommands()
        {
            DisposeHiddenCommands(
                DisposalPhase.Phase1Mask | DisposalPhase.Phase2Mask |
                DisposalPhase.Phase3Mask | DisposalPhase.Phase4Mask);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeHiddenCommands(
            DisposalPhase phase
            )
        {
            if (hiddenCommands == null)
                return;

            bool disposeNative = FlagOps.HasFlags(
                phase, DisposalPhase.Native, true);

            bool disposeSystem = FlagOps.HasFlags(
                phase, DisposalPhase.System, true);

            StringList keys = new StringList(hiddenCommands.Keys);

            foreach (string key in keys)
            {
                ICommand command = hiddenCommands[key];

                if (command == null)
                {
                    hiddenCommands.Remove(key);
                    continue;
                }

                CommandFlags commandFlags = EntityOps.GetFlagsNoThrow(
                    command);

                bool nativeCode = FlagOps.HasFlags(
                    commandFlags, CommandFlags.NativeCode, true);

                if (nativeCode && !disposeNative)
                    continue;

                bool system = FlagOps.HasFlags(
                    commandFlags, CommandFlags.Core, true);

                if (system && !disposeSystem)
                    continue;

                bool alias = FlagOps.HasFlags(
                    commandFlags, CommandFlags.Alias, true);

                string commandName = null;

                ReturnCode code;
                Result result = null;

                try
                {
                    commandName = EntityOps.GetNameNoThrow(command);

                    code = TerminateCommand(command, null, ref result);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Command successfully terminated, remove it.
                        //
                        hiddenCommands.Remove(key);

                        TraceOps.DebugTrace(String.Format(
                            "DisposeHiddenCommands: disposed {0} {1} hidden {2} {3}",
                            nativeCode ? "native" : "managed", system ? "system" : "user",
                            alias ? "alias" : "command", FormatOps.WrapOrNull(commandName)),
                            typeof(Interpreter).Name, TracePriority.CleanupDebug);
                    }
                }
                catch (Exception e)
                {
                    result = String.Format(
                        "caught exception while disposing {0} {1} hidden {2} {3}: {4}",
                        nativeCode ? "native" : "managed", system ? "system" : "user",
                        alias ? "alias" : "command", FormatOps.WrapOrNull(commandName),
                        e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, result);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Plugin & Command Disposal
        private void DisposePhase1PluginsAndCommands(
            DisposalPhase phase
            )
        {
            //
            // NOTE: Attempt to terminate native user plugins gracefully.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Plugin, true))
                DisposePlugins(DisposalPhase.Phase1Mask);

            ///////////////////////////////////////////////////////////////////////////////////////////
            //    *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*    //
            //                                                                                       //
            //             The interpreter may have no script commands after this point.             //
            //                                                                                       //
            //    *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*    //
            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Attempt to terminate native user commands gracefully.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Command, true))
            {
                DisposeCommands(DisposalPhase.Phase1Mask);
                DisposeHiddenCommands(DisposalPhase.Phase1Mask);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposePhase2PluginsAndCommands(
            DisposalPhase phase
            )
        {
            //
            // NOTE: Attempt to terminate native system plugins gracefully.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Plugin, true))
                DisposePlugins(DisposalPhase.Phase2Mask);

            ///////////////////////////////////////////////////////////////////////////////////////////
            //    *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*    //
            //                                                                                       //
            //             The interpreter may have no script commands after this point.             //
            //                                                                                       //
            //    *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*    //
            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Attempt to terminate native system commands gracefully.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Command, true))
            {
                DisposeCommands(DisposalPhase.Phase2Mask);
                DisposeHiddenCommands(DisposalPhase.Phase2Mask);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposePhase3PluginsAndCommands(
            DisposalPhase phase
            )
        {
            //
            // NOTE: Attempt to terminate managed user plugins gracefully.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Plugin, true))
                DisposePlugins(DisposalPhase.Phase3Mask);

            ///////////////////////////////////////////////////////////////////////////////////////////
            //    *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*    //
            //                                                                                       //
            //             The interpreter may have no script commands after this point.             //
            //                                                                                       //
            //    *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*    //
            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Attempt to terminate managed user commands gracefully.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Command, true))
            {
                DisposeCommands(DisposalPhase.Phase3Mask);
                DisposeHiddenCommands(DisposalPhase.Phase3Mask);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposePhase4PluginsAndCommands(
            DisposalPhase phase
            )
        {
            //
            // NOTE: Attempt to terminate managed system plugins gracefully.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Plugin, true))
                DisposePlugins(DisposalPhase.Phase4Mask);

            ///////////////////////////////////////////////////////////////////////////////////////////
            //    *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*    //
            //                                                                                       //
            //             The interpreter may have no script commands after this point.             //
            //                                                                                       //
            //    *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*    //
            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Attempt to terminate managed system commands gracefully.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Command, true))
            {
                DisposeCommands(DisposalPhase.Phase4Mask);
                DisposeHiddenCommands(DisposalPhase.Phase4Mask);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Package Disposal
        private void DisposePackages(
            DisposalPhase phase
            )
        {
            if (packages == null)
                return;

            bool disposePlugin = FlagOps.HasFlags(
                phase, DisposalPhase.Plugin, true);

            StringList keys = new StringList(packages.Keys);

            foreach (string key in keys)
            {
                IPackage package = packages[key];

                if (package == null)
                {
                    packages.Remove(key);
                    continue;
                }

                PackageFlags packageFlags = EntityOps.GetFlagsNoThrow(
                    package);

                bool plugin = FlagOps.HasFlags(
                    packageFlags, PackageFlags.Plugin, true);

                if (plugin && !disposePlugin)
                    continue;

                string packageName = null;

                ReturnCode code;
                Result result = null;

                try
                {
                    packageName = EntityOps.GetNameNoThrow(package);

                    code = TerminatePackage(package, null, ref result);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Package successfully terminated, remove it.
                        //
                        packages.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    result = String.Format(
                        "caught exception while disposing package {0}: {1}",
                        FormatOps.WrapOrNull(packageName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, result);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Expression Entity Disposal
        private void DisposeFunctions()
        {
            if (functions == null)
                return;

            StringList keys = new StringList(functions.Keys);

            foreach (string key in keys)
            {
                IFunction function = functions[key];

                if (function == null)
                {
                    functions.Remove(key);
                    continue;
                }

                string functionName = null;

                ReturnCode code;
                Result result = null;

                try
                {
                    functionName = EntityOps.GetNameNoThrow(function);

                    code = TerminateFunction(function, null, ref result);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Function successfully terminated, remove it.
                        //
                        functions.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    result = String.Format(
                        "caught exception while disposing function {0}: {1}",
                        FormatOps.WrapOrNull(functionName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, result);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeOperators()
        {
            if (operators == null)
                return;

            StringList keys = new StringList(operators.Keys);

            foreach (string key in keys)
            {
                IOperator @operator = operators[key];

                if (@operator == null)
                {
                    operators.Remove(key);
                    continue;
                }

                string operatorName = null;

                ReturnCode code;
                Result result = null;

                try
                {
                    operatorName = EntityOps.GetNameNoThrow(@operator);

                    code = TerminateOperator(@operator, null, ref result);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Operator successfully terminated, remove it.
                        //
                        operators.Remove(key);

                        //
                        // NOTE: Remove operator cache entry, if any.
                        //
                        ClearOperatorCacheEntry(EntityOps.GetLexemeNoThrow(
                            @operator));
                    }
                }
                catch (Exception e)
                {
                    result = String.Format(
                        "caught exception while disposing operator {0}: {1}",
                        FormatOps.WrapOrNull(operatorName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, result);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Managed Entity Disposal
        private void DisposeObjects()
        {
            if (objects == null)
                return;

            StringList keys = new StringList(objects.Keys);

            foreach (string key in keys)
            {
                IObject @object = objects[key];

                if (@object == null)
                {
                    objects.Remove(key);
                    continue;
                }

                object value = @object.Value;

                if (value == null)
                {
                    objects.Remove(key);
                    continue;
                }

                //
                // BUGFIX: Prevent accidental recursion.
                //
                // NOTE: Skip disposing of the interpreter containing this
                //       opaque object handle.
                //
                if (Object.ReferenceEquals(value, this))
                {
                    objects.Remove(key);
                    continue;
                }

                //
                // NOTE: Skip disposing of any interpreter associated with
                //       the one containing this opaque object handle.
                //
                if (IsParentOrChildInterpreter(value))
                {
                    objects.Remove(key);
                    continue;
                }

                //
                // NOTE: Grab the flags for this object as we need to check
                //       for several of them.
                //
                ObjectFlags flags = EntityOps.GetFlagsNoThrow(@object);

                //
                // NOTE: If the "NoDispose" flag is set, skip disposing of
                //       this object as we do not own it in that case.
                //
                if (FlagOps.HasFlags(flags, ObjectFlags.NoDispose, true))
                {
                    objects.Remove(key);
                    continue;
                }

                //
                // NOTE: Skip disposing of any object shared with this
                //       interpreter by another interpreter as we do not
                //       own it in that case.
                //
                if (FlagOps.HasFlags(flags, ObjectFlags.SharedObject, true))
                {
                    objects.Remove(key);
                    continue;
                }

#if NATIVE && TCL
                //
                // NOTE: Skip disposing of any object used to interact
                //       with the native Tcl subsystem.  This is simply
                //       not the place to dispose of these objects.  If
                //       one of these objects is disposed here, it may
                //       cause the DisposeTcl() method, et al, to throw
                //       an ObjectDisposedException later on.
                //
                if (FlagOps.HasFlags(flags, ObjectFlags.NativeTcl, true))
                {
                    objects.Remove(key);
                    continue;
                }
#endif

                string objectName = null;
                ReturnCode code;
                Result error = null;

                try
                {
                    //
                    // NOTE: *SPECIAL CASE* The IObject interface uses the
                    //       Value property to refer to the actual object,
                    //       which is what we want to try and dispose of
                    //       (i.e. and not the wrapper nor the underlying
                    //       "IObject" implementation, which are usually
                    //       just "_Wrappers_Object" and "_Objects.Default",
                    //       respectively).
                    //
                    objectName = EntityOps.GetNameNoThrow(
                        @object);

                    code = ObjectOps.TryDispose<object>(
                        ref value, ref error);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Object successfully disposed, remove it.
                        //
                        objects.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing object {0}: {1}",
                        FormatOps.WrapOrNull(objectName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeChannels()
        {
            if (channels == null)
                return;

            StringList keys = new StringList(channels.Keys);

            foreach (string key in keys)
            {
                IChannel channel = channels[key];

                if (channel == null)
                {
                    channels.Remove(key);
                    continue;
                }

                string channelName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    channelName = EntityOps.GetNameNoThrow(channel);

                    channel.Close(); /* throw */
                    code = ReturnCode.Ok;

                    // if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: If we get to this point, we succeeded (i.e.
                        //       channel was successfully closed, remove it).
                        //
                        channels.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while closing channel {0}: {1}",
                        FormatOps.WrapOrNull(channelName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeEncodings()
        {
            if (encodings == null)
                return;

            StringList keys = new StringList(encodings.Keys);

            foreach (string key in keys)
            {
                Encoding encoding = encodings[key];

                if (encoding == null)
                {
                    encodings.Remove(key);
                    continue;
                }

                string encodingName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    encodingName = EntityOps.GetNameNoThrow(encoding);

                    IDisposable disposable = encoding as IDisposable;

                    if (disposable != null)
                        disposable.Dispose(); /* throw */

                    code = ReturnCode.Ok;

                    // if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: If we get to this point, we succeeded (i.e.
                        //       encoding was successfully disposed, remove
                        //       it).
                        //
                        encodings.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing encoding {0}: {1}",
                        FormatOps.WrapOrNull(encodingName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if APPDOMAINS
        private void DisposeAppDomains()
        {
            if (appDomains == null)
                return;

            StringList keys = new StringList(appDomains.Keys);

            foreach (string key in keys)
            {
                AppDomain appDomain = appDomains[key];

                if (appDomain == null)
                {
                    appDomains.Remove(key);
                    continue;
                }

                string appDomainName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    appDomainName = EntityOps.GetNameNoThrow(appDomain);

                    code = AppDomainOps.Unload(key, appDomain, null, ref error);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: AppDomain successfully unloaded, remove it.
                        //
                        appDomains.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while unloading application domain {0}: {1}",
                        FormatOps.WrapOrNull(appDomainName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Database Entity Disposal
#if DATA
        private void DisposeTransactions()
        {
            if (transactions == null)
                return;

            StringList keys = new StringList(transactions.Keys);

            foreach (string key in keys)
            {
                IDbTransaction transaction = transactions[key];

                if (transaction == null)
                {
                    transactions.Remove(key);
                    continue;
                }

                string transactionName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    transactionName = EntityOps.GetNameNoThrow(
                        transaction);

                    code = ObjectOps.TryDispose<IDbTransaction>(
                        ref transaction, ref error);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Transaction successfully disposed, remove it.
                        //
                        transactions.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing transaction {0}: {1}",
                        FormatOps.WrapOrNull(transactionName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeConnections()
        {
            if (connections == null)
                return;

            StringList keys = new StringList(connections.Keys);

            foreach (string key in keys)
            {
                IDbConnection connection = connections[key];

                if (connection == null)
                {
                    connections.Remove(key);
                    continue;
                }

                string connectionName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    connectionName = EntityOps.GetNameNoThrow(
                        connection);

                    code = ObjectOps.TryDispose<IDbConnection>(
                        ref connection, ref error);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Connection successfully disposed, remove it.
                        //
                        connections.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing connection {0}: {1}",
                        FormatOps.WrapOrNull(connectionName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Native Entity Disposal
#if EMIT && NATIVE && LIBRARY
        private void DisposeDelegates()
        {
            if (delegates == null)
                return;

            StringList keys = new StringList(delegates.Keys);

            foreach (string key in keys)
            {
                IDelegate @delegate = delegates[key];

                if (@delegate == null)
                {
                    delegates.Remove(key);
                    continue;
                }

                string delegateName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    delegateName = EntityOps.GetNameNoThrow(
                        @delegate);

                    code = ObjectOps.TryDispose<IDelegate>(
                        ref @delegate, ref error);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Delegate successfully disposed, remove it.
                        //
                        delegates.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing delegate {0}: {1}",
                        FormatOps.WrapOrNull(delegateName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeModules()
        {
            if (modules == null)
                return;

            StringList keys = new StringList(modules.Keys);

            foreach (string key in keys)
            {
                IModule module = modules[key];

                if (module == null)
                {
                    modules.Remove(key);
                    continue;
                }

                string moduleName = null;

                ReturnCode code;
                Result error = null;

                try
                {
                    moduleName = EntityOps.GetNameNoThrow(
                        module);

                    code = ObjectOps.TryDispose<IModule>(
                        ref module, ref error);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Module successfully disposed, remove it.
                        //
                        modules.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing module {0}: {1}",
                        FormatOps.WrapOrNull(moduleName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Event Manager, Debugger, Host, & TextWriter Disposal
        private void DisposeEventManager()
        {
            if (eventManager == null) /* EXEMPT */
                return;

            ReturnCode code;
            Result error = null;

            try
            {
                code = ObjectOps.TryDispose<IEventManager>(
                    ref eventManager, ref error);
            }
            catch (Exception e)
            {
                error = String.Format(
                    "caught exception while disposing event manager: {0}",
                    e);

                code = ReturnCode.Error;
            }

            if (code != ReturnCode.Ok)
                DebugOps.Complain(this, code, error);

            eventManager = null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if DEBUGGER && !THREADING
        private void DisposeDebugger()
        {
            if (debugger == null)
                return;

            ReturnCode code;
            Result error = null;

            try
            {
                code = ObjectOps.TryDispose(debugger, ref error);
            }
            catch (Exception e)
            {
                error = String.Format(
                    "caught exception while disposing debugger: {0}",
                    e);

                code = ReturnCode.Error;
            }

            if (code != ReturnCode.Ok)
                DebugOps.Complain(this, code, error);

            debugger = null;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateIsNoDisposeHost()
        {
            //
            // NOTE: Assumes lock is already held.
            //
            return FlagOps.HasFlags(
                hostCreateFlags, HostCreateFlags.NoDispose, true);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeHost()
        {
            IHost oldHost = host;
            bool noDisposeHost = PrivateIsNoDisposeHost();

            try
            {
                #region Dispose Host
                if (host != null)
                {
                    string hostName = null;

                    try
                    {
                        hostName = EntityOps.GetNameNoThrow(host);
                    }
                    catch
                    {
                        // do nothing.
                    }

                    ReturnCode code = ReturnCode.Ok;
                    Result error = null;

                    if (!noDisposeHost)
                    {
                        try
                        {
                            code = ObjectOps.TryDispose<IHost>(
                                ref host, ref error);
                        }
                        catch (Exception e)
                        {
                            error = String.Format(
                                "caught exception while disposing host {0}: {1}",
                                FormatOps.WrapOrNull(hostName), e);

                            code = ReturnCode.Error;
                        }

                        if (code != ReturnCode.Ok)
                            DebugOps.Complain(this, code, error);
                    }
                    else
                    {
                        //
                        // NOTE: Unset the "exit mode" flag that was set in our caller
                        //       (the Dispose method) because this host may need to be
                        //       used by another interpreter.
                        //
                        HostOps.SetExiting(this, host, hostName, false, false);
                    }

                    host = null;
                }
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Dispose Interactive Host
                if (interactiveHost != null)
                {
                    if (!noDisposeHost &&
                        !Object.ReferenceEquals(interactiveHost, oldHost))
                    {
                        string interactiveHostName = null;

                        try
                        {
                            interactiveHostName = EntityOps.GetNameNoThrow(interactiveHost);
                        }
                        catch
                        {
                            // do nothing.
                        }

                        ReturnCode code;
                        Result error = null;

                        try
                        {
                            code = ObjectOps.TryDispose<IInteractiveHost>(
                                ref interactiveHost, ref error);
                        }
                        catch (Exception e)
                        {
                            error = String.Format(
                                "caught exception while disposing interactive host {0}: {1}",
                                FormatOps.WrapOrNull(interactiveHostName), e);

                            code = ReturnCode.Error;
                        }

                        if (code != ReturnCode.Ok)
                            DebugOps.Complain(this, code, error);
                    }

                    interactiveHost = null;
                }
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Dispose Isolated Host (ISOLATED_PLUGINS only)
#if ISOLATED_PLUGINS
                if (isolatedHost != null)
                {
                    //
                    // BUGFIX: If the isolated host is the same as the normal one,
                    //         there is nothing more to dispose.
                    //
                    if (!Object.ReferenceEquals(isolatedHost, oldHost))
                    {
                        string isolatedHostName = null;

                        try
                        {
                            isolatedHostName = EntityOps.GetNameNoThrow(isolatedHost);
                        }
                        catch
                        {
                            // do nothing.
                        }

                        ReturnCode code = ReturnCode.Ok;
                        Result error = null;

                        if (!noDisposeHost)
                        {
                            try
                            {
                                code = ObjectOps.TryDispose<IHost>(
                                    ref isolatedHost, ref error);
                            }
                            catch (Exception e)
                            {
                                error = String.Format(
                                    "caught exception while disposing isolated host {0}: {1}",
                                    FormatOps.WrapOrNull(isolatedHostName), e);

                                code = ReturnCode.Error;
                            }

                            if (code != ReturnCode.Ok)
                                DebugOps.Complain(this, code, error);
                        }
                        else
                        {
                            //
                            // NOTE: Unset the "exit mode" flag that was set in our caller
                            //       (the Dispose method) because this host may need to be
                            //       used by another interpreter.
                            //
                            HostOps.SetExiting(this, isolatedHost, isolatedHostName, true, false);
                        }
                    }

                    isolatedHost = null;
                }
#endif
                #endregion
            }
            finally
            {
                oldHost = null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void CleanupAndMaybeResetPaths(
            bool reset
            )
        {
            StringList list = null;

            CleanupAndMaybeResetPaths(reset, ref list);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void CleanupAndMaybeResetPaths(
            bool reset,
            ref StringList list
            )
        {
            if (cleanupPaths == null)
                return;

            IEnumerable<CleanupPathPair> pairs =
                cleanupPaths.GetPairsInOrder(true);

            if (pairs == null)
                return;

            foreach (CleanupPathPair pair in pairs)
            {
                string path = pair.Key;

                if (String.IsNullOrEmpty(path))
                    continue;

                CleanupPathClientData clientData = pair.Value;
                Result error = null;

                if ((clientData == null) ||
                    !clientData.MatchPathType(path, ref error))
                {
                    TraceOps.DebugTrace(String.Format(
                        "CleanupAndMaybeResetPaths: cannot " +
                        "delete {0}, mismatched {1}: {2}",
                        FormatOps.WrapOrNull(path),
                        FormatOps.WrapOrNull(clientData),
                        FormatOps.WrapOrNull(error)),
                        typeof(Interpreter).Name,
                        TracePriority.FileSystemError);

                    continue;
                }

                ReturnCode deleteCode;
                Result deleteError = null;
                string pathType = null;

                deleteCode = FileOps.FileDelete(
                    new string[] { path }, clientData.Recursive,
                    clientData.Force, clientData.NoComplain,
                    ref pathType, ref deleteError);

                if (deleteCode == ReturnCode.Ok)
                {
                    if (list != null)
                    {
                        list.Add(path);
                        list.Add(clientData.ToString());
                    }
                }
                else
                {
                    DebugOps.Complain(this, deleteCode, deleteError);
                    continue;
                }

                TraceOps.DebugTrace(String.Format(
                    "CleanupAndMaybeResetPaths: DELETED {0}{1}: {2}",
                    (pathType != null) ? String.Format("{0} ",
                    pathType) : String.Empty, FormatOps.WrapOrNull(path),
                    clientData.ToString()), typeof(Interpreter).Name,
                    TracePriority.FileSystemDebug);
            }

            cleanupPaths.Clear();

            if (reset)
                cleanupPaths = null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeTextWriters()
        {
            TraceOps.DebugTrace(String.Format(
                "DisposeTextWriters: This will be the final trace message " +
                "for interpreter {0} emitted via the configured text writer.",
                id), typeof(Interpreter).Name, TracePriority.DisposalDebug);

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Dispose TraceTextWriter
            if (traceTextWriter != null)
            {
                if (IsTraceTextWriterOwned())
                {
                    string textWriterName = null;

                    try
                    {
                        textWriterName = EntityOps.GetNameNoThrow(traceTextWriter);
                    }
                    catch
                    {
                        // do nothing.
                    }

                    ReturnCode code = ReturnCode.Ok;
                    Result error = null;

                    try
                    {
                        code = ObjectOps.TryDispose<TextWriter>(
                            ref traceTextWriter, ref error);
                    }
                    catch (Exception e)
                    {
                        error = String.Format(
                            "caught exception while disposing trace text writer {0}: {1}",
                            FormatOps.WrapOrNull(textWriterName), e);

                        code = ReturnCode.Error;
                    }

                    if (code != ReturnCode.Ok)
                        DebugOps.Complain(this, code, error);
                }

                traceTextWriter = null;
            }
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Dispose DebugTextWriter
            if (debugTextWriter != null)
            {
                if (IsDebugTextWriterOwned())
                {
                    string textWriterName = null;

                    try
                    {
                        textWriterName = EntityOps.GetNameNoThrow(debugTextWriter);
                    }
                    catch
                    {
                        // do nothing.
                    }

                    ReturnCode code = ReturnCode.Ok;
                    Result error = null;

                    try
                    {
                        code = ObjectOps.TryDispose<TextWriter>(
                            ref debugTextWriter, ref error);
                    }
                    catch (Exception e)
                    {
                        error = String.Format(
                            "caught exception while disposing debug text writer {0}: {1}",
                            FormatOps.WrapOrNull(textWriterName), e);

                        code = ReturnCode.Error;
                    }

                    if (code != ReturnCode.Ok)
                        DebugOps.Complain(this, code, error);
                }

                debugTextWriter = null;
            }
            #endregion
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeProfiler()
        {
            #region Dispose Profiler
            if (profiler != null)
            {
                ReturnCode code = ReturnCode.Ok;
                Result error = null;

                try
                {
                    code = ObjectOps.TryDispose<IProfilerState>(
                        ref profiler, ref error);
                }
                catch (Exception e)
                {
                    error = String.Format(
                        "caught exception while disposing profiler: {0}",
                        e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, error);

                profiler = null;
            }
            #endregion
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Random Number Generator Disposal
        private void DisposeRandomNumberGenerator()
        {
            if (randomNumberGenerator == null)
                return;

            ReturnCode code;
            Result error = null;

            try
            {
                code = ObjectOps.TryDispose<RandomNumberGenerator>(
                    ref randomNumberGenerator, ref error);
            }
            catch (Exception e)
            {
                error = String.Format(
                    "caught exception while disposing random number generator: {0}",
                    e);

                code = ReturnCode.Error;
            }

            if (code != ReturnCode.Ok)
                DebugOps.Complain(this, code, error);

            randomNumberGenerator = null;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Child Interpreter Disposal
        private void DisposeChildInterpreters()
        {
            if (childInterpreters == null)
                return;

            StringList keys = new StringList(childInterpreters.Keys);

            foreach (string key in keys)
            {
                //
                // NOTE: Skip invalid interpreters, this interpreter, and
                //       any interpreters that have been shared with this
                //       interpreter (i.e. as we do not actually own them
                //       and they should not be disposed by us).
                //
                Interpreter childInterpreter = childInterpreters[key];

                if (childInterpreter == null)
                {
                    childInterpreters.Remove(key);
                    continue;
                }

                if (Object.ReferenceEquals(childInterpreter, this))
                {
                    childInterpreters.Remove(key);
                    continue;
                }

                if (childInterpreter.IsShared())
                {
                    childInterpreters.Remove(key);
                    continue;
                }

                string childInterpreterName = null;

                ReturnCode code;
                Result result = null;

                try
                {
                    childInterpreterName = EntityOps.GetNameNoThrow(childInterpreter);

                    code = ObjectOps.TryDispose<Interpreter>(
                        ref childInterpreter, ref result);

                    if (code == ReturnCode.Ok)
                    {
                        //
                        // NOTE: Child interpreter successfully disposed, remove it.
                        //
                        childInterpreters.Remove(key);
                    }
                }
                catch (Exception e)
                {
                    result = String.Format(
                        "caught exception while disposing child interpreter {0}: {1}",
                        FormatOps.WrapOrNull(childInterpreterName), e);

                    code = ReturnCode.Error;
                }

                if (code != ReturnCode.Ok)
                    DebugOps.Complain(this, code, result);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Variable Wait Disposal
        private void DisposeVariableWaits()
        {
            //
            // NOTE: Unblock any and all pending [vwait] calls now.  When they
            //       awaken, they should realize that the interpreter has been
            //       deleted (out from under them) and bail out.
            //
            SignalVariableEvent();

            //
            // NOTE: Used to keep track of how long we waited for the other
            //       thread(s) to exit their variable wait states.
            //
            int elapsedMilliseconds = 0;

            //
            // BUGFIX: Calling the GetMinimumSleepTime method here was causing
            //         an exception because the event manager was already
            //         disposed via the GC.  In the future, much more care is
            //         required to prevent this method from accessing anything
            //         that can throw ObjectDisposedException.
            //
            int sleepMilliseconds = GetMinimumSleepTime(SleepType.Variable);

            //
            // HACK: Now, block until the pending calls to WaitVariable are
            //       all cleared.  This is potentially dangerous because it
            //       could block on the GC thread (?).  This loop is designed
            //       to keep waiting until the wait count is zero OR until
            //       the maximum timeout is reached (currently about 3000
            //       milliseconds).  Also, since the deleted flag has already
            //       been set for the interpreter (above), we should not have
            //       to worry about waits being started after this point.
            //
            while (Interlocked.CompareExchange(ref waitCount, 0, 0) > 0)
            {
                //
                // NOTE: Wait for a while to give other threads a chance to
                //       unwind out of their variable wait states.
                //
                ReturnCode code;
                Result error = null;

                code = HostOps.ThreadSleep(sleepMilliseconds, ref error);

                if (code != ReturnCode.Ok)
                {
                    TraceOps.DebugTrace(String.Format(
                        "DisposeVariableWaits: thread sleep failed, " +
                        "interpreter = {0}, sleepMilliseconds = {1}, " +
                        "elapsedMilliseconds = {2}, code = {3}, error = {4}",
                        id, sleepMilliseconds, elapsedMilliseconds, code,
                        FormatOps.WrapOrNull(error)), typeof(Interpreter).Name,
                        TracePriority.CleanupDebug);

                    break;
                }

                //
                // NOTE: Keep track of the total elapsed wait time.  If this
                //       value exceeds the total [default] allowed wait time,
                //       report this situation as an error and bail out.
                //
                elapsedMilliseconds += sleepMilliseconds;

                if (elapsedMilliseconds > ThreadOps.DefaultJoinTimeout)
                {
                    TraceOps.DebugTrace(String.Format(
                        "DisposeVariableWaits: timeout waiting, " +
                        "interpreter = {0}, sleepMilliseconds = {1}, " +
                        "elapsedMilliseconds = {2}", id, sleepMilliseconds,
                        elapsedMilliseconds), typeof(Interpreter).Name,
                        TracePriority.CleanupDebug);

                    break;
                }
            }

            TraceOps.DebugTrace(String.Format(
                "DisposeVariableWaits: done waiting, " +
                "interpreter = {0}, sleepMilliseconds = {1}, " +
                "elapsedMilliseconds = {2}", id, sleepMilliseconds,
                elapsedMilliseconds), typeof(Interpreter).Name,
                TracePriority.CleanupDebug);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Setup Wait Disposal
        private void DisposeSetupWaits()
        {
            //
            // NOTE: In theory, nobody should (still) be waiting for
            //       this interpreter to be (fully) setup; however,
            //       just in case there are waiters, make sure they
            //       are all unblocked before we continue to dispose
            //       the interpreter.
            //
            SignalSetupEvent();
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Disposal Phases
        private void DisposePhase0(
            DisposalPhase phase
            )
        {
            //
            // NOTE: Terminate all calls into [vwait] now.
            //
            DisposeVariableWaits();

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Allow any callers waiting on the setup event to exit
            //       now.
            //
            DisposeSetupWaits();

            ///////////////////////////////////////////////////////////////////////////////////////////

#if NATIVE && TCL
            //
            // NOTE: Mark the native Tcl integration subsystem as not being
            //       read-only.  This is useful in case a plugin (or other
            //       component being disposed) needs to cleanup some state
            //       within it.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.NativeTcl, true))
                MakeTclReadOnly(false);
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposePhase1(
            DisposalPhase phase,
            bool reset
            )
        {
            //
            // NOTE: Dispose of any utility threads that may be running.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Thread, true))
                DisposeOtherThreads();

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Dispose any nested interpreters first.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Interpreter, true))
                DisposeChildInterpreters();

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Attempt to dispose of all registered callbacks as well as
            //       those currently in the queue, gracefully.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Callback, true))
                DisposeCallbacks();

            ///////////////////////////////////////////////////////////////////////////////////////////

#if CALLBACK_QUEUE
            DisposeCallbackQueue();
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            DisposePhase1PluginsAndCommands(phase); // native user
            DisposePhase2PluginsAndCommands(phase); // native system

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Attempt to terminate all user functions and operators
            //       gracefully.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Function, true))
                DisposeFunctions();

            if (FlagOps.HasFlags(phase, DisposalPhase.Operator, true))
                DisposeOperators();

            ///////////////////////////////////////////////////////////////////////////////////////////

#if DATA
            //
            // NOTE: Attempt to dispose our database related objects, if any.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Database, true))
            {
                DisposeTransactions();
                DisposeConnections();
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Attempt to dispose all script visible objects.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Object, true))
            {
                DisposeObjects();
                ClearAndMaybeResetClrIntegrationPodObjects(reset);
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Dispose of the open channels and encodings, if any.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Channel, true))
            {
                DisposeChannels();
                DisposeEncodings();
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Dispose the event manager, if any.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.EventManager, true))
                DisposeEventManager();

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Dispose both the "secure" random number generator and/or
            //       the System.Random instance, if any.
            //
            if (FlagOps.HasFlags(
                    phase, DisposalPhase.RandomNumberGenerator, true))
            {
                DisposeRandomNumberGenerator();
                ResetSystemRandom();
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (FlagOps.HasFlags(phase, DisposalPhase.Scope, true))
                DisposeScopes();

            if (FlagOps.HasFlags(phase, DisposalPhase.Alias, true))
                DisposeAliases();

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Clear all the "plain old data" objects associated with
            //       this interpreter.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Trusted, true))
                ClearAndMaybeResetTrustedPodObjects(reset);

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Clear all the other executable objects associated with
            //       this interpreter (procedures, hidden procedures, IExecute
            //       objects, etc).
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Procedure, true))
                ClearAndMaybeResetProcedures(reset);

            if (FlagOps.HasFlags(phase, DisposalPhase.Execute, true))
                ClearAndMaybeResetIExecutes(reset);

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (FlagOps.HasFlags(phase, DisposalPhase.Delegate, true))
            {
                traceFilterCallback = null;
                newCommandCallback = null;
                newProcedureCallback = null;
                matchCallback = null;
                readyCallback = null;
                getTimeoutCallback = null;

#if NETWORK
                preWebClientCallback = null;
                newWebClientCallback = null;
#endif

                interruptCallback = null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposePhase2(
            DisposalPhase phase,
            bool disposing,
            bool reset
            )
        {
            //
            // NOTE: Attempt to dispose of all the remaining registered
            //       callbacks as well as those currently in the queue,
            //       gracefully.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Callback, true))
                DisposeCallbacks();

            ///////////////////////////////////////////////////////////////////////////////////////////

#if CALLBACK_QUEUE
            DisposeCallbackQueue();
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            DisposePhase3PluginsAndCommands(phase); // managed user
            DisposePhase4PluginsAndCommands(phase); // managed system

            ///////////////////////////////////////////////////////////////////////////////////////////

#if EMIT && NATIVE && LIBRARY
            //
            // NOTE: Attempt to dispose the native delegates and their native
            //       modules, if any.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.NativeLibrary, true))
            {
                DisposeDelegates();
                DisposeModules();
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Dispose the packages now.  We do this after the plugins
            //       because they may wish to withdraw their associated
            //       package(s).
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Package, true))
                DisposePackages(phase);

            ///////////////////////////////////////////////////////////////////////////////////////////

#if APPDOMAINS
            //
            // NOTE: Dispose (i.e. unload) AppDomains that we own, if any.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.AppDomain, true))
                DisposeAppDomains();
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Try to delete all namespaces now, starting with the
            //       (top-most) global namespace and working our way down
            //       the "logical tree".
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Namespace, true))
            {
                ClearAndMaybeResetNamespacePodObjects(reset);
                DisposeNamespaces();
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (FlagOps.HasFlags(phase, DisposalPhase.Resolver, true))
                DisposeResolvers();

            if (FlagOps.HasFlags(phase, DisposalPhase.Policy, true))
                DisposePolicies();

            if (FlagOps.HasFlags(phase, DisposalPhase.Trace, true))
                DisposeTraces();

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Reset all the objects that plugins typically manage now.
            //       This must be done after all the plugins have been
            //       "terminated" because the associated collections are both
            //       cleared and invalidated by this method.
            //
            if (reset)
                MaybeResetStatefulObjects(disposing);

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Policies, packages, and package indexes, etc are simply
            //       data, clear them now.  We have to wait until this point
            //       in case plugins refer to any of them while unloading.
            //
            ClearAndMaybeResetLatePodObjects(reset);

            ///////////////////////////////////////////////////////////////////////////////////////////

#if DEBUGGER && !THREADING
            //
            // NOTE: Dispose our debugger, if any, now.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.Debugger, true))
                DisposeDebugger();
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposePhase3(
            DisposalPhase phase
            )
        {
            //
            // NOTE: Reset all the user-defined and application-defined
            //       objects.  We do not actually "dispose" these objects
            //       because they do not belong to us.
            //
            ResetUserObjects();

            ///////////////////////////////////////////////////////////////////////////////////////////

#if WINFORMS
            //
            // HACK: Also reset the status objects, e.g. the status form
            //       and its associated resources.
            //
            MaybeStopStatusThread(GetStatusSynchronous(true, true));
            ResetStatusSubsystem();
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if NATIVE && TCL
        private void DisposePhase4(
            DisposalPhase phase,
            bool disposing
            )
        {
            //
            // NOTE: Dispose of our [native] Tcl related objects, if any, now.
            //       If we are on
            //       the wrong thread, the orphaned objects will be turned into
            //       "zombies" for later pickup by the next Interpreter object
            //       to be created on this thread.  Complaints (i.e. priority
            //       error messages) will be reported if any errors are
            //       encountered during this disposal process.
            //
            // HACK: Perhaps stronger measures are needed here to help prevent
            //       resource leaks?  However, the Dispose method is a very
            //       limited place.  For one thing, it has no means of
            //       communicating failure to the caller, which may be the GC
            //       thread (i.e. it is not supposed to throw exceptions and it
            //       returns no results).
            //
            // WARNING: All users of Interpreter objects are STRONGLY advised
            //          and encouraged to Dispose of their Interpreter objects
            //          [on the same thread they were created on] just as soon
            //          as they are finished with them; otherwise, all the
            //          [native] resources used by them will be disposed of on
            //          a "best-effort" basis.
            //
            if (FlagOps.HasFlags(phase, DisposalPhase.NativeTcl, true))
                DisposeTcl(true, disposing, false);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposePhase5(
            bool disposing
            )
        {
            //
            // BUGFIX: Previously, this was done without the interpreter
            //         lock; however, since the context manager instance
            //         itself is shared by all threads, that was wrong.
            //         From now on, the lock will be held by the caller
            //         for the entire duration of this method.
            //
            DisposeThreadAndContextManager(disposing);

            ///////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Dispose the host environment last.  This must be done
            //       without holding the lock on the Interpreter SyncRoot;
            //       otherwise, a deadlock can occur.
            //
            //       Deadlock Example:
            //
            //       1. This thread (thread #1) holds the lock on the
            //          Interpreter SyncRoot and wants the implicit lock
            //          on the System.Console object to remove its
            //          ConsoleCancelEventHandler.
            //
            //       2. The other thread (thread #2) holds the implicit
            //          lock on the System.Console object while the call
            //          to CancelEvaluate is pending awaiting the lock on
            //          the Interpreter SyncRoot.
            //
            DisposeHost();

            ///////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Dispose (really delete) any temporary paths associated
            //       with this interpreter now.  Since this may rely on the
            //       tracing subsystem, we do this before disposing of the
            //       TextWriter instances (below).
            //
            CleanupAndMaybeResetPaths(true);

            ///////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Dispose of the configured TextWriter instances right
            //       before the host.  This allows them to be used during
            //       interpreter disposal, even if they rely on the IHost
            //       implementation in order to do their work.  Obviously,
            //       this precludes them from being used during disposal
            //       of the host itself; however, if the host needs trace
            //       output during its disposal, it can be done entirely
            //       within the host itself.
            //
            DisposeTextWriters();

            ///////////////////////////////////////////////////////////////////////////////////////

            DisposeProfiler();
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Miscellaneous Disposal Methods
        //
        // NOTE: For use by the ScriptOps.PrepareForStaticData method only.
        //
        internal void RemoveNonBaseObjects(
            bool safe
            )
        {
            RemoveNonBaseObjects(DisposalPhase.NonBaseMask, safe);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void RemoveNonBaseObjects(
            DisposalPhase phase,
            bool safe
            )
        {
            //
            // NOTE: To avoid potential deadlocks with the event manager,
            //       the first phase of disposal must be done outside the
            //       interpreter lock, just like the Dispose() method
            //       itself does.  Also, temporarily mark the interpreter
            //       as "deleted" so the variable waits actually bail out.
            //
            bool savedDeleted;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                savedDeleted = deleted;
                deleted = true;
            }

            try
            {
                DisposePhase0(phase);
            }
            finally
            {
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    deleted = savedDeleted;
                }
            }

            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // NOTE: Perform most of the Dispose() process for the
                //       interpreter, leaving only the necessary objects
                //       to support commands and variables.  This will
                //       also include all (three of) the core plugins
                //       and their associated packages.
                //
                DisposePhase1(phase, false);
                DisposePhase2(phase, false, false);
                DisposePhase3(phase);
            }

#if NATIVE && TCL
            DisposePhase4(phase, false);
#endif

            lock (syncRoot) /* TRANSACTIONAL */
            {
                //
                // NOTE: If needed, manually dispose of all hidden commands.
                //       They may not have been disposed above because the
                //       required disposal phase may not be included in the
                //       mask used.
                //
                if (safe && !FlagOps.HasFlags(
                        phase, DisposalPhase.Command, true))
                {
                    DisposeHiddenCommands();
                }

                //
                // NOTE: Disable event processing by the engine.  This
                //       is necessary because we disposed of the event
                //       manager.
                //
                if (FlagOps.HasFlags(
                        phase, DisposalPhase.EventManager, true))
                {
                    engineFlags |= EngineFlags.NoEvent;
                }
            }

#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || EXECUTE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
            //
            // NOTE: Avoid potential deadlocks (with HelpOps, etc)
            //       by doing this outside of the interpreter lock.
            //
            ResetOrClearCaches(false);
#endif
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Disposal Helper Methods (Reset/Clear)
#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || EXECUTE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
        private void ResetOrClearCaches(
            bool reset
            )
        {
            //
            // HACK: Attempt to clear our cached data.  If the
            //       interpreter lock cannot be obtained, issue
            //       a warning and then do nothing as clearing
            //       the caches is non-critical.  This is a bit
            //       wonky; however, this method is called from
            //       places where it could potentially cause a
            //       deadlock.  At some point, tests should be
            //       added to verify this assumption.
            //
            bool locked = false;

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    if (reset)
                    {
                        //
                        // WARNING: The method called here grabs
                        //          the interpreter lock.
                        //
                        /* IGNORED */
                        ResetCaches(CacheFlags.ObjectMask);
                    }
                    else
                    {
                        //
                        // WARNING: The method called here grabs
                        //          the interpreter lock.
                        //
                        /* IGNORED */
                        PrivateClearCaches(CacheFlags.ObjectMask);
                    }
                }
                else
                {
                    TraceOps.DebugTrace(
                        "ResetOrClearCaches: unable to acquire lock",
                        typeof(Interpreter).Name,
                        TracePriority.LockWarning);
                }
            }
            finally
            {
                InternalExitLock(ref locked);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private CacheFlags ResetCaches(
            CacheFlags flags
            )
        {
            Dictionary<CacheFlags, long[]> savedCacheCounts = null;

            return ResetCaches(flags, ref savedCacheCounts);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private CacheFlags ResetCaches(
            CacheFlags flags,
            ref Dictionary<CacheFlags, long[]> savedCacheCounts
            )
        {
            CacheFlags newFlags = CacheFlags.None;

            lock (syncRoot) /* TRANSACTIONAL */
            {
                #region Argument Cache
#if ARGUMENT_CACHE
                if ((argumentCache != null) &&
                    FlagOps.HasFlags(flags, CacheFlags.Argument, true))
                {
#if CACHE_STATISTICS
                    if (FlagOps.HasFlags(
                            flags, CacheFlags.KeepCounts, true))
                    {
                        /* IGNORED */
                        RuntimeOps.MaybeSaveCacheCounts(
                            CacheFlags.Argument, argumentCache, false,
                            ref savedCacheCounts);
                    }
                    else if (FlagOps.HasFlags(
                            flags, CacheFlags.ZeroCounts, true))
                    {
                        argumentCache.ZeroCacheCounts();
                    }
#endif

                    argumentCache.Clear();
                    argumentCache = null;

                    newFlags |= CacheFlags.Argument;
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region StringList Cache
#if LIST_CACHE
                if ((stringListCache != null) &&
                    FlagOps.HasFlags(flags, CacheFlags.StringList, true))
                {
#if CACHE_STATISTICS
                    if (FlagOps.HasFlags(
                            flags, CacheFlags.KeepCounts, true))
                    {
                        /* IGNORED */
                        RuntimeOps.MaybeSaveCacheCounts(
                            CacheFlags.StringList, stringListCache, false,
                            ref savedCacheCounts);
                    }
                    else if (FlagOps.HasFlags(
                            flags, CacheFlags.ZeroCounts, true))
                    {
                        stringListCache.ZeroCacheCounts();
                    }
#endif

                    stringListCache.Clear();
                    stringListCache = null;

                    newFlags |= CacheFlags.StringList;
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region ParseState Cache
#if PARSE_CACHE
                if ((parseStateCache != null) &&
                    FlagOps.HasFlags(flags, CacheFlags.IParseState, true))
                {
#if CACHE_STATISTICS
                    if (FlagOps.HasFlags(
                            flags, CacheFlags.KeepCounts, true))
                    {
                        /* IGNORED */
                        RuntimeOps.MaybeSaveCacheCounts(
                            CacheFlags.IParseState, parseStateCache, false,
                            ref savedCacheCounts);
                    }
                    else if (FlagOps.HasFlags(
                            flags, CacheFlags.ZeroCounts, true))
                    {
                        parseStateCache.ZeroCacheCounts();
                    }
#endif

                    parseStateCache.Clear();
                    parseStateCache = null;

                    newFlags |= CacheFlags.IParseState;
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region IExecute Cache
#if EXECUTE_CACHE
                if (FlagOps.HasFlags(flags, CacheFlags.IExecute, true))
                {
                    if (hiddenExecuteCache != null)
                    {
#if CACHE_STATISTICS
                        if (FlagOps.HasFlags(
                                flags, CacheFlags.KeepCounts, true))
                        {
                            /* IGNORED */
                            RuntimeOps.MaybeSaveCacheCounts(
                                CacheFlags.HiddenIExecute, hiddenExecuteCache, false,
                                ref savedCacheCounts);
                        }
                        else if (FlagOps.HasFlags(
                            flags, CacheFlags.ZeroCounts, true))
                        {
                            hiddenExecuteCache.ZeroCacheCounts();
                        }
#endif

                        hiddenExecuteCache.Clear();
                        hiddenExecuteCache = null;

                        newFlags |= CacheFlags.IExecute; /* NOTE: Not a typo. */
                    }

                    if (executeCache != null)
                    {
#if CACHE_STATISTICS
                        if (FlagOps.HasFlags(
                                flags, CacheFlags.KeepCounts, true))
                        {
                            /* IGNORED */
                            RuntimeOps.MaybeSaveCacheCounts(
                                CacheFlags.IExecute, executeCache, false,
                                ref savedCacheCounts);
                        }
                        else if (FlagOps.HasFlags(
                            flags, CacheFlags.ZeroCounts, true))
                        {
                            executeCache.ZeroCacheCounts();
                        }
#endif

                        executeCache.Clear();
                        executeCache = null;

                        newFlags |= CacheFlags.IExecute; /* NOTE: Not a typo. */
                    }
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region Type Cache
#if TYPE_CACHE
                if ((typeCache != null) &&
                    FlagOps.HasFlags(flags, CacheFlags.Type, true))
                {
#if CACHE_STATISTICS
                    if (FlagOps.HasFlags(
                            flags, CacheFlags.KeepCounts, true))
                    {
                        /* IGNORED */
                        RuntimeOps.MaybeSaveCacheCounts(
                            CacheFlags.Type, typeCache, false,
                            ref savedCacheCounts);
                    }
                    else if (FlagOps.HasFlags(
                            flags, CacheFlags.ZeroCounts, true))
                    {
                        typeCache.ZeroCacheCounts();
                    }
#endif

                    typeCache.Clear();
                    typeCache = null;

                    newFlags |= CacheFlags.Type;
                }
#endif
                #endregion

                ///////////////////////////////////////////////////////////////////////////////////////

                #region ComTypeList Cache
#if COM_TYPE_CACHE
                if ((comTypeListCache != null) &&
                    FlagOps.HasFlags(flags, CacheFlags.ComTypeList, true))
                {
#if CACHE_STATISTICS
                    if (FlagOps.HasFlags(
                            flags, CacheFlags.KeepCounts, true))
                    {
                        /* IGNORED */
                        RuntimeOps.MaybeSaveCacheCounts(
                            CacheFlags.ComTypeList, comTypeListCache, false,
                            ref savedCacheCounts);
                    }
                    else if (FlagOps.HasFlags(
                            flags, CacheFlags.ZeroCounts, true))
                    {
                        comTypeListCache.ZeroCacheCounts();
                    }
#endif

                    comTypeListCache.Clear();
                    comTypeListCache = null;

                    newFlags |= CacheFlags.ComTypeList;
                }
#endif
                #endregion
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            return FlagOps.HasFlags(newFlags, flags & CacheFlags.ObjectMask, true) ?
                CacheFlags.Clear : CacheFlags.None;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if SHELL
        private void ClearAndMaybeResetPausedInteractiveLoops(
            bool reset
            )
        {
            if (pausedInteractiveLoops != null)
            {
                pausedInteractiveLoops.Clear();

                if (reset)
                    pausedInteractiveLoops = null;
            }
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void ClearAndMaybeResetNamespacePodObjects(
            bool reset
            )
        {
            #region Mappings
            //
            // NOTE: Clear all namespace mappings now.  These are just plain
            //       data and do not require any special disposal steps.
            //
            if (namespaceMappings != null)
            {
                namespaceMappings.Clear();

                if (reset)
                    namespaceMappings = null;
            }
            #endregion

            ///////////////////////////////////////////////////////////////////////////////////////////

            #region Pending Deletion List
            //
            // HACK: This code currently assumes that all namespaces pending
            //       deletion are also *still* present in the "logical tree"
            //       of namespaces starting from the global namespace.  If
            //       this assumption is not true, this code will likely not
            //       work correctly.  Therefore, we ignore pending namespace
            //       deletions during interpreter disposal because *ALL* of
            //       the namespaces should get disposed by this method.
            //
            if (pendingNamespaces != null)
            {
                pendingNamespaces.Clear();

                if (reset)
                    pendingNamespaces = null;
            }
            #endregion
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void ClearAndMaybeResetProcedures(
            bool reset
            )
        {
            if (procedures != null)
            {
                procedures.Clear();

                if (reset)
                    procedures = null;
            }

            if (hiddenProcedures != null)
            {
                hiddenProcedures.Clear();

                if (reset)
                    hiddenProcedures = null;
            }

            #region Dead Code
#if DEAD_CODE
            if (lambdas != null)
            {
                lambdas.Clear();

                if (reset)
                    lambdas = null;
            }
#endif
            #endregion
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void ClearAndMaybeResetIExecutes(
            bool reset
            )
        {
            if (executes != null)
            {
                executes.Clear();

                if (reset)
                    executes = null;
            }

            if (hiddenExecutes != null)
            {
                hiddenExecutes.Clear();

                if (reset)
                    hiddenExecutes = null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void ClearAndMaybeResetClrIntegrationPodObjects(
            bool reset
            )
        {
            if (objectAliasNamespaces != null)
            {
                objectAliasNamespaces.Clear();

                if (reset)
                    objectAliasNamespaces = null;
            }

            if (objectInterfaces != null)
            {
                objectInterfaces.Clear();

                if (reset)
                    objectInterfaces = null;
            }

            if (objectNamespaces != null)
            {
                objectNamespaces.Clear();

                if (reset)
                    objectNamespaces = null;
            }

            if (objectTypes != null)
            {
                objectTypes.Clear();

                if (reset)
                    objectTypes = null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void ClearAndMaybeResetTrustedPodObjects(
            bool reset
            )
        {
            if (trustedPaths != null)
            {
                trustedPaths.Clear();

                if (reset)
                    trustedPaths = null;
            }

            if (trustedUris != null)
            {
                trustedUris.Clear();

                if (reset)
                    trustedUris = null;
            }

            if (trustedTypes != null)
            {
                trustedTypes.Clear();

                if (reset)
                    trustedTypes = null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void ResetSystemRandom()
        {
            if (random != null)
                random = null;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void ClearAndMaybeResetLatePodObjects(
            bool reset
            )
        {
            if (runtimeOptions != null)
            {
                runtimeOptions.Clear();

                if (reset)
                    runtimeOptions = null;
            }

            if (pluginArguments != null)
            {
                pluginArguments.Clear();

                if (reset)
                    pluginArguments = null;
            }

            if (packageIndexes != null)
            {
                packageIndexes.Clear();

                if (reset)
                    packageIndexes = null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void ResetUserObjects()
        {
            if (userObject != null)
                userObject = null; /* WARNING: Not owner, do NOT dispose. */

            if (resolverObject != null)
                resolverObject = null; /* WARNING: Not owner, do NOT dispose. */

            if (policyObject != null)
                policyObject = null; /* WARNING: Not owner, do NOT dispose. */

            if (applicationObject != null)
                applicationObject = null; /* WARNING: Not owner, do NOT dispose. */
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if WINFORMS
        private void MaybeStopStatusThread(
            bool synchronous /* in */
            )
        {
            //
            // BUGBUG: Technically, this call to StopThread should
            //         not be required.  The reasoning behind this
            //         is that the target thread is running in an
            //         event processing loop that checks to see if
            //         the interpreter is still valid within each
            //         loop iteration.
            //
            if (statusThread != null)
            {
                /* IGNORED */
                StatusFormOps.StopThread(this, synchronous);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal void ResetStatusSubsystem()
        {
            Interlocked.Exchange(ref statusThread, null);
            Interlocked.Exchange(ref statusStartEventName, null);
            Interlocked.Exchange(ref statusDoneEventName, null);
            Interlocked.Exchange(ref statusObject, null); /* NOT OWNED */
            Interlocked.Exchange(ref statusCallback, null);
            Interlocked.Exchange(ref statusLevels, 0);
            Interlocked.Exchange(ref statusDisposed, 0);
            Interlocked.Exchange(ref statusIterations, 0);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This method resets the collections of objects that plugins
        //          typically rely upon, most of which require the Terminate()
        //          method handling.  This method must be called only AFTER
        //          attempting to gracefully unload all the loaded plugins,
        //          including those that may contain or reference native code.
        //
        // HACK: For now, disable complaining about "leftover" stateful object
        //       if we are being called via the GC (i.e. not being disposed by
        //       an explicit call to Dispose()).
        //
        private void MaybeResetStatefulObjects(
            bool disposing
            )
        {
            if (childInterpreters != null)
            {
                if (disposing && (childInterpreters.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} child interpreters.", childInterpreters.Count));
                }

                childInterpreters.Clear();
                childInterpreters = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (scopes != null)
            {
                if (disposing && (scopes.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} scopes.", scopes.Count));
                }

                scopes.Clear();
                scopes = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (aliases != null)
            {
                if (disposing && (aliases.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} aliases.", aliases.Count));
                }

                aliases.Clear();
                aliases = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (plugins != null)
            {
                if (disposing && (plugins.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} plugins.", plugins.Count));
                }

                plugins.Clear();
                plugins = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

#if NOTIFY || NOTIFY_OBJECT
            if (notifyPlugins != null)
            {
                if (disposing && (notifyPlugins.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} notify plugins.", notifyPlugins.Count));
                }

                notifyPlugins.Clear();
                notifyPlugins = null;
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (packages != null)
            {
                if (disposing && (packages.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} packages.", packages.Count));
                }

                packages.Clear();
                packages = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (operators != null)
            {
                if (disposing && (operators.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} operators.", operators.Count));
                }

                operators.Clear();
                operators = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            int count = ClearOperatorCache(true);

            if (disposing && (count > 0))
            {
                DebugOps.Complain(this, ReturnCode.Error, String.Format(
                    "Have {0} cached operators.", count));
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (functions != null)
            {
                if (disposing && (functions.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} functions.", functions.Count));
                }

                functions.Clear();
                functions = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (hiddenCommands != null)
            {
                if (disposing && (hiddenCommands.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} hidden commands.", hiddenCommands.Count));
                }

                hiddenCommands.Clear();
                hiddenCommands = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (commands != null)
            {
                if (disposing && (commands.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} commands.", commands.Count));
                }

                commands.Clear();
                commands = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (resolvers != null)
            {
                if (disposing && (resolvers.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} resolvers.", resolvers.Count));
                }

                resolvers.Clear();
                resolvers = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (policies != null)
            {
                if (disposing && (policies.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} policies.", policies.Count));
                }

                policies.Clear();
                policies = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (traces != null)
            {
                if (disposing && (traces.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} traces.", traces.Count));
                }

                traces.Clear();
                traces = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (objects != null)
            {
                if (disposing && (objects.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} objects.", objects.Count));
                }

                objects.Clear();
                objects = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (channels != null)
            {
                if (disposing && (channels.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} channels.", channels.Count));
                }

                channels.Clear();
                channels = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (encodings != null)
            {
                if (disposing && (encodings.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} encodings.", encodings.Count));
                }

                encodings.Clear();
                encodings = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

#if CALLBACK_QUEUE
            if (callbackQueue != null)
            {
                if (disposing && (callbackQueue.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} queued callbacks.", callbackQueue.Count));
                }

                callbackQueue.Clear();
                callbackQueue = null;
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (callbacks != null)
            {
                if (disposing && (callbacks.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} callbacks.", callbacks.Count));
                }

                callbacks.Clear();
                callbacks = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

#if DATA
            if (transactions != null)
            {
                if (disposing && (transactions.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} database transactions.", transactions.Count));
                }

                transactions.Clear();
                transactions = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (connections != null)
            {
                if (disposing && (connections.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} database connections.", connections.Count));
                }

                connections.Clear();
                connections = null;
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if APPDOMAINS
            if (appDomains != null)
            {
                if (disposing && (appDomains.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} application domains.", appDomains.Count));
                }

                appDomains.Clear();
                appDomains = null;
            }
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if EMIT && NATIVE && LIBRARY
            if (modules != null)
            {
                if (disposing && (modules.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} native modules.", modules.Count));
                }

                modules.Clear();
                modules = null;
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            if (delegates != null)
            {
                if (disposing && (delegates.Count > 0))
                {
                    DebugOps.Complain(this, ReturnCode.Error, String.Format(
                        "Have {0} native delegates.", delegates.Count));
                }

                delegates.Clear();
                delegates = null;
            }
#endif
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Disposal Helper Methods (Callbacks)
        private static void RemoveTargetDisposeCallback(
            IAlias alias
            )
        {
            try
            {
                if (alias != null)
                {
                    Interpreter targetInterpreter = alias.TargetInterpreter;

                    if (targetInterpreter != null)
                        targetInterpreter.RemoveDisposeCallback(alias);
                }
            }
            catch (Exception e)
            {
                TraceOps.DebugTrace(
                    e, typeof(Interpreter).Name,
                    TracePriority.CallbackError);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void RemoveDisposeCallback(
            IAlias alias
            )
        {
            try
            {
                lock (syncRoot) /* TRANSACTIONAL */
                {
                    if (postDisposeCallbacks != null)
                    {
                        DisposeCallback callback = alias.PostInterpreterDisposed;

                        if (callback != null)
                            postDisposeCallbacks -= callback;
                    }
                }
            }
            catch (Exception e)
            {
                TraceOps.DebugTrace(
                    e, typeof(Interpreter).Name,
                    TracePriority.CallbackError);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void ResetPreDisposeCallbacks()
        {
            lock (syncRoot)
            {
                preDisposeCallbacks = null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool FirePreDisposeCallbacks()
        {
            try
            {
                DisposeCallback localPreDisposeCallbacks;

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    localPreDisposeCallbacks = preDisposeCallbacks;
                }

                //
                // BUGFIX: Do not hold the interpreter lock while invoking
                //         the callbacks as that could lead to deadlocks.
                //
                if (localPreDisposeCallbacks != null)
                {
                    localPreDisposeCallbacks(this);
                    return true;
                }
            }
            catch (Exception e)
            {
                TraceOps.DebugTrace(
                    e, typeof(Interpreter).Name,
                    TracePriority.CallbackError);
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void ResetPostDisposeCallbacks()
        {
            lock (syncRoot)
            {
                postDisposeCallbacks = null;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool FirePostDisposeCallbacks()
        {
            try
            {
                DisposeCallback localPostDisposeCallbacks;

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    localPostDisposeCallbacks = postDisposeCallbacks;
                }

                //
                // BUGFIX: Do not hold the interpreter lock while invoking
                //         the callbacks as that could lead to deadlocks.
                //
                if (localPostDisposeCallbacks != null)
                {
                    localPostDisposeCallbacks(this);
                    return true;
                }
            }
            catch (Exception e)
            {
                TraceOps.DebugTrace(
                    e, typeof(Interpreter).Name,
                    TracePriority.CallbackError);
            }

            return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For now, this event is internal only; however, it may
        //       eventually be exposed.
        //
        internal event DisposeCallback PreInterpreterDisposed
        {
            add
            {
                // CheckDisposed();

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    preDisposeCallbacks -= value;
                    preDisposeCallbacks += value;
                }
            }
            remove
            {
                // CheckDisposed();

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    preDisposeCallbacks -= value;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // NOTE: For now, this event is internal only; however, it may
        //       eventually be exposed.
        //
        internal event DisposeCallback PostInterpreterDisposed
        {
            add
            {
                // CheckDisposed();

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    postDisposeCallbacks -= value;
                    postDisposeCallbacks += value;
                }
            }
            remove
            {
                // CheckDisposed();

                lock (syncRoot) /* TRANSACTIONAL */
                {
                    postDisposeCallbacks -= value;
                }
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IDisposable "Pattern" Members
        internal bool Deleted
        {
            get
            {
                lock (syncRoot)
                {
                    //
                    // NOTE: This flag is special.  Non-zero indicates that the
                    //       interpreter is currently being disposed; however,
                    //       the disposal process has not yet completed.  This
                    //       flag is checked and enforced by the Ready method
                    //       to prevent scripts from being evaluated during the
                    //       disposal process.
                    //
                    return InternalDeleted;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal bool InternalDeleted
        {
            get { /* NO-LOCK */ return deleted; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TEST
        internal void SetDisposed(
            bool disposed
            )
        {
            this.disposed = disposed;
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool PrivateDisposed
        {
            get { /* NO-LOCK */ return disposed; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: For use by the TestDebugInteractiveLoopCallback method
        //          only.
        //
        internal bool InternalDisposed
        {
            get { /* NO-LOCK */ return disposed; }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

#if TEST
        #region Dead Code
#if DEAD_CODE
        internal static int GlobalCreateCount
        {
            get
            {
                return Interlocked.CompareExchange(
                    ref globalCreateCount, 0, 0);
            }
        }
#endif
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static int GlobalDisposeCount
        {
            get
            {
                return Interlocked.CompareExchange(
                    ref globalDisposeCount, 0, 0);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // TODO: *HACK* This uses the same technique as the "interp-1.12"
        //       test.  Any changes that are necessary to keep it working
        //       should be made in both places.
        //
        internal void ClearReferences()
        {
            _Hosts.File fileHost = host as _Hosts.File;

            if (fileHost != null)
            {
                fileHost.ResetInterpreter(true);
                fileHost = null;
            }

#if THREADING
            IDisposable disposable = contextManager as IDisposable;

            if (disposable != null)
            {
                disposable.Dispose();
                disposable = null;
            }
#endif

            /* IGNORED */
            EngineThread.CleanupInterpreter(this);

            /* IGNORED */
            GlobalState.RemoveInterpreter(this);

            /* IGNORED */
            GlobalState.RemoveTokenInterpreter(this);
        }
#endif

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsDisposedOrPending(
            bool noTrace
            )
        {
            Result error = null;

            return IsDisposedOrPending(noTrace, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsDisposedOrPending(
            bool noTrace,
            ref Result error
            )
        {
            bool trace = false;
            bool locked = false;

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    if (disposed)
                    {
                        error = "interpreter is disposed";
                        trace = true;

                        return true;
                    }

                    if (Interlocked.CompareExchange(
                            ref disposeCount, 0, 0) > 0)
                    {
                        error = "interpreter is pending dispose";
                        trace = true;

                        return true;
                    }

                    return false;
                }
                else
                {
                    error = "unable to acquire lock";
                    trace = true;

                    return false;
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */

                if (trace)
                {
                    if (!noTrace)
                    {
                        TraceOps.DebugTrace(String.Format(
                            "IsDisposedOrPending: {0}", error),
                            typeof(Interpreter).Name,
                            TracePriority.CleanupWarning2);
                    }

                    trace = false;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsPendingDispose()
        {
            return Interlocked.CompareExchange(
                ref disposeCount, 0, 0) > 0;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static bool IsPendingDispose(
            Interpreter interpreter
            )
        {
            if (interpreter == null)
                return false;

            return interpreter.IsPendingDispose();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private bool IsDeletedOrDisposed(
            bool noTrace,
            ref Result error
            )
        {
            bool trace = false;
            bool locked = false;

            try
            {
                InternalHardTryLock(ref locked); /* TRANSACTIONAL */

                if (locked)
                {
                    if (deleted)
                    {
                        error = "interpreter is deleted";
                        trace = true;

                        return true;
                    }

                    if (disposed)
                    {
                        error = "interpreter is disposed";
                        trace = true;

                        return true;
                    }

                    return false;
                }
                else
                {
                    error = "unable to acquire lock";
                    trace = true;

                    return false;
                }
            }
            finally
            {
                InternalExitLock(ref locked); /* TRANSACTIONAL */

                if (trace)
                {
                    if (!noTrace)
                    {
                        TraceOps.DebugTrace(String.Format(
                            "IsDeletedOrDisposed: {0}", error),
                            typeof(Interpreter).Name,
                            TracePriority.CleanupWarning2);
                    }

                    trace = false;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static bool IsDeletedOrDisposed(
            Interpreter interpreter,
            bool noTrace
            )
        {
            Result error = null;

            return IsDeletedOrDisposed(interpreter, noTrace, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        internal static bool IsDeletedOrDisposed(
            Interpreter interpreter,
            bool noTrace,
            ref Result error
            )
        {
            if (interpreter == null)
                return false;

            return interpreter.IsDeletedOrDisposed(noTrace, ref error);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void CheckDisposed() /* throw */
        {
#if THROW_ON_DISPOSED
            if (disposed && Engine.IsThrowOnDisposed(this, true)) /* EXEMPT */
                throw new InterpreterDisposedException(this, typeof(Interpreter));
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void DisposeTrace(
            bool disabled,
            bool disposing
            )
        {
            TraceOps.DebugTrace(String.Format(
                "Dispose: {0} called via {1} for interpreter {2} on thread {3} " +
                "(primary thread is {4}), in application domain {5}, dispose " +
                "count is {6}, event count is {7}, Tcl event count is {8}, " +
                "Tcl sleep count is {9}, wait count is {10}, wait spin count " +
                "is {11}, already disposed is {12}",
                disabled ? "DISABLED" : "ENABLED",
                disposing ? typeof(IDisposable).Name : "destructor",
                id, GlobalState.GetCurrentSystemThreadId(), threadId,
                AppDomainOps.GetCurrentId(), Interlocked.CompareExchange(
                ref disposeCount, 0, 0), eventCount,
#if NATIVE && TCL
                tclEventCount,
                tclSleepCount,
#else
                0,
                0,
#endif
                waitCount, waitSpinCount, disposed),
                typeof(Interpreter).Name, TracePriority.CleanupDebug);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        private /* protected virtual */ void Dispose(
            bool disposing
            )
        {
            Interlocked.Increment(ref globalDisposeCount);

            DisposeTrace(false, disposing);

            if (!disposed)
            {
                if (Interlocked.Increment(ref disposeCount) == 1)
                {
                    //
                    // NOTE: Fire the configured "Free" static callback, if any, with a null value
                    //       for the IClientData.  This cannot throw an exception -AND- its return
                    //       value will be ignored.
                    //
                    FireFreeInterpreterCallbackOrTrace(this, null);

                    ///////////////////////////////////////////////////////////////////////////////////

#if NOTIFY || NOTIFY_OBJECT
                    //
                    // BUGFIX: Prevent notifications from firing and indirectly recreating anything
                    //         we have disposed (especially thread specific data).
                    //
                    lock (syncRoot) /* TRANSACTIONAL */
                    {
                        notifyFlags |= NotifyFlags.NoNotify;
                    }
#endif

                    ///////////////////////////////////////////////////////////////////////////////////

#if SHELL
                    //
                    // HACK: Next, make sure that all interactive loops are "unpaused" before doing
                    //       anything else.
                    //
                    lock (syncRoot) /* TRANSACTIONAL */
                    {
                        ClearAndMaybeResetPausedInteractiveLoops(true);
                    }

                    //
                    // HACK: Why are we resetting this value to zero here?  If the interactive loops
                    //       are going to exit clean, they will decrement; otherwise, they are still
                    //       running and this field will not be accurate.
                    //
                    /* IGNORED */
                    Interlocked.Exchange(ref globalInteractiveLoops, 0);
#endif

                    ///////////////////////////////////////////////////////////////////////////////////

                    //
                    // NOTE: Allow callbacks to figure out which interpreter is terminating them (even
                    //       if they were not directly passed an Interpreter object).
                    //
                    GlobalState.PushActiveInterpreter(this);

                    ///////////////////////////////////////////////////////////////////////////////////

                    //
                    // HACK: Possibly permit script evaluation during the pre-disposal callbacks by
                    //       temporarily resetting the exit flag?
                    //
                    bool? savedExit = null;

                    /* EXEMPT */
                    if (FlagOps.HasFlags(
                            this.InterpreterFlags, InterpreterFlags.PreDisposeScripts, true))
                    {
                        lock (syncRoot) /* TRANSACTIONAL */
                        {
                            savedExit = this.PrivateExit;
                            this.PrivateExit = false;
                        }
                    }

                    try
                    {
                        //
                        // NOTE: Invoke (and then clear) the registered interpreter pre-disposal
                        //       callbacks now, if any.  It should be noted that the pre-disposal
                        //       callbacks will not be reset if they are not successfully invoked.
                        //
                        if (FirePreDisposeCallbacks()) ResetPreDisposeCallbacks();
                    }
                    finally
                    {
                        if (savedExit != null)
                        {
                            lock (syncRoot) /* TRANSACTIONAL */
                            {
                                this.PrivateExit = (bool)savedExit;
                            }
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////

                    //
                    // NOTE: Dispose of any cached interpreters that were created and/or used
                    //       by this interpreter.  This is not strictly required; however, it
                    //       prevents spurious InterpreterDisposedException exceptions from
                    //       being thrown.
                    //
                    /* IGNORED */
                    ScriptOps.MaybeClearInterpreterCache(PrivateId);

                    ///////////////////////////////////////////////////////////////////////////////////

                    //
                    // NOTE: Grab the lock [temporarily] to set the deleted flag for the interpreter.
                    //
                    lock (syncRoot) /* TRANSACTIONAL */
                    {
                        //
                        // NOTE: Mark this interpreter as "deleted" (i.e. "disposal pending") so
                        //       any "user callbacks" do not attempt to get too clever with their
                        //       shutdown/cleanup code (i.e. no script evaluation, etc).
                        //
                        if (!deleted)
                            deleted = true;

                        //
                        // NOTE: Reset the global scope call frame now.  This is done before either
                        //       the named scopes or call frames are disposed to make those jobs a
                        //       bit easier.  This must be done while holding the lock because even
                        //       though the call stack and global scope call frame are per-thread,
                        //       the named scope itself is not.  This cannot be done successfully if
                        //       the interpreter is already disposed and/or we are being called via
                        //       the destructor.
                        //
                        if (disposing)
                        {
                            ReturnCode unsetCode;
                            Result unsetError = null;

                            unsetCode = UnsetGlobalScopeCallFrame(false, ref unsetError);

                            if (unsetCode != ReturnCode.Ok)
                                DebugOps.Complain(this, unsetCode, unsetError);
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////

                    DisposePhase0(DisposalPhase.Phase0Mask | DisposalPhase.All);

                    ///////////////////////////////////////////////////////////////////////////////////

                    //
                    // NOTE: We obtain and hold the lock on the Interpreter SyncRoot for almost the
                    //       entire duration of the cleanup.
                    //
                    lock (syncRoot) /* TRANSACTIONAL */
                    {
                        //
                        // NOTE: If the interpreter was read-only and/or immutable, we need to unset
                        //       those flags before proceeding; otherwise, commands and plugins cannot
                        //       be terminated gracefully.
                        //
                        if (readOnly)
                            readOnly = false;

                        if (immutable)
                            immutable = false;

                        ///////////////////////////////////////////////////////////////////////////////

                        //
                        // NOTE: Mark the host (and the isolated host, if applicable) as now being in
                        //       "exit mode" for additional help in troubleshooting any host shutdown
                        //       issues.  This does not need to be undone later because all hosts for
                        //       this interpreter will also be disposed below.
                        //
                        HostOps.SetExiting(this, true);

                        ///////////////////////////////////////////////////////////////////////////////

                        //
                        // NOTE: Are we disposing (or being called via the finalizer)?
                        //
                        if (disposing)
                        {
                            ////////////////////////////////////
                            // dispose managed resources here...
                            ////////////////////////////////////

                            DisposePhase1(DisposalPhase.All, true);
                        }

                        //////////////////////////////////////
                        // release unmanaged resources here...
                        //////////////////////////////////////

                        DisposePhase2(DisposalPhase.All, disposing, true);

                        ///////////////////////////////////////////////////////////////////////////////

#if SHELL
                        //
                        // NOTE: Close the interactive loop event and cleanup its other
                        //       data.
                        //
                        DisposeInteractiveLoopData();
#endif

                        ///////////////////////////////////////////////////////////////////////////////

                        //
                        // NOTE: Close the variable and setup events.
                        //
                        DisposeVariableEvent();
                        DisposeSetupEvent();

                        ///////////////////////////////////////////////////////////////////////////////

                        DisposePhase3(DisposalPhase.All);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////
                    //     *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*     //
                    //                                                                               //
                    //              The interpreter lock is not held after this point.               //
                    //                                                                               //
                    //     *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*     //
                    ///////////////////////////////////////////////////////////////////////////////////

#if NATIVE && TCL
                    DisposePhase4(DisposalPhase.All, disposing);
#endif

                    ///////////////////////////////////////////////////////////////////////////////////

#if ARGUMENT_CACHE || LIST_CACHE || PARSE_CACHE || EXECUTE_CACHE || TYPE_CACHE || COM_TYPE_CACHE
                    //
                    // NOTE: Avoid potential deadlocks (with HelpOps, etc) by doing this outside
                    //       of the interpreter lock.
                    //
                    ResetOrClearCaches(true);
#endif

                    ///////////////////////////////////////////////////////////////////////////////////

                    lock (syncRoot) /* TRANSACTIONAL */
                    {
                        DisposePhase5(disposing);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////

                    //
                    // NOTE: Invoke (and then clear) the registered interpreter post-disposal
                    //       callbacks now, if any.  It should be noted that the post-disposal
                    //       callbacks will not be reset if they are not successfully invoked.
                    //
                    if (FirePostDisposeCallbacks()) ResetPostDisposeCallbacks();

                    ///////////////////////////////////////////////////////////////////////////////////

                    //
                    // NOTE: Remove this interpreter from the active interpreter stack.
                    //
                    /* IGNORED */
                    GlobalState.PopActiveInterpreter();

                    ///////////////////////////////////////////////////////////////////////////////////

                    //
                    // NOTE: Next, attempt to make sure that this interpreter is no longer on
                    //       the active stack for *any* thread.
                    //
                    int threadActiveCount = GetActiveCount(false);
                    int globalActiveCount = GetActiveCount(true);

                    if ((threadActiveCount > 0) || (globalActiveCount > 0))
                    {
                        TraceOps.DebugTrace(String.Format(
                            "Dispose: found {0} global active instances of " +
                            "interpreter {1} with {2} active instances on " +
                            "current thread while {3}", globalActiveCount,
                            id, threadActiveCount, disposing ? "disposing" :
                            "finalizing"), typeof(Interpreter).Name,
                            TracePriority.CleanupWarning);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////

                    //
                    // NOTE: Finally, remove this interpreter from the global interpreter list.
                    //
                    /* IGNORED */
                    GlobalState.RemoveInterpreter(this);

                    /* IGNORED */
                    GlobalState.RemoveTokenInterpreter(this);

                    ///////////////////////////////////////////////////////////////////////////////////

#if NOTIFY && NOTIFY_GLOBAL
                    //
                    // NOTE: Grab the global notify setting now because we need it after marking the
                    //       interpreter as disposed.
                    //
                    bool notify = this.PrivateGlobalNotify;
#endif

                    ///////////////////////////////////////////////////////////////////////////////////

                    //
                    // NOTE: This object is now fully disposed.  We have reset all of the internal
                    //       data necessary for this object to function correctly and there is
                    //       currently no supported way to "revive" it; therefore, it should never
                    //       be used again after this point.  This constraint is [normally] enforced
                    //       by the CheckDisposed method, which is called from every publically
                    //       accessible property and method of this class.
                    //
                    disposed = true;

                    ///////////////////////////////////////////////////////////////////////////////////
                    //     *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*     //
                    //                                                                               //
                    //           The interpreter is flagged as disposed after this point.            //
                    //                                                                               //
                    //     *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING* *WARNING*     //
                    ///////////////////////////////////////////////////////////////////////////////////

#if NOTIFY && NOTIFY_GLOBAL
                    //
                    // BUGFIX: Only notify other interpreters if the global notify setting is enabled.
                    //         This prevents subtle locking issues when tearing down interpreters that
                    //         belong to different threads [OR interpreters that are currently being
                    //         used from different threads].
                    //
                    if (notify)
                    {
                        /* IGNORED */
                        CheckNotifications(
                            null, false,
                            NotifyType.Interpreter, NotifyFlags.Removed,
                            null, this,
                            null, null, null);
                    }
#endif
                }
            }

            TraceOps.DebugTrace(String.Format(
                "Dispose: exited, interpreter = {0}, disposing = {1}",
                id, disposing), typeof(Interpreter).Name,
                TracePriority.CleanupDebug);
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region System.Object Overrides
        public override bool Equals(object obj)
        {
            CheckDisposed();

            return Object.ReferenceEquals(this, obj);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public override int GetHashCode()
        {
            CheckDisposed();

            return GetHashCodeNoThrow();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public override string ToString()
        {
            CheckDisposed();

            return InternalToString();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private
        internal string InternalToString()
        {
            return PrivateId.ToString();
        }
        #endregion
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region IDisposable Members
        public void Dispose()
        {
            if (FlagOps.HasFlags(
                    interpreterStateFlags, InterpreterStateFlags.NoDispose, true))
            {
                DisposeTrace(true, false);
            }
            else
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Static Initialization
        public static void ForceStaticInitialize()
        {
            //
            // NOTE: Always initialize the ObjectOps static class near the top
            //       of this method, because it contains the MemberTypes and
            //       BindingFlags "lookup tables" needed by other classes,
            //       including TraceOps.
            //
            ObjectOps.Initialize(false);

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // HACK: Force the static CommonOps.Runtime class to be
            //       initialized now because it is required by several
            //       other classes, including this one.
            //
            /* NO RESULT */
            CommonOps.Runtime.Initialize(false);

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: When not running on the full .NET Framework, make sure to
            //       always initialize the primary thread Ids manually.
            //
            if (CommonOps.Runtime.IsMono() || CommonOps.Runtime.IsDotNetCore())
            {
                /* NO RESULT */
                GlobalState.SetupPrimaryThreadIds(false);
            }

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // NOTE: Next, initialize the static data in the ObjectOps class
            //       that requires the GlobalState class.
            //
            ObjectOps.InitializeGlobalState(false);

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // HACK: Force the static PlatformOps class to be initialized now
            //       because it is required by several other classes.
            //
            /* NO RESULT */
            PlatformOps.Initialize(false);

            ///////////////////////////////////////////////////////////////////////////////////////////

#if NATIVE
            //
            // HACK: Force the static FileOps class to be initialized now
            //       because it must be done before the NativeStack class.
            //
            FileOps.Initialize(false);

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // HACK: Force the static NativeStack class to be initialized now
            //       because it must be done before the stack is too deep.
            //
            /* NO RESULT */
            NativeStack.MaybeInitialize();

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // HACK: Force the static RuntimeOps class to be initialized now
            //       because it is required by several other classes.
            //
            /* NO RESULT */
            RuntimeOps.MaybeInitialize();

            ///////////////////////////////////////////////////////////////////////////////////////////

#if TCL
            //
            // HACK: Force the static TclApi class to be initialized now
            //       because it is required by several other classes.
            //
            /* NO RESULT */
            _TclApi.Initialize();

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // HACK: Force the static TclWrapper class to be initialized now
            //       because it is required by several other classes.
            //
            /* NO RESULT */
            TclWrapper.Initialize(false, false);
#endif
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // HACK: Force the static GlobalState class to be initialized now
            //       because it is required by several other classes.
            //
            /* IGNORED */
            GlobalState.GetPackageName();

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // HACK: Force the static Number class to be initialized now
            //       because it is required by several other classes.
            //
            /* NO RESULT */
            Number.InitializeTypes();

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // HACK: Force the static Variant class to be initialized now
            //       because it is required by several other classes.
            //
            /* NO RESULT */
            Variant.InitializeTypes();

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // HACK: Force the static Value class to be initialized now
            //       because it is required by several other classes.
            //
            /* NO RESULT */
            Value.Initialize();

            ///////////////////////////////////////////////////////////////////////////////////////////

            //
            // HACK: Force the static CertificateOps class to be initialized
            //       now because it is required by several other classes.
            //
            /* NO RESULT */
            CertificateOps.Initialize(false);

            ///////////////////////////////////////////////////////////////////////////////////////////

#if XML
            //
            // HACK: Force the static IScript XML processing class to be
            //       initialized now.
            //
            /* NO RESULT */
            ScriptXmlOps.InitializeAttributeGetters(false, false);
            ScriptXmlOps.InitializeAttributeSetters(false, false);
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if WINFORMS
            StatusFormOps.Initialize();
#endif

            ///////////////////////////////////////////////////////////////////////////////////////////

#if NATIVE && WINDOWS
            if (GlobalConfiguration.DoesValueExist(
                    EnvVars.NoMutexes, ConfigurationFlags.InterpreterVerbose))
            {
#if SHELL && CONSOLE
                //
                // TODO: Is this a good means of determining if *we* should be
                //       "allowed" to emit output to the console?
                //
                if (IsShellMainActive() || IsShellAssemblyActive())
                    ConsoleOps.MaybeWritePrompt(_Constants.Prompt.NoMutexes);
#endif

                TraceOps.DebugTrace(
                    _Constants.Prompt.NoMutexes, typeof(Interpreter).Name,
                    TracePriority.StartupDebug);
            }
            else if (PlatformOps.IsWindowsOperatingSystem())
            {
                //
                // HACK: Specific to Windows (i.e. there are no setup packages
                //       for non-Windows systems).
                //
                /* NO RESULT */
                SetupOps.CreateMutexes();
            }
#endif
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        public static void MaybeStaticInitialize()
        {
            bool success = false;

            try
            {
                if (Interlocked.Increment(ref globalInitializeCount) == 1)
                {
                    ForceStaticInitialize();
                    success = true;
                }
            }
            finally
            {
                if (!success)
                    Interlocked.Decrement(ref globalInitializeCount);
            }
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Private Constructors
        //
        // WARNING: This constructor is private because Interpreter objects MUST
        //          be created via the static Interpreter.Create factory method.
        //
        private Interpreter()
        {
            //
            // NOTE: Assign the "unique identifier" for this object type.
            //       This is actually something of a misnomer because the
            //       identifier is the same as all other instances; it is
            //       being used only to implement the IIdentifierBase.Id
            //       property.
            //
            uniqueId = AttributeOps.GetObjectId(this);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////

        //
        // WARNING: This constructor is private because Interpreter objects MUST
        //          be created via the static Interpreter.Create factory method.
        //
        private Interpreter(
            ulong? token /* in: OPTIONAL */
            )
            : this()
        {
            //
            // NOTE: Assign the lookup token for this interpreter, which may
            //       be null.  When the lookup token is not null, there will
            //       be different handling by the GlobalState class, i.e. it
            //       will not be visible in the normal lists of interpreters
            //       and it will only be possible to obtain a live reference
            //       to it by using its token.
            //
            this.token = token;
        }
        #endregion

        ///////////////////////////////////////////////////////////////////////////////////////////////

        #region Destructor
        ~Interpreter()
        {
            Interlocked.Increment(ref globalFinalizeCount);
            Dispose(false);
        }
        #endregion
    }
}
